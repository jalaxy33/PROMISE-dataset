package
org
apache
xml
utils
import
java
io
IOException
import
java
io
Serializable
import
org
apache
xalan
res
XSLTErrorResources
import
org
apache
xalan
res
XSLMessages
public
class
URI
implements
Serializable
public
static
class
MalformedURIException
extends
IOException
public
MalformedURIException
super
public
MalformedURIException
String
p_msg
super
p_msg
private
static
final
String
RESERVED_CHARACTERS
private
static
final
String
MARK_CHARACTERS
private
static
final
String
SCHEME_CHARACTERS
private
static
final
String
USERINFO_CHARACTERS
private
String
m_scheme
private
String
m_userinfo
private
String
m_host
private
int
m_port
private
String
m_path
private
String
m_queryString
private
String
m_fragment
private
static
boolean
DEBUG
public
URI
public
URI
URI
p_other
initialize
p_other
public
URI
String
p_uriSpec
throws
MalformedURIException
this
URI
p_uriSpec
public
URI
URI
p_base
String
p_uriSpec
throws
MalformedURIException
initialize
p_base
p_uriSpec
public
URI
String
p_scheme
String
p_schemeSpecificPart
throws
MalformedURIException
if
p_scheme
p_scheme
trim
length
throw
new
MalformedURIException
if
p_schemeSpecificPart
p_schemeSpecificPart
trim
length
throw
new
MalformedURIException
setScheme
p_scheme
setPath
p_schemeSpecificPart
public
URI
String
p_scheme
String
p_host
String
p_path
String
p_queryString
String
p_fragment
throws
MalformedURIException
this
p_scheme
p_host
p_path
p_queryString
p_fragment
public
URI
String
p_scheme
String
p_userinfo
String
p_host
int
p_port
String
p_path
String
p_queryString
String
p_fragment
throws
MalformedURIException
if
p_scheme
p_scheme
trim
length
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_SCHEME_REQUIRED
if
p_host
if
p_userinfo
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_NO_USERINFO_IF_NO_HOST
if
p_port
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_NO_PORT_IF_NO_HOST
if
p_path
if
p_path
indexOf
p_queryString
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_NO_QUERY_STRING_IN_PATH
if
p_path
indexOf
p_fragment
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_NO_FRAGMENT_STRING_IN_PATH
setScheme
p_scheme
setHost
p_host
setPort
p_port
setUserinfo
p_userinfo
setPath
p_path
setQueryString
p_queryString
setFragment
p_fragment
private
void
initialize
URI
p_other
m_scheme
p_other
getScheme
m_userinfo
p_other
getUserinfo
m_host
p_other
getHost
m_port
p_other
getPort
m_path
p_other
getPath
m_queryString
p_other
getQueryString
m_fragment
p_other
getFragment
private
void
initialize
URI
p_base
String
p_uriSpec
throws
MalformedURIException
if
p_base
p_uriSpec
p_uriSpec
trim
length
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_CANNOT_INIT_URI_EMPTY_PARMS
if
p_uriSpec
p_uriSpec
trim
length
initialize
p_base
return
String
uriSpec
p_uriSpec
trim
int
uriSpecLen
uriSpec
length
int
index
if
uriSpec
indexOf
if
p_base
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_NO_SCHEME_IN_URI
new
Object
uriSpec
else
initializeScheme
uriSpec
index
m_scheme
length
if
index
uriSpecLen
uriSpec
substring
index
startsWith
index
int
startPos
index
char
testChar
while
index
uriSpecLen
testChar
uriSpec
charAt
index
if
testChar
testChar
testChar
break
index
if
index
startPos
initializeAuthority
uriSpec
substring
startPos
index
else
m_host
initializePath
uriSpec
substring
index
if
p_base
if
m_path
length
m_scheme
m_host
m_scheme
p_base
getScheme
m_userinfo
p_base
getUserinfo
m_host
p_base
getHost
m_port
p_base
getPort
m_path
p_base
getPath
if
m_queryString
m_queryString
p_base
getQueryString
return
if
m_scheme
m_scheme
p_base
getScheme
else
return
if
m_host
m_userinfo
p_base
getUserinfo
m_host
p_base
getHost
m_port
p_base
getPort
else
return
if
m_path
length
m_path
startsWith
return
String
path
new
String
String
basePath
p_base
getPath
if
basePath
int
lastSlash
basePath
lastIndexOf
if
lastSlash
path
basePath
substring
lastSlash
path
path
concat
m_path
index
while
index
path
indexOf
path
path
substring
index
concat
path
substring
index
if
path
endsWith
path
path
substring
path
length
index
int
segIndex
String
tempString
while
index
path
indexOf
tempString
path
substring
path
indexOf
segIndex
tempString
lastIndexOf
if
segIndex
if
tempString
substring
segIndex
equals
path
path
substring
segIndex
concat
path
substring
index
if
path
endsWith
tempString
path
substring
path
length
segIndex
tempString
lastIndexOf
if
segIndex
path
path
substring
segIndex
m_path
path
private
void
initializeScheme
String
p_uriSpec
throws
MalformedURIException
int
uriSpecLen
p_uriSpec
length
int
index
String
scheme
char
testChar
while
index
uriSpecLen
testChar
p_uriSpec
charAt
index
if
testChar
testChar
testChar
testChar
break
index
scheme
p_uriSpec
substring
index
if
scheme
length
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_NO_SCHEME_INURI
else
setScheme
scheme
private
void
initializeAuthority
String
p_uriSpec
throws
MalformedURIException
int
index
int
start
int
end
p_uriSpec
length
char
testChar
String
userinfo
if
p_uriSpec
indexOf
start
while
index
end
testChar
p_uriSpec
charAt
index
if
testChar
break
index
userinfo
p_uriSpec
substring
start
index
index
String
host
start
index
while
index
end
testChar
p_uriSpec
charAt
index
if
testChar
break
index
host
p_uriSpec
substring
start
index
int
port
if
host
length
if
testChar
index
start
index
while
index
end
index
String
portStr
p_uriSpec
substring
start
index
if
portStr
length
for
int
i
i
portStr
length
i
if
isDigit
portStr
charAt
i
throw
new
MalformedURIException
portStr
try
port
Integer
parseInt
portStr
catch
NumberFormatException
nfe
setHost
host
setPort
port
setUserinfo
userinfo
private
void
initializePath
String
p_uriSpec
throws
MalformedURIException
if
p_uriSpec
throw
new
MalformedURIException
int
index
int
start
int
end
p_uriSpec
length
char
testChar
while
index
end
testChar
p_uriSpec
charAt
index
if
testChar
testChar
break
if
testChar
if
index
end
isHex
p_uriSpec
charAt
index
isHex
p_uriSpec
charAt
index
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE
else
if
isReservedCharacter
testChar
isUnreservedCharacter
testChar
if
testChar
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_PATH_INVALID_CHAR
new
Object
String
valueOf
testChar
index
m_path
p_uriSpec
substring
start
index
if
testChar
index
start
index
while
index
end
testChar
p_uriSpec
charAt
index
if
testChar
break
if
testChar
if
index
end
isHex
p_uriSpec
charAt
index
isHex
p_uriSpec
charAt
index
throw
new
MalformedURIException
else
if
isReservedCharacter
testChar
isUnreservedCharacter
testChar
throw
new
MalformedURIException
testChar
index
m_queryString
p_uriSpec
substring
start
index
if
testChar
index
start
index
while
index
end
testChar
p_uriSpec
charAt
index
if
testChar
if
index
end
isHex
p_uriSpec
charAt
index
isHex
p_uriSpec
charAt
index
throw
new
MalformedURIException
else
if
isReservedCharacter
testChar
isUnreservedCharacter
testChar
throw
new
MalformedURIException
testChar
index
m_fragment
p_uriSpec
substring
start
index
public
String
getScheme
return
m_scheme
public
String
getSchemeSpecificPart
StringBuffer
schemespec
new
StringBuffer
if
m_userinfo
m_host
m_port
schemespec
append
if
m_userinfo
schemespec
append
m_userinfo
schemespec
append
if
m_host
schemespec
append
m_host
if
m_port
schemespec
append
schemespec
append
m_port
if
m_path
schemespec
append
m_path
if
m_queryString
schemespec
append
schemespec
append
m_queryString
if
m_fragment
schemespec
append
schemespec
append
m_fragment
return
schemespec
toString
public
String
getUserinfo
return
m_userinfo
public
String
getHost
return
m_host
public
int
getPort
return
m_port
public
String
getPath
boolean
p_includeQueryString
boolean
p_includeFragment
StringBuffer
pathString
new
StringBuffer
m_path
if
p_includeQueryString
m_queryString
pathString
append
pathString
append
m_queryString
if
p_includeFragment
m_fragment
pathString
append
pathString
append
m_fragment
return
pathString
toString
public
String
getPath
return
m_path
public
String
getQueryString
return
m_queryString
public
String
getFragment
return
m_fragment
public
void
setScheme
String
p_scheme
throws
MalformedURIException
if
p_scheme
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_SCHEME_FROM_NULL_STRING
if
isConformantSchemeName
p_scheme
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_SCHEME_NOT_CONFORMANT
m_scheme
p_scheme
toLowerCase
public
void
setUserinfo
String
p_userinfo
throws
MalformedURIException
if
p_userinfo
m_userinfo
else
if
m_host
throw
new
MalformedURIException
int
index
int
end
p_userinfo
length
char
testChar
while
index
end
testChar
p_userinfo
charAt
index
if
testChar
if
index
end
isHex
p_userinfo
charAt
index
isHex
p_userinfo
charAt
index
throw
new
MalformedURIException
else
if
isUnreservedCharacter
testChar
USERINFO_CHARACTERS
indexOf
testChar
throw
new
MalformedURIException
testChar
index
m_userinfo
p_userinfo
public
void
setHost
String
p_host
throws
MalformedURIException
if
p_host
p_host
trim
length
m_host
p_host
m_userinfo
m_port
else
if
isWellFormedAddress
p_host
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_HOST_ADDRESS_NOT_WELLFORMED
m_host
p_host
public
void
setPort
int
p_port
throws
MalformedURIException
if
p_port
p_port
if
m_host
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_PORT_WHEN_HOST_NULL
else
if
p_port
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_INVALID_PORT
m_port
p_port
public
void
setPath
String
p_path
throws
MalformedURIException
if
p_path
m_path
m_queryString
m_fragment
else
initializePath
p_path
public
void
appendPath
String
p_addToPath
throws
MalformedURIException
if
p_addToPath
p_addToPath
trim
length
return
if
isURIString
p_addToPath
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_PATH_INVALID_CHAR
new
Object
p_addToPath
if
m_path
m_path
trim
length
if
p_addToPath
startsWith
m_path
p_addToPath
else
m_path
p_addToPath
else
if
m_path
endsWith
if
p_addToPath
startsWith
m_path
m_path
concat
p_addToPath
substring
else
m_path
m_path
concat
p_addToPath
else
if
p_addToPath
startsWith
m_path
m_path
concat
p_addToPath
else
m_path
m_path
concat
p_addToPath
public
void
setQueryString
String
p_queryString
throws
MalformedURIException
if
p_queryString
m_queryString
else
if
isGenericURI
throw
new
MalformedURIException
else
if
getPath
throw
new
MalformedURIException
else
if
isURIString
p_queryString
throw
new
MalformedURIException
else
m_queryString
p_queryString
public
void
setFragment
String
p_fragment
throws
MalformedURIException
if
p_fragment
m_fragment
else
if
isGenericURI
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_FRAG_FOR_GENERIC_URI
else
if
getPath
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_FRAG_WHEN_PATH_NULL
else
if
isURIString
p_fragment
throw
new
MalformedURIException
XSLMessages
createMessage
XSLTErrorResources
ER_FRAG_INVALID_CHAR
else
m_fragment
p_fragment
public
boolean
equals
Object
p_test
if
p_test
instanceof
URI
URI
testURI
URI
p_test
if
m_scheme
testURI
m_scheme
m_scheme
testURI
m_scheme
m_scheme
equals
testURI
m_scheme
m_userinfo
testURI
m_userinfo
m_userinfo
testURI
m_userinfo
m_userinfo
equals
testURI
m_userinfo
m_host
testURI
m_host
m_host
testURI
m_host
m_host
equals
testURI
m_host
m_port
testURI
m_port
m_path
testURI
m_path
m_path
testURI
m_path
m_path
equals
testURI
m_path
m_queryString
testURI
m_queryString
m_queryString
testURI
m_queryString
m_queryString
equals
testURI
m_queryString
m_fragment
testURI
m_fragment
m_fragment
testURI
m_fragment
m_fragment
equals
testURI
m_fragment
return
return
public
String
toString
StringBuffer
uriSpecString
new
StringBuffer
if
m_scheme
uriSpecString
append
m_scheme
uriSpecString
append
uriSpecString
append
getSchemeSpecificPart
return
uriSpecString
toString
public
boolean
isGenericURI
return
m_host
public
static
boolean
isConformantSchemeName
String
p_scheme
if
p_scheme
p_scheme
trim
length
return
if
isAlpha
p_scheme
charAt
return
char
testChar
for
int
i
i
p_scheme
length
i
testChar
p_scheme
charAt
i
if
isAlphanum
testChar
SCHEME_CHARACTERS
indexOf
testChar
return
return
public
static
boolean
isWellFormedAddress
String
p_address
if
p_address
return
String
address
p_address
trim
int
addrLength
address
length
if
addrLength
addrLength
return
if
address
startsWith
address
startsWith
return
int
index
address
lastIndexOf
if
address
endsWith
index
address
substring
index
lastIndexOf
if
index
addrLength
isDigit
p_address
charAt
index
char
testChar
int
numDots
for
int
i
i
addrLength
i
testChar
address
charAt
i
if
testChar
if
isDigit
address
charAt
i
i
addrLength
isDigit
address
charAt
i
return
numDots
else
if
isDigit
testChar
return
if
numDots
return
else
char
testChar
for
int
i
i
addrLength
i
testChar
address
charAt
i
if
testChar
if
isAlphanum
address
charAt
i
return
if
i
addrLength
isAlphanum
address
charAt
i
return
else
if
isAlphanum
testChar
testChar
return
return
private
static
boolean
isDigit
char
p_char
return
p_char
p_char
private
static
boolean
isHex
char
p_char
return
isDigit
p_char
p_char
p_char
p_char
p_char
private
static
boolean
isAlpha
char
p_char
return
p_char
p_char
p_char
p_char
private
static
boolean
isAlphanum
char
p_char
return
isAlpha
p_char
isDigit
p_char
private
static
boolean
isReservedCharacter
char
p_char
return
RESERVED_CHARACTERS
indexOf
p_char
private
static
boolean
isUnreservedCharacter
char
p_char
return
isAlphanum
p_char
MARK_CHARACTERS
indexOf
p_char
private
static
boolean
isURIString
String
p_uric
if
p_uric
return
int
end
p_uric
length
char
testChar
for
int
i
i
end
i
testChar
p_uric
charAt
i
if
testChar
if
i
end
isHex
p_uric
charAt
i
isHex
p_uric
charAt
i
return
else
i
continue
if
isReservedCharacter
testChar
isUnreservedCharacter
testChar
continue
else
return
return
