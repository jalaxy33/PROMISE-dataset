NodeVector
long
serialVersionUID
int
m_blocksize
int
m_map
int
m_firstFree
int
m_mapSize
NodeVector
m_blocksize
m_mapSize
NodeVector
blocksize
int
m_blocksize
blocksize
m_mapSize
clone
Object
NodeVector
clone
NodeVector
clone
if
m_map
m_map
m_map
block
m_map
int
m_map
length
arraycopy
m_map
m_map
m_map
length
return
clone
size
int
return
m_firstFree
addElement
value
int
if
m_firstFree
m_mapSize
block
if
m_map
block
m_map
int
m_blocksize
m_mapSize
m_blocksize
block
m_mapSize
m_blocksize
int
newMap
int
m_mapSize
arraycopy
m_map
newMap
m_firstFree
m_map
newMap
m_map
m_firstFree
value
m_firstFree
push
value
int
int
ff
m_firstFree
if
ff
m_mapSize
block
if
m_map
block
m_map
int
m_blocksize
m_mapSize
m_blocksize
block
m_mapSize
m_blocksize
int
newMap
int
m_mapSize
arraycopy
m_map
newMap
ff
m_map
newMap
m_map
ff
value
ff
m_firstFree
ff
pop
int
m_firstFree
int
n
m_map
m_firstFree
m_map
m_firstFree
NULL
return
n
popAndTop
int
m_firstFree
m_map
m_firstFree
NULL
return
m_firstFree
NULL
m_map
m_firstFree
popQuick
m_firstFree
m_map
m_firstFree
NULL
peepOrNull
int
return
m_map
m_firstFree
m_map
m_firstFree
NULL
pushPair
v1
int
v2
int
if
m_map
block
m_map
int
m_blocksize
m_mapSize
m_blocksize
block
if
m_firstFree
m_mapSize
block
m_mapSize
m_blocksize
int
newMap
int
m_mapSize
arraycopy
m_map
newMap
m_firstFree
m_map
newMap
m_map
m_firstFree
v1
m_map
m_firstFree
v2
m_firstFree
popPair
m_firstFree
m_map
m_firstFree
NULL
m_map
m_firstFree
NULL
setTail
n
int
m_map
m_firstFree
n
setTailSub1
n
int
m_map
m_firstFree
n
peepTail
int
return
m_map
m_firstFree
peepTailSub1
int
return
m_map
m_firstFree
insertInOrder
value
int
for
forControl
int
i
i
m_firstFree
i
block
if
value
m_map
i
block
insertElementAt
value
i
return
addElement
value
insertElementAt
value
int
at
int
if
m_map
block
m_map
int
m_blocksize
m_mapSize
m_blocksize
if
m_firstFree
m_mapSize
block
m_mapSize
m_blocksize
int
newMap
int
m_mapSize
arraycopy
m_map
newMap
m_firstFree
m_map
newMap
if
at
m_firstFree
block
arraycopy
m_map
at
m_map
at
m_firstFree
at
m_map
at
value
m_firstFree
appendNodes
nodes
NodeVector
int
nNodes
size
if
m_map
block
m_mapSize
nNodes
m_blocksize
m_map
int
m_mapSize
if
m_firstFree
nNodes
m_mapSize
block
m_mapSize
nNodes
m_blocksize
int
newMap
int
m_mapSize
arraycopy
m_map
newMap
m_firstFree
nNodes
m_map
newMap
arraycopy
m_map
m_map
m_firstFree
nNodes
m_firstFree
nNodes
removeAllElements
if
m_map
return
for
forControl
int
i
i
m_firstFree
i
block
m_map
i
NULL
m_firstFree
RemoveAllNoClear
if
m_map
return
m_firstFree
removeElement
boolean
s
int
if
m_map
return
for
forControl
int
i
i
m_firstFree
i
block
int
node
m_map
i
if
node
s
block
if
i
m_firstFree
arraycopy
m_map
i
m_map
i
m_firstFree
i
m_map
i
NULL
m_firstFree
return
return
removeElementAt
i
int
if
m_map
return
if
i
m_firstFree
arraycopy
m_map
i
m_map
i
m_firstFree
i
m_map
i
NULL
setElementAt
node
int
index
int
if
m_map
block
m_map
int
m_blocksize
m_mapSize
m_blocksize
if
index
addElement
node
m_map
index
node
elementAt
int
i
int
if
m_map
return
NULL
return
m_map
i
contains
boolean
s
int
if
m_map
return
for
forControl
int
i
i
m_firstFree
i
block
int
node
m_map
i
if
node
s
return
return
indexOf
int
elem
int
index
int
if
m_map
return
for
forControl
int
i
index
i
m_firstFree
i
block
int
node
m_map
i
if
node
elem
return
i
return
indexOf
int
elem
int
if
m_map
return
for
forControl
int
i
i
m_firstFree
i
block
int
node
m_map
i
if
node
elem
return
i
return
sort
a
int
lo0
int
hi0
int
int
lo
lo0
int
hi
hi0
if
lo
hi
block
return
if
lo
hi
block
if
a
lo
a
hi
block
int
T
a
lo
a
lo
a
hi
a
hi
T
return
int
pivot
a
lo
hi
a
lo
hi
a
hi
a
hi
pivot
while
lo
hi
block
while
a
lo
pivot
lo
hi
block
lo
while
pivot
a
hi
lo
hi
block
hi
if
lo
hi
block
int
T
a
lo
a
lo
a
hi
a
hi
T
a
hi0
a
hi
a
hi
pivot
sort
a
lo0
lo
sort
a
hi
hi0
sort
sort
m_map
m_firstFree
Serializable
Cloneable
