Lexer
Compiler
m_compiler
PrefixResolver
m_namespaceContext
XPathParser
m_processor
int
TARGETEXTRA
int
m_patternMap
int
int
m_patternMapSize
Lexer
compiler
Compiler
resolver
PrefixResolver
xpathProcessor
XPathParser
m_compiler
compiler
m_namespaceContext
resolver
m_processor
xpathProcessor
tokenize
pat
String
tokenize
pat
tokenize
pat
String
targetStrings
Vector
m_currentPattern
pat
m_patternMapSize
m_opMap
OpMapVector
MAXTOKENQUEUESIZE
BLOCKTOKENQUEUESIZE
MAPINDEX_LENGTH
int
nChars
length
int
startSubstring
int
posOfNSSep
boolean
isStartOfPat
boolean
isAttrName
boolean
isNum
int
nesting
for
forControl
int
i
i
nChars
i
block
char
c
charAt
i
switch
c
case
block
if
startSubstring
block
isNum
isStartOfPat
mapPatternElemPos
nesting
isStartOfPat
isAttrName
isAttrName
if
posOfNSSep
block
posOfNSSep
mapNSTokens
pat
startSubstring
posOfNSSep
i
block
addToTokenQueue
substring
startSubstring
i
startSubstring
i
for
forControl
i
i
nChars
c
charAt
i
i
if
c
i
nChars
block
addToTokenQueue
substring
startSubstring
i
startSubstring
block
error
ER_EXPECTED_DOUBLE_QUOTE
break
case
if
startSubstring
block
isNum
isStartOfPat
mapPatternElemPos
nesting
isStartOfPat
isAttrName
isAttrName
if
posOfNSSep
block
posOfNSSep
mapNSTokens
pat
startSubstring
posOfNSSep
i
block
addToTokenQueue
substring
startSubstring
i
startSubstring
i
for
forControl
i
i
nChars
c
charAt
i
i
if
c
i
nChars
block
addToTokenQueue
substring
startSubstring
i
startSubstring
block
error
ER_EXPECTED_SINGLE_QUOTE
break
case
if
startSubstring
block
isNum
isStartOfPat
mapPatternElemPos
nesting
isStartOfPat
isAttrName
isAttrName
if
posOfNSSep
block
posOfNSSep
mapNSTokens
pat
startSubstring
posOfNSSep
i
block
addToTokenQueue
substring
startSubstring
i
startSubstring
break
case
isAttrName
case
if
c
block
if
isNum
startSubstring
block
break
isNum
case
if
startSubstring
block
isNum
isStartOfPat
mapPatternElemPos
nesting
isStartOfPat
isAttrName
isAttrName
if
posOfNSSep
block
posOfNSSep
mapNSTokens
pat
startSubstring
posOfNSSep
i
block
addToTokenQueue
substring
startSubstring
i
startSubstring
if
c
isStartOfPat
block
isStartOfPat
mapPatternElemPos
nesting
isStartOfPat
isAttrName
if
c
block
isStartOfPat
mapPatternElemPos
nesting
isStartOfPat
isAttrName
isAttrName
if
nesting
block
if
c
block
if
targetStrings
block
recordTokenString
targetStrings
isStartOfPat
if
c
c
block
nesting
if
c
c
block
nesting
addToTokenQueue
substring
i
i
break
case
if
i
block
if
posOfNSSep
i
block
if
startSubstring
block
if
startSubstring
i
addToTokenQueue
substring
startSubstring
i
isNum
isAttrName
startSubstring
posOfNSSep
addToTokenQueue
substring
i
i
break
block
posOfNSSep
i
case
if
startSubstring
block
startSubstring
i
isNum
isDigit
c
if
isNum
block
isNum
isDigit
c
if
startSubstring
block
isNum
isStartOfPat
mapPatternElemPos
nesting
isStartOfPat
isAttrName
if
posOfNSSep
m_namespaceContext
handlesNullPrefixes
block
posOfNSSep
mapNSTokens
pat
startSubstring
posOfNSSep
nChars
block
addToTokenQueue
substring
startSubstring
nChars
if
getTokenQueueSize
block
error
ER_EMPTY_EXPRESSION
if
targetStrings
block
recordTokenString
targetStrings
m_queueMark
mapPatternElemPos
boolean
nesting
int
isStart
boolean
isAttrName
boolean
if
nesting
block
if
m_patternMapSize
length
block
int
patternMap
m_patternMap
int
len
length
m_patternMap
int
m_patternMapSize
arraycopy
patternMap
m_patternMap
len
if
isStart
block
m_patternMap
m_patternMapSize
TARGETEXTRA
m_patternMap
m_patternMapSize
getTokenQueueSize
isAttrName
TARGETEXTRA
m_patternMapSize
isStart
return
isStart
getTokenQueuePosFromMap
int
i
int
int
pos
m_patternMap
i
return
pos
TARGETEXTRA
pos
TARGETEXTRA
pos
resetTokenMark
mark
int
int
qsz
getTokenQueueSize
m_queueMark
mark
mark
qsz
mark
mark
if
m_queueMark
qsz
block
m_token
String
getTokenQueue
elementAt
m_queueMark
m_tokenChar
charAt
block
m_token
m_tokenChar
getKeywordToken
int
key
String
int
tok
try
Integer
itok
Integer
get
key
tok
itok
intValue
catchClause
npe
tok
catchClause
cce
tok
return
tok
recordTokenString
targetStrings
Vector
int
tokPos
getTokenQueuePosFromMap
m_patternMapSize
resetTokenMark
tokPos
if
lookahead
block
int
tok
getKeywordToken
m_token
switch
tok
case
NODETYPE_COMMENT
addElement
PSEUDONAME_COMMENT
break
case
NODETYPE_TEXT
addElement
PSEUDONAME_TEXT
break
case
NODETYPE_NODE
addElement
PSEUDONAME_ANY
break
case
NODETYPE_ROOT
addElement
PSEUDONAME_ROOT
break
case
NODETYPE_ANYELEMENT
addElement
PSEUDONAME_ANY
break
case
NODETYPE_PI
addElement
PSEUDONAME_ANY
break
case
addElement
PSEUDONAME_ANY
block
if
tokenIs
block
tokPos
resetTokenMark
tokPos
if
lookahead
block
tokPos
addElement
getTokenQueue
elementAt
tokPos
addToTokenQueue
s
String
getTokenQueue
addElement
s
mapNSTokens
int
pat
String
startSubstring
int
posOfNSSep
int
posOfScan
int
String
prefix
if
startSubstring
posOfNSSep
block
prefix
substring
startSubstring
posOfNSSep
String
uName
if
m_namespaceContext
equals
equals
block
try
if
length
uName
PrefixResolver
m_namespaceContext
block
if
block
addToTokenQueue
String
s
substring
posOfNSSep
posOfScan
if
length
addToTokenQueue
s
return
block
uName
PrefixResolver
m_namespaceContext
catchClause
cce
uName
getNamespaceForPrefix
prefix
block
uName
prefix
if
uName
length
block
addToTokenQueue
uName
addToTokenQueue
String
s
substring
posOfNSSep
posOfScan
if
length
addToTokenQueue
s
block
error
ER_PREFIX_MUST_RESOLVE
String
prefix
return
