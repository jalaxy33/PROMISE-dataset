BinaryTree
Node
_root
Node
int
_size
int
_modifications
Set
_key_set
Set
Set
_entry_set
Set
Collection
_value_collection
Collection
int
_KEY
int
_VALUE
int
_INDEX_SUM
_KEY
_VALUE
int
_MINIMUM_INDEX
int
_INDEX_COUNT
String
_data_name
String
BinaryTree
BinaryTree
map
Map
putAll
map
getKeyForValue
Object
value
Object
return
doGet
Comparable
value
_VALUE
removeValue
Object
value
Object
return
doRemove
Comparable
value
_VALUE
entrySetByValue
Set
if
_entry_set
_VALUE
block
_entry_set
_VALUE
AbstractSet
iterator
Iterator
return
BinaryTreeIterator
_VALUE
doGetNext
Object
return
_last_returned_node
contains
boolean
o
Object
if
o
Map
Entry
block
return
Map
Entry
entry
Map
Entry
o
Object
key
getKey
Node
node
lookup
Comparable
getValue
_VALUE
return
node
getData
equals
key
_KEY
remove
boolean
o
Object
if
o
Map
Entry
block
return
Map
Entry
entry
Map
Entry
o
Object
key
getKey
Node
node
lookup
Comparable
getValue
_VALUE
if
node
getData
equals
key
_KEY
block
doRedBlackDelete
node
return
return
size
int
return
size
clear
clear
return
_entry_set
_VALUE
keySetByValue
Set
if
_key_set
_VALUE
block
_key_set
_VALUE
AbstractSet
iterator
Iterator
return
BinaryTreeIterator
_VALUE
doGetNext
Object
return
getData
_KEY
size
int
return
size
contains
boolean
o
Object
return
containsKey
o
remove
boolean
o
Object
int
old_size
_size
remove
o
return
_size
old_size
clear
clear
return
_key_set
_VALUE
valuesByValue
Collection
if
_value_collection
_VALUE
block
_value_collection
_VALUE
AbstractCollection
iterator
Iterator
return
BinaryTreeIterator
_VALUE
doGetNext
Object
return
getData
_VALUE
size
int
return
size
contains
boolean
o
Object
return
containsValue
o
remove
boolean
o
Object
int
old_size
_size
removeValue
o
return
_size
old_size
removeAll
boolean
c
Collection
boolean
modified
Iterator
iter
iterator
while
hasNext
block
if
removeValue
next
block
modified
return
modified
clear
clear
return
_value_collection
_VALUE
doRemove
Object
o
Comparable
index
int
Node
node
lookup
o
index
Object
rval
if
node
block
rval
getData
oppositeIndex
index
doRedBlackDelete
node
return
rval
doGet
Object
o
Comparable
index
int
checkNonNullComparable
o
index
Node
node
lookup
o
index
return
node
getData
oppositeIndex
index
oppositeIndex
int
index
int
return
_INDEX_SUM
index
lookup
Node
data
Comparable
index
int
Node
rval
Node
node
_root
index
while
node
block
int
cmp
compare
data
getData
index
if
cmp
block
rval
node
break
block
node
cmp
getLeft
index
getRight
index
return
rval
compare
int
o1
Comparable
o2
Comparable
return
Comparable
o1
leastNode
Node
node
Node
index
int
Node
rval
node
if
rval
block
while
getLeft
index
block
rval
getLeft
index
return
rval
nextGreater
Node
node
Node
index
int
Node
rval
if
node
block
rval
if
getRight
index
block
rval
leastNode
getRight
index
index
block
Node
parent
getParent
index
Node
child
node
while
parent
child
getRight
index
block
child
parent
parent
getParent
index
rval
parent
return
rval
copyColor
from
Node
to
Node
index
int
if
to
block
if
from
block
setBlack
index
block
copyColor
from
index
isRed
boolean
node
Node
index
int
return
node
isRed
index
isBlack
boolean
node
Node
index
int
return
node
isBlack
index
makeRed
node
Node
index
int
if
node
block
setRed
index
makeBlack
node
Node
index
int
if
node
block
setBlack
index
getGrandParent
Node
node
Node
index
int
return
getParent
getParent
node
index
index
getParent
Node
node
Node
index
int
return
node
getParent
index
getRightChild
Node
node
Node
index
int
return
node
getRight
index
getLeftChild
Node
node
Node
index
int
return
node
getLeft
index
isLeftChild
boolean
node
Node
index
int
return
node
getParent
index
node
getParent
getLeft
index
index
isRightChild
boolean
node
Node
index
int
return
node
getParent
index
node
getParent
getRight
index
index
rotateLeft
node
Node
index
int
Node
right_child
getRight
index
setRight
getLeft
index
index
if
getLeft
index
block
getLeft
setParent
node
index
index
setParent
getParent
index
index
if
getParent
index
block
_root
index
right_child
if
getParent
getLeft
index
index
node
block
getParent
setLeft
right_child
index
index
block
getParent
setRight
right_child
index
index
setLeft
node
index
setParent
right_child
index
rotateRight
node
Node
index
int
Node
left_child
getLeft
index
setLeft
getRight
index
index
if
getRight
index
block
getRight
setParent
node
index
index
setParent
getParent
index
index
if
getParent
index
block
_root
index
left_child
if
getParent
getRight
index
index
node
block
getParent
setRight
left_child
index
index
block
getParent
setLeft
left_child
index
index
setRight
node
index
setParent
left_child
index
doRedBlackInsert
inserted_node
Node
index
int
Node
current_node
inserted_node
makeRed
current_node
index
while
current_node
current_node
_root
index
isRed
getParent
index
index
block
if
isLeftChild
getParent
current_node
index
index
block
Node
y
getRightChild
getGrandParent
current_node
index
index
if
isRed
y
index
block
makeBlack
getParent
current_node
index
index
makeBlack
y
index
makeRed
getGrandParent
current_node
index
index
current_node
getGrandParent
current_node
index
block
if
isRightChild
current_node
index
block
current_node
getParent
current_node
index
rotateLeft
current_node
index
makeBlack
getParent
current_node
index
index
makeRed
getGrandParent
current_node
index
index
if
getGrandParent
current_node
index
block
rotateRight
getGrandParent
current_node
index
index
block
Node
y
getLeftChild
getGrandParent
current_node
index
index
if
isRed
y
index
block
makeBlack
getParent
current_node
index
index
makeBlack
y
index
makeRed
getGrandParent
current_node
index
index
current_node
getGrandParent
current_node
index
block
if
isLeftChild
current_node
index
block
current_node
getParent
current_node
index
rotateRight
current_node
index
makeBlack
getParent
current_node
index
index
makeRed
getGrandParent
current_node
index
index
if
getGrandParent
current_node
index
block
rotateLeft
getGrandParent
current_node
index
index
makeBlack
_root
index
index
doRedBlackDelete
deleted_node
Node
for
forControl
int
index
_MINIMUM_INDEX
index
_INDEX_COUNT
index
block
if
getLeft
index
getRight
index
block
swapPosition
nextGreater
deleted_node
index
deleted_node
index
Node
replacement
getLeft
index
getLeft
index
getRight
index
if
replacement
block
setParent
getParent
index
index
if
getParent
index
block
_root
index
replacement
if
deleted_node
getParent
getLeft
index
index
block
getParent
setLeft
replacement
index
index
block
getParent
setRight
replacement
index
index
setLeft
index
setRight
index
setParent
index
if
isBlack
deleted_node
index
block
doRedBlackDeleteFixup
replacement
index
block
if
getParent
index
block
_root
index
block
if
isBlack
deleted_node
index
block
doRedBlackDeleteFixup
deleted_node
index
if
getParent
index
block
if
deleted_node
getParent
getLeft
index
index
block
getParent
setLeft
index
index
block
getParent
setRight
index
index
setParent
index
shrink
doRedBlackDeleteFixup
replacement_node
Node
index
int
Node
current_node
replacement_node
while
current_node
_root
index
isBlack
current_node
index
block
if
isLeftChild
current_node
index
block
Node
sibling_node
getRightChild
getParent
current_node
index
index
if
isRed
sibling_node
index
block
makeBlack
sibling_node
index
makeRed
getParent
current_node
index
index
rotateLeft
getParent
current_node
index
index
sibling_node
getRightChild
getParent
current_node
index
index
if
isBlack
getLeftChild
sibling_node
index
index
isBlack
getRightChild
sibling_node
index
index
block
makeRed
sibling_node
index
current_node
getParent
current_node
index
block
if
isBlack
getRightChild
sibling_node
index
index
block
makeBlack
getLeftChild
sibling_node
index
index
makeRed
sibling_node
index
rotateRight
sibling_node
index
sibling_node
getRightChild
getParent
current_node
index
index
copyColor
getParent
current_node
index
sibling_node
index
makeBlack
getParent
current_node
index
index
makeBlack
getRightChild
sibling_node
index
index
rotateLeft
getParent
current_node
index
index
current_node
_root
index
block
Node
sibling_node
getLeftChild
getParent
current_node
index
index
if
isRed
sibling_node
index
block
makeBlack
sibling_node
index
makeRed
getParent
current_node
index
index
rotateRight
getParent
current_node
index
index
sibling_node
getLeftChild
getParent
current_node
index
index
if
isBlack
getRightChild
sibling_node
index
index
isBlack
getLeftChild
sibling_node
index
index
block
makeRed
sibling_node
index
current_node
getParent
current_node
index
block
if
isBlack
getLeftChild
sibling_node
index
index
block
makeBlack
getRightChild
sibling_node
index
index
makeRed
sibling_node
index
rotateLeft
sibling_node
index
sibling_node
getLeftChild
getParent
current_node
index
index
copyColor
getParent
current_node
index
sibling_node
index
makeBlack
getParent
current_node
index
index
makeBlack
getLeftChild
sibling_node
index
index
rotateRight
getParent
current_node
index
index
current_node
_root
index
makeBlack
current_node
index
swapPosition
x
Node
y
Node
index
int
Node
x_old_parent
getParent
index
Node
x_old_left_child
getLeft
index
Node
x_old_right_child
getRight
index
Node
y_old_parent
getParent
index
Node
y_old_left_child
getLeft
index
Node
y_old_right_child
getRight
index
boolean
x_was_left_child
getParent
index
x
getParent
getLeft
index
index
boolean
y_was_left_child
getParent
index
y
getParent
getLeft
index
index
if
x
y_old_parent
block
setParent
y
index
if
y_was_left_child
block
setLeft
x
index
setRight
x_old_right_child
index
block
setRight
x
index
setLeft
x_old_left_child
index
block
setParent
y_old_parent
index
if
y_old_parent
block
if
y_was_left_child
block
setLeft
x
index
block
setRight
x
index
setLeft
x_old_left_child
index
setRight
x_old_right_child
index
if
y
x_old_parent
block
setParent
x
index
if
x_was_left_child
block
setLeft
y
index
setRight
y_old_right_child
index
block
setRight
y
index
setLeft
y_old_left_child
index
block
setParent
x_old_parent
index
if
x_old_parent
block
if
x_was_left_child
block
setLeft
y
index
block
setRight
y
index
setLeft
y_old_left_child
index
setRight
y_old_right_child
index
if
getLeft
index
block
getLeft
setParent
x
index
index
if
getRight
index
block
getRight
setParent
x
index
index
if
getLeft
index
block
getLeft
setParent
y
index
index
if
getRight
index
block
getRight
setParent
y
index
index
swapColors
y
index
if
_root
index
x
block
_root
index
y
if
_root
index
y
block
_root
index
x
checkNonNullComparable
o
Object
index
int
if
o
block
throw
NullPointerException
_data_name
index
if
o
Comparable
block
throw
ClassCastException
_data_name
index
checkKey
key
Object
checkNonNullComparable
key
_KEY
checkValue
value
Object
checkNonNullComparable
value
_VALUE
checkKeyAndValue
key
Object
value
Object
checkKey
key
checkValue
value
modify
_modifications
grow
modify
_size
shrink
modify
_size
insertValue
newNode
Node
Node
node
_root
_VALUE
while
block
int
cmp
compare
getData
_VALUE
getData
_VALUE
if
cmp
block
throw
IllegalArgumentException
getData
_VALUE
if
cmp
block
if
getLeft
_VALUE
block
node
getLeft
_VALUE
block
setLeft
newNode
_VALUE
setParent
node
_VALUE
doRedBlackInsert
newNode
_VALUE
break
block
if
getRight
_VALUE
block
node
getRight
_VALUE
block
setRight
newNode
_VALUE
setParent
node
_VALUE
doRedBlackInsert
newNode
_VALUE
break
size
int
return
_size
containsKey
boolean
key
Object
checkKey
key
return
lookup
Comparable
key
_KEY
containsValue
boolean
value
Object
checkValue
value
return
lookup
Comparable
value
_VALUE
get
Object
key
Object
return
doGet
Comparable
key
_KEY
put
Object
key
Object
value
Object
checkKeyAndValue
key
value
Node
node
_root
_KEY
if
node
block
Node
root
Node
Comparable
key
Comparable
value
_root
_KEY
root
_root
_VALUE
root
grow
block
while
block
int
cmp
compare
Comparable
key
getData
_KEY
if
cmp
block
throw
IllegalArgumentException
key
if
cmp
block
if
getLeft
_KEY
block
node
getLeft
_KEY
block
Node
newNode
Node
Comparable
key
Comparable
value
insertValue
newNode
setLeft
newNode
_KEY
setParent
node
_KEY
doRedBlackInsert
newNode
_KEY
grow
break
block
if
getRight
_KEY
block
node
getRight
_KEY
block
Node
newNode
Node
Comparable
key
Comparable
value
insertValue
newNode
setRight
newNode
_KEY
setParent
node
_KEY
doRedBlackInsert
newNode
_KEY
grow
break
return
remove
Object
key
Object
return
doRemove
Comparable
key
_KEY
clear
modify
_size
_root
_KEY
_root
_VALUE
keySet
Set
if
_key_set
_KEY
block
_key_set
_KEY
AbstractSet
iterator
Iterator
return
BinaryTreeIterator
_KEY
doGetNext
Object
return
getData
_KEY
size
int
return
size
contains
boolean
o
Object
return
containsKey
o
remove
boolean
o
Object
int
old_size
_size
remove
o
return
_size
old_size
clear
clear
return
_key_set
_KEY
values
Collection
if
_value_collection
_KEY
block
_value_collection
_KEY
AbstractCollection
iterator
Iterator
return
BinaryTreeIterator
_KEY
doGetNext
Object
return
getData
_VALUE
size
int
return
size
contains
boolean
o
Object
return
containsValue
o
remove
boolean
o
Object
int
old_size
_size
removeValue
o
return
_size
old_size
removeAll
boolean
c
Collection
boolean
modified
Iterator
iter
iterator
while
hasNext
block
if
removeValue
next
block
modified
return
modified
clear
clear
return
_value_collection
_KEY
entrySet
Set
if
_entry_set
_KEY
block
_entry_set
_KEY
AbstractSet
iterator
Iterator
return
BinaryTreeIterator
_KEY
doGetNext
Object
return
_last_returned_node
contains
boolean
o
Object
if
o
Map
Entry
block
return
Map
Entry
entry
Map
Entry
o
Object
value
getValue
Node
node
lookup
Comparable
getKey
_KEY
return
node
getData
equals
value
_VALUE
remove
boolean
o
Object
if
o
Map
Entry
block
return
Map
Entry
entry
Map
Entry
o
Object
value
getValue
Node
node
lookup
Comparable
getKey
_KEY
if
node
getData
equals
value
_VALUE
block
doRedBlackDelete
node
return
return
size
int
return
size
clear
clear
return
_entry_set
_KEY
BinaryTreeIterator
int
_expected_modifications
Node
_last_returned_node
Node
_next_node
int
_type
BinaryTreeIterator
type
int
_type
type
_expected_modifications
_modifications
_last_returned_node
_next_node
leastNode
_root
_type
_type
doGetNext
Object
hasNext
boolean
return
_next_node
next
Object
if
_next_node
block
throw
NoSuchElementException
if
_modifications
_expected_modifications
block
throw
ConcurrentModificationException
_last_returned_node
_next_node
_next_node
nextGreater
_next_node
_type
return
doGetNext
remove
if
_last_returned_node
block
throw
IllegalStateException
if
_modifications
_expected_modifications
block
throw
ConcurrentModificationException
doRedBlackDelete
_last_returned_node
_expected_modifications
_last_returned_node
Iterator
Node
Comparable
_data
Node
_left
Node
_right
Node
_parent
boolean
_black
int
_hashcode
boolean
_calculated_hashcode
Node
key
Comparable
value
Comparable
_data
Comparable
key
value
_left
Node
_right
Node
_parent
Node
_black
boolean
_calculated_hashcode
getData
Comparable
index
int
return
_data
index
setLeft
node
Node
index
int
_left
index
node
getLeft
Node
index
int
return
_left
index
setRight
node
Node
index
int
_right
index
node
getRight
Node
index
int
return
_right
index
setParent
node
Node
index
int
_parent
index
node
getParent
Node
index
int
return
_parent
index
swapColors
node
Node
index
int
_black
index
_black
index
_black
index
_black
index
_black
index
_black
index
isBlack
boolean
index
int
return
_black
index
isRed
boolean
index
int
return
_black
index
setBlack
index
int
_black
index
setRed
index
int
_black
index
copyColor
node
Node
index
int
_black
index
_black
index
getKey
Object
return
_data
_KEY
getValue
Object
return
_data
_VALUE
setValue
Object
ignored
Object
throw
UnsupportedOperationException
equals
boolean
o
Object
if
o
block
return
if
o
Map
Entry
block
return
Map
Entry
e
Map
Entry
o
return
_data
_KEY
equals
getKey
_data
_VALUE
equals
getValue
hashCode
int
if
_calculated_hashcode
block
_hashcode
_data
_KEY
hashCode
_data
_VALUE
hashCode
_calculated_hashcode
return
_hashcode
Map
Entry
AbstractMap
