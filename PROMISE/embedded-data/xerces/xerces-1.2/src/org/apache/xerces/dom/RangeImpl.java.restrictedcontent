RangeImpl
int
START
int
AFTER
int
BEFORE
DocumentImpl
fDocument
Node
fStartContainer
Node
fEndContainer
int
fStartOffset
int
fEndOffset
boolean
fIsCollapsed
boolean
fDetach
Node
fInsertNode
Node
fDeleteNode
Node
fSplitNode
RangeImpl
document
DocumentImpl
fDocument
document
fStartContainer
document
fEndContainer
document
fStartOffset
fEndOffset
fDetach
getStartContainer
Node
return
fStartContainer
getStartOffset
int
return
fStartOffset
getEndContainer
Node
return
fEndContainer
getEndOffset
int
return
fEndOffset
getCollapsed
boolean
return
fStartContainer
fEndContainer
fStartOffset
fEndOffset
getCommonAncestorContainer
Node
Vector
startV
Vector
Node
node
for
forControl
node
fStartContainer
node
node
getParentNode
block
addElement
node
Vector
endV
Vector
for
forControl
node
fEndContainer
node
node
getParentNode
block
addElement
node
int
s
size
int
e
size
Object
result
while
s
e
block
if
elementAt
s
elementAt
e
block
result
elementAt
s
block
break
s
e
return
Node
result
setStart
refNode
Node
offset
int
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
if
isAncestorTypeValid
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
checkIndex
refNode
offset
fStartContainer
refNode
fStartOffset
offset
setEnd
refNode
Node
offset
int
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
if
isAncestorTypeValid
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
checkIndex
refNode
offset
fEndContainer
refNode
fEndOffset
offset
setStartBefore
refNode
Node
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
if
isAncestorTypeValid
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
fStartContainer
getParentNode
int
i
for
forControl
Node
n
refNode
n
n
getPreviousSibling
block
i
fStartOffset
i
setStartAfter
refNode
Node
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
if
isAncestorTypeValid
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
fStartContainer
getParentNode
int
i
for
forControl
Node
n
refNode
n
n
getPreviousSibling
block
i
fStartOffset
i
setEndBefore
refNode
Node
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
if
isAncestorTypeValid
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
fEndContainer
getParentNode
int
i
for
forControl
Node
n
refNode
n
n
getPreviousSibling
block
i
fEndOffset
i
setEndAfter
refNode
Node
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
if
isAncestorTypeValid
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
fEndContainer
getParentNode
int
i
for
forControl
Node
n
refNode
n
n
getPreviousSibling
block
i
fEndOffset
i
collapse
toStart
boolean
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
if
toStart
block
fEndContainer
fStartContainer
fEndOffset
fStartOffset
block
fStartContainer
fEndContainer
fStartOffset
fEndOffset
selectNode
refNode
Node
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
if
isAncestorTypeValid
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
Node
parent
getParentNode
if
parent
block
fStartContainer
parent
fEndContainer
parent
int
i
for
forControl
Node
n
refNode
n
n
getPreviousSibling
block
i
fStartOffset
i
fEndOffset
fStartOffset
selectNodeContents
refNode
Node
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
if
isAncestorTypeValid
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
fStartContainer
refNode
fEndContainer
refNode
Node
first
getFirstChild
fStartOffset
if
first
block
fEndOffset
block
int
i
for
forControl
Node
n
first
n
n
getNextSibling
block
i
fEndOffset
i
compareBoundaryPoints
short
how
short
sourceRange
Range
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
Node
endPointA
Node
endPointB
int
offsetA
int
offsetB
if
how
START_TO_START
block
endPointA
getStartContainer
endPointB
fStartContainer
offsetA
getStartOffset
offsetB
fStartOffset
if
how
START_TO_END
block
endPointA
getStartContainer
endPointB
fEndContainer
offsetA
getStartOffset
offsetB
fEndOffset
if
how
END_TO_START
block
endPointA
getEndContainer
endPointB
fStartContainer
offsetA
getEndOffset
offsetB
fStartOffset
block
endPointA
getEndContainer
endPointB
fEndContainer
offsetA
getEndOffset
offsetB
fEndOffset
if
endPointA
endPointB
block
if
offsetA
offsetB
return
if
offsetA
offsetB
return
return
for
forControl
Node
node
getFirstChild
node
node
getNextSibling
block
if
isAncestorOf
node
endPointB
block
int
index
indexOf
node
endPointA
if
offsetA
index
return
if
offsetA
index
return
return
for
forControl
Node
node
getFirstChild
node
node
getNextSibling
block
if
isAncestorOf
node
endPointA
block
int
index
indexOf
node
endPointB
if
offsetB
index
return
if
offsetB
index
return
return
Node
ancestor
getCommonAncestorContainer
Node
current
ancestor
do
current
current
ancestor
block
if
current
endPointA
return
if
current
endPointB
return
current
nextNode
current
return
deleteContents
Node
current
fStartContainer
Node
parent
Node
next
boolean
deleteCurrent
Node
root
getCommonAncestorContainer
if
fStartContainer
fEndContainer
block
if
fStartOffset
fEndOffset
block
return
if
getNodeType
TEXT_NODE
block
String
value
getNodeValue
int
realStart
fStartOffset
int
realEnd
fEndOffset
if
fStartOffset
length
realStart
length
if
fEndOffset
length
realEnd
length
deleteData
CharacterData
fStartContainer
realStart
realEnd
realStart
block
current
getFirstChild
int
i
for
forControl
i
i
fStartOffset
current
i
block
current
getNextSibling
for
forControl
i
i
fEndOffset
fStartOffset
current
i
block
Node
newCurrent
getNextSibling
removeChild
fStartContainer
current
current
newCurrent
collapse
return
Node
partialNode
int
partialInt
START
Node
startRoot
if
getNodeType
TEXT_NODE
block
deleteData
CharacterData
current
fStartOffset
getNodeValue
length
fStartOffset
block
current
getFirstChild
for
forControl
int
i
i
fStartOffset
current
i
block
current
getNextSibling
if
current
block
current
fStartContainer
if
current
fStartContainer
block
deleteCurrent
while
current
root
current
block
parent
getParentNode
if
parent
root
block
if
startRoot
startRoot
current
block
if
partialNode
block
partialNode
parent
partialInt
AFTER
if
parent
root
block
next
getNextSibling
Node
nextnext
while
next
block
nextnext
getNextSibling
removeChild
parent
next
next
nextnext
if
deleteCurrent
block
removeChild
parent
current
deleteCurrent
current
parent
Node
endRoot
current
fEndContainer
if
getNodeType
TEXT_NODE
block
deleteData
CharacterData
current
fEndOffset
block
if
fEndOffset
block
current
fEndContainer
block
current
getFirstChild
for
forControl
int
i
i
fEndOffset
current
i
block
current
getNextSibling
if
current
block
current
getLastChild
if
current
fStartContainer
block
deleteCurrent
while
current
root
current
block
parent
getParentNode
if
parent
root
block
if
endRoot
endRoot
current
block
if
partialNode
block
partialNode
parent
partialInt
BEFORE
if
parent
root
parent
block
next
getPreviousSibling
Node
nextnext
while
next
block
nextnext
getPreviousSibling
removeChild
parent
next
next
nextnext
if
deleteCurrent
block
removeChild
parent
current
deleteCurrent
current
parent
current
getPreviousSibling
Node
prev
while
current
current
startRoot
block
prev
getPreviousSibling
parent
getParentNode
if
parent
block
removeChild
parent
current
current
prev
if
partialNode
block
collapse
if
partialInt
AFTER
block
setStartAfter
partialNode
setEndAfter
partialNode
if
partialInt
BEFORE
block
setStartBefore
partialNode
setEndBefore
partialNode
extractContents
DocumentFragment
return
traverseContents
EXTRACT_CONTENTS
cloneContents
DocumentFragment
return
traverseContents
CLONE_CONTENTS
insertNode
newNode
Node
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
int
type
getNodeType
if
type
ATTRIBUTE_NODE
type
ENTITY_NODE
type
NOTATION_NODE
type
DOCUMENT_NODE
type
DOCUMENT_FRAGMENT_NODE
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
if
newNode
return
Node
cloneCurrent
Node
current
boolean
MULTIPLE_MODE
if
getNodeType
TEXT_NODE
block
if
getNodeType
TEXT_NODE
block
cloneCurrent
cloneNode
TextImpl
cloneCurrent
TextImpl
fStartContainer
Node
next
getNextSibling
if
next
block
Node
parent
getParentNode
if
parent
block
insertBefore
newNode
next
insertBefore
cloneCurrent
next
block
Node
parent
getParentNode
if
parent
block
appendChild
newNode
appendChild
cloneCurrent
signalSplitData
fStartContainer
cloneCurrent
fStartOffset
block
String
value
getNodeValue
String
newValue
getNodeValue
insertData
CharacterData
fStartContainer
fStartOffset
newValue
block
current
getFirstChild
int
i
for
forControl
i
i
fStartOffset
current
i
block
current
getNextSibling
if
current
block
insertBefore
newNode
current
block
appendChild
newNode
surroundContents
newParent
Node
if
newParent
return
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
int
type
getNodeType
if
type
ATTRIBUTE_NODE
type
ENTITY_NODE
type
NOTATION_NODE
type
DOCUMENT_TYPE_NODE
type
DOCUMENT_NODE
type
DOCUMENT_FRAGMENT_NODE
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
Node
root
getCommonAncestorContainer
Node
realStart
fStartContainer
Node
realEnd
fEndContainer
if
getNodeType
TEXT_NODE
block
realStart
getParentNode
if
getNodeType
TEXT_NODE
block
realEnd
getParentNode
if
realStart
realEnd
block
throw
RangeExceptionImpl
BAD_BOUNDARYPOINTS_ERR
DocumentFragment
frag
extractContents
insertNode
newParent
appendChild
frag
selectNode
newParent
cloneRange
Range
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
Range
range
createRange
setStart
fStartContainer
fStartOffset
setEnd
fEndContainer
fEndOffset
return
range
toString
String
if
fDetach
block
throw
DOMExceptionImpl
INVALID_STATE_ERR
Node
node
fStartContainer
StringBuffer
sb
StringBuffer
if
getNodeType
TEXT_NODE
getNodeType
CDATA_SECTION_NODE
block
if
fStartContainer
fEndContainer
block
append
getNodeValue
substring
fStartOffset
fEndOffset
return
toString
block
append
getNodeValue
substring
fStartOffset
while
node
fEndContainer
block
node
nextNode
node
if
node
break
if
getNodeType
TEXT_NODE
getNodeType
CDATA_SECTION_NODE
block
append
getNodeValue
if
getNodeType
TEXT_NODE
getNodeType
CDATA_SECTION_NODE
block
append
getNodeValue
substring
fEndOffset
return
toString
detach
fDetach
removeRange
signalSplitData
node
Node
newNode
Node
offset
int
fSplitNode
node
splitData
node
newNode
offset
fSplitNode
receiveSplitData
node
Node
newNode
Node
offset
int
if
node
newNode
return
if
fSplitNode
node
return
if
node
fStartContainer
getNodeType
TEXT_NODE
block
if
fStartOffset
offset
block
fStartOffset
fStartOffset
offset
fStartContainer
newNode
if
node
fEndContainer
getNodeType
TEXT_NODE
block
if
fEndOffset
offset
block
fEndOffset
fEndOffset
offset
fEndContainer
newNode
deleteData
node
CharacterData
offset
int
count
int
fDeleteNode
node
deleteData
offset
count
fDeleteNode
receiveDeletedText
node
Node
offset
int
count
int
if
node
return
if
fDeleteNode
node
return
if
node
fStartContainer
getNodeType
TEXT_NODE
block
if
fStartOffset
offset
count
block
fStartOffset
offset
fStartOffset
offset
count
if
fStartOffset
offset
block
fStartOffset
offset
if
node
fEndContainer
getNodeType
TEXT_NODE
block
if
fEndOffset
offset
count
block
fEndOffset
offset
fEndOffset
offset
count
if
fEndOffset
offset
block
fEndOffset
offset
insertData
node
CharacterData
index
int
insert
String
fInsertNode
node
insertData
index
insert
fInsertNode
receiveInsertedText
node
Node
index
int
len
int
if
node
return
if
fInsertNode
node
return
if
node
fStartContainer
getNodeType
TEXT_NODE
block
if
index
fStartOffset
block
fStartOffset
fStartOffset
len
if
node
fEndContainer
getNodeType
TEXT_NODE
block
if
index
fEndOffset
block
fEndOffset
fEndOffset
len
receiveReplacedText
node
Node
if
node
return
if
node
fStartContainer
getNodeType
TEXT_NODE
block
fStartOffset
if
node
fEndContainer
getNodeType
TEXT_NODE
block
fEndOffset
insertedNodeFromDOM
node
Node
if
node
return
if
fInsertNode
node
return
Node
parent
getParentNode
if
parent
fStartContainer
block
int
index
indexOf
node
fStartContainer
if
index
fStartOffset
block
fStartOffset
if
parent
fEndContainer
block
int
index
indexOf
node
fEndContainer
if
index
fEndOffset
block
fEndOffset
Node
fRemoveChild
removeChild
Node
parent
Node
child
Node
fRemoveChild
child
Node
n
removeChild
child
fRemoveChild
return
n
removeNode
node
Node
if
node
return
if
fRemoveChild
node
return
Node
parent
getParentNode
if
parent
fStartContainer
block
int
index
indexOf
node
fStartContainer
if
index
fStartOffset
block
fStartOffset
if
parent
fEndContainer
block
int
index
indexOf
node
fEndContainer
if
index
fEndOffset
block
fEndOffset
if
parent
fStartContainer
parent
fEndContainer
block
if
isAncestorOf
node
fStartContainer
block
fStartContainer
parent
fStartOffset
indexOf
node
parent
if
isAncestorOf
node
fEndContainer
block
fEndContainer
parent
fEndOffset
indexOf
node
parent
int
EXTRACT_CONTENTS
int
CLONE_CONTENTS
traverseContents
DocumentFragment
traversalType
int
if
fStartContainer
fEndContainer
block
return
DocumentFragment
frag
createDocumentFragment
Node
current
fStartContainer
Node
cloneCurrent
Node
cloneParent
Node
partialNode
int
partialInt
START
Vector
d
Vector
if
fStartContainer
fEndContainer
block
if
fStartOffset
fEndOffset
block
return
frag
if
getNodeType
TEXT_NODE
block
cloneCurrent
cloneNode
setNodeValue
getNodeValue
substring
fStartOffset
fEndOffset
if
traversalType
EXTRACT_CONTENTS
block
deleteData
CharacterData
current
fStartOffset
fEndOffset
fStartOffset
appendChild
cloneCurrent
block
current
getFirstChild
int
i
for
forControl
i
i
fStartOffset
current
i
block
current
getNextSibling
int
n
fEndOffset
fStartOffset
for
forControl
i
i
n
current
i
block
Node
newCurrent
getNextSibling
if
traversalType
CLONE_CONTENTS
block
cloneCurrent
cloneNode
appendChild
cloneCurrent
if
traversalType
EXTRACT_CONTENTS
block
appendChild
current
current
newCurrent
return
frag
Node
root
getCommonAncestorContainer
Node
parent
current
fStartContainer
if
getNodeType
TEXT_NODE
block
cloneCurrent
cloneNode
setNodeValue
getNodeValue
substring
fStartOffset
if
traversalType
EXTRACT_CONTENTS
block
deleteData
CharacterData
current
fStartOffset
getNodeValue
length
fStartOffset
block
current
getFirstChild
for
forControl
int
i
i
fStartOffset
current
i
block
current
getNextSibling
if
current
block
current
fStartContainer
if
traversalType
CLONE_CONTENTS
block
cloneCurrent
cloneNode
if
traversalType
EXTRACT_CONTENTS
block
cloneCurrent
current
Node
startRoot
parent
while
current
root
block
parent
getParentNode
if
parent
root
block
cloneParent
frag
startRoot
current
block
if
parent
println
current
cloneParent
cloneNode
if
partialNode
parent
root
block
partialNode
parent
partialInt
AFTER
Node
next
current
getNextSibling
appendChild
cloneCurrent
while
current
block
next
getNextSibling
if
current
parent
root
block
if
traversalType
CLONE_CONTENTS
block
cloneCurrent
cloneNode
appendChild
cloneCurrent
if
traversalType
EXTRACT_CONTENTS
block
appendChild
current
current
next
current
parent
cloneCurrent
cloneParent
Node
endRoot
current
fEndContainer
if
getNodeType
TEXT_NODE
block
cloneCurrent
cloneNode
setNodeValue
getNodeValue
substring
fEndOffset
if
traversalType
EXTRACT_CONTENTS
block
deleteData
CharacterData
current
fEndOffset
block
if
fEndOffset
block
current
fEndContainer
block
current
getFirstChild
for
forControl
int
i
i
fEndOffset
current
i
block
current
getNextSibling
if
current
block
current
getLastChild
if
traversalType
CLONE_CONTENTS
block
cloneCurrent
cloneNode
if
traversalType
EXTRACT_CONTENTS
block
cloneCurrent
current
while
current
root
current
block
parent
getParentNode
if
parent
root
block
cloneParent
frag
endRoot
current
block
cloneParent
cloneNode
if
partialNode
parent
root
block
partialNode
parent
partialInt
BEFORE
Node
holdCurrent
current
current
getFirstChild
appendChild
cloneCurrent
Node
next
while
current
holdCurrent
current
block
next
getNextSibling
if
current
parent
root
block
if
traversalType
CLONE_CONTENTS
block
cloneCurrent
cloneNode
appendChild
cloneCurrent
if
traversalType
EXTRACT_CONTENTS
block
appendChild
current
current
next
current
parent
cloneCurrent
cloneParent
removeAllElements
Node
clonedPrevious
getLastChild
current
getPreviousSibling
Node
prev
while
current
startRoot
current
block
prev
getPreviousSibling
if
traversalType
CLONE_CONTENTS
block
cloneCurrent
cloneNode
if
traversalType
EXTRACT_CONTENTS
block
cloneCurrent
current
insertBefore
cloneCurrent
clonedPrevious
current
prev
clonedPrevious
cloneCurrent
if
traversalType
EXTRACT_CONTENTS
block
if
partialNode
block
collapse
if
partialInt
AFTER
block
setStartAfter
partialNode
setEndAfter
partialNode
if
partialInt
BEFORE
block
setStartBefore
partialNode
setEndBefore
partialNode
return
frag
checkIndex
refNode
Node
offset
int
if
offset
block
throw
DOMExceptionImpl
INDEX_SIZE_ERR
int
type
getNodeType
if
type
TEXT_NODE
type
CDATA_SECTION_NODE
type
COMMENT_NODE
type
PROCESSING_INSTRUCTION_NODE
offset
getNodeValue
length
block
throw
DOMExceptionImpl
INDEX_SIZE_ERR
Node
child
getFirstChild
int
i
for
forControl
child
i
block
child
getNextSibling
if
i
offset
block
throw
DOMExceptionImpl
INDEX_SIZE_ERR
isAncestorTypeValid
boolean
node
Node
for
forControl
Node
n
node
n
n
getParentNode
block
int
type
getNodeType
if
type
ATTRIBUTE_NODE
type
ENTITY_NODE
type
NOTATION_NODE
type
DOCUMENT_TYPE_NODE
return
return
nextNode
Node
node
Node
visitChildren
boolean
if
node
return
Node
result
if
visitChildren
block
result
getFirstChild
if
result
block
return
result
result
getNextSibling
if
result
block
return
result
Node
parent
getParentNode
while
parent
parent
fDocument
block
result
getNextSibling
if
result
block
return
result
block
parent
getParentNode
return
isAncestorOf
boolean
a
Node
b
Node
for
forControl
Node
node
b
node
node
getParentNode
block
if
node
a
return
return
indexOf
int
child
Node
parent
Node
Node
node
int
i
if
getParentNode
parent
return
for
forControl
node
child
node
node
getPreviousSibling
block
i
return
i
Range
