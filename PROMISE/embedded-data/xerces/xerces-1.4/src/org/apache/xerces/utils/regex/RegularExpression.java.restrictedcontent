RegularExpression
boolean
DEBUG
compile
tok
Token
if
operations
return
numberOfClosures
operations
compile
tok
compile
Op
tok
Token
next
Op
reverse
boolean
Op
ret
switch
type
case
DOT
ret
createDot
next
next
break
case
CHAR
ret
createChar
getChar
next
next
break
case
ANCHOR
ret
createAnchor
getChar
next
next
break
case
RANGE
NRANGE
ret
createRange
tok
next
next
break
case
CONCAT
ret
next
if
reverse
block
for
forControl
int
i
size
i
i
block
ret
compile
getChild
i
ret
block
for
forControl
int
i
i
size
i
block
ret
compile
getChild
i
ret
break
case
UNION
Op
UnionOp
uni
createUnion
size
for
forControl
int
i
i
size
i
block
addElement
compile
getChild
i
next
reverse
ret
uni
break
case
CLOSURE
NONGREEDYCLOSURE
Token
child
getChild
int
min
getMin
int
max
getMax
if
min
min
max
block
ret
next
for
forControl
int
i
i
min
i
block
ret
compile
child
ret
reverse
break
if
min
max
max
min
if
max
block
ret
next
for
forControl
int
i
i
max
i
block
Op
ChildOp
q
createQuestion
type
NONGREEDYCLOSURE
next
next
setChild
compile
child
ret
reverse
ret
q
block
Op
ChildOp
op
if
type
NONGREEDYCLOSURE
block
op
createNonGreedyClosure
block
if
getMinLength
op
createClosure
numberOfClosures
op
createClosure
next
next
setChild
compile
child
op
reverse
ret
op
if
min
block
for
forControl
int
i
i
min
i
block
ret
compile
child
ret
reverse
break
case
EMPTY
ret
next
break
case
STRING
ret
createString
getString
next
next
break
case
BACKREFERENCE
ret
createBackReference
getReferenceNumber
next
next
break
case
PAREN
if
getParenNumber
block
ret
compile
getChild
next
reverse
if
reverse
block
next
createCapture
getParenNumber
next
next
compile
getChild
next
reverse
ret
createCapture
getParenNumber
next
block
next
createCapture
getParenNumber
next
next
compile
getChild
next
reverse
ret
createCapture
getParenNumber
next
break
case
LOOKAHEAD
ret
createLook
LOOKAHEAD
next
compile
getChild
break
case
NEGATIVELOOKAHEAD
ret
createLook
NEGATIVELOOKAHEAD
next
compile
getChild
break
case
LOOKBEHIND
ret
createLook
LOOKBEHIND
next
compile
getChild
break
case
NEGATIVELOOKBEHIND
ret
createLook
NEGATIVELOOKBEHIND
next
compile
getChild
break
case
INDEPENDENT
ret
createIndependent
next
compile
getChild
reverse
break
case
MODIFIERGROUP
ret
createModifier
next
compile
getChild
reverse
Token
ModifierToken
tok
Token
ModifierToken
tok
break
case
CONDITION
Token
ConditionToken
ctok
Token
ConditionToken
tok
int
ref
refNumber
Op
condition
condition
compile
condition
reverse
Op
yes
compile
yes
next
reverse
Op
no
no
compile
no
next
reverse
ret
createCondition
next
ref
condition
yes
no
break
case
throw
RuntimeException
type
return
ret
matches
boolean
target
char
return
matches
target
length
Match
matches
boolean
target
char
start
int
end
int
return
matches
target
start
end
Match
matches
boolean
target
char
match
Match
return
matches
target
length
match
matches
boolean
target
char
start
int
end
int
match
Match
synchronized
if
operations
prepare
if
context
context
Context
Context
con
synchronized
context
con
context
inuse
Context
context
reset
target
start
end
numberOfClosures
if
match
block
setNumberOfGroups
nofparen
setSource
target
if
hasBackReferences
block
match
Match
setNumberOfGroups
nofparen
match
match
if
isSet
options
XMLSCHEMA_MODE
block
int
matchEnd
matchCharArray
con
operations
start
options
if
matchEnd
limit
block
if
match
block
setBeginning
start
setEnd
matchEnd
inuse
return
return
if
fixedStringOnly
block
int
o
fixedStringTable
matches
target
start
limit
if
o
block
if
match
block
setBeginning
o
setEnd
o
fixedString
length
inuse
return
inuse
return
if
fixedString
block
int
o
fixedStringTable
matches
target
start
limit
if
o
block
inuse
return
int
limit
limit
minlength
int
matchStart
int
matchEnd
if
operations
operations
type
CLOSURE
operations
getChild
type
DOT
block
if
isSet
options
SINGLE_LINE
block
matchStart
start
matchEnd
matchCharArray
con
operations
start
options
block
boolean
previousIsEOL
for
forControl
matchStart
start
matchStart
limit
matchStart
block
int
ch
target
matchStart
if
isEOLChar
ch
block
previousIsEOL
block
if
previousIsEOL
block
if
matchEnd
matchCharArray
con
operations
matchStart
options
break
previousIsEOL
if
firstChar
block
RangeToken
range
firstChar
if
isSet
options
IGNORE_CASE
block
range
firstChar
getCaseInsensitiveToken
for
forControl
matchStart
start
matchStart
limit
matchStart
block
int
ch
target
matchStart
if
isHighSurrogate
ch
matchStart
limit
block
ch
composeFromSurrogates
ch
target
matchStart
if
match
ch
continue
block
if
match
ch
block
char
ch1
toUpperCase
char
ch
if
match
ch1
if
match
toLowerCase
ch1
continue
if
matchEnd
matchCharArray
con
operations
matchStart
options
break
block
for
forControl
matchStart
start
matchStart
limit
matchStart
block
int
ch
target
matchStart
if
isHighSurrogate
ch
matchStart
limit
ch
composeFromSurrogates
ch
target
matchStart
if
match
ch
continue
if
matchEnd
matchCharArray
con
operations
matchStart
options
break
block
for
forControl
matchStart
start
matchStart
limit
matchStart
block
if
matchEnd
matchCharArray
con
operations
matchStart
options
break
if
matchEnd
block
if
match
block
setBeginning
matchStart
setEnd
matchEnd
inuse
return
block
inuse
return
matchCharArray
int
con
Context
op
Op
offset
int
dx
int
opts
int
char
target
charTarget
while
block
if
op
return
offset
if
offset
limit
offset
start
return
switch
type
case
CHAR
if
isSet
opts
IGNORE_CASE
block
int
ch
getData
if
dx
block
if
offset
limit
matchIgnoreCase
ch
target
offset
return
offset
block
int
o1
offset
if
o1
limit
o1
matchIgnoreCase
ch
target
o1
return
offset
o1
block
int
ch
getData
if
dx
block
if
offset
limit
ch
target
offset
return
offset
block
int
o1
offset
if
o1
limit
o1
ch
target
o1
return
offset
o1
op
next
break
case
DOT
if
dx
block
if
offset
limit
return
int
ch
target
offset
if
isSet
opts
SINGLE_LINE
block
if
isHighSurrogate
ch
offset
limit
offset
block
if
isHighSurrogate
ch
offset
limit
ch
composeFromSurrogates
ch
target
offset
if
isEOLChar
ch
return
offset
block
int
o1
offset
if
o1
limit
o1
return
int
ch
target
o1
if
isSet
opts
SINGLE_LINE
block
if
isLowSurrogate
ch
o1
o1
block
if
isLowSurrogate
ch
o1
ch
composeFromSurrogates
target
o1
ch
if
isEOLChar
ch
return
offset
o1
op
next
break
case
RANGE
NRANGE
if
dx
block
if
offset
limit
return
int
ch
target
offset
if
isHighSurrogate
ch
offset
limit
ch
composeFromSurrogates
ch
target
offset
RangeToken
tok
getToken
if
isSet
opts
IGNORE_CASE
block
tok
getCaseInsensitiveToken
if
match
ch
block
if
ch
return
char
uch
if
match
uch
toUpperCase
char
ch
match
toLowerCase
uch
return
block
if
match
ch
return
offset
block
int
o1
offset
if
o1
limit
o1
return
int
ch
target
o1
if
isLowSurrogate
ch
o1
ch
composeFromSurrogates
target
o1
ch
RangeToken
tok
getToken
if
isSet
opts
IGNORE_CASE
block
tok
getCaseInsensitiveToken
if
match
ch
block
if
ch
return
char
uch
if
match
uch
toUpperCase
char
ch
match
toLowerCase
uch
return
block
if
match
ch
return
offset
o1
op
next
break
case
ANCHOR
boolean
go
switch
getData
case
if
isSet
opts
MULTIPLE_LINES
block
if
offset
start
offset
start
isEOLChar
target
offset
return
block
if
offset
start
return
break
case
if
offset
start
offset
start
isEOLChar
target
offset
return
break
case
if
isSet
opts
MULTIPLE_LINES
block
if
offset
limit
offset
limit
isEOLChar
target
offset
return
block
if
offset
limit
offset
limit
isEOLChar
target
offset
offset
limit
target
offset
CARRIAGE_RETURN
target
offset
LINE_FEED
return
break
case
if
offset
start
return
break
case
if
offset
limit
offset
limit
isEOLChar
target
offset
offset
limit
target
offset
CARRIAGE_RETURN
target
offset
LINE_FEED
return
break
case
if
offset
limit
return
break
case
if
length
return
block
int
after
getWordType
target
start
limit
offset
opts
if
after
WT_IGNORE
return
int
before
getPreviousWordType
target
start
limit
offset
opts
if
after
before
return
break
case
if
length
go
block
int
after
getWordType
target
start
limit
offset
opts
go
after
WT_IGNORE
after
getPreviousWordType
target
start
limit
offset
opts
if
go
return
break
case
if
length
offset
limit
return
if
getWordType
target
start
limit
offset
opts
WT_LETTER
getPreviousWordType
target
start
limit
offset
opts
WT_OTHER
return
break
case
if
length
offset
start
return
if
getWordType
target
start
limit
offset
opts
WT_OTHER
getPreviousWordType
target
start
limit
offset
opts
WT_LETTER
return
break
op
next
break
case
BACKREFERENCE
block
int
refno
getData
if
refno
refno
nofparen
throw
RuntimeException
refno
if
getBeginning
refno
getEnd
refno
return
int
o2
getBeginning
refno
int
literallen
getEnd
refno
o2
if
isSet
opts
IGNORE_CASE
block
if
dx
block
if
regionMatches
target
offset
limit
o2
literallen
return
offset
literallen
block
if
regionMatches
target
offset
literallen
limit
o2
literallen
return
offset
literallen
block
if
dx
block
if
regionMatchesIgnoreCase
target
offset
limit
o2
literallen
return
offset
literallen
block
if
regionMatchesIgnoreCase
target
offset
literallen
limit
o2
literallen
return
offset
literallen
op
next
break
case
STRING
block
String
literal
getString
int
literallen
length
if
isSet
opts
IGNORE_CASE
block
if
dx
block
if
regionMatches
target
offset
limit
literal
literallen
return
offset
literallen
block
if
regionMatches
target
offset
literallen
limit
literal
literallen
return
offset
literallen
block
if
dx
block
if
regionMatchesIgnoreCase
target
offset
limit
literal
literallen
return
offset
literallen
block
if
regionMatchesIgnoreCase
target
offset
literallen
limit
literal
literallen
return
offset
literallen
op
next
break
case
CLOSURE
block
int
id
getData
if
id
block
int
previousOffset
offsets
id
if
previousOffset
previousOffset
offset
block
offsets
id
offset
block
offsets
id
op
next
break
int
ret
matchCharArray
con
getChild
offset
dx
opts
if
id
offsets
id
if
ret
return
ret
op
next
break
case
QUESTION
block
int
ret
matchCharArray
con
getChild
offset
dx
opts
if
ret
return
ret
op
next
break
case
NONGREEDYCLOSURE
NONGREEDYQUESTION
block
int
ret
matchCharArray
con
next
offset
dx
opts
if
ret
return
ret
op
getChild
break
case
UNION
for
forControl
int
i
i
size
i
block
int
ret
matchCharArray
con
elementAt
i
offset
dx
opts
if
DEBUG
block
println
i
ret
if
ret
length
return
ret
return
case
CAPTURE
int
refno
getData
if
match
refno
block
int
save
getBeginning
refno
setBeginning
refno
offset
int
ret
matchCharArray
con
next
offset
dx
opts
if
ret
setBeginning
refno
save
return
ret
if
match
refno
block
int
index
refno
int
save
getEnd
index
setEnd
index
offset
int
ret
matchCharArray
con
next
offset
dx
opts
if
ret
setEnd
index
save
return
ret
op
next
break
case
LOOKAHEAD
if
matchCharArray
con
getChild
offset
opts
return
op
next
break
case
NEGATIVELOOKAHEAD
if
matchCharArray
con
getChild
offset
opts
return
op
next
break
case
LOOKBEHIND
if
matchCharArray
con
getChild
offset
opts
return
op
next
break
case
NEGATIVELOOKBEHIND
if
matchCharArray
con
getChild
offset
opts
return
op
next
break
case
INDEPENDENT
block
int
ret
matchCharArray
con
getChild
offset
dx
opts
if
ret
return
ret
offset
ret
op
next
break
case
MODIFIER
block
int
localopts
opts
localopts
getData
localopts
getData2
int
ret
matchCharArray
con
getChild
offset
dx
localopts
if
ret
return
ret
offset
ret
op
next
break
case
CONDITION
block
Op
ConditionOp
cop
Op
ConditionOp
op
boolean
matchp
if
refNumber
block
if
refNumber
nofparen
throw
RuntimeException
refNumber
matchp
getBeginning
refNumber
getEnd
refNumber
block
matchp
matchCharArray
con
condition
offset
dx
opts
if
matchp
block
op
yes
if
no
block
op
no
block
op
next
break
case
throw
RuntimeException
type
getPreviousWordType
int
target
char
begin
int
end
int
offset
int
opts
int
int
ret
getWordType
target
begin
end
offset
opts
while
ret
WT_IGNORE
ret
getWordType
target
begin
end
offset
opts
return
ret
getWordType
int
target
char
begin
int
end
int
offset
int
opts
int
if
offset
begin
offset
end
return
WT_OTHER
return
getWordType0
target
offset
opts
regionMatches
boolean
target
char
offset
int
limit
int
part
String
partlen
int
if
offset
return
if
limit
offset
partlen
return
int
i
while
partlen
block
if
target
offset
charAt
i
return
return
regionMatches
boolean
target
char
offset
int
limit
int
offset2
int
partlen
int
if
offset
return
if
limit
offset
partlen
return
int
i
offset2
while
partlen
block
if
target
offset
target
i
return
return
regionMatchesIgnoreCase
boolean
target
char
offset
int
limit
int
part
String
partlen
int
if
offset
return
if
limit
offset
partlen
return
int
i
while
partlen
block
char
ch1
target
offset
char
ch2
charAt
i
if
ch1
ch2
continue
char
uch1
toUpperCase
ch1
char
uch2
toUpperCase
ch2
if
uch1
uch2
continue
if
toLowerCase
uch1
toLowerCase
uch2
return
return
regionMatchesIgnoreCase
boolean
target
char
offset
int
limit
int
offset2
int
partlen
int
if
offset
return
if
limit
offset
partlen
return
int
i
offset2
while
partlen
block
char
ch1
target
offset
char
ch2
target
i
if
ch1
ch2
continue
char
uch1
toUpperCase
ch1
char
uch2
toUpperCase
ch2
if
uch1
uch2
continue
if
toLowerCase
uch1
toLowerCase
uch2
return
return
matches
boolean
target
String
return
matches
target
length
Match
matches
boolean
target
String
start
int
end
int
return
matches
target
start
end
Match
matches
boolean
target
String
match
Match
return
matches
target
length
match
matches
boolean
target
String
start
int
end
int
match
Match
synchronized
if
operations
prepare
if
context
context
Context
Context
con
synchronized
context
con
context
inuse
Context
context
reset
target
start
end
numberOfClosures
if
match
block
setNumberOfGroups
nofparen
setSource
target
if
hasBackReferences
block
match
Match
setNumberOfGroups
nofparen
match
match
if
isSet
options
XMLSCHEMA_MODE
block
if
DEBUG
block
println
target
int
matchEnd
matchString
con
operations
start
options
if
DEBUG
block
println
matchEnd
println
limit
if
matchEnd
limit
block
if
match
block
setBeginning
start
setEnd
matchEnd
inuse
return
return
if
fixedStringOnly
block
int
o
fixedStringTable
matches
target
start
limit
if
o
block
if
match
block
setBeginning
o
setEnd
o
fixedString
length
inuse
return
inuse
return
if
fixedString
block
int
o
fixedStringTable
matches
target
start
limit
if
o
block
inuse
return
int
limit
limit
minlength
int
matchStart
int
matchEnd
if
operations
operations
type
CLOSURE
operations
getChild
type
DOT
block
if
isSet
options
SINGLE_LINE
block
matchStart
start
matchEnd
matchString
con
operations
start
options
block
boolean
previousIsEOL
for
forControl
matchStart
start
matchStart
limit
matchStart
block
int
ch
charAt
matchStart
if
isEOLChar
ch
block
previousIsEOL
block
if
previousIsEOL
block
if
matchEnd
matchString
con
operations
matchStart
options
break
previousIsEOL
if
firstChar
block
RangeToken
range
firstChar
if
isSet
options
IGNORE_CASE
block
range
firstChar
getCaseInsensitiveToken
for
forControl
matchStart
start
matchStart
limit
matchStart
block
int
ch
charAt
matchStart
if
isHighSurrogate
ch
matchStart
limit
block
ch
composeFromSurrogates
ch
charAt
matchStart
if
match
ch
continue
block
if
match
ch
block
char
ch1
toUpperCase
char
ch
if
match
ch1
if
match
toLowerCase
ch1
continue
if
matchEnd
matchString
con
operations
matchStart
options
break
block
for
forControl
matchStart
start
matchStart
limit
matchStart
block
int
ch
charAt
matchStart
if
isHighSurrogate
ch
matchStart
limit
ch
composeFromSurrogates
ch
charAt
matchStart
if
match
ch
continue
if
matchEnd
matchString
con
operations
matchStart
options
break
block
for
forControl
matchStart
start
matchStart
limit
matchStart
block
if
matchEnd
matchString
con
operations
matchStart
options
break
if
matchEnd
block
if
match
block
setBeginning
matchStart
setEnd
matchEnd
inuse
return
block
inuse
return
matchString
int
con
Context
op
Op
offset
int
dx
int
opts
int
String
target
strTarget
while
block
if
op
return
offset
if
offset
limit
offset
start
return
switch
type
case
CHAR
if
isSet
opts
IGNORE_CASE
block
int
ch
getData
if
dx
block
if
offset
limit
matchIgnoreCase
ch
charAt
offset
return
offset
block
int
o1
offset
if
o1
limit
o1
matchIgnoreCase
ch
charAt
o1
return
offset
o1
block
int
ch
getData
if
dx
block
if
offset
limit
ch
charAt
offset
return
offset
block
int
o1
offset
if
o1
limit
o1
ch
charAt
o1
return
offset
o1
op
next
break
case
DOT
if
dx
block
if
offset
limit
return
int
ch
charAt
offset
if
isSet
opts
SINGLE_LINE
block
if
isHighSurrogate
ch
offset
limit
offset
block
if
isHighSurrogate
ch
offset
limit
ch
composeFromSurrogates
ch
charAt
offset
if
isEOLChar
ch
return
offset
block
int
o1
offset
if
o1
limit
o1
return
int
ch
charAt
o1
if
isSet
opts
SINGLE_LINE
block
if
isLowSurrogate
ch
o1
o1
block
if
isLowSurrogate
ch
o1
ch
composeFromSurrogates
charAt
o1
ch
if
isEOLChar
ch
return
offset
o1
op
next
break
case
RANGE
NRANGE
if
dx
block
if
offset
limit
return
int
ch
charAt
offset
if
isHighSurrogate
ch
offset
limit
ch
composeFromSurrogates
ch
charAt
offset
RangeToken
tok
getToken
if
isSet
opts
IGNORE_CASE
block
tok
getCaseInsensitiveToken
if
match
ch
block
if
ch
return
char
uch
if
match
uch
toUpperCase
char
ch
match
toLowerCase
uch
return
block
if
match
ch
return
offset
block
int
o1
offset
if
o1
limit
o1
return
int
ch
charAt
o1
if
isLowSurrogate
ch
o1
ch
composeFromSurrogates
charAt
o1
ch
RangeToken
tok
getToken
if
isSet
opts
IGNORE_CASE
block
tok
getCaseInsensitiveToken
if
match
ch
block
if
ch
return
char
uch
if
match
uch
toUpperCase
char
ch
match
toLowerCase
uch
return
block
if
match
ch
return
offset
o1
op
next
break
case
ANCHOR
boolean
go
switch
getData
case
if
isSet
opts
MULTIPLE_LINES
block
if
offset
start
offset
start
isEOLChar
charAt
offset
return
block
if
offset
start
return
break
case
if
offset
start
offset
start
isEOLChar
charAt
offset
return
break
case
if
isSet
opts
MULTIPLE_LINES
block
if
offset
limit
offset
limit
isEOLChar
charAt
offset
return
block
if
offset
limit
offset
limit
isEOLChar
charAt
offset
offset
limit
charAt
offset
CARRIAGE_RETURN
charAt
offset
LINE_FEED
return
break
case
if
offset
start
return
break
case
if
offset
limit
offset
limit
isEOLChar
charAt
offset
offset
limit
charAt
offset
CARRIAGE_RETURN
charAt
offset
LINE_FEED
return
break
case
if
offset
limit
return
break
case
if
length
return
block
int
after
getWordType
target
start
limit
offset
opts
if
after
WT_IGNORE
return
int
before
getPreviousWordType
target
start
limit
offset
opts
if
after
before
return
break
case
if
length
go
block
int
after
getWordType
target
start
limit
offset
opts
go
after
WT_IGNORE
after
getPreviousWordType
target
start
limit
offset
opts
if
go
return
break
case
if
length
offset
limit
return
if
getWordType
target
start
limit
offset
opts
WT_LETTER
getPreviousWordType
target
start
limit
offset
opts
WT_OTHER
return
break
case
if
length
offset
start
return
if
getWordType
target
start
limit
offset
opts
WT_OTHER
getPreviousWordType
target
start
limit
offset
opts
WT_LETTER
return
break
op
next
break
case
BACKREFERENCE
block
int
refno
getData
if
refno
refno
nofparen
throw
RuntimeException
refno
if
getBeginning
refno
getEnd
refno
return
int
o2
getBeginning
refno
int
literallen
getEnd
refno
o2
if
isSet
opts
IGNORE_CASE
block
if
dx
block
if
regionMatches
target
offset
limit
o2
literallen
return
offset
literallen
block
if
regionMatches
target
offset
literallen
limit
o2
literallen
return
offset
literallen
block
if
dx
block
if
regionMatchesIgnoreCase
target
offset
limit
o2
literallen
return
offset
literallen
block
if
regionMatchesIgnoreCase
target
offset
literallen
limit
o2
literallen
return
offset
literallen
op
next
break
case
STRING
block
String
literal
getString
int
literallen
length
if
isSet
opts
IGNORE_CASE
block
if
dx
block
if
regionMatches
target
offset
limit
literal
literallen
return
offset
literallen
block
if
regionMatches
target
offset
literallen
limit
literal
literallen
return
offset
literallen
block
if
dx
block
if
regionMatchesIgnoreCase
target
offset
limit
literal
literallen
return
offset
literallen
block
if
regionMatchesIgnoreCase
target
offset
literallen
limit
literal
literallen
return
offset
literallen
op
next
break
case
CLOSURE
block
int
id
getData
if
id
block
int
previousOffset
offsets
id
if
previousOffset
previousOffset
offset
block
offsets
id
offset
block
offsets
id
op
next
break
int
ret
matchString
con
getChild
offset
dx
opts
if
id
offsets
id
if
ret
return
ret
op
next
break
case
QUESTION
block
int
ret
matchString
con
getChild
offset
dx
opts
if
ret
return
ret
op
next
break
case
NONGREEDYCLOSURE
NONGREEDYQUESTION
block
int
ret
matchString
con
next
offset
dx
opts
if
ret
return
ret
op
getChild
break
case
UNION
for
forControl
int
i
i
size
i
block
int
ret
matchString
con
elementAt
i
offset
dx
opts
if
DEBUG
block
println
i
ret
if
ret
length
return
ret
return
case
CAPTURE
int
refno
getData
if
match
refno
block
int
save
getBeginning
refno
setBeginning
refno
offset
int
ret
matchString
con
next
offset
dx
opts
if
ret
setBeginning
refno
save
return
ret
if
match
refno
block
int
index
refno
int
save
getEnd
index
setEnd
index
offset
int
ret
matchString
con
next
offset
dx
opts
if
ret
setEnd
index
save
return
ret
op
next
break
case
LOOKAHEAD
if
matchString
con
getChild
offset
opts
return
op
next
break
case
NEGATIVELOOKAHEAD
if
matchString
con
getChild
offset
opts
return
op
next
break
case
LOOKBEHIND
if
matchString
con
getChild
offset
opts
return
op
next
break
case
NEGATIVELOOKBEHIND
if
matchString
con
getChild
offset
opts
return
op
next
break
case
INDEPENDENT
block
int
ret
matchString
con
getChild
offset
dx
opts
if
ret
return
ret
offset
ret
op
next
break
case
MODIFIER
block
int
localopts
opts
localopts
getData
localopts
getData2
int
ret
matchString
con
getChild
offset
dx
localopts
if
ret
return
ret
offset
ret
op
next
break
case
CONDITION
block
Op
ConditionOp
cop
Op
ConditionOp
op
boolean
matchp
if
refNumber
block
if
refNumber
nofparen
throw
RuntimeException
refNumber
matchp
getBeginning
refNumber
getEnd
refNumber
block
matchp
matchString
con
condition
offset
dx
opts
if
matchp
block
op
yes
if
no
block
op
no
block
op
next
break
case
throw
RuntimeException
type
getPreviousWordType
int
target
String
begin
int
end
int
offset
int
opts
int
int
ret
getWordType
target
begin
end
offset
opts
while
ret
WT_IGNORE
ret
getWordType
target
begin
end
offset
opts
return
ret
getWordType
int
target
String
begin
int
end
int
offset
int
opts
int
if
offset
begin
offset
end
return
WT_OTHER
return
getWordType0
charAt
offset
opts
regionMatches
boolean
text
String
offset
int
limit
int
part
String
partlen
int
if
limit
offset
partlen
return
return
regionMatches
offset
part
partlen
regionMatches
boolean
text
String
offset
int
limit
int
offset2
int
partlen
int
if
limit
offset
partlen
return
return
regionMatches
offset
text
offset2
partlen
regionMatchesIgnoreCase
boolean
text
String
offset
int
limit
int
part
String
partlen
int
return
regionMatches
offset
part
partlen
regionMatchesIgnoreCase
boolean
text
String
offset
int
limit
int
offset2
int
partlen
int
if
limit
offset
partlen
return
return
regionMatches
offset
text
offset2
partlen
matches
boolean
target
CharacterIterator
return
matches
target
Match
matches
boolean
target
CharacterIterator
match
Match
int
start
getBeginIndex
int
end
getEndIndex
synchronized
if
operations
prepare
if
context
context
Context
Context
con
synchronized
context
con
context
inuse
Context
context
reset
target
start
end
numberOfClosures
if
match
block
setNumberOfGroups
nofparen
setSource
target
if
hasBackReferences
block
match
Match
setNumberOfGroups
nofparen
match
match
if
isSet
options
XMLSCHEMA_MODE
block
int
matchEnd
matchCharacterIterator
con
operations
start
options
if
matchEnd
limit
block
if
match
block
setBeginning
start
setEnd
matchEnd
inuse
return
return
if
fixedStringOnly
block
int
o
fixedStringTable
matches
target
start
limit
if
o
block
if
match
block
setBeginning
o
setEnd
o
fixedString
length
inuse
return
inuse
return
if
fixedString
block
int
o
fixedStringTable
matches
target
start
limit
if
o
block
inuse
return
int
limit
limit
minlength
int
matchStart
int
matchEnd
if
operations
operations
type
CLOSURE
operations
getChild
type
DOT
block
if
isSet
options
SINGLE_LINE
block
matchStart
start
matchEnd
matchCharacterIterator
con
operations
start
options
block
boolean
previousIsEOL
for
forControl
matchStart
start
matchStart
limit
matchStart
block
int
ch
setIndex
matchStart
if
isEOLChar
ch
block
previousIsEOL
block
if
previousIsEOL
block
if
matchEnd
matchCharacterIterator
con
operations
matchStart
options
break
previousIsEOL
if
firstChar
block
RangeToken
range
firstChar
if
isSet
options
IGNORE_CASE
block
range
firstChar
getCaseInsensitiveToken
for
forControl
matchStart
start
matchStart
limit
matchStart
block
int
ch
setIndex
matchStart
if
isHighSurrogate
ch
matchStart
limit
block
ch
composeFromSurrogates
ch
setIndex
matchStart
if
match
ch
continue
block
if
match
ch
block
char
ch1
toUpperCase
char
ch
if
match
ch1
if
match
toLowerCase
ch1
continue
if
matchEnd
matchCharacterIterator
con
operations
matchStart
options
break
block
for
forControl
matchStart
start
matchStart
limit
matchStart
block
int
ch
setIndex
matchStart
if
isHighSurrogate
ch
matchStart
limit
ch
composeFromSurrogates
ch
setIndex
matchStart
if
match
ch
continue
if
matchEnd
matchCharacterIterator
con
operations
matchStart
options
break
block
for
forControl
matchStart
start
matchStart
limit
matchStart
block
if
matchEnd
matchCharacterIterator
con
operations
matchStart
options
break
if
matchEnd
block
if
match
block
setBeginning
matchStart
setEnd
matchEnd
inuse
return
block
inuse
return
matchCharacterIterator
int
con
Context
op
Op
offset
int
dx
int
opts
int
CharacterIterator
target
ciTarget
while
block
if
op
return
offset
if
offset
limit
offset
start
return
switch
type
case
CHAR
if
isSet
opts
IGNORE_CASE
block
int
ch
getData
if
dx
block
if
offset
limit
matchIgnoreCase
ch
setIndex
offset
return
offset
block
int
o1
offset
if
o1
limit
o1
matchIgnoreCase
ch
setIndex
o1
return
offset
o1
block
int
ch
getData
if
dx
block
if
offset
limit
ch
setIndex
offset
return
offset
block
int
o1
offset
if
o1
limit
o1
ch
setIndex
o1
return
offset
o1
op
next
break
case
DOT
if
dx
block
if
offset
limit
return
int
ch
setIndex
offset
if
isSet
opts
SINGLE_LINE
block
if
isHighSurrogate
ch
offset
limit
offset
block
if
isHighSurrogate
ch
offset
limit
ch
composeFromSurrogates
ch
setIndex
offset
if
isEOLChar
ch
return
offset
block
int
o1
offset
if
o1
limit
o1
return
int
ch
setIndex
o1
if
isSet
opts
SINGLE_LINE
block
if
isLowSurrogate
ch
o1
o1
block
if
isLowSurrogate
ch
o1
ch
composeFromSurrogates
setIndex
o1
ch
if
isEOLChar
ch
return
offset
o1
op
next
break
case
RANGE
NRANGE
if
dx
block
if
offset
limit
return
int
ch
setIndex
offset
if
isHighSurrogate
ch
offset
limit
ch
composeFromSurrogates
ch
setIndex
offset
RangeToken
tok
getToken
if
isSet
opts
IGNORE_CASE
block
tok
getCaseInsensitiveToken
if
match
ch
block
if
ch
return
char
uch
if
match
uch
toUpperCase
char
ch
match
toLowerCase
uch
return
block
if
match
ch
return
offset
block
int
o1
offset
if
o1
limit
o1
return
int
ch
setIndex
o1
if
isLowSurrogate
ch
o1
ch
composeFromSurrogates
setIndex
o1
ch
RangeToken
tok
getToken
if
isSet
opts
IGNORE_CASE
block
tok
getCaseInsensitiveToken
if
match
ch
block
if
ch
return
char
uch
if
match
uch
toUpperCase
char
ch
match
toLowerCase
uch
return
block
if
match
ch
return
offset
o1
op
next
break
case
ANCHOR
boolean
go
switch
getData
case
if
isSet
opts
MULTIPLE_LINES
block
if
offset
start
offset
start
isEOLChar
setIndex
offset
return
block
if
offset
start
return
break
case
if
offset
start
offset
start
isEOLChar
setIndex
offset
return
break
case
if
isSet
opts
MULTIPLE_LINES
block
if
offset
limit
offset
limit
isEOLChar
setIndex
offset
return
block
if
offset
limit
offset
limit
isEOLChar
setIndex
offset
offset
limit
setIndex
offset
CARRIAGE_RETURN
setIndex
offset
LINE_FEED
return
break
case
if
offset
start
return
break
case
if
offset
limit
offset
limit
isEOLChar
setIndex
offset
offset
limit
setIndex
offset
CARRIAGE_RETURN
setIndex
offset
LINE_FEED
return
break
case
if
offset
limit
return
break
case
if
length
return
block
int
after
getWordType
target
start
limit
offset
opts
if
after
WT_IGNORE
return
int
before
getPreviousWordType
target
start
limit
offset
opts
if
after
before
return
break
case
if
length
go
block
int
after
getWordType
target
start
limit
offset
opts
go
after
WT_IGNORE
after
getPreviousWordType
target
start
limit
offset
opts
if
go
return
break
case
if
length
offset
limit
return
if
getWordType
target
start
limit
offset
opts
WT_LETTER
getPreviousWordType
target
start
limit
offset
opts
WT_OTHER
return
break
case
if
length
offset
start
return
if
getWordType
target
start
limit
offset
opts
WT_OTHER
getPreviousWordType
target
start
limit
offset
opts
WT_LETTER
return
break
op
next
break
case
BACKREFERENCE
block
int
refno
getData
if
refno
refno
nofparen
throw
RuntimeException
refno
if
getBeginning
refno
getEnd
refno
return
int
o2
getBeginning
refno
int
literallen
getEnd
refno
o2
if
isSet
opts
IGNORE_CASE
block
if
dx
block
if
regionMatches
target
offset
limit
o2
literallen
return
offset
literallen
block
if
regionMatches
target
offset
literallen
limit
o2
literallen
return
offset
literallen
block
if
dx
block
if
regionMatchesIgnoreCase
target
offset
limit
o2
literallen
return
offset
literallen
block
if
regionMatchesIgnoreCase
target
offset
literallen
limit
o2
literallen
return
offset
literallen
op
next
break
case
STRING
block
String
literal
getString
int
literallen
length
if
isSet
opts
IGNORE_CASE
block
if
dx
block
if
regionMatches
target
offset
limit
literal
literallen
return
offset
literallen
block
if
regionMatches
target
offset
literallen
limit
literal
literallen
return
offset
literallen
block
if
dx
block
if
regionMatchesIgnoreCase
target
offset
limit
literal
literallen
return
offset
literallen
block
if
regionMatchesIgnoreCase
target
offset
literallen
limit
literal
literallen
return
offset
literallen
op
next
break
case
CLOSURE
block
int
id
getData
if
id
block
int
previousOffset
offsets
id
if
previousOffset
previousOffset
offset
block
offsets
id
offset
block
offsets
id
op
next
break
int
ret
matchCharacterIterator
con
getChild
offset
dx
opts
if
id
offsets
id
if
ret
return
ret
op
next
break
case
QUESTION
block
int
ret
matchCharacterIterator
con
getChild
offset
dx
opts
if
ret
return
ret
op
next
break
case
NONGREEDYCLOSURE
NONGREEDYQUESTION
block
int
ret
matchCharacterIterator
con
next
offset
dx
opts
if
ret
return
ret
op
getChild
break
case
UNION
for
forControl
int
i
i
size
i
block
int
ret
matchCharacterIterator
con
elementAt
i
offset
dx
opts
if
DEBUG
block
println
i
ret
if
ret
length
return
ret
return
case
CAPTURE
int
refno
getData
if
match
refno
block
int
save
getBeginning
refno
setBeginning
refno
offset
int
ret
matchCharacterIterator
con
next
offset
dx
opts
if
ret
setBeginning
refno
save
return
ret
if
match
refno
block
int
index
refno
int
save
getEnd
index
setEnd
index
offset
int
ret
matchCharacterIterator
con
next
offset
dx
opts
if
ret
setEnd
index
save
return
ret
op
next
break
case
LOOKAHEAD
if
matchCharacterIterator
con
getChild
offset
opts
return
op
next
break
case
NEGATIVELOOKAHEAD
if
matchCharacterIterator
con
getChild
offset
opts
return
op
next
break
case
LOOKBEHIND
if
matchCharacterIterator
con
getChild
offset
opts
return
op
next
break
case
NEGATIVELOOKBEHIND
if
matchCharacterIterator
con
getChild
offset
opts
return
op
next
break
case
INDEPENDENT
block
int
ret
matchCharacterIterator
con
getChild
offset
dx
opts
if
ret
return
ret
offset
ret
op
next
break
case
MODIFIER
block
int
localopts
opts
localopts
getData
localopts
getData2
int
ret
matchCharacterIterator
con
getChild
offset
dx
localopts
if
ret
return
ret
offset
ret
op
next
break
case
CONDITION
block
Op
ConditionOp
cop
Op
ConditionOp
op
boolean
matchp
if
refNumber
block
if
refNumber
nofparen
throw
RuntimeException
refNumber
matchp
getBeginning
refNumber
getEnd
refNumber
block
matchp
matchCharacterIterator
con
condition
offset
dx
opts
if
matchp
block
op
yes
if
no
block
op
no
block
op
next
break
case
throw
RuntimeException
type
getPreviousWordType
int
target
CharacterIterator
begin
int
end
int
offset
int
opts
int
int
ret
getWordType
target
begin
end
offset
opts
while
ret
WT_IGNORE
ret
getWordType
target
begin
end
offset
opts
return
ret
getWordType
int
target
CharacterIterator
begin
int
end
int
offset
int
opts
int
if
offset
begin
offset
end
return
WT_OTHER
return
getWordType0
setIndex
offset
opts
regionMatches
boolean
target
CharacterIterator
offset
int
limit
int
part
String
partlen
int
if
offset
return
if
limit
offset
partlen
return
int
i
while
partlen
block
if
setIndex
offset
charAt
i
return
return
regionMatches
boolean
target
CharacterIterator
offset
int
limit
int
offset2
int
partlen
int
if
offset
return
if
limit
offset
partlen
return
int
i
offset2
while
partlen
block
if
setIndex
offset
setIndex
i
return
return
regionMatchesIgnoreCase
boolean
target
CharacterIterator
offset
int
limit
int
part
String
partlen
int
if
offset
return
if
limit
offset
partlen
return
int
i
while
partlen
block
char
ch1
setIndex
offset
char
ch2
charAt
i
if
ch1
ch2
continue
char
uch1
toUpperCase
ch1
char
uch2
toUpperCase
ch2
if
uch1
uch2
continue
if
toLowerCase
uch1
toLowerCase
uch2
return
return
regionMatchesIgnoreCase
boolean
target
CharacterIterator
offset
int
limit
int
offset2
int
partlen
int
if
offset
return
if
limit
offset
partlen
return
int
i
offset2
while
partlen
block
char
ch1
setIndex
offset
char
ch2
setIndex
i
if
ch1
ch2
continue
char
uch1
toUpperCase
ch1
char
uch2
toUpperCase
ch2
if
uch1
uch2
continue
if
toLowerCase
uch1
toLowerCase
uch2
return
return
String
regex
int
options
int
nofparen
Token
tokentree
boolean
hasBackReferences
int
minlength
Op
operations
int
numberOfClosures
Context
context
RangeToken
firstChar
String
fixedString
int
fixedStringOptions
BMPattern
fixedStringTable
boolean
fixedStringOnly
Context
CharacterIterator
ciTarget
String
strTarget
char
charTarget
int
start
int
limit
int
length
Match
match
boolean
inuse
int
offsets
Context
resetCommon
nofclosures
int
length
limit
start
inuse
match
if
offsets
offsets
length
nofclosures
offsets
int
nofclosures
for
forControl
int
i
i
nofclosures
i
offsets
i
reset
target
CharacterIterator
start
int
limit
int
nofclosures
int
ciTarget
target
start
start
limit
limit
resetCommon
nofclosures
reset
target
String
start
int
limit
int
nofclosures
int
strTarget
target
start
start
limit
limit
resetCommon
nofclosures
reset
target
char
start
int
limit
int
nofclosures
int
charTarget
target
start
start
limit
limit
resetCommon
nofclosures
prepare
if
COUNT
nofinstances
compile
tokentree
if
COUNT
println
nofinstances
minlength
tokentree
getMinLength
firstChar
if
isSet
options
PROHIBIT_HEAD_CHARACTER_OPTIMIZATION
isSet
options
XMLSCHEMA_MODE
block
RangeToken
firstChar
createRange
int
fresult
tokentree
analyzeFirstCharacter
firstChar
options
if
fresult
FC_TERMINAL
block
compactRanges
firstChar
firstChar
if
DEBUG
println
firstChar
if
operations
operations
type
STRING
operations
type
CHAR
operations
next
block
if
DEBUG
print
fixedStringOnly
if
operations
type
STRING
fixedString
operations
getString
if
operations
getData
block
fixedString
decomposeToSurrogates
operations
getData
block
char
ac
char
ac
char
operations
getData
fixedString
String
ac
fixedStringOptions
options
fixedStringTable
BMPattern
fixedString
isSet
fixedStringOptions
IGNORE_CASE
if
isSet
options
PROHIBIT_FIXED_STRING_OPTIMIZATION
isSet
options
XMLSCHEMA_MODE
block
Token
FixedStringContainer
container
Token
FixedStringContainer
tokentree
findFixedString
container
options
fixedString
token
getString
fixedStringOptions
options
if
fixedString
fixedString
length
fixedString
if
fixedString
block
fixedStringTable
BMPattern
fixedString
isSet
fixedStringOptions
IGNORE_CASE
if
DEBUG
block
println
fixedString
length
createOptionString
fixedStringOptions
print
dumpString
fixedString
int
IGNORE_CASE
int
SINGLE_LINE
int
MULTIPLE_LINES
int
EXTENDED_COMMENT
int
USE_UNICODE_CATEGORY
int
UNICODE_WORD_BOUNDARY
int
PROHIBIT_HEAD_CHARACTER_OPTIMIZATION
int
PROHIBIT_FIXED_STRING_OPTIMIZATION
int
XMLSCHEMA_MODE
int
SPECIAL_COMMA
isSet
boolean
options
int
flag
int
return
options
flag
flag
RegularExpression
regex
String
setPattern
regex
RegularExpression
regex
String
options
String
setPattern
regex
options
RegularExpression
regex
String
tok
Token
parens
int
hasBackReferences
boolean
options
int
regex
regex
tokentree
tok
nofparen
parens
options
options
hasBackReferences
hasBackReferences
setPattern
newPattern
String
setPattern
newPattern
options
setPattern
newPattern
String
options
int
regex
newPattern
options
options
RegexParser
rp
isSet
options
XMLSCHEMA_MODE
ParserForXMLSchema
RegexParser
tokentree
parse
regex
options
nofparen
parennumber
hasBackReferences
hasBackReferences
operations
context
setPattern
newPattern
String
options
String
setPattern
newPattern
parseOptions
options
getPattern
String
return
regex
toString
String
return
tokentree
toString
options
getOptions
String
return
createOptionString
options
equals
boolean
obj
Object
if
obj
return
if
obj
RegularExpression
return
RegularExpression
r
RegularExpression
obj
return
regex
equals
regex
options
options
equals
boolean
pattern
String
options
int
return
regex
equals
pattern
options
options
hashCode
int
return
regex
getOptions
getNumberOfGroups
int
return
nofparen
int
WT_IGNORE
int
WT_LETTER
int
WT_OTHER
Token
wordchar
getWordType0
int
ch
char
opts
int
if
isSet
opts
UNICODE_WORD_BOUNDARY
block
if
isSet
opts
USE_UNICODE_CATEGORY
block
if
wordchar
wordchar
getRange
return
match
ch
WT_LETTER
WT_OTHER
return
isWordChar
ch
WT_LETTER
WT_OTHER
switch
getType
ch
case
UPPERCASE_LETTER
LOWERCASE_LETTER
TITLECASE_LETTER
MODIFIER_LETTER
OTHER_LETTER
LETTER_NUMBER
DECIMAL_DIGIT_NUMBER
OTHER_NUMBER
COMBINING_SPACING_MARK
return
WT_LETTER
case
FORMAT
NON_SPACING_MARK
ENCLOSING_MARK
return
WT_IGNORE
case
CONTROL
switch
ch
case
return
WT_OTHER
case
return
WT_IGNORE
case
return
WT_OTHER
int
LINE_FEED
int
CARRIAGE_RETURN
int
LINE_SEPARATOR
int
PARAGRAPH_SEPARATOR
isEOLChar
boolean
ch
int
return
ch
LINE_FEED
ch
CARRIAGE_RETURN
ch
LINE_SEPARATOR
ch
PARAGRAPH_SEPARATOR
isWordChar
boolean
ch
int
if
ch
return
if
ch
return
if
ch
return
if
ch
return
if
ch
return
if
ch
return
if
ch
return
return
matchIgnoreCase
boolean
chardata
int
ch
int
if
chardata
ch
return
if
chardata
ch
return
char
uch1
toUpperCase
char
chardata
char
uch2
toUpperCase
char
ch
if
uch1
uch2
return
return
toLowerCase
uch1
toLowerCase
uch2
java
io
Serializable
