RegexParser
int
T_CHAR
int
T_EOF
int
T_OR
int
T_STAR
int
T_PLUS
int
T_QUESTION
int
T_LPAREN
int
T_RPAREN
int
T_DOT
int
T_LBRACKET
int
T_BACKSOLIDUS
int
T_CARET
int
T_DOLLAR
int
T_LPAREN2
int
T_LOOKAHEAD
int
T_NEGATIVELOOKAHEAD
int
T_LOOKBEHIND
int
T_NEGATIVELOOKBEHIND
int
T_INDEPENDENT
int
T_SET_OPERATIONS
int
T_POSIX_CHARCLASS_START
int
T_COMMENT
int
T_MODIFIERS
int
T_CONDITION
int
T_XMLSCHEMA_CC_SUBTRACTION
ReferencePosition
int
refNumber
int
position
ReferencePosition
n
int
pos
int
refNumber
n
position
pos
int
offset
String
regex
int
regexlen
int
options
ResourceBundle
resources
int
chardata
int
nexttoken
int
S_NORMAL
int
S_INBRACKETS
int
S_INXBRACKETS
int
context
S_NORMAL
int
parennumber
boolean
hasBackReferences
Vector
references
RegexParser
RegexParser
locale
Locale
setLocale
locale
Locale
try
resources
getBundle
locale
catchClause
mre
throw
RuntimeException
getMessage
ex
ParseException
key
String
loc
int
return
ParseException
resources
getString
key
loc
isSet
boolean
flag
int
return
options
flag
flag
parse
Token
regex
String
options
int
options
options
offset
setContext
S_NORMAL
parennumber
hasBackReferences
regex
regex
if
isSet
EXTENDED_COMMENT
regex
stripExtendedComment
regex
regexlen
regex
length
next
Token
ret
parseRegex
if
offset
regexlen
throw
ex
offset
if
references
block
for
forControl
int
i
i
references
size
i
block
ReferencePosition
position
ReferencePosition
references
elementAt
i
if
parennumber
refNumber
throw
ex
position
references
removeAllElements
return
ret
setContext
con
int
context
con
read
int
return
nexttoken
next
if
offset
regexlen
block
chardata
nexttoken
T_EOF
return
int
ret
int
ch
regex
charAt
offset
chardata
ch
if
context
S_INBRACKETS
block
switch
ch
case
ret
T_BACKSOLIDUS
if
offset
regexlen
throw
ex
offset
chardata
regex
charAt
offset
break
case
if
isSet
XMLSCHEMA_MODE
offset
regexlen
regex
charAt
offset
block
offset
ret
T_XMLSCHEMA_CC_SUBTRACTION
ret
T_CHAR
break
case
if
isSet
XMLSCHEMA_MODE
offset
regexlen
regex
charAt
offset
block
offset
ret
T_POSIX_CHARCLASS_START
break
case
if
isHighSurrogate
ch
offset
regexlen
block
int
low
regex
charAt
offset
if
isLowSurrogate
low
block
chardata
composeFromSurrogates
ch
low
offset
ret
T_CHAR
nexttoken
ret
return
switch
ch
case
ret
T_OR
break
case
ret
T_STAR
break
case
ret
T_PLUS
break
case
ret
T_QUESTION
break
case
ret
T_RPAREN
break
case
ret
T_DOT
break
case
ret
T_LBRACKET
break
case
ret
T_CARET
break
case
ret
T_DOLLAR
break
case
ret
T_LPAREN
if
offset
regexlen
break
if
regex
charAt
offset
break
if
offset
regexlen
throw
ex
offset
ch
regex
charAt
offset
switch
ch
case
ret
T_LPAREN2
break
case
ret
T_LOOKAHEAD
break
case
ret
T_NEGATIVELOOKAHEAD
break
case
ret
T_SET_OPERATIONS
break
case
ret
T_INDEPENDENT
break
case
if
offset
regexlen
throw
ex
offset
ch
regex
charAt
offset
if
ch
block
ret
T_LOOKBEHIND
if
ch
block
ret
T_NEGATIVELOOKBEHIND
throw
ex
offset
break
case
while
offset
regexlen
block
ch
regex
charAt
offset
if
ch
break
if
ch
throw
ex
offset
ret
T_COMMENT
break
case
if
ch
ch
ch
ch
ch
block
offset
ret
T_MODIFIERS
break
if
ch
block
ret
T_CONDITION
break
throw
ex
offset
break
case
ret
T_BACKSOLIDUS
if
offset
regexlen
throw
ex
offset
chardata
regex
charAt
offset
break
case
ret
T_CHAR
if
isHighSurrogate
chardata
offset
regexlen
chardata
composeFromSurrogates
chardata
regex
charAt
offset
nexttoken
ret
parseRegex
Token
Token
tok
parseTerm
Token
parent
while
read
T_OR
block
next
if
parent
block
parent
createUnion
addChild
tok
tok
parent
addChild
parseTerm
return
tok
parseTerm
Token
int
ch
read
if
ch
T_OR
ch
T_RPAREN
ch
T_EOF
block
return
createEmpty
block
Token
tok
parseFactor
Token
concat
while
ch
read
T_OR
ch
T_RPAREN
ch
T_EOF
block
if
concat
block
concat
createConcat
addChild
tok
tok
concat
addChild
parseFactor
return
tok
processCaret
Token
next
return
token_linebeginning
processDollar
Token
next
return
token_lineend
processLookahead
Token
next
Token
tok
createLook
LOOKAHEAD
parseRegex
if
read
T_RPAREN
throw
ex
offset
next
return
tok
processNegativelookahead
Token
next
Token
tok
createLook
NEGATIVELOOKAHEAD
parseRegex
if
read
T_RPAREN
throw
ex
offset
next
return
tok
processLookbehind
Token
next
Token
tok
createLook
LOOKBEHIND
parseRegex
if
read
T_RPAREN
throw
ex
offset
next
return
tok
processNegativelookbehind
Token
next
Token
tok
createLook
NEGATIVELOOKBEHIND
parseRegex
if
read
T_RPAREN
throw
ex
offset
next
return
tok
processBacksolidus_A
Token
next
return
token_stringbeginning
processBacksolidus_Z
Token
next
return
token_stringend2
processBacksolidus_z
Token
next
return
token_stringend
processBacksolidus_b
Token
next
return
token_wordedge
processBacksolidus_B
Token
next
return
token_not_wordedge
processBacksolidus_lt
Token
next
return
token_wordbeginning
processBacksolidus_gt
Token
next
return
token_wordend
processStar
Token
tok
Token
next
if
read
T_QUESTION
block
next
return
createNGClosure
tok
return
createClosure
tok
processPlus
Token
tok
Token
next
if
read
T_QUESTION
block
next
return
createConcat
tok
createNGClosure
tok
return
createConcat
tok
createClosure
tok
processQuestion
Token
tok
Token
next
Token
par
createUnion
if
read
T_QUESTION
block
next
addChild
createEmpty
addChild
tok
block
addChild
tok
addChild
createEmpty
return
par
checkQuestion
boolean
off
int
return
off
regexlen
regex
charAt
off
processParen
Token
next
int
p
parennumber
Token
tok
createParen
parseRegex
p
if
read
T_RPAREN
throw
ex
offset
next
return
tok
processParen2
Token
next
Token
tok
createParen
parseRegex
if
read
T_RPAREN
throw
ex
offset
next
return
tok
processCondition
Token
if
offset
regexlen
throw
ex
offset
int
refno
Token
condition
int
ch
regex
charAt
offset
if
ch
ch
block
refno
ch
hasBackReferences
if
references
references
Vector
references
addElement
ReferencePosition
refno
offset
offset
if
regex
charAt
offset
throw
ex
offset
offset
block
if
ch
offset
next
condition
parseFactor
switch
type
case
LOOKAHEAD
NEGATIVELOOKAHEAD
LOOKBEHIND
NEGATIVELOOKBEHIND
break
case
ANCHOR
if
read
T_RPAREN
throw
ex
offset
break
case
throw
ex
offset
next
Token
yesPattern
parseRegex
Token
noPattern
if
type
UNION
block
if
size
throw
ex
offset
noPattern
getChild
yesPattern
getChild
if
read
T_RPAREN
throw
ex
offset
next
return
createCondition
refno
condition
yesPattern
noPattern
processModifiers
Token
int
add
mask
ch
while
offset
regexlen
block
ch
regex
charAt
offset
int
v
getOptionValue
ch
if
v
break
add
v
offset
if
offset
regexlen
throw
ex
offset
if
ch
block
offset
while
offset
regexlen
block
ch
regex
charAt
offset
int
v
getOptionValue
ch
if
v
break
mask
v
offset
if
offset
regexlen
throw
ex
offset
Token
tok
if
ch
block
offset
next
tok
createModifierGroup
parseRegex
add
mask
if
read
T_RPAREN
throw
ex
offset
next
if
ch
block
offset
next
tok
createModifierGroup
parseRegex
add
mask
throw
ex
offset
return
tok
processIndependent
Token
next
Token
tok
createLook
INDEPENDENT
parseRegex
if
read
T_RPAREN
throw
ex
offset
next
return
tok
processBacksolidus_c
Token
int
ch2
if
offset
regexlen
ch2
regex
charAt
offset
throw
ex
offset
next
return
createChar
ch2
processBacksolidus_C
Token
throw
ex
offset
processBacksolidus_i
Token
Token
tok
createChar
next
return
tok
processBacksolidus_I
Token
throw
ex
offset
processBacksolidus_g
Token
next
return
getGraphemePattern
processBacksolidus_X
Token
next
return
getCombiningCharacterSequence
processBackreference
Token
int
refnum
chardata
Token
tok
createBackReference
refnum
hasBackReferences
if
references
references
Vector
references
addElement
ReferencePosition
refnum
offset
next
return
tok
parseFactor
Token
int
ch
read
Token
tok
switch
ch
case
return
processCaret
case
return
processDollar
case
return
processLookahead
case
return
processNegativelookahead
case
return
processLookbehind
case
return
processNegativelookbehind
case
next
return
createEmpty
case
switch
chardata
case
return
processBacksolidus_A
case
return
processBacksolidus_Z
case
return
processBacksolidus_z
case
return
processBacksolidus_b
case
return
processBacksolidus_B
case
return
processBacksolidus_lt
case
return
processBacksolidus_gt
tok
parseAtom
ch
read
switch
ch
case
return
processStar
tok
case
return
processPlus
tok
case
return
processQuestion
tok
case
if
chardata
block
int
off
offset
int
min
max
if
off
regexlen
break
ch
regex
charAt
off
if
ch
ch
ch
break
if
ch
block
min
ch
while
off
regexlen
ch
regex
charAt
off
ch
block
min
min
ch
ch
if
ch
break
max
min
if
ch
block
if
off
regexlen
ch
regex
charAt
off
ch
ch
break
if
ch
block
max
block
max
ch
while
off
regexlen
ch
regex
charAt
off
ch
block
max
max
ch
ch
if
ch
break
if
ch
break
if
checkQuestion
off
block
tok
createNGClosure
tok
offset
off
block
tok
createClosure
tok
offset
off
setMin
min
setMax
max
next
return
tok
parseAtom
Token
int
ch
read
Token
tok
switch
ch
case
return
processParen
case
return
processParen2
case
return
processCondition
case
return
processModifiers
case
return
processIndependent
case
next
tok
token_dot
break
case
return
parseCharacterClass
case
return
parseSetOperations
case
switch
chardata
case
tok
getTokenForShorthand
chardata
next
return
tok
case
block
int
ch2
decodeEscaped
if
ch2
block
tok
createChar
ch2
block
tok
createString
decomposeToSurrogates
ch2
break
case
return
processBacksolidus_c
case
return
processBacksolidus_C
case
return
processBacksolidus_i
case
return
processBacksolidus_I
case
return
processBacksolidus_g
case
return
processBacksolidus_X
case
return
processBackreference
case
int
pstart
offset
tok
processBacksolidus_pP
chardata
if
tok
throw
ex
pstart
break
case
tok
createChar
chardata
next
break
case
tok
createChar
chardata
next
break
case
throw
ex
offset
return
tok
processBacksolidus_pP
RangeToken
c
int
boolean
positive
c
next
if
read
T_CHAR
throw
ex
offset
RangeToken
tok
switch
chardata
case
tok
getRange
positive
break
case
tok
getRange
positive
break
case
tok
getRange
positive
break
case
tok
getRange
positive
break
case
tok
getRange
positive
break
case
tok
getRange
positive
break
case
tok
getRange
positive
break
case
int
namestart
offset
int
nameend
regex
indexOf
namestart
if
nameend
throw
ex
offset
offset
nameend
tok
getRange
regex
substring
namestart
nameend
positive
break
case
throw
ex
offset
return
tok
processCIinCharacterClass
int
tok
RangeToken
c
int
return
decodeEscaped
parseCharacterClass
RangeToken
useNrange
boolean
setContext
S_INBRACKETS
next
boolean
nrange
RangeToken
base
RangeToken
tok
if
read
T_CHAR
chardata
block
nrange
next
if
useNrange
block
tok
createNRange
block
base
createRange
addRange
UTF16_MAX
tok
createRange
block
tok
createRange
int
type
boolean
firstloop
while
type
read
T_EOF
block
if
type
T_CHAR
chardata
firstloop
break
firstloop
int
c
chardata
boolean
end
if
type
T_BACKSOLIDUS
block
switch
c
case
mergeRanges
getTokenForShorthand
c
end
break
case
c
processCIinCharacterClass
tok
c
if
c
end
break
case
int
pstart
offset
RangeToken
tok2
processBacksolidus_pP
c
if
tok2
throw
ex
pstart
mergeRanges
tok2
end
break
case
c
decodeEscaped
if
type
T_POSIX_CHARCLASS_START
block
int
nameend
regex
indexOf
offset
if
nameend
throw
ex
offset
boolean
positive
if
regex
charAt
offset
block
offset
positive
String
name
regex
substring
offset
nameend
RangeToken
range
getRange
name
positive
if
range
throw
ex
offset
mergeRanges
range
end
if
nameend
regexlen
regex
charAt
nameend
throw
ex
nameend
offset
nameend
next
if
end
block
if
read
T_CHAR
chardata
block
addRange
c
c
block
next
if
type
read
T_EOF
throw
ex
offset
if
type
T_CHAR
chardata
block
addRange
c
c
addRange
block
int
rangeend
chardata
if
type
T_BACKSOLIDUS
rangeend
decodeEscaped
next
addRange
c
rangeend
if
isSet
SPECIAL_COMMA
read
T_CHAR
chardata
next
if
read
T_EOF
throw
ex
offset
if
useNrange
nrange
block
subtractRanges
tok
tok
base
sortRanges
compactRanges
setContext
S_NORMAL
next
return
tok
parseCharacterClass_old
RangeToken
useNrange
boolean
setContext
S_INBRACKETS
next
boolean
nrange
RangeToken
base
RangeToken
tok
if
read
T_CHAR
chardata
block
nrange
next
if
useNrange
block
tok
createNRange
block
base
createRange
addRange
UTF16_MAX
tok
createRange
block
tok
createRange
int
type
while
type
read
T_EOF
type
T_CHAR
chardata
block
int
c
chardata
boolean
end
if
type
T_BACKSOLIDUS
block
switch
c
case
mergeRanges
getTokenForShorthand
c
end
break
case
c
processCIinCharacterClass
tok
c
if
c
end
break
case
boolean
positive
c
int
pstart
offset
next
if
read
T_CHAR
throw
ex
offset
RangeToken
tok2
switch
chardata
case
tok2
getRange
positive
break
case
tok2
getRange
positive
break
case
tok2
getRange
positive
break
case
tok2
getRange
positive
break
case
tok2
getRange
positive
break
case
tok2
getRange
positive
break
case
tok2
getRange
positive
break
case
pstart
offset
int
namestart
offset
int
nameend
regex
indexOf
namestart
if
nameend
throw
ex
offset
offset
nameend
tok2
getRange
regex
substring
namestart
nameend
positive
break
case
throw
ex
offset
if
tok2
throw
ex
pstart
mergeRanges
tok2
end
break
case
c
decodeEscaped
if
type
T_POSIX_CHARCLASS_START
block
int
nameend
regex
indexOf
offset
if
nameend
throw
ex
offset
String
name
regex
substring
offset
nameend
RangeToken
range
getRange
name
if
range
throw
ex
offset
mergeRanges
range
end
if
nameend
regexlen
regex
charAt
nameend
throw
ex
nameend
offset
nameend
next
if
end
block
if
read
T_CHAR
chardata
block
addRange
c
c
block
next
if
type
read
T_EOF
throw
ex
offset
int
rangeend
chardata
if
type
T_BACKSOLIDUS
rangeend
decodeEscaped
next
addRange
c
rangeend
if
read
T_CHAR
chardata
next
if
read
T_EOF
throw
ex
offset
if
useNrange
nrange
block
subtractRanges
tok
tok
base
sortRanges
compactRanges
setContext
S_NORMAL
next
return
tok
parseSetOperations
RangeToken
RangeToken
tok
parseCharacterClass
int
type
while
type
read
T_RPAREN
block
int
ch
chardata
if
type
T_CHAR
ch
ch
type
T_PLUS
block
next
if
read
T_LBRACKET
throw
ex
offset
RangeToken
t2
parseCharacterClass
if
type
T_PLUS
mergeRanges
t2
if
ch
subtractRanges
t2
if
ch
intersectRanges
t2
throw
RuntimeException
block
throw
ex
offset
next
return
tok
getTokenForShorthand
Token
ch
int
Token
tok
switch
ch
case
tok
isSet
USE_UNICODE_CATEGORY
getRange
token_0to9
break
case
tok
isSet
USE_UNICODE_CATEGORY
getRange
token_not_0to9
break
case
tok
isSet
USE_UNICODE_CATEGORY
getRange
token_wordchars
break
case
tok
isSet
USE_UNICODE_CATEGORY
getRange
token_not_wordchars
break
case
tok
isSet
USE_UNICODE_CATEGORY
getRange
token_spaces
break
case
tok
isSet
USE_UNICODE_CATEGORY
getRange
token_not_spaces
break
case
throw
RuntimeException
toString
ch
return
tok
decodeEscaped
int
if
read
T_BACKSOLIDUS
throw
ex
offset
int
c
chardata
switch
c
case
c
break
case
c
break
case
c
break
case
c
break
case
c
break
case
next
if
read
T_CHAR
throw
ex
offset
if
chardata
block
int
v1
int
uv
do
block
next
if
read
T_CHAR
throw
ex
offset
if
v1
hexChar
chardata
break
if
uv
uv
throw
ex
offset
uv
uv
v1
if
chardata
throw
ex
offset
if
uv
UTF16_MAX
throw
ex
offset
c
uv
block
int
v1
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
int
uv
v1
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
uv
uv
v1
c
uv
break
case
int
v1
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
int
uv
v1
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
uv
uv
v1
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
uv
uv
v1
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
uv
uv
v1
c
uv
break
case
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
uv
v1
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
uv
uv
v1
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
uv
uv
v1
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
uv
uv
v1
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
uv
uv
v1
next
if
read
T_CHAR
v1
hexChar
chardata
throw
ex
offset
uv
uv
v1
if
uv
UTF16_MAX
throw
ex
offset
c
uv
break
case
throw
ex
offset
case
return
c
hexChar
int
ch
int
if
ch
return
if
ch
return
if
ch
return
ch
if
ch
return
if
ch
return
ch
if
ch
return
return
ch
