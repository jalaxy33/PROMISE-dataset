RangeImpl
DocumentImpl
fDocument
Node
fStartContainer
Node
fEndContainer
int
fStartOffset
int
fEndOffset
boolean
fIsCollapsed
boolean
fDetach
Node
fInsertNode
Node
fDeleteNode
Node
fSplitNode
RangeImpl
document
DocumentImpl
fDocument
document
fStartContainer
document
fEndContainer
document
fStartOffset
fEndOffset
fDetach
getStartContainer
Node
return
fStartContainer
getStartOffset
int
return
fStartOffset
getEndContainer
Node
return
fEndContainer
getEndOffset
int
return
fEndOffset
getCollapsed
boolean
return
fStartContainer
fEndContainer
fStartOffset
fEndOffset
getCommonAncestorContainer
Node
Vector
startV
Vector
Node
node
for
forControl
node
fStartContainer
node
node
getParentNode
block
addElement
node
Vector
endV
Vector
for
forControl
node
fEndContainer
node
node
getParentNode
block
addElement
node
int
s
size
int
e
size
Object
result
while
s
e
block
if
elementAt
s
elementAt
e
block
result
elementAt
s
block
break
s
e
return
Node
result
setStart
refNode
Node
offset
int
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
isLegalContainer
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
checkIndex
refNode
offset
fStartContainer
refNode
fStartOffset
offset
setEnd
refNode
Node
offset
int
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
isLegalContainer
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
checkIndex
refNode
offset
fEndContainer
refNode
fEndOffset
offset
setStartBefore
refNode
Node
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
hasLegalRootContainer
refNode
isLegalContainedNode
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
fStartContainer
getParentNode
int
i
for
forControl
Node
n
refNode
n
n
getPreviousSibling
block
i
fStartOffset
i
setStartAfter
refNode
Node
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
hasLegalRootContainer
refNode
isLegalContainedNode
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
fStartContainer
getParentNode
int
i
for
forControl
Node
n
refNode
n
n
getPreviousSibling
block
i
fStartOffset
i
setEndBefore
refNode
Node
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
hasLegalRootContainer
refNode
isLegalContainedNode
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
fEndContainer
getParentNode
int
i
for
forControl
Node
n
refNode
n
n
getPreviousSibling
block
i
fEndOffset
i
setEndAfter
refNode
Node
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
hasLegalRootContainer
refNode
isLegalContainedNode
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
fEndContainer
getParentNode
int
i
for
forControl
Node
n
refNode
n
n
getPreviousSibling
block
i
fEndOffset
i
collapse
toStart
boolean
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
toStart
block
fEndContainer
fStartContainer
fEndOffset
fStartOffset
block
fStartContainer
fEndContainer
fStartOffset
fEndOffset
selectNode
refNode
Node
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
isLegalContainer
getParentNode
isLegalContainedNode
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
Node
parent
getParentNode
if
parent
block
fStartContainer
parent
fEndContainer
parent
int
i
for
forControl
Node
n
refNode
n
n
getPreviousSibling
block
i
fStartOffset
i
fEndOffset
fStartOffset
selectNodeContents
refNode
Node
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
isLegalContainer
refNode
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
fStartContainer
refNode
fEndContainer
refNode
Node
first
getFirstChild
fStartOffset
if
first
block
fEndOffset
block
int
i
for
forControl
Node
n
first
n
n
getNextSibling
block
i
fEndOffset
i
compareBoundaryPoints
short
how
short
sourceRange
Range
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
Node
endPointA
Node
endPointB
int
offsetA
int
offsetB
if
how
START_TO_START
block
endPointA
getStartContainer
endPointB
fStartContainer
offsetA
getStartOffset
offsetB
fStartOffset
if
how
START_TO_END
block
endPointA
getStartContainer
endPointB
fEndContainer
offsetA
getStartOffset
offsetB
fEndOffset
if
how
END_TO_START
block
endPointA
getEndContainer
endPointB
fStartContainer
offsetA
getEndOffset
offsetB
fStartOffset
block
endPointA
getEndContainer
endPointB
fEndContainer
offsetA
getEndOffset
offsetB
fEndOffset
if
endPointA
endPointB
block
if
offsetA
offsetB
return
if
offsetA
offsetB
return
return
for
forControl
Node
c
endPointB
p
getParentNode
p
c
p
p
getParentNode
block
if
p
endPointA
block
int
index
indexOf
c
endPointA
if
offsetA
index
return
return
for
forControl
Node
c
endPointA
p
getParentNode
p
c
p
p
getParentNode
block
if
p
endPointB
block
int
index
indexOf
c
endPointB
if
index
offsetB
return
return
int
depthDiff
for
forControl
Node
n
endPointA
n
n
getParentNode
depthDiff
for
forControl
Node
n
endPointB
n
n
getParentNode
depthDiff
while
depthDiff
block
endPointA
getParentNode
depthDiff
while
depthDiff
block
endPointB
getParentNode
depthDiff
for
forControl
Node
pA
getParentNode
pB
getParentNode
pA
pB
pA
getParentNode
pB
getParentNode
block
endPointA
pA
endPointB
pB
for
forControl
Node
n
getNextSibling
n
n
getNextSibling
block
if
n
endPointB
block
return
return
deleteContents
traverseContents
DELETE_CONTENTS
extractContents
DocumentFragment
return
traverseContents
EXTRACT_CONTENTS
cloneContents
DocumentFragment
return
traverseContents
CLONE_CONTENTS
insertNode
newNode
Node
if
newNode
return
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
fDocument
getOwnerDocument
block
throw
DOMException
WRONG_DOCUMENT_ERR
int
type
getNodeType
if
type
ATTRIBUTE_NODE
type
ENTITY_NODE
type
NOTATION_NODE
type
DOCUMENT_NODE
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
Node
cloneCurrent
Node
current
int
currentChildren
if
getNodeType
TEXT_NODE
block
Node
parent
getParentNode
currentChildren
getChildNodes
getLength
cloneCurrent
cloneNode
TextImpl
cloneCurrent
TextImpl
fStartContainer
Node
next
getNextSibling
if
next
block
if
parent
block
insertBefore
newNode
next
insertBefore
cloneCurrent
next
block
if
parent
block
appendChild
newNode
appendChild
cloneCurrent
if
fEndContainer
fStartContainer
block
fEndContainer
cloneCurrent
fEndOffset
fStartOffset
if
fEndContainer
parent
block
fEndOffset
getChildNodes
getLength
currentChildren
signalSplitData
fStartContainer
cloneCurrent
fStartOffset
block
if
fEndContainer
fStartContainer
currentChildren
getChildNodes
getLength
current
getFirstChild
int
i
for
forControl
i
i
fStartOffset
current
i
block
current
getNextSibling
if
current
block
insertBefore
newNode
current
block
appendChild
newNode
if
fEndContainer
fStartContainer
block
fEndOffset
getChildNodes
getLength
currentChildren
surroundContents
newParent
Node
if
newParent
return
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
int
type
getNodeType
if
type
ATTRIBUTE_NODE
type
ENTITY_NODE
type
NOTATION_NODE
type
DOCUMENT_TYPE_NODE
type
DOCUMENT_NODE
type
DOCUMENT_FRAGMENT_NODE
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
Node
root
getCommonAncestorContainer
Node
realStart
fStartContainer
Node
realEnd
fEndContainer
if
getNodeType
TEXT_NODE
block
realStart
getParentNode
if
getNodeType
TEXT_NODE
block
realEnd
getParentNode
if
realStart
realEnd
block
throw
RangeExceptionImpl
BAD_BOUNDARYPOINTS_ERR
DocumentFragment
frag
extractContents
insertNode
newParent
appendChild
frag
selectNode
newParent
cloneRange
Range
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
Range
range
createRange
setStart
fStartContainer
fStartOffset
setEnd
fEndContainer
fEndOffset
return
range
toString
String
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
Node
node
fStartContainer
Node
stopNode
fEndContainer
StringBuffer
sb
StringBuffer
if
getNodeType
TEXT_NODE
getNodeType
CDATA_SECTION_NODE
block
if
fStartContainer
fEndContainer
block
append
getNodeValue
substring
fStartOffset
fEndOffset
return
toString
append
getNodeValue
substring
fStartOffset
node
nextNode
node
block
node
getFirstChild
if
fStartOffset
block
int
counter
while
counter
fStartOffset
node
block
node
getNextSibling
counter
if
node
block
node
nextNode
fStartContainer
if
getNodeType
TEXT_NODE
getNodeType
CDATA_SECTION_NODE
block
int
i
fEndOffset
stopNode
getFirstChild
while
i
stopNode
block
i
stopNode
getNextSibling
if
stopNode
stopNode
nextNode
fEndContainer
while
node
stopNode
block
if
node
break
if
getNodeType
TEXT_NODE
getNodeType
CDATA_SECTION_NODE
block
append
getNodeValue
node
nextNode
node
if
getNodeType
TEXT_NODE
getNodeType
CDATA_SECTION_NODE
block
append
getNodeValue
substring
fEndOffset
return
toString
detach
fDetach
removeRange
signalSplitData
node
Node
newNode
Node
offset
int
fSplitNode
node
splitData
node
newNode
offset
fSplitNode
receiveSplitData
node
Node
newNode
Node
offset
int
if
node
newNode
return
if
fSplitNode
node
return
if
node
fStartContainer
getNodeType
TEXT_NODE
block
if
fStartOffset
offset
block
fStartOffset
fStartOffset
offset
fStartContainer
newNode
if
node
fEndContainer
getNodeType
TEXT_NODE
block
if
fEndOffset
offset
block
fEndOffset
fEndOffset
offset
fEndContainer
newNode
deleteData
node
CharacterData
offset
int
count
int
fDeleteNode
node
deleteData
offset
count
fDeleteNode
receiveDeletedText
node
Node
offset
int
count
int
if
node
return
if
fDeleteNode
node
return
if
node
fStartContainer
getNodeType
TEXT_NODE
block
if
fStartOffset
offset
count
block
fStartOffset
offset
fStartOffset
offset
count
if
fStartOffset
offset
block
fStartOffset
offset
if
node
fEndContainer
getNodeType
TEXT_NODE
block
if
fEndOffset
offset
count
block
fEndOffset
offset
fEndOffset
offset
count
if
fEndOffset
offset
block
fEndOffset
offset
insertData
node
CharacterData
index
int
insert
String
fInsertNode
node
insertData
index
insert
fInsertNode
receiveInsertedText
node
Node
index
int
len
int
if
node
return
if
fInsertNode
node
return
if
node
fStartContainer
getNodeType
TEXT_NODE
block
if
index
fStartOffset
block
fStartOffset
fStartOffset
len
if
node
fEndContainer
getNodeType
TEXT_NODE
block
if
index
fEndOffset
block
fEndOffset
fEndOffset
len
receiveReplacedText
node
Node
if
node
return
if
node
fStartContainer
getNodeType
TEXT_NODE
block
fStartOffset
if
node
fEndContainer
getNodeType
TEXT_NODE
block
fEndOffset
insertedNodeFromDOM
node
Node
if
node
return
if
fInsertNode
node
return
Node
parent
getParentNode
if
parent
fStartContainer
block
int
index
indexOf
node
fStartContainer
if
index
fStartOffset
block
fStartOffset
if
parent
fEndContainer
block
int
index
indexOf
node
fEndContainer
if
index
fEndOffset
block
fEndOffset
Node
fRemoveChild
removeChild
Node
parent
Node
child
Node
fRemoveChild
child
Node
n
removeChild
child
fRemoveChild
return
n
removeNode
node
Node
if
node
return
if
fRemoveChild
node
return
Node
parent
getParentNode
if
parent
fStartContainer
block
int
index
indexOf
node
fStartContainer
if
index
fStartOffset
block
fStartOffset
if
parent
fEndContainer
block
int
index
indexOf
node
fEndContainer
if
index
fEndOffset
block
fEndOffset
if
parent
fStartContainer
parent
fEndContainer
block
if
isAncestorOf
node
fStartContainer
block
fStartContainer
parent
fStartOffset
indexOf
node
parent
if
isAncestorOf
node
fEndContainer
block
fEndContainer
parent
fEndOffset
indexOf
node
parent
int
EXTRACT_CONTENTS
int
CLONE_CONTENTS
int
DELETE_CONTENTS
traverseContents
DocumentFragment
how
int
if
fStartContainer
fEndContainer
block
return
if
fDetach
block
throw
DOMException
INVALID_STATE_ERR
if
fStartContainer
fEndContainer
return
traverseSameContainer
how
int
endContainerDepth
for
forControl
Node
c
fEndContainer
p
getParentNode
p
c
p
p
getParentNode
block
if
p
fStartContainer
return
traverseCommonStartContainer
c
how
endContainerDepth
int
startContainerDepth
for
forControl
Node
c
fStartContainer
p
getParentNode
p
c
p
p
getParentNode
block
if
p
fEndContainer
return
traverseCommonEndContainer
c
how
startContainerDepth
int
depthDiff
startContainerDepth
endContainerDepth
Node
startNode
fStartContainer
while
depthDiff
block
startNode
getParentNode
depthDiff
Node
endNode
fEndContainer
while
depthDiff
block
endNode
getParentNode
depthDiff
for
forControl
Node
sp
getParentNode
ep
getParentNode
sp
ep
sp
getParentNode
ep
getParentNode
block
startNode
sp
endNode
ep
return
traverseCommonAncestors
startNode
endNode
how
traverseSameContainer
DocumentFragment
how
int
DocumentFragment
frag
if
how
DELETE_CONTENTS
frag
createDocumentFragment
if
fStartOffset
fEndOffset
return
frag
if
getNodeType
TEXT_NODE
block
String
s
getNodeValue
String
sub
substring
fStartOffset
fEndOffset
if
how
CLONE_CONTENTS
block
setNodeValue
substring
fStartOffset
substring
fEndOffset
collapse
if
how
DELETE_CONTENTS
return
appendChild
createTextNode
sub
return
frag
Node
n
getSelectedNode
fStartContainer
fStartOffset
int
cnt
fEndOffset
fStartOffset
while
cnt
block
Node
sibling
getNextSibling
Node
xferNode
traverseFullySelected
n
how
if
frag
appendChild
xferNode
cnt
n
sibling
if
how
CLONE_CONTENTS
collapse
return
frag
traverseCommonStartContainer
DocumentFragment
endAncestor
Node
how
int
DocumentFragment
frag
if
how
DELETE_CONTENTS
frag
createDocumentFragment
Node
n
traverseRightBoundary
endAncestor
how
if
frag
appendChild
n
int
endIdx
indexOf
endAncestor
fStartContainer
int
cnt
endIdx
fStartOffset
if
cnt
block
if
how
CLONE_CONTENTS
block
setEndBefore
endAncestor
collapse
return
frag
n
getPreviousSibling
while
cnt
block
Node
sibling
getPreviousSibling
Node
xferNode
traverseFullySelected
n
how
if
frag
insertBefore
xferNode
getFirstChild
cnt
n
sibling
if
how
CLONE_CONTENTS
block
setEndBefore
endAncestor
collapse
return
frag
traverseCommonEndContainer
DocumentFragment
startAncestor
Node
how
int
DocumentFragment
frag
if
how
DELETE_CONTENTS
frag
createDocumentFragment
Node
n
traverseLeftBoundary
startAncestor
how
if
frag
appendChild
n
int
startIdx
indexOf
startAncestor
fEndContainer
startIdx
int
cnt
fEndOffset
startIdx
n
getNextSibling
while
cnt
block
Node
sibling
getNextSibling
Node
xferNode
traverseFullySelected
n
how
if
frag
appendChild
xferNode
cnt
n
sibling
if
how
CLONE_CONTENTS
block
setStartAfter
startAncestor
collapse
return
frag
traverseCommonAncestors
DocumentFragment
startAncestor
Node
endAncestor
Node
how
int
DocumentFragment
frag
if
how
DELETE_CONTENTS
frag
createDocumentFragment
Node
n
traverseLeftBoundary
startAncestor
how
if
frag
appendChild
n
Node
commonParent
getParentNode
int
startOffset
indexOf
startAncestor
commonParent
int
endOffset
indexOf
endAncestor
commonParent
startOffset
int
cnt
endOffset
startOffset
Node
sibling
getNextSibling
while
cnt
block
Node
nextSibling
getNextSibling
n
traverseFullySelected
sibling
how
if
frag
appendChild
n
sibling
nextSibling
cnt
n
traverseRightBoundary
endAncestor
how
if
frag
appendChild
n
if
how
CLONE_CONTENTS
block
setStartAfter
startAncestor
collapse
return
frag
traverseRightBoundary
Node
root
Node
how
int
Node
next
getSelectedNode
fEndContainer
fEndOffset
boolean
isFullySelected
next
fEndContainer
if
next
root
return
traverseNode
next
isFullySelected
how
Node
parent
getParentNode
Node
clonedParent
traverseNode
parent
how
while
parent
block
while
next
block
Node
prevSibling
getPreviousSibling
Node
clonedChild
traverseNode
next
isFullySelected
how
if
how
DELETE_CONTENTS
block
insertBefore
clonedChild
getFirstChild
isFullySelected
next
prevSibling
if
parent
root
return
clonedParent
next
getPreviousSibling
parent
getParentNode
Node
clonedGrandParent
traverseNode
parent
how
if
how
DELETE_CONTENTS
appendChild
clonedParent
clonedParent
clonedGrandParent
return
traverseLeftBoundary
Node
root
Node
how
int
Node
next
getSelectedNode
getStartContainer
getStartOffset
boolean
isFullySelected
next
getStartContainer
if
next
root
return
traverseNode
next
isFullySelected
how
Node
parent
getParentNode
Node
clonedParent
traverseNode
parent
how
while
parent
block
while
next
block
Node
nextSibling
getNextSibling
Node
clonedChild
traverseNode
next
isFullySelected
how
if
how
DELETE_CONTENTS
appendChild
clonedChild
isFullySelected
next
nextSibling
if
parent
root
return
clonedParent
next
getNextSibling
parent
getParentNode
Node
clonedGrandParent
traverseNode
parent
how
if
how
DELETE_CONTENTS
appendChild
clonedParent
clonedParent
clonedGrandParent
return
traverseNode
Node
n
Node
isFullySelected
boolean
isLeft
boolean
how
int
if
isFullySelected
return
traverseFullySelected
n
how
if
getNodeType
TEXT_NODE
return
traverseTextNode
n
isLeft
how
return
traversePartiallySelected
n
how
traverseFullySelected
Node
n
Node
how
int
switch
how
case
return
cloneNode
case
if
getNodeType
DOCUMENT_TYPE_NODE
block
throw
RangeExceptionImpl
INVALID_NODE_TYPE_ERR
return
n
case
getParentNode
removeChild
n
return
return
traversePartiallySelected
Node
n
Node
how
int
switch
how
case
return
case
return
cloneNode
return
traverseTextNode
Node
n
Node
isLeft
boolean
how
int
String
txtValue
getNodeValue
String
newNodeValue
String
oldNodeValue
if
isLeft
block
int
offset
getStartOffset
newNodeValue
substring
offset
oldNodeValue
substring
offset
block
int
offset
getEndOffset
newNodeValue
substring
offset
oldNodeValue
substring
offset
if
how
CLONE_CONTENTS
setNodeValue
oldNodeValue
if
how
DELETE_CONTENTS
return
Node
newNode
cloneNode
setNodeValue
newNodeValue
return
newNode
checkIndex
refNode
Node
offset
int
if
offset
block
throw
DOMException
INDEX_SIZE_ERR
int
type
getNodeType
if
type
TEXT_NODE
type
CDATA_SECTION_NODE
type
COMMENT_NODE
type
PROCESSING_INSTRUCTION_NODE
block
if
offset
getNodeValue
length
block
throw
DOMException
INDEX_SIZE_ERR
block
if
offset
getChildNodes
getLength
block
throw
DOMException
INDEX_SIZE_ERR
getRootContainer
Node
node
Node
if
node
return
while
getParentNode
node
getParentNode
return
node
isLegalContainer
boolean
node
Node
if
node
return
while
node
block
switch
getNodeType
case
ENTITY_NODE
NOTATION_NODE
DOCUMENT_TYPE_NODE
return
node
getParentNode
return
hasLegalRootContainer
boolean
node
Node
if
node
return
Node
rootContainer
getRootContainer
node
switch
getNodeType
case
ATTRIBUTE_NODE
DOCUMENT_NODE
DOCUMENT_FRAGMENT_NODE
return
return
isLegalContainedNode
boolean
node
Node
if
node
return
switch
getNodeType
case
DOCUMENT_NODE
DOCUMENT_FRAGMENT_NODE
ATTRIBUTE_NODE
ENTITY_NODE
NOTATION_NODE
return
return
nextNode
Node
node
Node
visitChildren
boolean
if
node
return
Node
result
if
visitChildren
block
result
getFirstChild
if
result
block
return
result
result
getNextSibling
if
result
block
return
result
Node
parent
getParentNode
while
parent
parent
fDocument
block
result
getNextSibling
if
result
block
return
result
block
parent
getParentNode
return
isAncestorOf
boolean
a
Node
b
Node
for
forControl
Node
node
b
node
node
getParentNode
block
if
node
a
return
return
indexOf
int
child
Node
parent
Node
if
getParentNode
parent
return
int
i
for
forControl
Node
node
getFirstChild
node
child
node
getNextSibling
block
i
return
i
getSelectedNode
Node
container
Node
offset
int
if
getNodeType
TEXT_NODE
return
container
if
offset
return
container
Node
child
getFirstChild
while
child
offset
block
offset
child
getNextSibling
if
child
return
child
return
container
Range
