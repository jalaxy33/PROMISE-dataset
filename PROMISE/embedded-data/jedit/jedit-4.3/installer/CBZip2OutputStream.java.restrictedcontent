CBZip2OutputStream
int
LOWER_BYTE_MASK
int
UPPER_BYTE_MASK
int
SETMASK
int
CLEARMASK
SETMASK
int
GREATER_ICOST
int
LESSER_ICOST
int
SMALL_THRESH
int
DEPTH_THRESH
int
QSORT_STACK_SIZE
CRC
m_crc
CRC
boolean
m_inUse
boolean
char
m_seqToUnseq
char
char
m_unseqToSeq
char
char
m_selector
char
MAX_SELECTORS
char
m_selectorMtf
char
MAX_SELECTORS
int
m_mtfFreq
int
MAX_ALPHA_SIZE
int
m_currentChar
int
m_runLength
boolean
m_closed
int
m_incs
int
boolean
m_blockRandomised
int
m_blockSize100k
int
m_bsBuff
int
m_bsLive
int
m_last
int
m_origPtr
int
m_allowableBlockSize
char
m_block
int
m_blockCRC
int
m_combinedCRC
OutputStream
m_bsStream
boolean
m_firstAttempt
int
m_ftab
int
m_nInUse
int
m_nMTF
int
m_quadrant
short
m_szptr
int
m_workDone
int
m_workFactor
int
m_workLimit
int
m_zptr
CBZip2OutputStream
output
OutputStream
output
CBZip2OutputStream
output
OutputStream
blockSize
int
bsSetStream
output
m_workFactor
int
outBlockSize
blockSize
if
outBlockSize
block
outBlockSize
if
outBlockSize
block
outBlockSize
m_blockSize100k
outBlockSize
allocateCompressStructures
initialize
initBlock
hbMakeCodeLengths
len
char
freq
int
alphaSize
int
maxLen
int
int
nNodes
int
nHeap
int
n1
int
n2
int
i
int
j
int
k
boolean
tooLong
int
heap
int
MAX_ALPHA_SIZE
int
weights
int
MAX_ALPHA_SIZE
int
parent
int
MAX_ALPHA_SIZE
for
forControl
i
i
alphaSize
i
block
weights
i
freq
i
freq
i
while
block
nNodes
alphaSize
nHeap
heap
weights
parent
for
forControl
i
i
alphaSize
i
block
parent
i
nHeap
heap
nHeap
i
block
int
zz
int
tmp
zz
nHeap
tmp
heap
zz
while
weights
tmp
weights
heap
zz
block
heap
zz
heap
zz
zz
heap
zz
tmp
if
nHeap
MAX_ALPHA_SIZE
block
panic
while
nHeap
block
n1
heap
heap
heap
nHeap
nHeap
block
int
zz
int
yy
int
tmp
zz
tmp
heap
zz
while
block
yy
zz
if
yy
nHeap
block
break
if
yy
nHeap
weights
heap
yy
weights
heap
yy
block
yy
if
weights
tmp
weights
heap
yy
block
break
heap
zz
heap
yy
zz
yy
heap
zz
tmp
n2
heap
heap
heap
nHeap
nHeap
block
int
zz
int
yy
int
tmp
zz
tmp
heap
zz
while
block
yy
zz
if
yy
nHeap
block
break
if
yy
nHeap
weights
heap
yy
weights
heap
yy
block
yy
if
weights
tmp
weights
heap
yy
block
break
heap
zz
heap
yy
zz
yy
heap
zz
tmp
nNodes
parent
n1
nNodes
parent
n2
nNodes
int
v1
weights
n1
int
v2
weights
n2
int
weight
calculateWeight
v1
v2
weights
nNodes
weight
parent
nNodes
nHeap
heap
nHeap
nNodes
block
int
zz
int
tmp
zz
nHeap
tmp
heap
zz
while
weights
tmp
weights
heap
zz
block
heap
zz
heap
zz
zz
heap
zz
tmp
if
nNodes
MAX_ALPHA_SIZE
block
panic
tooLong
for
forControl
i
i
alphaSize
i
block
j
k
i
while
parent
k
block
k
parent
k
j
len
i
char
j
if
j
maxLen
block
tooLong
if
tooLong
block
break
for
forControl
i
i
alphaSize
i
block
j
weights
i
j
j
weights
i
j
calculateWeight
int
v1
int
v2
int
int
upper
v1
UPPER_BYTE_MASK
v2
UPPER_BYTE_MASK
int
v1Lower
v1
LOWER_BYTE_MASK
int
v2Lower
v2
LOWER_BYTE_MASK
int
nnnn
v1Lower
v2Lower
v1Lower
v2Lower
return
upper
nnnn
panic
println
close
if
m_closed
block
return
if
m_runLength
block
writeRun
m_currentChar
endBlock
endCompression
m_closed
close
close
finalize
close
flush
flush
flush
write
bv
int
int
b
bv
if
m_currentChar
block
if
m_currentChar
b
block
m_runLength
if
m_runLength
block
writeRun
m_currentChar
m_runLength
block
writeRun
m_runLength
m_currentChar
b
block
m_currentChar
b
m_runLength
allocateCompressStructures
int
n
BASE_BLOCK_SIZE
m_blockSize100k
m_block
char
n
NUM_OVERSHOOT_BYTES
m_quadrant
int
n
NUM_OVERSHOOT_BYTES
m_zptr
int
n
m_ftab
int
if
m_block
m_quadrant
m_zptr
m_ftab
block
m_szptr
short
n
bsFinishedWithStream
while
m_bsLive
block
int
ch
m_bsBuff
try
write
ch
catchClause
e
throw
e
m_bsBuff
m_bsLive
bsPutIntVS
numBits
int
c
int
bsW
numBits
c
bsPutUChar
c
int
bsW
c
bsPutint
u
int
bsW
u
bsW
u
bsW
u
bsW
u
bsSetStream
f
OutputStream
m_bsStream
f
m_bsLive
m_bsBuff
bsW
n
int
v
int
while
m_bsLive
block
int
ch
m_bsBuff
try
write
ch
catchClause
e
throw
e
m_bsBuff
m_bsLive
m_bsBuff
v
m_bsLive
n
m_bsLive
n
doReversibleTransformation
int
i
m_workLimit
m_workFactor
m_last
m_workDone
m_blockRandomised
m_firstAttempt
mainSort
if
m_workDone
m_workLimit
m_firstAttempt
block
randomiseBlock
m_workLimit
m_workDone
m_blockRandomised
m_firstAttempt
mainSort
m_origPtr
for
forControl
i
i
m_last
i
block
if
m_zptr
i
block
m_origPtr
i
break
if
m_origPtr
block
panic
endBlock
m_blockCRC
getFinalCRC
m_combinedCRC
m_combinedCRC
m_combinedCRC
m_combinedCRC
m_blockCRC
doReversibleTransformation
bsPutUChar
bsPutUChar
bsPutUChar
bsPutUChar
bsPutUChar
bsPutUChar
bsPutint
m_blockCRC
if
m_blockRandomised
block
bsW
block
bsW
moveToFrontCodeAndSend
endCompression
bsPutUChar
bsPutUChar
bsPutUChar
bsPutUChar
bsPutUChar
bsPutUChar
bsPutint
m_combinedCRC
bsFinishedWithStream
fullGtU
boolean
i1
int
i2
int
int
k
char
c1
char
c2
int
s1
int
s2
c1
m_block
i1
c2
m_block
i2
if
c1
c2
block
return
c1
c2
i1
i2
c1
m_block
i1
c2
m_block
i2
if
c1
c2
block
return
c1
c2
i1
i2
c1
m_block
i1
c2
m_block
i2
if
c1
c2
block
return
c1
c2
i1
i2
c1
m_block
i1
c2
m_block
i2
if
c1
c2
block
return
c1
c2
i1
i2
c1
m_block
i1
c2
m_block
i2
if
c1
c2
block
return
c1
c2
i1
i2
c1
m_block
i1
c2
m_block
i2
if
c1
c2
block
return
c1
c2
i1
i2
k
m_last
do
k
block
c1
m_block
i1
c2
m_block
i2
if
c1
c2
block
return
c1
c2
s1
m_quadrant
i1
s2
m_quadrant
i2
if
s1
s2
block
return
s1
s2
i1
i2
c1
m_block
i1
c2
m_block
i2
if
c1
c2
block
return
c1
c2
s1
m_quadrant
i1
s2
m_quadrant
i2
if
s1
s2
block
return
s1
s2
i1
i2
c1
m_block
i1
c2
m_block
i2
if
c1
c2
block
return
c1
c2
s1
m_quadrant
i1
s2
m_quadrant
i2
if
s1
s2
block
return
s1
s2
i1
i2
c1
m_block
i1
c2
m_block
i2
if
c1
c2
block
return
c1
c2
s1
m_quadrant
i1
s2
m_quadrant
i2
if
s1
s2
block
return
s1
s2
i1
i2
if
i1
m_last
block
i1
m_last
i1
if
i2
m_last
block
i2
m_last
i2
k
m_workDone
return
generateMTFValues
char
yy
char
int
i
int
j
char
tmp
char
tmp2
int
zPend
int
wr
int
EOB
makeMaps
EOB
m_nInUse
for
forControl
i
i
EOB
i
block
m_mtfFreq
i
wr
zPend
for
forControl
i
i
m_nInUse
i
block
yy
i
char
i
for
forControl
i
i
m_last
i
block
char
ll_i
ll_i
m_unseqToSeq
m_block
m_zptr
i
j
tmp
yy
j
while
ll_i
tmp
block
j
tmp2
tmp
tmp
yy
j
yy
j
tmp2
yy
tmp
if
j
block
zPend
block
if
zPend
block
zPend
while
block
switch
zPend
case
m_szptr
wr
short
RUNA
wr
m_mtfFreq
RUNA
break
case
m_szptr
wr
short
RUNB
wr
m_mtfFreq
RUNB
break
if
zPend
block
break
zPend
zPend
zPend
m_szptr
wr
short
j
wr
m_mtfFreq
j
if
zPend
block
zPend
while
block
switch
zPend
case
m_szptr
wr
short
RUNA
wr
m_mtfFreq
RUNA
break
case
m_szptr
wr
short
RUNB
wr
m_mtfFreq
RUNB
break
if
zPend
block
break
zPend
zPend
m_szptr
wr
short
EOB
wr
m_mtfFreq
EOB
m_nMTF
wr
hbAssignCodes
code
int
length
char
minLen
int
maxLen
int
alphaSize
int
int
n
int
vec
int
i
vec
for
forControl
n
minLen
n
maxLen
n
block
for
forControl
i
i
alphaSize
i
block
if
length
i
n
block
code
i
vec
vec
vec
initBlock
initialiseCRC
m_last
for
forControl
int
i
i
i
block
m_inUse
i
m_allowableBlockSize
BASE_BLOCK_SIZE
m_blockSize100k
initialize
bsPutUChar
bsPutUChar
m_blockSize100k
m_combinedCRC
mainSort
int
i
int
j
int
ss
int
sb
int
runningOrder
int
int
copy
int
boolean
bigDone
boolean
int
c1
int
c2
for
forControl
i
i
NUM_OVERSHOOT_BYTES
i
block
m_block
m_last
i
m_block
i
m_last
for
forControl
i
i
m_last
NUM_OVERSHOOT_BYTES
i
block
m_quadrant
i
m_block
m_block
m_last
if
m_last
block
for
forControl
i
i
m_last
i
block
m_zptr
i
i
m_firstAttempt
m_workDone
m_workLimit
simpleSort
m_last
block
for
forControl
i
i
i
block
bigDone
i
for
forControl
i
i
i
block
m_ftab
i
c1
m_block
for
forControl
i
i
m_last
i
block
c2
m_block
i
m_ftab
c1
c2
c1
c2
for
forControl
i
i
i
block
m_ftab
i
m_ftab
i
c1
m_block
for
forControl
i
i
m_last
i
block
c2
m_block
i
j
c1
c2
c1
c2
m_ftab
j
m_zptr
m_ftab
j
i
j
m_block
m_block
m_ftab
j
m_zptr
m_ftab
j
m_last
for
forControl
i
i
i
block
runningOrder
i
i
block
int
vv
int
h
do
h
block
h
h
do
h
block
h
h
for
forControl
i
h
i
i
block
vv
runningOrder
i
j
i
while
m_ftab
runningOrder
m_ftab
runningOrder
m_ftab
vv
m_ftab
vv
block
runningOrder
j
runningOrder
j
h
j
j
h
if
j
h
block
break
runningOrder
j
vv
for
forControl
i
i
i
block
ss
runningOrder
i
for
forControl
j
j
j
block
sb
ss
j
if
m_ftab
sb
SETMASK
SETMASK
block
int
lo
m_ftab
sb
CLEARMASK
int
hi
m_ftab
sb
CLEARMASK
if
hi
lo
block
qSort3
lo
hi
if
m_workDone
m_workLimit
m_firstAttempt
block
return
m_ftab
sb
SETMASK
bigDone
ss
if
i
block
int
bbStart
m_ftab
ss
CLEARMASK
int
bbSize
m_ftab
ss
CLEARMASK
bbStart
int
shifts
while
bbSize
shifts
block
shifts
for
forControl
j
j
bbSize
j
block
int
a2update
m_zptr
bbStart
j
int
qVal
j
shifts
m_quadrant
a2update
qVal
if
a2update
NUM_OVERSHOOT_BYTES
block
m_quadrant
a2update
m_last
qVal
if
bbSize
shifts
block
panic
for
forControl
j
j
j
block
copy
j
m_ftab
j
ss
CLEARMASK
for
forControl
j
m_ftab
ss
CLEARMASK
j
m_ftab
ss
CLEARMASK
j
block
c1
m_block
m_zptr
j
if
bigDone
c1
block
m_zptr
copy
c1
m_zptr
j
m_last
m_zptr
j
copy
c1
for
forControl
j
j
j
block
m_ftab
j
ss
SETMASK
makeMaps
int
i
m_nInUse
for
forControl
i
i
i
block
if
m_inUse
i
block
m_seqToUnseq
m_nInUse
char
i
m_unseqToSeq
i
char
m_nInUse
m_nInUse
med3
char
a
char
b
char
c
char
char
t
if
a
b
block
t
a
a
b
b
t
if
b
c
block
t
b
b
c
c
t
if
a
b
block
b
a
return
b
moveToFrontCodeAndSend
bsPutIntVS
m_origPtr
generateMTFValues
sendMTFValues
qSort3
loSt
int
hiSt
int
dSt
int
int
unLo
int
unHi
int
ltLo
int
gtHi
int
med
int
n
int
m
int
sp
int
lo
int
hi
int
d
StackElem
stack
StackElem
QSORT_STACK_SIZE
for
forControl
int
count
count
QSORT_STACK_SIZE
count
block
stack
count
StackElem
sp
stack
sp
m_ll
loSt
stack
sp
m_hh
hiSt
stack
sp
m_dd
dSt
sp
while
sp
block
if
sp
QSORT_STACK_SIZE
block
panic
sp
lo
stack
sp
m_ll
hi
stack
sp
m_hh
d
stack
sp
m_dd
if
hi
lo
SMALL_THRESH
d
DEPTH_THRESH
block
simpleSort
lo
hi
d
if
m_workDone
m_workLimit
m_firstAttempt
block
return
continue
med
med3
m_block
m_zptr
lo
d
m_block
m_zptr
hi
d
m_block
m_zptr
lo
hi
d
unLo
lo
ltLo
lo
unHi
hi
gtHi
hi
while
block
while
block
if
unLo
unHi
block
break
n
m_block
m_zptr
unLo
d
med
if
n
block
int
temp
temp
m_zptr
unLo
m_zptr
unLo
m_zptr
ltLo
m_zptr
ltLo
temp
ltLo
unLo
continue
if
n
block
break
unLo
while
block
if
unLo
unHi
block
break
n
m_block
m_zptr
unHi
d
med
if
n
block
int
temp
temp
m_zptr
unHi
m_zptr
unHi
m_zptr
gtHi
m_zptr
gtHi
temp
gtHi
unHi
continue
if
n
block
break
unHi
if
unLo
unHi
block
break
int
temp
temp
m_zptr
unLo
m_zptr
unLo
m_zptr
unHi
m_zptr
unHi
temp
unLo
unHi
if
gtHi
ltLo
block
stack
sp
m_ll
lo
stack
sp
m_hh
hi
stack
sp
m_dd
d
sp
continue
n
ltLo
lo
unLo
ltLo
ltLo
lo
unLo
ltLo
vswap
lo
unLo
n
n
m
hi
gtHi
gtHi
unHi
hi
gtHi
gtHi
unHi
vswap
unLo
hi
m
m
n
lo
unLo
ltLo
m
hi
gtHi
unHi
stack
sp
m_ll
lo
stack
sp
m_hh
n
stack
sp
m_dd
d
sp
stack
sp
m_ll
n
stack
sp
m_hh
m
stack
sp
m_dd
d
sp
stack
sp
m_ll
m
stack
sp
m_hh
hi
stack
sp
m_dd
d
sp
randomiseBlock
int
i
int
rNToGo
int
rTPos
for
forControl
i
i
i
block
m_inUse
i
for
forControl
i
i
m_last
i
block
if
rNToGo
block
rNToGo
char
RAND_NUMS
rTPos
rTPos
if
rTPos
block
rTPos
rNToGo
m_block
i
rNToGo
m_block
i
m_inUse
m_block
i
sendMTFValues
char
len
char
N_GROUPS
MAX_ALPHA_SIZE
int
v
int
t
int
i
int
j
int
gs
int
ge
int
bt
int
bc
int
iter
int
nSelectors
int
alphaSize
int
minLen
int
maxLen
int
selCtr
int
nGroups
alphaSize
m_nInUse
for
forControl
t
t
N_GROUPS
t
block
for
forControl
v
v
alphaSize
v
block
len
t
v
char
GREATER_ICOST
if
m_nMTF
block
panic
if
m_nMTF
block
nGroups
if
m_nMTF
block
nGroups
if
m_nMTF
block
nGroups
if
m_nMTF
block
nGroups
block
nGroups
block
int
nPart
int
remF
int
tFreq
int
aFreq
nPart
nGroups
remF
m_nMTF
gs
while
nPart
block
tFreq
remF
nPart
ge
gs
aFreq
while
aFreq
tFreq
ge
alphaSize
block
ge
aFreq
m_mtfFreq
ge
if
ge
gs
nPart
nGroups
nPart
nGroups
nPart
block
aFreq
m_mtfFreq
ge
ge
for
forControl
v
v
alphaSize
v
block
if
v
gs
v
ge
block
len
nPart
v
char
LESSER_ICOST
block
len
nPart
v
char
GREATER_ICOST
nPart
gs
ge
remF
aFreq
int
rfreq
int
N_GROUPS
MAX_ALPHA_SIZE
int
fave
int
N_GROUPS
short
cost
short
N_GROUPS
for
forControl
iter
iter
N_ITERS
iter
block
for
forControl
t
t
nGroups
t
block
fave
t
for
forControl
t
t
nGroups
t
block
for
forControl
v
v
alphaSize
v
block
rfreq
t
v
nSelectors
gs
while
block
if
gs
m_nMTF
block
break
ge
gs
G_SIZE
if
ge
m_nMTF
block
ge
m_nMTF
for
forControl
t
t
nGroups
t
block
cost
t
if
nGroups
block
short
cost0
short
cost1
short
cost2
short
cost3
short
cost4
short
cost5
for
forControl
i
gs
i
ge
i
block
short
icv
m_szptr
i
cost0
len
icv
cost1
len
icv
cost2
len
icv
cost3
len
icv
cost4
len
icv
cost5
len
icv
cost
cost0
cost
cost1
cost
cost2
cost
cost3
cost
cost4
cost
cost5
block
for
forControl
i
gs
i
ge
i
block
short
icv
m_szptr
i
for
forControl
t
t
nGroups
t
block
cost
t
len
t
icv
bc
bt
for
forControl
t
t
nGroups
t
block
if
cost
t
bc
block
bc
cost
t
bt
t
fave
bt
m_selector
nSelectors
char
bt
nSelectors
for
forControl
i
gs
i
ge
i
block
rfreq
bt
m_szptr
i
gs
ge
for
forControl
t
t
nGroups
t
block
hbMakeCodeLengths
len
t
rfreq
t
alphaSize
rfreq
fave
cost
if
nGroups
block
panic
if
nSelectors
nSelectors
G_SIZE
block
panic
block
char
pos
char
N_GROUPS
char
ll_i
char
tmp2
char
tmp
for
forControl
i
i
nGroups
i
block
pos
i
char
i
for
forControl
i
i
nSelectors
i
block
ll_i
m_selector
i
j
tmp
pos
j
while
ll_i
tmp
block
j
tmp2
tmp
tmp
pos
j
pos
j
tmp2
pos
tmp
m_selectorMtf
i
char
j
int
code
int
N_GROUPS
MAX_ALPHA_SIZE
for
forControl
t
t
nGroups
t
block
minLen
maxLen
for
forControl
i
i
alphaSize
i
block
if
len
t
i
maxLen
block
maxLen
len
t
i
if
len
t
i
minLen
block
minLen
len
t
i
if
maxLen
block
panic
if
minLen
block
panic
hbAssignCodes
code
t
len
t
minLen
maxLen
alphaSize
block
boolean
inUse16
boolean
for
forControl
i
i
i
block
inUse16
i
for
forControl
j
j
j
block
if
m_inUse
i
j
block
inUse16
i
for
forControl
i
i
i
block
if
inUse16
i
block
bsW
block
bsW
for
forControl
i
i
i
block
if
inUse16
i
block
for
forControl
j
j
j
block
if
m_inUse
i
j
block
bsW
block
bsW
bsW
nGroups
bsW
nSelectors
for
forControl
i
i
nSelectors
i
block
for
forControl
j
j
m_selectorMtf
i
j
block
bsW
bsW
for
forControl
t
t
nGroups
t
block
int
curr
len
t
bsW
curr
for
forControl
i
i
alphaSize
i
block
while
curr
len
t
i
block
bsW
curr
while
curr
len
t
i
block
bsW
curr
bsW
selCtr
gs
while
block
if
gs
m_nMTF
block
break
ge
gs
G_SIZE
if
ge
m_nMTF
block
ge
m_nMTF
for
forControl
i
gs
i
ge
i
block
bsW
len
m_selector
selCtr
m_szptr
i
code
m_selector
selCtr
m_szptr
i
gs
ge
selCtr
if
selCtr
nSelectors
block
panic
simpleSort
lo
int
hi
int
d
int
int
i
int
j
int
h
int
bigN
int
hp
int
v
bigN
hi
lo
if
bigN
block
return
hp
while
m_incs
hp
bigN
block
hp
hp
for
forControl
hp
hp
block
h
m_incs
hp
i
lo
h
while
block
if
i
hi
block
break
v
m_zptr
i
j
i
while
fullGtU
m_zptr
j
h
d
v
d
block
m_zptr
j
m_zptr
j
h
j
j
h
if
j
lo
h
block
break
m_zptr
j
v
i
if
i
hi
block
break
v
m_zptr
i
j
i
while
fullGtU
m_zptr
j
h
d
v
d
block
m_zptr
j
m_zptr
j
h
j
j
h
if
j
lo
h
block
break
m_zptr
j
v
i
if
i
hi
block
break
v
m_zptr
i
j
i
while
fullGtU
m_zptr
j
h
d
v
d
block
m_zptr
j
m_zptr
j
h
j
j
h
if
j
lo
h
block
break
m_zptr
j
v
i
if
m_workDone
m_workLimit
m_firstAttempt
block
return
vswap
p1
int
p2
int
n
int
int
temp
while
n
block
temp
m_zptr
p1
m_zptr
p1
m_zptr
p2
m_zptr
p2
temp
p1
p2
n
writeRun
if
m_last
m_allowableBlockSize
block
m_inUse
m_currentChar
for
forControl
int
i
i
m_runLength
i
block
updateCRC
char
m_currentChar
switch
m_runLength
case
m_last
m_block
m_last
char
m_currentChar
break
case
m_last
m_block
m_last
char
m_currentChar
m_last
m_block
m_last
char
m_currentChar
break
case
m_last
m_block
m_last
char
m_currentChar
m_last
m_block
m_last
char
m_currentChar
m_last
m_block
m_last
char
m_currentChar
break
case
m_inUse
m_runLength
m_last
m_block
m_last
char
m_currentChar
m_last
m_block
m_last
char
m_currentChar
m_last
m_block
m_last
char
m_currentChar
m_last
m_block
m_last
char
m_currentChar
m_last
m_block
m_last
char
m_runLength
break
block
endBlock
initBlock
writeRun
StackElem
int
m_dd
int
m_hh
int
m_ll
OutputStream
BZip2Constants
