PrecedenceQueryParserTokenManager
java
io
PrintStream
debugStream
out
setDebugStream
ds
java
io
PrintStream
debugStream
ds
jjStopStringLiteralDfa_3
int
pos
int
active0
long
switch
pos
case
return
jjStartNfa_3
int
pos
int
active0
long
return
jjMoveNfa_3
jjStopStringLiteralDfa_3
pos
active0
pos
jjStopAtPos
int
pos
int
kind
int
jjmatchedKind
kind
jjmatchedPos
pos
return
pos
jjStartNfaWithStates_3
int
pos
int
kind
int
state
int
jjmatchedKind
kind
jjmatchedPos
pos
try
curChar
readChar
catchClause
e
return
pos
return
jjMoveNfa_3
state
pos
jjMoveStringLiteralDfa0_3
int
switch
curChar
case
return
jjStopAtPos
case
return
jjStopAtPos
case
return
jjStopAtPos
case
return
jjStopAtPos
case
return
jjStopAtPos
case
return
jjStopAtPos
case
return
jjStopAtPos
case
return
jjStopAtPos
case
return
jjMoveNfa_3
jjCheckNAdd
state
int
if
jjrounds
state
jjround
block
jjstateSet
jjnewStateCnt
state
jjrounds
state
jjround
jjAddStates
start
int
end
int
do
start
end
block
jjstateSet
jjnewStateCnt
jjnextStates
start
jjCheckNAddTwoStates
state1
int
state2
int
jjCheckNAdd
state1
jjCheckNAdd
state2
jjCheckNAddStates
start
int
end
int
do
start
end
block
jjCheckNAdd
jjnextStates
start
jjCheckNAddStates
start
int
jjCheckNAdd
jjnextStates
start
jjCheckNAdd
jjnextStates
start
long
jjbitVec0
long
jjbitVec2
jjMoveNfa_3
int
startState
int
curPos
int
int
nextStates
int
startsAt
jjnewStateCnt
int
i
jjstateSet
startState
int
j
kind
for
forControl
block
if
jjround
ReInitRounds
if
curChar
block
long
l
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
if
l
block
if
kind
kind
jjCheckNAddStates
if
l
block
if
kind
kind
if
curChar
jjCheckNAdd
if
curChar
block
if
kind
kind
if
curChar
jjstateSet
jjnewStateCnt
break
case
if
curChar
kind
kind
break
case
if
curChar
jjstateSet
jjnewStateCnt
break
case
if
curChar
kind
kind
break
case
if
curChar
jjCheckNAdd
break
case
if
l
jjCheckNAddTwoStates
break
case
if
curChar
kind
kind
break
case
if
l
break
if
kind
kind
jjAddStates
break
case
if
curChar
jjCheckNAdd
break
case
if
l
break
if
kind
kind
jjCheckNAdd
break
case
if
l
break
if
kind
kind
jjCheckNAddStates
break
case
if
l
break
if
kind
kind
jjCheckNAddTwoStates
break
case
if
l
break
if
kind
kind
jjCheckNAddTwoStates
break
case
if
l
jjCheckNAddStates
break
case
if
curChar
kind
kind
break
case
if
l
jjCheckNAddStates
break
case
if
l
break
if
kind
kind
jjCheckNAddTwoStates
break
case
if
l
break
if
kind
kind
jjCheckNAddTwoStates
break
case
break
if
curChar
block
long
l
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
if
l
block
if
kind
kind
jjCheckNAddStates
if
curChar
block
if
kind
kind
jjstateSet
jjnewStateCnt
if
curChar
jjCheckNAddStates
if
curChar
jjstateSet
jjnewStateCnt
if
curChar
jjstateSet
jjnewStateCnt
if
curChar
jjstateSet
jjnewStateCnt
if
curChar
jjstateSet
jjnewStateCnt
break
case
if
curChar
kind
kind
break
case
if
curChar
jjstateSet
jjnewStateCnt
break
case
if
curChar
jjstateSet
jjnewStateCnt
break
case
if
curChar
kind
kind
break
case
if
curChar
jjstateSet
jjnewStateCnt
break
case
if
curChar
kind
kind
break
case
if
curChar
jjstateSet
jjnewStateCnt
break
case
if
curChar
kind
kind
break
case
if
curChar
jjstateSet
jjnewStateCnt
break
case
if
curChar
jjstateSet
jjnewStateCnt
break
case
jjAddStates
break
case
if
curChar
break
if
kind
kind
jjstateSet
jjnewStateCnt
break
case
if
l
break
if
kind
kind
jjCheckNAddStates
break
case
if
l
break
if
kind
kind
jjCheckNAddTwoStates
break
case
if
curChar
jjCheckNAddTwoStates
break
case
if
l
break
if
kind
kind
jjCheckNAddTwoStates
break
case
if
l
jjCheckNAddStates
break
case
if
curChar
jjCheckNAddTwoStates
break
case
if
l
jjCheckNAddStates
break
case
if
l
break
if
kind
kind
jjCheckNAddTwoStates
break
case
if
curChar
jjCheckNAddTwoStates
break
case
if
l
break
if
kind
kind
jjCheckNAddTwoStates
break
case
if
curChar
jjCheckNAddStates
break
case
break
block
int
hiByte
int
curChar
int
i1
hiByte
long
l1
hiByte
int
i2
curChar
long
l2
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
if
jjCanMove_0
hiByte
i1
i2
l1
l2
break
if
kind
kind
jjCheckNAddStates
break
case
if
jjCanMove_0
hiByte
i1
i2
l1
l2
jjAddStates
break
case
if
jjCanMove_0
hiByte
i1
i2
l1
l2
break
if
kind
kind
jjCheckNAddTwoStates
break
case
if
jjCanMove_0
hiByte
i1
i2
l1
l2
jjCheckNAddStates
break
case
if
jjCanMove_0
hiByte
i1
i2
l1
l2
break
if
kind
kind
jjCheckNAddTwoStates
break
case
break
if
kind
block
jjmatchedKind
kind
jjmatchedPos
curPos
kind
curPos
if
i
jjnewStateCnt
startsAt
jjnewStateCnt
startsAt
return
curPos
try
curChar
readChar
catchClause
e
return
curPos
jjStopStringLiteralDfa_1
int
pos
int
active0
long
switch
pos
case
if
active0
block
jjmatchedKind
return
return
case
return
jjStartNfa_1
int
pos
int
active0
long
return
jjMoveNfa_1
jjStopStringLiteralDfa_1
pos
active0
pos
jjStartNfaWithStates_1
int
pos
int
kind
int
state
int
jjmatchedKind
kind
jjmatchedPos
pos
try
curChar
readChar
catchClause
e
return
pos
return
jjMoveNfa_1
state
pos
jjMoveStringLiteralDfa0_1
int
switch
curChar
case
return
jjMoveStringLiteralDfa1_1
case
return
jjStopAtPos
case
return
jjMoveNfa_1
jjMoveStringLiteralDfa1_1
int
active0
long
try
curChar
readChar
catchClause
e
jjStopStringLiteralDfa_1
active0
return
switch
curChar
case
if
active0
return
jjStartNfaWithStates_1
break
case
break
return
jjStartNfa_1
active0
jjMoveNfa_1
int
startState
int
curPos
int
int
nextStates
int
startsAt
jjnewStateCnt
int
i
jjstateSet
startState
int
j
kind
for
forControl
block
if
jjround
ReInitRounds
if
curChar
block
long
l
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
if
l
block
if
kind
kind
jjCheckNAdd
if
l
block
if
kind
kind
if
curChar
jjCheckNAdd
break
case
if
curChar
jjCheckNAdd
break
case
if
l
jjCheckNAddTwoStates
break
case
if
curChar
kind
kind
break
case
if
l
break
if
kind
kind
jjCheckNAdd
break
case
break
if
curChar
block
long
l
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
if
l
break
if
kind
kind
jjCheckNAdd
break
case
jjAddStates
break
case
break
block
int
hiByte
int
curChar
int
i1
hiByte
long
l1
hiByte
int
i2
curChar
long
l2
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
if
jjCanMove_0
hiByte
i1
i2
l1
l2
break
if
kind
kind
jjCheckNAdd
break
case
if
jjCanMove_0
hiByte
i1
i2
l1
l2
jjAddStates
break
case
break
if
kind
block
jjmatchedKind
kind
jjmatchedPos
curPos
kind
curPos
if
i
jjnewStateCnt
startsAt
jjnewStateCnt
startsAt
return
curPos
try
curChar
readChar
catchClause
e
return
curPos
jjMoveStringLiteralDfa0_0
int
return
jjMoveNfa_0
jjMoveNfa_0
int
startState
int
curPos
int
int
nextStates
int
startsAt
jjnewStateCnt
int
i
jjstateSet
startState
int
j
kind
for
forControl
block
if
jjround
ReInitRounds
if
curChar
block
long
l
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
if
l
break
if
kind
kind
jjAddStates
break
case
if
curChar
jjCheckNAdd
break
case
if
l
break
if
kind
kind
jjCheckNAdd
break
case
break
if
curChar
block
long
l
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
break
block
int
hiByte
int
curChar
int
i1
hiByte
long
l1
hiByte
int
i2
curChar
long
l2
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
break
if
kind
block
jjmatchedKind
kind
jjmatchedPos
curPos
kind
curPos
if
i
jjnewStateCnt
startsAt
jjnewStateCnt
startsAt
return
curPos
try
curChar
readChar
catchClause
e
return
curPos
jjStopStringLiteralDfa_2
int
pos
int
active0
long
switch
pos
case
if
active0
block
jjmatchedKind
return
return
case
return
jjStartNfa_2
int
pos
int
active0
long
return
jjMoveNfa_2
jjStopStringLiteralDfa_2
pos
active0
pos
jjStartNfaWithStates_2
int
pos
int
kind
int
state
int
jjmatchedKind
kind
jjmatchedPos
pos
try
curChar
readChar
catchClause
e
return
pos
return
jjMoveNfa_2
state
pos
jjMoveStringLiteralDfa0_2
int
switch
curChar
case
return
jjMoveStringLiteralDfa1_2
case
return
jjStopAtPos
case
return
jjMoveNfa_2
jjMoveStringLiteralDfa1_2
int
active0
long
try
curChar
readChar
catchClause
e
jjStopStringLiteralDfa_2
active0
return
switch
curChar
case
if
active0
return
jjStartNfaWithStates_2
break
case
break
return
jjStartNfa_2
active0
jjMoveNfa_2
int
startState
int
curPos
int
int
nextStates
int
startsAt
jjnewStateCnt
int
i
jjstateSet
startState
int
j
kind
for
forControl
block
if
jjround
ReInitRounds
if
curChar
block
long
l
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
if
l
block
if
kind
kind
jjCheckNAdd
if
l
block
if
kind
kind
if
curChar
jjCheckNAdd
break
case
if
curChar
jjCheckNAdd
break
case
if
l
jjCheckNAddTwoStates
break
case
if
curChar
kind
kind
break
case
if
l
break
if
kind
kind
jjCheckNAdd
break
case
break
if
curChar
block
long
l
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
if
l
break
if
kind
kind
jjCheckNAdd
break
case
jjAddStates
break
case
break
block
int
hiByte
int
curChar
int
i1
hiByte
long
l1
hiByte
int
i2
curChar
long
l2
curChar
do
i
startsAt
block
switch
jjstateSet
i
case
if
jjCanMove_0
hiByte
i1
i2
l1
l2
break
if
kind
kind
jjCheckNAdd
break
case
if
jjCanMove_0
hiByte
i1
i2
l1
l2
jjAddStates
break
case
break
if
kind
block
jjmatchedKind
kind
jjmatchedPos
curPos
kind
curPos
if
i
jjnewStateCnt
startsAt
jjnewStateCnt
startsAt
return
curPos
try
curChar
readChar
catchClause
e
return
curPos
int
jjnextStates
jjCanMove_0
boolean
hiByte
int
i1
int
i2
int
l1
long
l2
long
switch
hiByte
case
return
jjbitVec2
i2
l2
case
if
jjbitVec0
i1
l1
return
return
String
jjstrLiteralImages
String
lexStateNames
int
jjnewLexState
long
jjtoToken
long
jjtoSkip
CharStream
input_stream
int
jjrounds
int
int
jjstateSet
int
char
curChar
PrecedenceQueryParserTokenManager
stream
CharStream
input_stream
stream
PrecedenceQueryParserTokenManager
stream
CharStream
lexState
int
stream
SwitchTo
lexState
ReInit
stream
CharStream
jjmatchedPos
jjnewStateCnt
curLexState
defaultLexState
input_stream
stream
ReInitRounds
ReInitRounds
int
i
jjround
for
forControl
i
i
jjrounds
i
ReInit
stream
CharStream
lexState
int
ReInit
stream
SwitchTo
lexState
SwitchTo
lexState
int
if
lexState
lexState
throw
TokenMgrError
lexState
INVALID_LEXICAL_STATE
curLexState
lexState
jjFillToken
Token
Token
t
newToken
jjmatchedKind
kind
jjmatchedKind
String
im
jjstrLiteralImages
jjmatchedKind
image
im
GetImage
im
beginLine
getBeginLine
beginColumn
getBeginColumn
endLine
getEndLine
endColumn
getEndColumn
return
t
int
curLexState
int
defaultLexState
int
jjnewStateCnt
int
jjround
int
jjmatchedPos
int
jjmatchedKind
getNextToken
Token
int
kind
Token
specialToken
Token
matchedToken
int
curPos
for
forControl
block
try
curChar
BeginToken
catchClause
e
jjmatchedKind
matchedToken
jjFillToken
return
matchedToken
switch
curLexState
case
jjmatchedKind
jjmatchedPos
curPos
jjMoveStringLiteralDfa0_0
break
case
jjmatchedKind
jjmatchedPos
curPos
jjMoveStringLiteralDfa0_1
break
case
jjmatchedKind
jjmatchedPos
curPos
jjMoveStringLiteralDfa0_2
break
case
jjmatchedKind
jjmatchedPos
curPos
jjMoveStringLiteralDfa0_3
break
if
jjmatchedKind
block
if
jjmatchedPos
curPos
backup
curPos
jjmatchedPos
if
jjtoToken
jjmatchedKind
jjmatchedKind
block
matchedToken
jjFillToken
if
jjnewLexState
jjmatchedKind
curLexState
jjnewLexState
jjmatchedKind
return
matchedToken
block
if
jjnewLexState
jjmatchedKind
curLexState
jjnewLexState
jjmatchedKind
continue
int
error_line
getEndLine
int
error_column
getEndColumn
String
error_after
boolean
EOFSeen
try
readChar
backup
catchClause
e1
EOFSeen
error_after
curPos
GetImage
if
curChar
curChar
block
error_line
error_column
error_column
if
EOFSeen
block
backup
error_after
curPos
GetImage
throw
TokenMgrError
EOFSeen
curLexState
error_line
error_column
error_after
curChar
LEXICAL_ERROR
PrecedenceQueryParserConstants
