/*
 * InstallData.cpp - part of jEditLauncher package
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * Notwithstanding the terms of the General Public License, the author grants
 * permission to compile and link object code generated by the compilation of
 * this program with object code and libraries that are not subject to the
 * GNU General Public License, provided that the executable output of such
 * compilation shall be distributed with source code on substantially the
 * same basis as the jEditLauncher package of which this program is a part.
 * By way of example, a distribution would satisfy this condition if it
 * included a working makefile for any freely available make utility that
 * runs on the Windows family of operating systems. This condition does not
 * require a licensee of this software to distribute any proprietary software
 * (including header files and libraries) that is licensed under terms
 * prohibiting redistribution to third parties.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: InstallData.cpp,v 1.7 2001/08/01 14:53:25 jgellene Exp $
 */

#include "stdafx.h"
#include "StringPtr.h"
#include "InstallData.h"

bool InstallData::Init()
{
	// check OS
	OSVERSIONINFO osver;
	osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osver);
	bIsWinNT = (osver.dwPlatformId == VER_PLATFORM_WIN32_NT);

	HKEY hSoftwareKey, hLauncherKey, hCurVerKey, hKey;

	// get current installed version and context menu version
	CString strCurrentGUID, strCtxMenuGUID;
	if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT,
		_T("JEdit.JEditLauncher\\CLSID"), 0, KEY_READ, &hKey))
	{
		CStringBuf<> pBuf(strCurrentGUID);
		DWORD bufSize = pBuf.Size();
		RegQueryValueEx(hKey, 0, 0, 0, pBuf, &bufSize);
	}
	RegCloseKey(hKey);
	hKey = 0;
	if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT,
		_T("*\\shellex\\ContextMenuHandlers\\Open with jEdit"),
		0, KEY_READ, &hKey))
	{
		CStringBuf<> pBuf(strCtxMenuGUID);
		DWORD bufSize = pBuf.Size();
		RegQueryValueEx(hKey, 0, 0, 0, pBuf, &bufSize);
	}
	RegCloseKey(hKey);
	hKey = 0;

	// Add key and values for this version if necessary
	if(ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER,
		_T("Software\\www.jedit.org"), 0, 0, 0, KEY_ALL_ACCESS,
		0, &hSoftwareKey, 0))
	{
		return false;
	}
	if(ERROR_SUCCESS != RegCreateKeyEx(hSoftwareKey,
		_T("jEditLauncher"), 0, 0, 0, KEY_ALL_ACCESS,
		0, &hLauncherKey, 0))
	{
		RegCloseKey(hSoftwareKey);
		return false;
	}
	RegCloseKey(hSoftwareKey);
	if(ERROR_SUCCESS != RegCreateKeyEx(hLauncherKey,
		strInstallVersion, 0, 0, 0, KEY_ALL_ACCESS,
		0, &hCurVerKey, 0))
	{
		RegCloseKey(hLauncherKey);
		return false;
	}
	if(ERROR_SUCCESS != RegSetValueEx(hCurVerKey, _T("Launcher GUID"), 0,
		REG_SZ, (LPBYTE)(LPCTSTR)strInstallGUID, GetBufferByteLen(strInstallGUID))
		||
	  ERROR_SUCCESS != RegSetValueEx(hCurVerKey, _T("Installation Directory"),
	  	0, REG_SZ, (LPBYTE)(LPCSTR)strInstallDir, GetBufferByteLen(strInstallDir)))
	{
		RegCloseKey(hCurVerKey);
		RegCloseKey(hLauncherKey);
		return false;
	}
	RegCloseKey(hCurVerKey);



	//check for number and identity of installed versions
	RegQueryInfoKey(hLauncherKey, 0, 0, 0, &nInstalledVersions,
			0, 0, 0, 0, 0, 0, 0);
	if(nInstalledVersions != 0)
	{
		arPathNames = new CString[nInstalledVersions];
		arVersionNames = new CString[nInstalledVersions];
		arGUID = new CString[nInstalledVersions];
		HKEY hVersionKey = 0;
		for(DWORD nVersion = 0; nVersion < nInstalledVersions; ++nVersion)
		{
			CStringBuf<> pVersionBuf(arVersionNames[nVersion]);
			DWORD bufSize = pVersionBuf.Size();
			if(ERROR_SUCCESS == RegEnumKeyEx(hLauncherKey, nVersion, pVersionBuf,
				&bufSize, 0, 0, 0, 0))
			{
				if(ERROR_SUCCESS == RegOpenKeyEx(hLauncherKey, pVersionBuf, 0,
					KEY_READ, &hVersionKey))
				{
					CStringBuf<> pPathBuf(arPathNames[nVersion]);
					DWORD bufSize = pPathBuf.Size();
					RegQueryValueEx(hVersionKey,
						_T("Installation Directory"), 0, 0,
						(LPBYTE)pPathBuf, &bufSize);
					CStringBuf<> pGUIDBuf(arGUID[nVersion]);
					bufSize = pGUIDBuf.Size();
					RegQueryValueEx(hVersionKey,
						_T("Launcher GUID"), 0, 0,
						(LPBYTE)pGUIDBuf, &bufSize);
					}
				RegCloseKey(hVersionKey);
				hVersionKey = 0;
				CString& strVerGUID = arGUID[nVersion];
				if(strInstallGUID.Compare(strVerGUID) == 0)
				{
					nIndexSubjectVer = nVersion;
				}
				if(strCurrentGUID.Compare(strVerGUID) == 0)
				{
					nIndexCurrentVer = nVersion;
				}
				if(strCtxMenuGUID.Compare(strVerGUID) == 0)
				{
					// matching version
				}
				TCHAR szKeyValue[MAX_PATH], szInstallValue[MAX_PATH];
				GetShortPathName(arPathNames[nVersion], szKeyValue, MAX_PATH);
				GetShortPathName(strInstallDir, szInstallValue, MAX_PATH);
				int nLengthInstallValue = _tcslen(szInstallValue);
				// check if overwriting an installation -- same directory
				if(CompareString(LOCALE_SYSTEM_DEFAULT, 
					NORM_IGNORECASE | SORT_STRINGSORT,
					szKeyValue, nLengthInstallValue,
					szInstallValue, nLengthInstallValue) == CSTR_EQUAL)
				{
					strOldPath = arPathNames[nVersion] + _T("\\jeshlstb.dll");
					nIndexOverwrittenVer = nVersion;
				}
			}	// end extraction of version information
		}   // end for loop
	}	// end installed version > 0  (should always be true because of initial data)
	RegCloseKey(hLauncherKey);
	// end routine for getting prior installation data

	/*
	 * we must confirm we have the correct version of the component available
	 * we look in the following places
	 * 		1.	a new installation should have "jeshlstb.dl_" in the
	 * 			current directory; confirm correct version
	 * 		2.	if not present, then check if "jeshlstb.dll" in the current
	 * 			directory is the correct version
	 * 		3.	if not found in current directory, use version already recorded
	 * 			in registry, if exists (found by Init() and recorded in
	 			arFileNames)
	 * if no file is available, installation fails
	 * if succeeds, set strFullInstallName to correct full name (after renaming)
	 */
 	CString strComponentPath(strInstallDir);
	strComponentPath += _T('\\');
	strComponentPath += strInstallName;
	if(CompareVersion(strComponentPath))
	{
		strInstallPath = strComponentPath;
	}
	else
	{
		strComponentPath.SetAt(strComponentPath.GetLength() - 1, _T('l'));
		if(CompareVersion(strComponentPath))
		{
			strInstallPath = strComponentPath;
		}
		else
		{
			if(arPathNames[nIndexSubjectVer].IsEmpty())
				return false;
			strComponentPath = arPathNames[nIndexSubjectVer];
			strComponentPath += _T("\\jeshlstb.dll");
			if(CompareVersion(strComponentPath))
			{
				strInstallPath = strComponentPath;
			}
			else
				return false;
		}
	}
	strInstallFinalPath = strInstallPath;
	strInstallFinalPath.SetAt(strInstallFinalPath.GetLength() - 1, _T('l'));
	if(strInstallPath.Compare(strInstallFinalPath) == 0)
		bUsingTempFileName = false;
	return true;
}

void InstallData::ShortenToDirectory(TCHAR* lpszPath)
{
	TCHAR* pSlash = 0;
	TCHAR* p = lpszPath;
	while (*p != 0)
	{
		if (*p == _T('\\'))
			pSlash = p;
		p = ::CharNext(p);
	}
	if(pSlash == 0)
		*(lpszPath + 2) = 0; // drive name only
	else
		*pSlash = 0;
}


bool InstallData::CompareVersion(LPCTSTR szPath)
{
	DWORD dwAttributes = GetFileAttributes(szPath);
	if(dwAttributes == -1)
		return false;
	DWORD ms, ls;
	return GetVersion(szPath, &ms, &ls)
		&& ms == InstallCurVerData::Version;
		//&& ls == InstallCurVerData::MinorVersion;
}


bool InstallData::GetVersion(const char* szPath, DWORD *pdwms, DWORD *pdwls)
{
	DWORD dwInfoSize = 0;
	DWORD dwIgnored = 0;
	UINT nLenVsffi = 0;
	LPVOID lpData = 0;
	VS_FIXEDFILEINFO *pvsffi = 0;
	dwInfoSize = GetFileVersionInfoSize((LPTSTR)szPath, &dwInfoSize);
	if(dwInfoSize != 0)
	{
		lpData = CoTaskMemAlloc(dwInfoSize);
		if(lpData != 0 && GetFileVersionInfo((LPTSTR)szPath, dwIgnored,
			dwInfoSize, lpData)	&& VerQueryValue(lpData, _T("\\"),
			(void**)&pvsffi, &nLenVsffi))
		{
			*pdwms = pvsffi->dwFileVersionMS;
			*pdwls = pvsffi->dwFileVersionLS;
		}
		else dwInfoSize = 0;
		CoTaskMemFree(lpData);
	}
	return dwInfoSize != 0;
}


/*
void InstallData::OSErrorMsgBox(LPCTSTR szHeader, UINT nMsg, UINT nType)
{
	LPVOID lpMsgBuf = 0;
	if(nMsg != 0)
	::FormatMessage(
	    FORMAT_MESSAGE_ALLOCATE_BUFFER |
	    FORMAT_MESSAGE_FROM_SYSTEM |
	    FORMAT_MESSAGE_IGNORE_INSERTS,
	    NULL,
	    nMsg,
	    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
	    (LPTSTR) &lpMsgBuf,
	    0,
	    NULL
	);

	CString strMessage;
	if( nMsg != 0)
		strMessage.Format("%s %s", szHeader, lpMsgBuf);
	else
		strMessage = CString(szHeader);
	// fix here (must this be static?)
	::MessageBox(0, strMessage, _T("jEdit"), nType);
	LocalFree(lpMsgBuf);
}
*/

DWORD InstallData::GetBufferByteLen(const WTL::CString& str)
{
	return (str.GetLength() + 1) * sizeof(TCHAR);
}

#if defined(_DEBUG)

void InstallData::Dump()
{
	OutputDebugString("Dumping InstallData....\n");
	CString strOutput;
	strOutput.Format("strJavaHome: %s\nstrInstallDir: %s\nstrInstallName: %s\n",
		strJavaHome, strInstallDir, strInstallName);
	OutputDebugString(strOutput);
	strOutput.Format("strOldPath: %s\nstrInstallGUID: %s\nstrInstallVersion: %s\n",
		strOldPath, strInstallGUID, strInstallVersion);
	OutputDebugString(strOutput);
	strOutput.Format("strApp: %s\nstrVersionLabel: %s\n",
		strApp, strVersionLabel);
	OutputDebugString(strOutput);
	strOutput.Format("bRebootRequired: %s\nbUsingTempFileName: %s\nbIsWinNT: %s\n",
		bRebootRequired ? "true" : "false", bUsingTempFileName ? "true" : "false",
		bIsWinNT ? "true" : "false");
	OutputDebugString(strOutput);
	strOutput.Format("dwInstalledVersion: %d\nnInstalledVersions: %d\nnIndexSubjectVer: %d\n",
		dwInstalledVersions, nInstalledVersions, nIndexSubjectVer);
	OutputDebugString(strOutput);
	strOutput.Format("nIndexOverwrittenVer: %d\nnIndexCurrentVer: %d\n",
		nIndexOverwrittenVer, nIndexCurrentVer);
	OutputDebugString(strOutput);
	strOutput.Format("arPathNames:\n");
	OutputDebugString(strOutput);
	unsigned int n;
	for(n = 0; n < nInstalledVersions; ++n)
	{
		strOutput.Format("    Item %d: %s\n", n, arPathNames[n]);
		OutputDebugString(strOutput);
	}
	strOutput.Format("arVersionNames:\n");
	OutputDebugString(strOutput);
	for(n = 0; n < nInstalledVersions; ++n)
	{
		strOutput.Format("    Item %d: %s\n", n, arVersionNames[n]);
		OutputDebugString(strOutput);
	}
}

#endif
