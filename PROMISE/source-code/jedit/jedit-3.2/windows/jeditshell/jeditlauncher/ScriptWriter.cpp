/*
 * ScriptWriter.cpp - part of jEditLauncher package
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * Notwithstanding the terms of the General Public License, the author grants
 * permission to compile and link object code generated by the compilation of
 * this program with object code and libraries that are not subject to the
 * GNU General Public License, provided that the executable output of such
 * compilation shall be distributed with source code on substantially the
 * same basis as the jEditLauncher package of which this program is a part.
 * By way of example, a distribution would satisfy this condition if it
 * included a working makefile for any freely available make utility that
 * runs on the Windows family of operating systems. This condition does not
 * require a licensee of this software to distribute any proprietary software
 * (including header files and libraries) that is licensed under terms
 * prohibiting redistribution to third parties.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id: ScriptWriter.cpp,v 1.6 2001/08/28 19:37:20 jgellene Exp $
 */

#include "stdafx.h"
#include "resource.h"
#include "JELauncher.h"
#include "ScriptWriter.h"
#include <shlobj.h>

// implementation of ScriptWriter class

ScriptWriter::ScriptWriter()
	: pBuffer(0), pPathBuffer(0), bufferSize(0L) {}


ScriptWriter::~ScriptWriter()
{
	ReleaseBuffer();
}


HRESULT ScriptWriter::WriteScript(VARIANTARG var, char** ppScript)
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling ScriptWriter::WriteScript() passing variant\n");
#endif
	WritePrefix();
	ProcessPathArray(var);
	WriteSuffix();
	*ppScript = GetBuffer();
	return S_OK;
}


HRESULT ScriptWriter::WriteScript(wchar_t* wargv[], int nArgs,
		char **ppScript)
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling ScriptWriter::WriteScript() passing wide char array\n");
#endif
	WritePrefix();
	for(wchar_t **pp = wargv; nArgs > 0; --nArgs, ++pp)
	{
		ProcessPath(*pp);
	}
	WriteSuffix();
	*ppScript = GetBuffer();
	return S_OK;
}


HRESULT ScriptWriter::WriteScript(char* argv[], int nArgs,
		char **ppScript)
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling ScriptWriter::WriteScript() passing char array\n");
#endif
	WritePrefix();
	for(char **pp = argv; nArgs > 0; --nArgs, ++pp)
	{
		ProcessPath(*pp);
	}
	WriteSuffix();
	*ppScript = GetBuffer();
	return S_OK;
}


HRESULT ScriptWriter::InitBuffer(size_t size)
{
	if(pPathBuffer == 0 &&
		(pPathBuffer = (char*)CoTaskMemAlloc(1024)) == 0)
		return E_FAIL;
	char *pBuf = pBuffer;
	pBuffer = (char*)CoTaskMemRealloc(pBuf, (ULONG)size);
	if(pBuffer == 0)
	{
		pBuffer = pBuf;
		return E_FAIL;
	}
	bufferSize = size;
	return S_OK;
}


void ScriptWriter::ReleaseBuffer()
{
	CoTaskMemFree((LPVOID)pBuffer);
	CoTaskMemFree((LPVOID)pPathBuffer);
	pBuffer = 0;
	bufferSize = 0;
	pPathBuffer = 0;
}


void ScriptWriter::ClearBuffer()
{
	ZeroMemory(pBuffer, bufferSize);
}


char* ScriptWriter::GetBuffer()
{
	return pBuffer;
}


HRESULT ScriptWriter::CheckBuffer(size_t sizeCheck, size_t sizeIncr)
{
	size_t needed = 0;
	size_t target = strlen(pBuffer) + sizeCheck;
	while(target + needed > bufferSize - 1)
		needed += sizeIncr;
	return needed != 0 ? InitBuffer(bufferSize + needed) : S_OK;
}


HRESULT ScriptWriter::ProcessPathArray(VARIANTARG arg)
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling ScriptWriter::ProcessPathArray() passing variant\n");
#endif
	HRESULT hr;
	VARIANT varPath;
	VariantInit(&varPath);
	switch(arg.vt)
	{
		case VT_BSTR:   // single string in JScript or VBScript
		{
			hr = ProcessPath(arg.bstrVal);
			break;
		}

		case VT_DISPATCH:  // JScript array
		{
			DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
			hr = arg.pdispVal->Invoke( DISPID_NEWENUM, IID_NULL,
					LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
					&dispparamsNoArgs, &varPath, NULL, NULL);
			IEnumVARIANT *pEnum = 0;
			hr = varPath.punkVal->QueryInterface(__uuidof(IEnumVARIANT),
				(void**)&pEnum);
			VariantClear(&varPath);
			HRESULT loop_hr = pEnum->Next(1, &varPath, 0);
			while(loop_hr == S_OK)
			{
				ProcessPath(varPath.bstrVal);
				VariantClear(&varPath);
				loop_hr = pEnum->Next(1, &varPath, 0);
			}
			if(pEnum)
				pEnum->Release();
			break;
		}

		case VT_ARRAY | VT_VARIANT:  // VBScript array
		{
			LONG nIndex = 0;
			HRESULT loop_hr = SafeArrayGetElement(arg.parray,
				&nIndex, &varPath);
			while(loop_hr == S_OK)
			{
				ProcessPath(varPath.bstrVal);
				VariantClear(&varPath);
				loop_hr = SafeArrayGetElement(arg.parray,
					&(++nIndex), &varPath);
			}
			break;
		}
		default:
			hr = E_INVALIDARG;
	}
	VariantClear(&varPath);
	return hr;
}


HRESULT ScriptWriter::ProcessPath(wchar_t* pwszPath)
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling ScriptWriter::ProcessPath with wide char parameter.\n");
#endif
	if(pwszPath == 0 || wcslen(pwszPath) == 0)
	{
		CJEditLauncher::MakeErrorInfo(IDS_ERR_NO_FILENAME);
		return E_FAIL;
	}
	::WideCharToMultiByte(CP_ACP, 0, pwszPath,
		-1, pPathBuffer, MAX_PATH * 2, 0, 0);
	return ProcessPath(pPathBuffer);
}


HRESULT ScriptWriter::ProcessPath(char* pszName)
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling ScriptWriter::ProcessPath with char parameter ");
	_Module.pLauncher->WriteLogFile(pszName);
	_Module.pLauncher->WriteLogFile("\n");
#endif
	CJEditLauncher::MakeErrorInfo((UINT)0);
	// new
	CHAR pszPath[MAX_PATH];
	CHAR* pFileName = 0;
	GetFullPathName(pszName, MAX_PATH, pszPath, &pFileName);
	OutputDebugString(pszPath);
	// wild card search and expansion
	if(strcspn(pszPath, "*?") != strlen(pszPath))
	{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] ScriptWriter::ProcessPath() performing wild-card expansion\n");
#endif

		CHAR* pSlash = strrchr(pszPath, '\\');
		UINT pathLen = pSlash ? (UINT)(pSlash - pszPath) + 1 : 0;
		BOOL bDotNoStar = FALSE;
		CHAR* pDot = strrchr(pszPath, '.');
		if(pDot != 0 && strchr(pDot, '*') == 0)
			bDotNoStar = TRUE;
		OutputDebugString(bDotNoStar ? "bDotNoStar is TRUE" : "bDotNoStar is FALSE");
		UINT maskExtLen = strlen(strrchr(pszPath, '.'));
		CHAR pszRecursivePath[MAX_PATH];
		WIN32_FIND_DATA finddata;
		HANDLE findHandle = FindFirstFile(pszPath, &finddata);
		if(findHandle != INVALID_HANDLE_VALUE)
		{
			BOOL findResult = TRUE;
			while (findResult)
			{
				OutputDebugString("FileFound:");
				OutputDebugString(finddata.cFileName);
				if((finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0
					&& (!bDotNoStar || maskExtLen ==
						strlen(strrchr(finddata.cFileName, '.'))))
				{
					strncpy(pszRecursivePath, pszPath, pathLen);
					pszRecursivePath[pathLen] = 0;
					strcat(pszRecursivePath, finddata.cFileName);
					MakeFullPath(pszRecursivePath);
					ProcessSinglePath(pszRecursivePath);
				}
				findResult = FindNextFile(findHandle, &finddata);
			}
			FindClose(findHandle);
		}
		else
			return E_FAIL;
	}
	else  	// non-recursive routine
	{
		MakeFullPath(pszPath);
		ProcessSinglePath(pszPath);
	}
	return S_OK;
}


void ScriptWriter::MakeFullPath(char* pszPath)
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling ScriptWriter::MakeFullPath with char parameter ");
	_Module.pLauncher->WriteLogFile(pszPath);
	_Module.pLauncher->WriteLogFile("\n");
#endif

	BOOL isMinLen = strlen(pszPath) > 1;
	//BOOL isFullPath = isMinLen && isalpha(*pszPath) && *(pszPath + 1) == ':';
	BOOL isUNC = isMinLen && strncmp(pszPath, "\\\\", 2) == 0;

	if(isUNC) return;

	CHAR buf[MAX_PATH * 2];
	CHAR *pFileName;
	GetFullPathName(pszPath, MAX_PATH * 2, buf, &pFileName);
/*

	if(isFullPath)
	{
		strcpy(buf, pszPath);
	}
	else
	{
		CHAR dir[MAX_PATH];
		strcpy(buf, pszPath);
		GetCurrentDirectoryA(MAX_PATH, dir);
		strncpy(buf, dir, MAX_PATH);
		strcat(buf, "\\");
		strncat(buf, pszPath, MAX_PATH);
	}
*/
	ResolveLink(buf, pszPath);
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] After call to ScriptWriter::ResolveLink(), path is ");
	_Module.pLauncher->WriteLogFile(pszPath);
	_Module.pLauncher->WriteLogFile("\n");
#endif
}


/* Resolve a Shortcut (ShellLink)
 * Put the resolved path into outPath
 * Copies path to outPath on failure so
 * outPath is always a useable path
 */
HRESULT ScriptWriter::ResolveLink(char* path, char* outPath)
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling ScriptWriter::ResolveLink() with char parameters:\n\t");
	_Module.pLauncher->WriteLogFile(path);
	_Module.pLauncher->WriteLogFile("\n\t");
	_Module.pLauncher->WriteLogFile(outPath);
	_Module.pLauncher->WriteLogFile("\n");
#endif

	IShellLink *psl;
	HRESULT hres;

	hres = CoCreateInstance(CLSID_ShellLink, NULL,
		CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *)&psl);
	if (SUCCEEDED(hres))
	{
		IPersistFile *ppf;
		hres = psl->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
		if (SUCCEEDED(hres))
		{
			WORD wsz[MAX_PATH];
		    MultiByteToWideChar(CP_ACP, 0, path, -1, wsz, MAX_PATH);
		    hres = ppf->Load(wsz, STGM_READ);
			if (SUCCEEDED(hres))
			{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] IPersistFile::Load call succeeded.\n");
#endif
				hres = psl->Resolve(0, SLR_ANY_MATCH | SLR_NO_UI);
				if (SUCCEEDED(hres))
				{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] IShellLink::Resolve call succeeded.\n");
#endif
					WIN32_FIND_DATA wfd;
					char szgotpath[MAX_PATH];
					ZeroMemory(szgotpath, MAX_PATH);
				    hres = psl->GetPath(szgotpath, MAX_PATH,
						&wfd, SLGP_SHORTPATH);
					if(SUCCEEDED(hres))
					{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] IShellLink::GetPath() call succeeded; resolved path is ");
	if(szgotpath == 0 || strlen(szgotpath) == 0)
		_Module.pLauncher->WriteLogFile("<zero-length string>.");
	else
		_Module.pLauncher->WriteLogFile(szgotpath);
	_Module.pLauncher->WriteLogFile("\n");
#endif
						if(szgotpath != 0 && strlen(szgotpath) != 0)
							strcpy(outPath, szgotpath);
					}
#if defined SPECIAL_BUILD
					else
					{
	_Module.pLauncher->WriteLogFile("[launcher] IShellLink::GetPath() call did not succeed. Error code: ");
	char szMsg[32];
	strcpy(szMsg, "0x");
	ltoa(hres, szMsg + 2, 16);
	strcat(szMsg, "\n");
	_Module.pLauncher->WriteLogFile(szMsg);
					}
#endif
				}
#if defined SPECIAL_BUILD
				else
				{
	_Module.pLauncher->WriteLogFile("[launcher] IShellLink::Resolve call failed. Error code: ");
	char szMsg[32];
	strcpy(szMsg, "0x");
	ltoa(hres, szMsg + 2, 16);
	strcat(szMsg, "\n");
	_Module.pLauncher->WriteLogFile(szMsg);
				}
#endif
			}
#if defined SPECIAL_BUILD
			else
			{
	_Module.pLauncher->WriteLogFile("[launcher] IPersistFile::Load call failed. Error code: ");
	char szMsg[32];
	strcpy(szMsg, "0x");
	ltoa(hres, szMsg + 2, 16);
	strcat(szMsg, "\n");
	_Module.pLauncher->WriteLogFile(szMsg);
			}
#endif
			ppf->Release();
		}
#if defined SPECIAL_BUILD
		else
		{
	_Module.pLauncher->WriteLogFile("[launcher] Could not get pointer to IPersistFile object. Error code: ");
	char szMsg[32];
	strcpy(szMsg, "0x");
	ltoa(hres, szMsg + 2, 16);
	strcat(szMsg, "\n");
	_Module.pLauncher->WriteLogFile(szMsg);
		}
#endif
		psl->Release();
	}
#if defined SPECIAL_BUILD
	else
	{
	_Module.pLauncher->WriteLogFile("[launcher] Could not get pointer to IShellLink object. Error code:");
	char szMsg[32];
	strcpy(szMsg, "0x");
	ltoa(hres, szMsg + 2, 16);
	strcat(szMsg, "\n");
	_Module.pLauncher->WriteLogFile(szMsg);
	}
#endif
	if(!SUCCEEDED(hres))
	{
		strcpy(outPath, path);
	}
	return hres;
}


void ScriptWriter::AppendPath(const char* path)
{
	if(path == 0) return;
	const char* s = path;
	char *d = pBuffer + strlen(pBuffer);
	*d++ = '\"';
	while(*s != 0)
	{
		if(*s == '\\')
			*d++ = '\\';
		*d++ = *s++;
	}
	*d++ = '\"';
	*d = 0;
}


void ScriptWriter::Append(const char* source)
{
	strcat(pBuffer, source);
}


// Implementation of class OpenFileScript

OpenFileScript::OpenFileScript()
	: ScriptWriter(), m_nFiles(0)
{
	InitBuffer(4096);
}

OpenFileScript::~OpenFileScript() {}


HRESULT OpenFileScript::WritePrefix()
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling OpenFileScript::WritePrefix()\n");
#endif
	ClearBuffer();
	Append("v = new java.util.Vector(8); ");
	return S_OK;
}


HRESULT OpenFileScript::ProcessSinglePath(const char* pszPath)
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling OpenFileScript::ProcessSinglePath() with char parameter ");
	_Module.pLauncher->WriteLogFile(pszPath);
	_Module.pLauncher->WriteLogFile("\n");
#endif
	Append("v.addElement(");
	AppendPath(pszPath);
	Append("); ");
	++m_nFiles;
	return S_OK;
}


HRESULT OpenFileScript::WriteSuffix()
{
#if defined SPECIAL_BUILD
	_Module.pLauncher->WriteLogFile("[launcher] Calling OpenFileScript::WriteSuffix()\n");
#endif
	if(m_nFiles == 0)
	{
		ClearBuffer();
		Append("Macros.error(jEdit.getFirstView(), ");
		Append("\"No files met the supplied wild-card specification.\");");
	}
	else
	{
		Append("s = v.size(); args = new String[s]; v.copyInto(args); ");
		Append("EditServer.handleClient(true, null, args); ");
		Append("jEdit.openFile(jEdit.getFirstView(), args[s - 1]);\n\n");
	}
	return S_OK;
}

// Implementation of class OpenDiffScript

/*
	Here is the script written by this object:
 // ----- prefix -----
 	v = jEdit.getFirstView();
	if(jEdit.getPlugin("JDiffPlugin") == null) {
		Macros.error(v, "You must have the JDiff plugin "
        	+ "installed to use this jEditLauncher feature.");
			return;
	}
	if(DualDiff.isEnabledFor(v))
		DualDiff.toggleFor(v);
	while(v.getEditPanes().length > 1)
		v.unsplit();
	v.splitVertically();
	DualDiff.toggleFor(v);
	openDiffFiles(vv) {
		v = vv;
		run() {
			buf1 =
 // ----- file 1 -----
				jEdit.openFile(v, "<file 1>");
			buf2 =
 // ----- file 2 -----
			jEdit.openFile(v, "<file 2>");
 // ----- suffix -----
			VFSManager.waitForRequests();
			editPanes = v.getEditPanes();
			editPanes[0].setBuffer(buf1);
			editPanes[1].setBuffer(buf2);
		}
		return this;
	}
	SwingUtilities.invokeLater(openDiffFiles(v));

*/

OpenDiffScript::OpenDiffScript()
	: ScriptWriter(), secondFile(false)
{
	InitBuffer(1024);
}

OpenDiffScript::~OpenDiffScript() {}

HRESULT OpenDiffScript::WritePrefix()
{
	ClearBuffer();
	Append("v = jEdit.getFirstView(); ");
	Append("if(jEdit.getPlugin(\"JDiffPlugin\") == null) { ");
	Append("Macros.error(v, \"You must have the JDiff plugin ");
	Append("installed to use this jEditLauncher feature.\"); return; } ");
	Append("if(DualDiff.isEnabledFor(v)) DualDiff.toggleFor(v); ");
	Append("while(v.getEditPanes().length > 1) v.unsplit(); ");
	Append("v.splitVertically(); ");
	Append("DualDiff.toggleFor(v); openDiffFiles(vv) { v = vv; run() { buf1 = ");
	return S_OK;
}


HRESULT OpenDiffScript::ProcessSinglePath(const char* pszPath)
{
	Append("jEdit.openFile(v, ");
	AppendPath(pszPath);
	Append("); ");
	if(!secondFile)
	{
		Append("buf2 = ");
		secondFile = true;
	}
	return S_OK;
}


HRESULT OpenDiffScript::WriteSuffix()
{
	Append("VFSManager.waitForRequests(); editPanes = v.getEditPanes(); ");
	Append("editPanes[0].setBuffer(buf1); ");
	Append("editPanes[1].setBuffer(buf2); } return this; } ");
	Append("SwingUtilities.invokeLater(openDiffFiles(v));");
	return S_OK;
}


// Implementation of class StartAppScript

StartAppScript::StartAppScript()
	: ScriptWriter(), bFirstFile(true)
{
	InitBuffer(2048);
}

StartAppScript::~StartAppScript() {}

HRESULT StartAppScript::WritePrefix()
{
	ClearBuffer();
	HKEY hKey;
	LONG nResult;
	TCHAR szExec[1024],
		  szExpanded[1024],
		  szTemp[MAX_PATH],
		  szKeyPath[MAX_PATH];
	const TCHAR space[2] = {_T(' '), 0};
	DWORD dwCount = MAX_PATH * sizeof(TCHAR);
	DWORD dwType = 0;
	LoadString(_Module.GetModuleInstance(), IDS_REG_PARAMS_KEY_3_2,
		szKeyPath, MAX_PATH);
	nResult = RegOpenKeyEx(HKEY_CURRENT_USER, szKeyPath, 0, KEY_READ, &hKey);
	if(nResult != ERROR_SUCCESS)
	{
		CJEditLauncher::MakeErrorInfo(IDS_ERR_NO_REGISTRY_KEY);
	}
	else
	{
		nResult = RegQueryValueEx(hKey, _T("Java Executable"), 0, &dwType, (LPBYTE)szExec, &dwCount);
		if(nResult != ERROR_SUCCESS)
		{
			CJEditLauncher::MakeErrorInfo(IDS_ERR_NO_JAVA_EXEC_VALUE);
		}
		else
		{
			dwCount = MAX_PATH;
			nResult = RegQueryValueEx(hKey, _T("Java Options"), 0, &dwType, (LPBYTE)szTemp, &dwCount);
		}
	}
	if(nResult == ERROR_SUCCESS)
	{
		if(*szTemp)
		{
			strcat(szExec, space);
			strcat(szExec, szTemp);
		}
		dwCount = MAX_PATH;
		nResult = RegQueryValueEx(hKey, _T("jEdit Target"), 0, &dwType, (LPBYTE)szTemp, &dwCount);
	}
	else
	{
		CJEditLauncher::MakeErrorInfo(IDS_ERR_NO_JEDIT_TARGET_VALUE);
	}
	if(nResult == ERROR_SUCCESS)
	{
		if(*szTemp)
		{
			strcat(szExec, space);
			strcat(szExec, szTemp);
		}
		dwCount = MAX_PATH;
		nResult = RegQueryValueEx(hKey, _T("jEdit Options"), 0, &dwType, (LPBYTE)szTemp, &dwCount);
	}
	if(nResult == ERROR_SUCCESS)
	{
		if(*szTemp)
		{
			strcat(szExec, space);
			strcat(szExec, szTemp);
		}
	}
	else
	{
		CJEditLauncher::MakeErrorInfo(IDS_ERR_NO_JEDIT_OPTIONS_VALUE);
	}

	RegCloseKey(hKey);
	if(nResult != ERROR_SUCCESS)
		return E_FAIL;

	ExpandEnvironmentStringsA(szExec, szExpanded, 1024);
	strcat(szExpanded, space);
	Append(szExpanded);

	return S_OK;
}



HRESULT StartAppScript::ProcessSinglePath(const char* pszPath)
{
	if(bFirstFile)
	{
		Append("-- ");
		bFirstFile = false;
	}
	AppendPath(pszPath);
	Append(" ");
	return S_OK;
}


HRESULT StartAppScript::WriteSuffix()
{
	bFirstFile = true;		// reset
	return S_OK;
}


// Implementation of class FileListScript

FileListScript::FileListScript()
	: ScriptWriter()
{
	InitBuffer(1024);
}

FileListScript::~FileListScript() {}

HRESULT FileListScript::WritePrefix()
{
	ClearBuffer();
	Append("-- ");
	return S_OK;
}


HRESULT FileListScript::ProcessSinglePath(const char* pszPath)
{
	AppendPath(pszPath);
	Append(" ");
	return S_OK;
}


HRESULT FileListScript::WriteSuffix()
{
	return S_OK;
}
