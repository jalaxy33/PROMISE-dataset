<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
   Copyright 2000-2004 The Apache Software Foundation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->

<document>
<properties>
<title>Guía del Usuario de Velocity</title>
<author email="jvanzyl@zenplex.com">Velocity Documentation Team</author>
<author email="jcastura@kw.igs.net">John Castura</author>
<author email="ju-moral@uniandes.edu.co">Juan Pablo Morales</author>
</properties>
<body>
	<section name="Tabla de Contenidos">

<ol>
	<li><a href="#Acerca de esta guía">Acerca de esta guía</a></li>
	<li><a href="#¿Qué es Velocity?">¿Qué es Velocity?</a></li>
	<li><a href="#¿Qué puede hacer Velocity por mi?">¿Qué puede hacer Velocity por mi?</a>
	<ol>
		<li><a href="#El Ejemplo de la tienda de Lodo">El Ejemplo de la tienda de
			Lodo</a></li>
	</ol>
</li>
<li><a href="#El Lenguaje de Plantillas de Velocity (VTL): Una Introducción">El Lenguaje de Plantillas de Velocity (VTL): Una Introducción</a></li>
<li><a href="#¡Hola Mundo Velocity!">¡Hola Mundo Velocity!</a></li>
<li><a href="#Comentarios">Comentarios</a></li>
<li><a href="#Referencias">Referencias</a>
	<ol>
		<li><a href="#Variables">Variables</a></li>
		<li><a href="#Propiedades">Propiedades</a></li>
		<li><a href="#Métodos">Métodos</a></li>
	</ol>
</li>
<li><a href="#Notación Formal de Referencias">Notación Formal de Referencias</a></li>
<li><a href="#Notación Sileciosa de Referencias">Notación Sileciosa de Referencias</a></li>
<li><a href="#Literalmente">Literalmente</a>
	<ol>
		<li><a href="#Dinero">Dinero</a></li>
		<li><a href="#Escapando Referencias VTL Válidas">Escapando Referencias VTL Válidas</a></li>
	</ol>
</li>
<li><a href="#Sustitución de Mayúsculas y Minúsculas">Sustitución de Mayúsculas y Minúsculas</a></li>
<li><a href="#Directivas">Directivas</a>
	<ol>
		<li><a href="#Set">Set</a></li>
		<li><a href="#Cadenas de Caracteres">Cadenas de Caracteres</a></li>
		<li><a href="#Sentencias If-Else">Sentencias If-Else</a>
			<ol>
				<li><a href="#Operadores Lógicos y Relacionales">Operadores Lógicos y Relacionales</a></li>
			</ol>
		</li>
		<li><a href="#Ciclos Foreach">Ciclos Foreach</a></li>
		<li><a href="#Include">Include</a></li>
		<li><a href="#Parse">Parse</a></li>
		<li><a href="#Stop">Stop</a></li>
		<li><a href="#Velocimacros">Velocimacros</a></li>
	</ol>
</li>
<li><a href="#Escapando Directivas VTL">Escapando Directivas VTL</a></li>
<li><a href="#VTL: Asuntos de Formato">VTL: Asuntos de Formato</a></li>
<li><a href="#Otras Características y Miscelánea">Otras Características y Miscelánea</a>
	<ol>
		<li><a href="#Matemáticas">Matemáticas</a></li>
		<li><a href="#El Operador de Rango">El Operador de Rango</a></li>
		<li><a href="#Temas Avanzados: Escapando y !">Temas Avanzados: Escapando y !</a></li>
		<li><a href="#Miscelánea de Velocimacro">Miscelánea de Velocimacro</a></li>
		<li><a href="#Concatenación de Cadenas">Concatenación de Cadenas</a></li>
	</ol>
</li>
<li><a href="#Retroalimentación">Retroalimentación</a></li>
</ol>
</section>
<section name="Acerca de esta guía">

<p>
La Guía del usuario de Velocity busca ayudar a los diseñadores de páginas y a
los proveedores de contenido a sentirse a gusto con Velocity y con la sintáxis
de su simple pero poderoso lenguaje de script, el Lenguaje de Plantillas de
Velocity (VTL por sus siglas en inglés).  Muchos de los ejemplos de esta guía
muestran como usar Velocity para incluir contenidos dinámicos en sitios web,
pero todos los ejemplos de VTL son igualmente aplicables a otras páginas y
plantillas.
</p>

<p>Gracias por escoger Velocity!</p>
</section>
<section name="¿Qué es Velocity?">
<p>
Velocity es un motor de plantillas basado en Java. Le permite a los diseñadores
de páginas hacer referencia a métodos definidos dentro del código Java. Los
diseñadores Web pueden trabajar en paralelo con los programadores Java para
desarrollar sitios de acuerdo al modelo de Modelo-Vista-Controlador (MVC),
permitiendo que los diseñadores se concentren únicamente en crear un sitio bien
diseñado y que los programadores se encarguen solamente de escribir código de
primera calidad. Velocity separa el código Java de las páginas Web, haciendo el
sitio más mantenible a largo plazo y presentando una alternativa viable a <a
	href="http://java.sun.com/products/jsp/">Java Server Pages</a> (JSP) o <a
	href="http://www.php.net">PHP</a>.
</p>

<p>
Velocity se puede utilizar para crear páginas web, SQL, PostScript y cualquier
otro tipo de salida de plantillas. Se puede utilizar como una aplicación
independiente para generar código fuente y reportes, o como un componente
integrado en otros sistemas. Cuando este completo Velocity proveerá servicios
para el conjunto de aplicaciones web de <a
	href="http://jakarta.apache.org/turbine">Turbine</a>.  Velocity+Turbine
proveerá un servicio de plantillas que facilitará el desarrollo de aplicaciones
web de acuerdo a un verdadero modelo MVC.
</p>
</section>
<section name="¿Qué puede hacer Velocity por mi?">
<subsection name="El Ejemplo de la tienda de Lodo">
<p>
Suponga que usted es un diseñador para una tienda en línea que se especializa
en vender lodo a la que llamaremos "La Tienda de Lodo en línea". Los negocios
están muy bien. Sus clientes ordenan diferentes tipos y cantidades de
lodo.
Ellos ingresan en su sitio con su nombre de usuario y su clave secreta, lo que
les permite ver sus órdenes y pedir más lodo. En estos momentos el Lodo
Terracota, que es muy popular, esta en oferta. Una minoría de sus clientes
usualmente compra Lodo Rojo Brillante, que también esta en oferta, pero no es
tan popular y usualmente esta relegado al márgen de su página web. La
información sobre cada cliente esta dentro de su base de datos por lo que surge
la pregunta: ¿Por qué no usar Velocity para enfocar las ofertas especiales para
los clientes que están más interesados en ciertas clases de lodo?
</p>

<p>
Velocity hace fácil el personalizar las páginas para sus visitantes.  Como un
diseñador dentro de "El Cuarto de Lodo", usted quiere crear la página que sus
usuarios verán después de entrar a su sitio.
</p>

<p>
Usted se encuentra con los ingenieros de su compañía, y todos acuerdan que
<em>$cliente</em> contendrá la información pertienente al cliente que está
dentro de la página en un momento dado, que <em>$lodosEnOferta</em> contendrá
todos los tipos de lodo que están en oferta hoy en día.  Además, el objeto
<em>$flogger</em> contendrá métodos para ayudar con la promoción. Para la tarea
actual, solo se utilizarán estas tres referencias. Recuerde, usted no necesita
preocuparse por como los ingenieros de software extraen la información
necesaria de la base de datos; sólo tiene que saber que funciona. Esto le
permite a usted continuar con su trabajo a la vez que deja a los ingenieros
hacer el de ellos.
</p>

<p>Usted podría incluir el siguiente código VTL dentro de su página:</p>

<source>
<![CDATA[
<HTML>
<BODY>
Hello $cliente.Nombre!
<table>
#foreach( $lodo in $lodosEnOferta )
#if ( $cliente.haComprado($lodo) )
<tr>
<td>
$flogger.obtenerPromocion( $lodo )
</td>
</tr>
#end
#end
</table>
]]>
</source>

<p>
Los detalles exactos de la sentencia <i>foreach</i> serán descritos en
profundidad próximamente; lo que es importante es el impacto que este pequeño
script pueda tener en su sitio.  Cuando un cliente con una debilidad por el
Lodo Rojo Brillante ingrese, si el Lodo Rojo Brillante esta en oferta, eso
será lo que el cliente verá, de manera prominente. Si otro cliente, con una
historia larga de compras de Lodo Terracota ingresa, entonces para él la
noticia de un rebaja de Lodo Terracota estará en un lugar muy importante. La
flexibilidad de Velocity es enorme y sólo esta limitada por su creatividad.
</p>

<p>
En la  referencia de VTL están documentados muchos otros elementos de Velocity
que, colectivamente le dan el poder y la flexibilidad que usted necesita para
hacer de su sitio en la red una <em>presencia</em> en la red. A medida que
usted se familiarice con estos elementos usted comenzará a aprovechar el poder
de Velocity.
</p>
</subsection>
</section>
<section name="El Lenguaje de Plantillas de Velocity (VTL): Una Introducción">
  <p>
  El Lenguaje de Plantillas de Velocity (VTL) fue creado para prover la
  manera mas fácil, simple y limpia de incorporar contenido dinámico
  dentro de una página web. Incluso un desarrollador de páginas web con
  poca y ninguna experiencia puede rápidamente ser capaz de utilizar VTL
  para incluir contenido dinámico en un sitio web.
 </p>

 <p>
 	VTL usa <em>referencias</em> para incluir contenido dinámico dentro
	de un sitio web. Una variable es un tipo de referencia que puede
	referirse a algo definido dentro del código Java o obtener su valor
	de un <em>enunciado</em> VTL en la página misma. A continuación hay
	un ejemplo de un enunciado VTL que se puede incluir en un documento
	HTML:
 </p>

<source><![CDATA[
#set( $a = "Velocity" )
]]></source>

  <p>
  	Este enunciado VTL, como todos los enunciados VTL comienza con el
	caracter <em>#</em> y contiene una directiva: <em>set</em>. Cuando
	un visitante solicita su página, el Motor de Plantillas de Velocity
	buscará dentro del contenido de su página y encontrará todos los
	símbolos <em>#</em>, para luego determinar cuáles marcan el comienzo
	de enunciados VTL y cuáles no tienen nada que ver con VTL.
 </p>

 <p>
 El caracter <em>#</em> viene seguido por una directiva <em>set</em>.
 La directiva <em>set</em> utiliza una expresión (encerrada entre
 paréntesis) -- una ecuación que asigna un <em>valor</em> a una
 <em>variable</em>.
 La variable se encuentra en el lado derecho y el valor está en el lado
 izquierdo; los dos se encuentran separados por un signo igual
 (<em>=</em>).
 </p>

 <p>
 En el ejemplo en la parte superior, la variable es <em>$a</em> y el
 valor es <em>Velocity</em>. Esta variable, al igual que todas las
 referencias, comienza con el caracter <em>$</em>. Los valores siempre
 se encuentran ente comillas; con Velocity no hay confusión acerca de
 los tipos de datos, ya que solamente cadenas (información basada en
 texto) pueden ser pasados a las variables.
 </p>

 <p>
 La siguiente regla puede ser útil para entender mejor como funciona
 Velocity: <strong>Las Referencias comienzan con <em>$</em> y se
	 utilizan para obtener algo. Las directivas comienzan con <em>#</em>
	 y se utilizan para hacer algo</strong>
 </p>

 <p>
 En el ejemplo anterior <em>#set</em> se utilizó para asignarle un valor
 a una variable. La variable, <em>$a</em>, puede utilizarse dentro de la
 plantilla para escribir la palabara "Velocity".
 </p>

</section>

<section name="¡Hola Mundo Velocity!">

  <p>
	Una vez un valor ha sido asignado a una variable, usted puede
	referenciar la variable en cualquier lugar dentro del documento
	HTML. En el ejemplo siguiente, un valor es asignado a la variable
	<em>$foo</em>, que luego es referenciada.
 </p>

<source><![CDATA[
<html>
<body>
#set( $foo = "Velocity" )
¡Hola Mundo $foo!
</body>
<html>
]]></source>

 <p>
 El resultado es una página web que imprime "¡Hola Mundo Velocity!"
 </p>

 <p>
 Para hacer los enunciados con directivas VTL más legibles, nosotros le
 recomendamos comenzar cada enunciado VTL en una nueva línea, aunque
 usted no esta obligado a hacerlo así. La directiva <em>set</em> ser
 verá con mayor detalle más adelante.
 </p>

</section>

<section name="Comentarios">

<p>
Los comentarios es posible incluir texto que no aparecerá como parte de
la salida del motor de plantillas. Los comentarios sirven para recordar
e indicar a otros que es lo que están haciendo los enunciados VTL, o
para cualquier otro propósito que usted considere útil. A continuación
hay un ejemplo de un comentario de VTL.
</p>

<source><![CDATA[
## Este es un comentario de una sola línea
]]></source>

<p>
	Un comentario de una sola línea comienza con <em>##</em> y termina
	al final de la línea. Si usted desea escribir varias líneas de
	comentario no es necesario tener numerosos comentarios de una sóla
	línea. Los comentarios de varias líneas, que comienzan con
	<em>#*</em> y terminan con <em>*#</em> le permiten manejar
	fácilmente esta situación.
 </p>

 <source><![CDATA[
 Este es un texto que esta fuera de un comentario de múltiples líneas.
 Los visitantes de su página lo pueden ver.

#*
 He aquí un comentario de varias líneas. Los visitantes
 de su sitio no verán esto, ya que el Motor de Plantillas
 de Velocity lo ignorará
*#

Aquí hay texto fuera del comentario, este si es visible.
]]></source>

 <p>
 	A continuación hay algunos ejemplos para aclarar como funcionan
	los comentarios de una y varias líneas:
 </p>

 <source><![CDATA[
Este texto es visible. ## Este no lo es
Este texto es visible.
Este texto es visible. #* Este texto, como parte de un comentario de
varias líneas, no es visible. Este texto no es visible; tambiés es parte
del comentario. Este texto aún no es visible. *# Este texto esta fuera
del comentario, por lo que es visible.
## Este texto no es visible.
]]></source>

<p>
	Existe un tercer tipo de comentario, el bloque de comentario VTL,
	que puede ser utilizado para almacenar datos como el autor y la
	información de versiones:
</p>

<source><![CDATA[
#**
Este es un bloque de comentario VTL y
puede utilizarse para almacenar datos
como el nombre del autor y la
información de versiones:
@author
@version 5
*#
]]></source>

</section>

<section name="Referencias">

<p>
	Existen tres tipos de referencias en VTL: variables, propiedades y
	métodos. Como un diseñador que utilizar VTL, usted y sus ingenieros
	deben llegar a un acuerdo respecto a los nombres de las referencias
	para que usted pueda utilizarlas correctamente en sus plantillas.
 </p>

 <p>
 	Todo lo que entra y sale de una referencia se trata como una cadena
	de caracteres (un objeto String). Si existe un objeto que representa
	<em>$foo</em> (por ejemplo, un objeto Integer), entonces Velocity
	llamará el método <code>.toString()</code> de ese objeto para
	convertirlo en una cadena de caracteres.
 </p>

 <p>
 <a name="Variables"><strong>Variables</strong></a>
 <br />
 	La notación breve de una variable esta compuesta por un signo "$"
	inicial seguido de un <em>Identificador</em>. Un identificador VTL
	debe comenzar con un caracter alfabético (a .. z ó A .. Z). El resto
	de los caracteres deb ser de alguno de los siguiente tipos:
 </p>

 <p>
   <ul>
     <li>alfabético (a .. z, A .. Z)</li>
	 <li>numérico (0 .. 9)</li>
	 <li>línea ("-")</li>
     <li>underscore ("_")</li>
   </ul>
 </p>

 <p>
 	A continuación hay algunos ejemplos de referencias válidas en VTL:
 </p>

<source><![CDATA[
$foo
$lanzaLodo
$lanza-lodo
$lanza_lodo
$lanzaLodo1
]]></source>

<p>
	Cuando VTL hace referencia una variable, po ejemplo, <em>$foo</em>,
	la variable puede obtener su valor de una directiva <em>set</em>
	dentro de la plantilla, o del código Java. Por ejemplo, si la
	variable de Java <em>$foo</em> tiene el valor <em>bar</em> en el
	momento en que se solicita la plantilla, entonces <em>bar</em>
	reemplaza todas las ocurrencias (o instancias) de <em>$foo</em>
	dentro de la página web. De manera alterna, si se incluye el
	enunciado
 </p>

<source><![CDATA[
#set( $foo = "bar" )
]]></source>

<p>
	La salida será la misma para todas las instancias de <em>$foo</em>
	que se encuentren a continuación es esta directiva.
 </p>

 <p>
 <a name="Propiedades"><strong>Propiedades</strong></a>
 <br />
 	El segundo sabor de referencias VTL son las propiedades; las
	propiedades tienen un formato particular. La versión corta se
	compone de un signo <em>$</em> seguido de un identificador VTL,
	seguido de un punto y de otro identificador VTL. A continuación hay
	ejemplos de referencias de propiedades válidas en VTL:
 </p>

<source><![CDATA[
$cliente.Direccion
$compra.Total
]]></source>

<p>
	Tome el primer ejemplo, <em>$cliente.Direccion</em>. Puede tener dos
	significados. Puede significar, Busque en la tabla de hashing
	identificada como <em>cliente</em> y devuelva el valor asociado con
	la llave <em>Direccion</em>. Pero <em>$customer.Address</em> puede
	también referirse a un método (las referencias que se relacionan con
	métodos se discutirán en la sección siguiente);
	<em>$customer.Address</em> puede ser una manera corta de escribir
	<em>$customer.getAddress()</em>. Cuando su página sea solicitada
	Velocity determinará cuál de las dos posibilidades tiene sentido, y
	luego devolverá el valor apropiado.
 </p>

 <p>
 <a name="Métodos"><strong>Methods</strong></a>
 <br />
 	Un método esta definido dentro del código de Java y es capaz de
	hacer algo útil, como desarrollar un cálculo o llegar a una
	decisión. Los métodos son referencias compuestas de un signo "$"
	inicial seguido en un identificador VTL, seguido de un <em>Cuerpo de
		Método</em> VTL. Un cuerpo de método VTL, a su vez esta formado
	por un identificador VTL seguido por un paréntesis izquierdo ("("),
	seguido, opcionalmente, por una lista de parámetros, para terminar
	en un paréntesis derecho. A continuación hay ejemplos de referencias
	de métodos válidas dentro de VTL:

 </p>

<source><![CDATA[
$cliente.getDireccion()
$compra.getTotal()
$pagina.setTitulo( "My Página Principal" )
$persona.establecerAtributos( ["Extraño", "Raro", "Excitado"] )
]]></source>

<p>
	Los primeros dos ejemplos -- <em>$cliente.getDireccion()</em> y
	<em>$compra.getTotal()</em> -- pueden parecer similares a aquellos
	utilizados en la sección de propiedades, <em>$cliente.Direccion</em>
	y <em>$compra.Total</em>. Si usted supuso que estos ejemplos están
	relacionados de alguna manera, usted esta en lo cierto.
 </p>

 <p>
 	Las Propiedades VTL pueden utilizarse como notación abreviada para
	los métodos de VTL. La propiedad <em>$cliente.Direccion</em> tiene
	exactamente el mismo efecto que el método
	<em>$cliente.getDireccion()</em> (Nótese el uso de la palabra
	inglesa <em>get</em> en lugar de la castellana <em>obtener</em>).
	Generalmente es preferible utilizar una Propiedad si esta
	disponible. La diferencia principal entre las propiedades y los
	métodos es que usted le puede dar una lista de parámetros a un
	Método.
 </p>

 <p>
 La notación breve se puede utilizar en los Métodos siguientes:
 </p>

<source><![CDATA[
$sol.getPlanetas()
$anhelido.getMugre()
$album.getFoto()
]]></source>

<p>
	Podríamos esperar que estos métodos devolvieran los nombres de los
	planetas que giran alrededor del sol, alimentaran un gusano de
	tierra y extrajeran una foro de un album. Los siguientes Métodos
	solo se pueden referenciar por medio de la notación larga:
 </p>

<source><![CDATA[
$sol.getPlaneta( ["Tierra", "Marte", "Neptuno"] )
## No es posible pasar una lista de parámetros con $sun.Planets

$sisifo.empujarPiedra()
## Si dijera $sisifo.piedra Velocity asumiría $sisifo.pushPiedra()

$libro.setTitulo( "Homenaje a Colombia" )
## No se puede pasar un parámetro en la notación abreviada.
]]></source>

 <p>
 <a name="Notación Formal de Referencias"><strong>Notación Formal de
		 Referncias</strong></a>
 <br />
 La notación abreviada para referencias fue utilizada en los ejemplos
 anteriores, pero también existe una notación formal para referencias,
 que se demuestra a continuación:
 </p>

<source><![CDATA[
${lanzaLodo}
${cliente.Direccion}
${compra.getTotal()}
]]></source>

<p>
Casi en todos los casos usted utilizará la notación abreviada, pero
existen escenarios en los cuales la notación formal se requiere para
procesar corectamente la plantilla.
 </p>

 <p>
 Suponga que usted estuviera creando una frase en la que <em>$vicio</em>
 se utilizará como prefijo para el ajetivo de una clase. La idea es
 permitir a alguién escoger la palabra base para producir uno de los dos
 siguientes resultados: "Juan es un pirómano." ó "Juan es un
 cleptómano.". En este caso la notación abreviada no es apropiada;
 considere el siguiente ejemplo:
 </p>

<source><![CDATA[
Juan is a $viciomano.
]]></source>

<p>
Hay ambigüedad aquí, y Velocity asume que <em>$viciomano</em>, no
<em>$vicio</em>, es el Identificador que usted quería utilizar. Al no
encontrar ningún valor para <em>$viciomano</em> Velocity escribirá
simplemente <em>$viciomano</em>. Este problema se resueklve usando
notación formal.
 </p>

<source><![CDATA[
Juan es un ${vicio}mano.
]]></source>

<p>
	Ahora Velocity save que la referencia es <em>$vicio</em> y no
	<em>$viciomano</em>. La notación formal es útil cuando las
	referencias están ubicadas directamente al lado del texto dentro de
	una plantilla.
 </p>


 <p>
 <a name="Notación Sileciosa de Referencias"><strong>Notación de Referenias
		 Silenciosas</strong></a>
 <br />
 	Cuando Velocity encuentra una referencia indefinida, su
	comportamiento normal es es de escribir el nombre de la referencia.
	Por ejemplo, suponga que la siguiente referencia aparece como parte
	de una plantilla VTL.
 </p>

<source><![CDATA[
<input type="text" name="correo" value="$correo"/>
]]></source>

	<p>
	Cuando el formulario se carga por primera vez la referencia
	<em>$correo</em> no tiene valor, pero usted probablemente preferiría
	un texto en blanco a uno con el valor de "$correo". Usando la
	notación de referencias silenciosa se pasa por alto el
	comportamiento normal de Velocity. Para lograr eso en lugar de
	<em>$correo</em> en el VTL usted utilizaría <em>$!correo</em>. Con
	esta modificación el ejemplo anterior quedaría así:
 </p>

<source><![CDATA[
<input type="text" name="correo" value="$!correo"/>
]]></source>

<p>
	Ahora cuando el formulario se carga por primera vez y $correo no
	tenga valor una cadena vacía se escribirá en lugar de "$correo".
 </p>

 <p>
 	La notación formal y la silenciosa se puede usar juntas como se
	muestra en el ejemplo siguiente:
 </p>

<source><![CDATA[
<input type="text" name="correo" value="$!{correo}"/>
]]></source>

</section>

<section name="Literalmente">

  <p>
  VTL hace uso de caracteres especiales, como <em>$</em> y <em>#</em>,
  para hacer su trabajo por lo que se debe tener algo de cuidado en el
  momento de utilizar estos caracteres dentro de las plantillas. Esta
  sección habla de como escapar el caracter <em>$</em>.
  </p>

  <p>
    <a name="Dinero"><strong>Dinero</strong></a>
	<br />
	No hay ningún problema en escribir "Yo compré un saco de maíz de
	2 kg. en el mercado de lagranja por sólo $2.50!". Como se mencionó
	anteriormente, un identificador VTL siempre comienza con una letra
	mayúscula o minúscula por lo que $2.50 no se confunde con una
	referencia.
  </p>

  <p>
  <a name="Escapando Referencias VTL Válidas"><strong>Escapando Referencias
		  VTL Válidas</strong></a>
  <br />
  Pueden existir casos en donde haya la posibilidad de que Velocity se
  confunda. <em>Escapar</em> caracteres especiales es la mejor manera de
  manejar los caracteres partículares de VTL dentro de sus plantillas, y
  esto se puede hacer utilizando el caracter palote o backslash (
  <em>\</em> ).
  </p>

<source><![CDATA[
#set( $correo = "foo" )
$correo
]]></source>

<p>
	Si Velocity encuentra una referencia en su plantilla VTL a
	<em>$correo</em>, el buscará el contexto ppor un valor
	correspondiente. En este caso el resultado será <em>foo</em> por
	qué <em>$correo</em> esta definido. Si <em>$correo</em> no esta
	definido el resultado será <em>$correo</em>.
  </p>

  <p>
  	Suponga que <em>$correo</em> está definido (por ejemplo, que tiene
	el valor <em>foo</em>) y que usted desea escribir <em>$correo</em>.
	Existen varias maneras de hacer esto pero la más sencilla es usar el
	caracter de escape.
  </p>

<source><![CDATA[
## La siguiente línea define $correo en esta plantilla:
#set( $correo = "foo" )
$correo
\$correo
\\$correo
\\\$correo
]]></source>

  <p>
     se muestra como
  </p>

<source><![CDATA[
foo
$correo
\foo
\$correo
]]></source>

  <p>
  Note que el caracter <em>\</em> se asocia con <em>$</em> por la
  izquierda. La regla de asociación por la izquierda hace que
  <em>\\\$correo</em> se muestre como <em>\\$correo</em>. Compare estos
  ejemplos con lo siguientes, en los que <em>$correo</em> no esta
  definido.
  </p>

<source><![CDATA[
$correo
\$correo
\\$correo
\\\$correo
]]></source>

  <p>
  se muestra como
  </p>

<source><![CDATA[
$correo
\$correo
\\$correo
\\\$correo
]]></source>

<p>
	Note que Velocity maneja de manera diferentes las referencias que
	están definidas de aquellas que no lo están. A continuación se
	encuentra una directiva que da a <em>$foo</em> el valor
	<em>verde</em>.
  </p>

<source><![CDATA[
#set( $foo = "verde" )
$luna = $foo
]]></source>

<p>
La salida será: <em>$luna = verde</em> -- donde <em>$luna</em> se
escribe literalmente porqué esta indefinido y <em>verde</em> se escribe
en lugar de <em>$foo</em>
  </p>


  <p>
  	También es posible escapar directivas de VTL; esto se describe con
	más detalle en la sección de Directivas.
  </p>

</section>

<section name="Sustitución de Mayúsculas y Minúsculas">

<p>
Ahora que usted esta familiarizado con las referencias, puede comenzar a
aplicarlas de manera efectiva en sus plantillas. Las referencias de
Velocity aprovechan algunos principios de Java que los diseñadores de
plantillas encontraránm fáciles de utilizar. Por ejemplo:
    </p>

<source><![CDATA[
$foo

$foo.getBar()
## el lo mismo que
$foo.Bar

$data.getUser("jon")
## es lo mismo que
$data.User("jon")

$data.getRequest().getServerName()
## es lo mismo que
$data.Request.ServerName
## que a su vez, es igual a
${data.Request.ServerName}
]]></source>

<p>
Estos ejemplos ilustran usos alternativos para la mismas referencias.
Velocity se aprovechas de la instrospección y las capacidades de beans
de Java para resolver los nombre de referencias tanto en el Contexto
como en los métodos de los objetos. Es posible incluir y evaluar
referencias casi en cualquier lugar de su plantilla.
    </p>

    <p>
	Velocity, que ha sido modelado con las especificaciones de Bean
	definidas por Sun Microsystems, distingue entre mayúsculas y
	minúsculas; sin embargo sus desarrolladores se han esforzado para
	encontrar y corregir los errores del usuario cuando sea posible.
	Cuando el método <em>getFoo()</em> es referenciado dentro de una
	plantilla como <code>$bar.foo</code>, Velocity intentará primero
	<code>getfoo()</code>. Si esto falla, intentará <code>getFoo()</code>.
	De la misma manera, cuando una plantilla se refiera a
	<code>$bar.Foo</code>, Velocity intentará <em>$getFoo()</em> primero
	y luego <em>getfoo()</em>.
    </p>

    <p>
	Nota: <em>Las Referencias a variables de instancia dentro de una
		plantilla no se resuelven.</em> Solo las referencias a los
	atributos get y set de los JavaBeans se resuelven (i.e.
	<code>$foo.Nombre</code> se resuelve como el método de instancia
	<code>getNombre()</code> de la clase Foo, pero no como su variable
	de instancia <code>Nombre</code>).
    </p>

</section>


<section name="Directivas">

<p>
	Las Referencias le permiten a los diseñadores de plantillas generar
	contenido dinámico para sitios web, mientras que las
	<em>directivas</em> -- elementos de script fáciles de usar que se
	pueden usar para manipular de manera creativa la salida del código
	Java -- les permiten a los diseñadores realmente estar a cargo de la
	apariencia y en contenido del sitio web.
 </p>

 <a name="Set"><strong>#set</strong></a>
 <p>
 La directiva <em>#set</em> se utiliza para establecer el valor de una
 referencia. El valor se puede asignar a una referencia de variable o
 una referencia de propiedad, siempre entre paréntesis, como se muestra
 a continuación:
 </p>

<source><![CDATA[
#set( $primate = "mono" )
#set( $cliente.Comportamiento = $primate )
]]></source>

<p>
	El lado izquierdo (LI) de la asignación debe ser una referencia de
	variable o una referencia de propiedad. El lado derecho (LD) puede
	ser de alguno de los siguientes tipos:
 </p>

 <p>
    <ul>
		<li>Referencia de Variable</li>
		<li>Constante de Cadena</li>
		<li>Referencia de Propiedad</li>
		<li>Referencia de Método</li>
        <li>Literal Numérico</li>
		<li>Lista de elementos como arreglo</li>
    </ul>
 </p>

 <p>
    These examples demonstrate each of the aforementioned types:
 </p>

<source><![CDATA[
#set( $mono = $pedro ) ## Referencia de Variable
#set( $mono.Amigo = "monica" ) ## Constante de Cadena
#set( $mono.Culpar = $casablanca.Fuga ) ## referencia de propiedad
#set( $mono.Plan = $doctor.llamar($web) ) ## referencia de método
#set( $mono.Numero = 123 ) ##Literal Numérico
#set( $mono.Decir = ["No", "es", $mi, "culpa"] ) ##Arreglo
]]></source>

 <p>
 NOTA: En el último ejemplo los elementos definidos con el operador
 [..] son accesibles usando los métodos definidos en la clase ArrayList.
 Así, por ejemplo, usted podría acceder el primer elemento del arreglo utilizando $mono.Decir.get(0), con lo que obtendría la palabra "No".
 </p>


 <p>
 El lado derecho también puede ser una expresión aritmética sencilla:
 </p>

<source><![CDATA[
#set( $value = $foo + 1 )
#set( $value = $bar - 1 )
#set( $value = $foo * $bar )
#set( $value = $foo / $bar )
]]></source>

<p>
	Si el Lado Derecho es una propiedad o referencia de método que se
	evalúa como <em>null</em>, <b>no</b> será asignada al lado
	izquierdo. No es posible remover una referencia existente del
	contexto utilizando este mecanismo. Esto puede ser confuso para los
	recién llegados a Velocity. Por ejemplo:
 </p>

<source><![CDATA[
#set( $resultado = $consulta.criterio("nombre") )
El resultado de la primera consulta en $resultado

#set( $resultado = $consulta.criterio("direccion") )
El resultado de la segunda consulta es $resultado
]]></source>

<p>
	Si <em>$consulta.criterio("nombre")</em> retorna la cadena "pedro",
	y <em>$consulta.criterio("direccion")</em> retorna <em>null</em>, el
	VTL anterio se mostraría de la siguiente manera:
 </p>

<source><![CDATA[
El resultado de la primera consulta en pedro

El resultado de la primera consulta en pedro
]]></source>

<p>
	Esto tiende a confundir a quines están comenzando, que construyen
	ciclos <em>#foreach</em> que intentan hacer <em>#set</em> de una
	referencia por medio de una propiedad o un método e inmediatamente
	evalúan la referencia con una directiva <em>#if</em>. Por ejemplo:
 </p>

<source><![CDATA[

#set( $criterios = ["nombre", "direccion"] )

#foreach( $criterio in $criterios )

    #set( $resultado = $consulta.criterios($criterio) )

    #if( $result )
	La consulta tuvo éxito
    #end

#end
]]></source>

<p>
	En el ejemplo anterior, no sería inteligente confiar en la
	evaluación de <em>$resultado</em> para determinar si una consulta
	tuvo éxito. Después de que <em>$result</em> ha sido agregado al
	contexto (por medio de una directiva <em>#set</em>), no puede volver
	a establecerse a <em>null</em> (quitarse del contexto). Los detalles
	de las directivas <em>#if</em> y <em>#foreach</em> son cubiertos con
	mayor detalle posteriormente en esta guía.
 </p>

 <p>
 	Una solución para este problema puede ser predefinir
	<em>$resultado</em> a <em>false</em>. Luego, si la llamada a
	<em>$consulta.criterios()</em> falla, es posible verificar.
 </p>


<source><![CDATA[

#set( $criterios = ["nombre", "direccion"] )

#foreach( $criterio in $criterios )

    #set( $resultado = false )
    #set( $resultado = $consulta.criterios($criterio) )

    #if( $resultado )
		La consulta tuvo éxito
    #end

#end
]]></source>

<p>
	A diferencia de algunas de las otras directivas de Velocity, la
	directiva <em>#set</em> no tiene un enunciado <em>#end</em>.
 </p>

 <a name="Cadenas de Caracteres"><strong>Cadenas de Caracteres</strong></a>

 <p>
 	Cuando se utiliza la directiva <em>#set</em>, los literales de
	cadena que están encerrados en comillas dobles serán evaluados y
	mostrados en la plantilla, como se demuestra a continuación:
 </p>

<source><![CDATA[
#set( $directorioRaiz = "www" )
#set( $nombrePlantilla = "indice.vm" )
#set( $plantilla = "$directorioRaiz/$nombrePlantilla" )
$plantilla
]]></source>

 <p>
 La salida será:
 </p>

<source><![CDATA[
www/indice.vm
]]></source>

<p>
	Sin embargo, cuando la cadena de caracteres esta encerrada en
	comillas sencillas, no será evaluada:
 </p>

<source><![CDATA[
#set( $foo = "bar" )
$foo
#set( $blarg = '$foo' )
$blarg
]]></source>

<p>Se muestra como:</p>

<source><![CDATA[
  bar
  $foo
]]></source>

<p>
	Por defecto, la característica de las comillas sencillas para
	mostrar texto sin evaluar esta disponible en Velocity; sin embargo
	este valor por defecto se puede cambiar editando el archivo
	<code>velocity.properties</code> de tal manera que
    <code>stringliterals.interpolate=false</code>.
 </p>
</section>


<section name="Sentencias If-Else">

<strong>Condicionales</strong>
<p>
	La directiva <em>#if</em> en Velocity permite que se incluya texto
	dentro de la plantilla generada, con la condición de que el
	enunciado condicional evalue a verdadero. Por ejemplo:
</p>

<source><![CDATA[
#if( $foo )
   <strong>Velocity!</strong>
#end
]]></source>

<p>
	La variable <em>$foo</em> se evalúa para determinar si es verdadera,
	cosa que ocurrirá bajo una de dos circunstancias: (i) <em>$foo</em>
	es un valor booleano (verdadero ó falso) que tiene un valor de
	verdadero, ó (ii) el valor no es <em>null</em>. Recuerde que el
	contexto de Velocity solamente contiene objetos, por lo que cuando
	se dice 'booleano' se habla en realidad de la clase Boolean. Esto es
	cierto incluso para los métodos que devuelven un valor de tipo
	<code>boolean</code> - la infraestructura de introspección devolverá
	un <code>Boolean</code> del mismo valor lógico.
</p>

<p>
	El contenido que se encuentra entre el enunciado <em>#if</em> y el
	enunciado <em>#end</em> es lo que se escribe en la plantilla si la
	evaluación resulta en un valor verdadero. En este caso, si
	<em>$foo</em> es verdadero, la salida será: "Velocity!". De manera
	análoga, si <em>$foo</em> tiene un valor <em>null</em>, o evalua a
	falso, entonces el enunciado completo es falso y no se escribe nada.
</p>

<p>
	Un elemento <em>#elseif</em> ó <em>#else</em> puede utilizarse junto
	con una sentencia <em>#if</em> para indicar condiciones adicionales
	o la labor por defecto. Note que el Motor de Plantillas de Velocity
	parará en la primera expresión que evalue a verdadero. En el ejemplo
	siguiente suponga que <em>$foo</em> tiene un valor de 15 y
	<em>$bar</em> tiene un valor de 6.
</p>

<source><![CDATA[
#if( $foo < 10 )
	<strong>Vaya hacía el Norte</strong>
#elseif( $foo == 10 )
    <strong>Vaya hacía el Este</strong>
#elseif( $bar == 6 )
	<strong>Vaya al Sur</strong>
#else
    <strong>Vaya al Oeste</strong>
#end
]]></source>

	<p>En este ejemplo, <em>$foo</em> es mayor que diez, por lo que las
	dos primeras comparaciones fallan. A continuación se compara
	<em>$bar</em> con 6, como son iguales, la salida es <strong>Vaya al
		Sur</strong>
    </p>

	<p>
	Actualmente las comparaciones numéricas de Velocity están
	restringidas a los elementos de la clase Integer - cualquier otra
	cosa evaluará a <em>falso</em>. La única excepción a esta regla es
	la igualdad, '==', donde Velocity exige que los objetos a cada lado
	del '==' sean de la <em>misma</em> clase.
    </p>

    <p>
	<a name="Operadores Lógicos y Relacionales"><strong>Operadores
			Lógicos y Relacionales</strong></a>
    </p>

	<p>
	Velocity usa el operador de equivalencia para determinar las
	relaciones entre las variables. A continuación hay un ejemplo
	sencillo para ilustrar como se utiliza el operador de igualdad.
    </p>

<source><![CDATA[
#set ($foo = "ácido desoxiribonucleico")
#set ($bar = "ácido ribonucleico")

#if ($foo == $bar)
	En este caso es claro que no son equivalentes por lo que....
  In this case it's clear they aren't equivalent. So...
#else
	No son equivalentes y esta será la salida.
#end
]]></source>

<p>
	Velocity tiene también operadores lógicos para el Y, el O y el NO
	(AND, OR y NOT). Para mayor información vea la <a
		href="vtl-reference-guide.html">Guía de Referencia VTL</a>.
	A continuación se encuentran ejemplos que demuestran la utilización
	de los operadores lógicos AND, OR y NOT.
    </p>

<source><![CDATA[

## Y lógico

#if( $foo && $bar )
	<strong>Esto Y aquello</strong>
#end

]]></source>

    <p>
	La directiva <em>#if()</em> solamente evaluará a verdadero si tanto
	<em>$foo</em> como <em>$bar</em> son ciertos. Si <em>$foo</em> es
	falso la expresión evaluará a falso; <em>$bar</em> no será evaluada.
	Si <em>$foo</em> es verdadero el Motor de Plantillas de Velocity
	verificará el valor de <em>$bar</em>; si <em>$bar</em> es cierto,
	entonces toda la expresión es cierto y la salida es <strong>Esto Y
		aquello</strong>. Si <em>$bar</em> es falso, entonces no habrá
	ninguna salida porque toda la expresión es falsa.
    </p>

	<p>
	El O lógico trabaja de la misma manera, pero sólo una de las
	referencias debe evaluar a verdadero para que toda la expresión
	evalue a verdadero. Considere el ejemplo siguiente.
    </p>

<source><![CDATA[

## O lógico

#if( $foo || $bar )
    <strong>Esto O Aquello</strong>
#end
]]></source>

    <p>
	Si <em>$foo</em> es verdadero, el Motor de Plantillas de Velocity no
	necesita consultar <em>$bar,</em>; sin importar si <em>$bar</em> es
	cierto o falso, la expresión será cierta, y <strong>Esto O
		Aquello</strong> será la salida. Si <em>$foo</em> es falso, en
	cambio, es necesario verificar <em>$bar</em>. En este caso, si
	<em>$bar</em> es falso, entonces la expresión es falsa y no se
	escribe nada. De otro lado, si <em>$bar</em> es verdadero, entonces
	toda la expresión es verdadera y el resultado es <strong>Esto O
		Aquello</strong>
    </p>

	<p>
	Con el operador lógico NO, solo hay un argumento :
    </p>

<source><![CDATA[

## NO lógico

#if( !$foo )
<strong>eso NO</strong>
#end

]]></source>

<p>
	Aquí si <em>$foo</em> es cierto, entonces <em>!$foo</em> es falso, y
	no se escribe nada. Por el contrario, si <em>$foo</em> es falso,
	entonces <em>!$foo</em> será verdadero y <strong>eso NO</strong>
	será escrito. Tenga cuidado de no confundir este operador con la
	<em>referencia sileciosa $!foo</em>, que es algo completamente
	distinto.
    </p>


 </section>

<section name="Ciclos Foreach">

   <strong>Ciclo Foreach</strong>

   <p>
   	El elemento <em>#foreach</em> permite la construcción de ciclos. Por
	ejemplo:
    </p>

<source><![CDATA[
<ul>
#foreach( $producto in $todosProductos )
    <li>$producto</li>
#end
</ul>
]]></source>

<p>
	Este cilco <em>#foreach</em> hace que el objeto correspondiente a la
	lista de $todosProductos sea iterado buscando todos los productos de
	la lista. En cada iteración del ciclo, el valor de
	<em>$todosProductos</em> se asigna a la variable <em>$producto</em>.
    </p>

	<p>
	El contenido de la variable <em>$todosProductos</em> es un Vector,
	una tabla de Hashing (Hashtable) o un arreglo (Array). El valor
	asignado a la variable <em>$producto</em> es un objeto Java y se
	puede referenciar desde una variabkle como tal. Por ejemplo, si
	<em>$product</em> fuera realmente un elemento de la clase Producto
	en Java, su nombre se podría obtener referenciando el método
	<em>$producto.Nombre</em> (ie: <em>$Product.getName()</em>).
    </p>

	<p>
	Ahora supongamos que <em>$todosProductos</em> es una tabla de
	Hashing. Si usted quisiera recuperar los valores de las llaves de la
	tabla de Hashing, al igual que los objetos dentro de esta, usted
	podría utilizar código como el siguiente:
    </p>

<source><![CDATA[
<ul>
	#foreach( $llave in $todosProductos.keySet() )
	<li>Llave: $llave -> Valor: $todosProductos.get($llave)</li>
#end
</ul>
]]></source>

<p>
	Velocity proporciona una manera sencilla de obtener el contador del
	ciclo para que usted pueda hacer algo como lo siguiente:
</p>

<source><![CDATA[
<table>
	#foreach( $cliente in $listaClientes )
    <tr><td>$velocityCount</td><td>$cliente.Nombre</td></tr>
#end
</table>
]]></source>

<p>
	El nombre por defecto para la referencia de la variable contador del
	ciclo, que se especifica en el archivo
	<code>velocity.properties</code>, es
	$velocityCount. Por defecto el contador comienza en 1, pero esto se
	puede hacer 0 o 1 en el archivo <code>velocity.properties</code>. A
	continuación se muestra el fragmento de este archivo que corresponde
	al contador de ciclo (en inglés, tal como aparece en el archivo
	original):
    </p>

<source><![CDATA[
# Default name of the loop counter
# variable reference.
directive.foreach.counter.nombre = velocityCount

# Default starting value of the loop
# counter variable reference.
directive.foreach.counter.initial.value = 1
]]></source>

 </section>

<section name="Include">

	<p>
	El elemento de script <em>#include</em> le permite al diseñador de
	plantillas importar un archivo local, que después es insertado en la
	localización donde se encuentra la sentencia <em>#include</em>. Los
	contenidos del archivo no se muestran por intermedio del motor de
	plantillas por lo que si se hacen referencias dentro del archivo,
	estas no serán reemplazadas. Por motivos de seguridad el archivo que
	va a ser incluido debe encontrarse en el directorio indicado por la
	propiedad TEMPLATE_ROOT.
    </p>

<source><![CDATA[
#include( "uno.txt" )
]]></source>

<p>
	El archivo al que se refiere la directiva <em>#include</em> se
	encierra entre comillas. Si mas de un archivo será incluido, los
	nombres de los archivos a incluir deben ir separados por comas.
    </p>

<source><![CDATA[
#include( "uno.gif","dos.txt","tres.htm" )
]]></source>

<p>
	El archivo a incluir no tiene que ser referenciado por nombre, de
	hecho, muchas veces es preferible usar una variable, en lugar de un
	nombre de archivo. Esto puede ser útil para dirigir la salida de
	acuerdo a criterios determinados cuando la solicitud de la página es
	enviada, es decir, que dependa de factores como los datos del
	usuario que visita la página, el momento del día, etc. A
	continuación se muestra un ejemplo en el que se usan tanto un nombre
	como una variable.
    </p>

<source><![CDATA[
#include( "greetings.txt", $seasonalstock )
]]></source>

 </section>

<section name="Parse">

<p>
	El elemento de script <em>#parse</em> le permite al diseñadore de
	plantillas importar un archivo local que contiene VTL. Velocity
	procesará el VTL y mostrará la plantilla especificada.
</p>

<source><![CDATA[
#parse( "yo.vm" )
]]></source>

<p>
	Al igual que la directiva <em>#include</em>, <em>#parse</em> puede
	utilizar una variable, en lugar de una plantilla. Todas las
	plantillas a las que <em>#parse</em> se refiera deben incluirse bajo
	TEMPLATE_ROOT. A diferencia de la directva <em>#include</em>,
	<em>#parse</em> solo recibe un argumento.
</p>

<p>
	Las plantillas de VTL puede tener sentencias <em>#parse</em> que se
	refieran a plantillas que a su vez tengan sentencias
	<em>#parse</em>. La línea <em>parse_directive.maxdepth</em> del
	archivo <code>velocity.properties</code>, cuyo valor por defecto es
	10, permite a los usuarios configurar el máximo número de
	referencias a <em>#parse</em> que pueden ocurrir desde una única
	plantilla. (Nota: Si la propiedad <em>parse_directive.maxdepth</em>
	no esta dentro del archivo <code>velocity.properties</code>,
	Velocity establecerá el valor por defecto en 10.) La recursión esta
	permitida, por ejemplo, si la plantilla <code>hacerfoo.vm</code>
	contiene las siguientes líneas:
    </p>

<source><![CDATA[
Cuenta Regresiva.
#set( $cuenta = 8 )
#parse( "parsefoo.vm" )
Listo hacerfoo.vm!
]]></source>

<p>
	Hay una referencia a la plantilla <code>parsefoo.vm</code>, que
	contiene el siguiente código VTL:
</p>

<source><![CDATA[
$cuenta
#set( $cuenta = $cuenta - 1 )
#if( $cuenta > 0 )
    #parse( "parsefoo.vm" )
#else
    Listo parsefoo.vm!
#end
]]></source>

<p>
	Después de que se muestra "Cuenta Regresiva.", Velocity pasa por
	<code>parsefoo.vm</code>, contando hacía abajo desde 8. Cuando el
	conteo llegue a 0, mostrará el mensaje "Listo parsefoo.vm!". En este
	punto Velocity volverá a <code>dofoo.vm</code> y escribirá el
	mensaje "Listo hacerfoo.vm!".
    </p>

 </section>


<section name="Stop">

<p>
El elemento de script <em>#stop</em> permite al diseñador parar la
ejecución del motor de plantillas y volver. Esto es útil para propósitos
de corrección de errores.
</p>

<source><![CDATA[
#stop
]]></source>
 </section>

<section name="Velocimacros">

    <p>
	El elemento de script <em>#macro</em> script permite definir un
	segmento de plantilla VTL repetitivo. Los Velocimacros son muy
	útiles en una amplia gama se situaciones, tanto simples como
	complejas. El siguiente Velocimacro, creado con el único propósito
	de ahorrar tecleo y minimizar errores tipográficos, provee una
	introducción al concepto de Velocimacros
	element allows template designers to.
    </p>

<source><![CDATA[
#macro( d )
<tr><td></td></tr>
#end
]]></source>

<p>
	El Velocimacro que se define en este ejemplo es <em>d</em>, y se
	puede llamar de manera similar a cualquier otra directiva VTL:
    </p>

<source><![CDATA[
#d()
]]></source>

<p>
Cuando esta plantilla sea solicitada, Velocity reemplazará <em>#d()</em>
por una fila conteniendo un única celda vacia.
</p>

<p>
Un Velocimacro puiede tomar cualquier número de argumentos -- no tener
ningún argumento, como se mostró en el primer ejemplo, es una opción --
pero cuando sea invocado el Velocimacro debe ser llamado con el mismo
número de argumentos con el que fue definido. Muchos Velocimacros se
relacionan con el entorno mucho más con su entorno que el ejemplo
demostrado anteriormente. Aquí hay un Velocimacro que recibe dos
argumentos, un color y un arreglo.
</p>

<source><![CDATA[
#macro( filastabla $color $algunalista )
#foreach( $algo in $algunalista )
    <tr><td bgcolor=$color>$algo</td></tr>
#end
#end
]]></source>

<p>
El Velocimacro que se define en este ejemplo, <em>filastabla</em>, toma
dos argumentos. El primer argumento toma el lugar de <em>$color</em>, y
el segundo argumento el de <em>$algunalista</em>
    </p>

	<p>
Cualquier cosa que se pueda incluir dentro de una plantilla VTL puede
formar parte delcuerpo de un Velocimacro. El Velocimacro
<em>filastabla</em> es una sentencia <em>foreach</em>. Hay dos
sentencias <em>#end</em> dentro del Velocimacro; la primera pertenece al
<em>foreach</em> y a segunda termina la definición del Velocimacro.
    </p>

<source><![CDATA[
#set( $grandeslagos = ["Superior","Michigan","Huron","Erie","Ontario"] )
#set( $color = "blue" )
<table>
	#filastabla( $color $grandeslagos )
</table>
]]></source>

    <p>
	Note que <em>$grandeslagos</em> toma el lugar de
	<em>$algunalista</em>. Cuando el Velocimacro es llamado en esta
	situación, la siguiente salida es generada:
    </p>

<source><![CDATA[
<table>
    <tr><td bgcolor="blue">Superior</td></tr>
    <tr><td bgcolor="blue">Michigan</td></tr>
    <tr><td bgcolor="blue">Huron</td></tr>
    <tr><td bgcolor="blue">Erie</td></tr>
    <tr><td bgcolor="blue">Ontario</td></tr>
</table>
]]></source>

<p>
Los Velocimacro pueden ser definidos <em>inline</em> dentro de una
plantilla. Esto quiere decir que la definición del macro no esta
disponible para otras plantillas dentro del mimso sitio Web. Definir un
Velocimacro de tal forma que sea compartido por todas las plantillas
tiene ventajas obvias: Reduce la necesidad de redefinir el macro en
varias plantillas, ahorrando trabajo y disminuyendo las posiblidades de
error, además de asegurar que un único cambio en un archivo quedará
disponible para todas las plantillas.
</p>

<p>
Si el Velocimacro <em>#filastabla($color $lista)</em> fuera definido en
una librería, se podría utilizar en cualquiera de la plantillas
normales; se podría utilizar muchas veces con propósitos distintos. En
la plantilla <code>vegetal.vm</code> dedicado a todas las plantas, el
Velocimacro <em>#filastabla</em> podría invocarse para listar las partes
de un vegetal típico:
    </p>

<source><![CDATA[
#set( $partes = ["raíz","tallo","hojas","flores","frutos"] )
#set( $colorCelda = "#CC00FF" )
<table>
	#filastabla( $colorCelda $parts )
</table>
]]></source>

<p>
Cuando atendiera ls solicitud de <code>vegetal.vm</code>, Velocity
encontraría el macro <em>#filastabla</em> en la librería de plantillas
(definida en el archivo <code>velocity.properties</code>) y generaría el
siguiente resultado:
    </p>

<source><![CDATA[
<table>
    <tr><td bgcolor="#CC00FF">raíz</td></tr>
    <tr><td bgcolor="#CC00FF">tallo</td></tr>
    <tr><td bgcolor="#CC00FF">hojas</td></tr>
    <tr><td bgcolor="#CC00FF">flores</td></tr>
    <tr><td bgcolor="#CC00FF">frutos</td></tr>
</table>
]]></source>

<strong>Argumentos de un Velocimacro</strong>

<p>
Los Velocimacros pueden recibir como argumentos cualquiera de los
siguientes elementos de VTL:
  </p>

  <ul>
    <li>
	Referencia : cualquier cosa que comience con '$'
    </li>
    <li>
	Cadena de caracteres : algo como "$foo" u 'hola'
    </li>
    <li>
      Número : 1, 2 etc
    </li>
    <li>
		Rango de enteros : [ 1..2] ó [$foo .. $bar]
    </li>
    <li>
      	ObjectArray : [ "a", "b", "c"]
    </li>
    <li>
       El valor booleano "verdadero"
    </li>
	<li>
	   El valor booleano "falso"
    </li>
  </ul>

  <p>
  	Cuando pase referencias como argumentos para los Velocimacros tenga
	en cuenta que las referencias se pasan 'por nombre'. Esto quiere
	decir que su valor es 'generado' cada vez que se usa dentro del
	Velocimacros. Esta característica le permite pasar referencias con
	las llamadas de método y hacer que el método se llame cada vez. Por
	ejemplo, cuando llame el siguiente Velocimacro
   </p>

   <source><![CDATA[
   #macro( llamame $a )
         $a $a $a
     #end

#llamame( $foo.bar() )
   ]]></source>

   <p>
   	Esa llamada hace que el método bar() de la referencia $foo sea
	llamado 3 veces.
    </p>

	<p>
	A primera vista, esta característica parece sorprendente, pero
	cuando se tiene en cuenta la motivación original de los Velocimacros
	-- eliminar la duplicación de "copiar y pegar" del VTL usado varias
	veces -- tiene mucho sentido. Permite pasar al Velocimacro objetos
	con estado, como un objeto que genera colores en una secuencia
	repetitiva para colorear las filas de una tabla.
    </p>

	<p>
	Si usted no desea utilizar esta característica siempre es posible
	simplemente obtener el valor del método como una nueva referencia y
	pasar ese valor:
    </p>

    <source><![CDATA[
	#set( $mivalor = $foo.bar() )
	#llamame( $mivalor )
   ]]></source>


   <strong>Propiedades de un Velocimacro</strong>

   <p>
   Varias líneas en al archivo <code>velocity.properties</code> permiten
   flexibilizar la implementación de los Velocimacro. Tenga en cuenta
   que estas propiedades también están documentadas en la <a
	   href="developer-guide.html">Guía de Desarrolladores</a>.
   </p>

   <p>
   <code>velocimacro.library</code> - Una lista, separada por comas de
   todas la librerias de plantillas de Velocimacros. Por defecto,
   Velocity busca una sola librería: <em>VM_global_library.vm</em>. El
   directorio en el que se buscan las plantillas también se utiliza para
   localizar las librerías.
    </p>

    <p>
	<code>velocimacro.permissions.allow.inline</code> - Esta propiedad,
	que tiene como valores posibles verdadero y falso (true y false),
	determina si los Velocimacros pueden ser definidos dentro de las
	plantillas normales.
	El valor por defecto, verdadero, le permite a los diseñadores
	definir por si mismos macros en las plantillas.
    </p>

    <p>
    <code>velocimacro.permissions.allow.inline.to.replace.global</code> -
	Con valores posibles verdadero y falso (true y false), esta
	propiedad le permite al usuario decidir si un Velocimacro definido
	inline dentro de una plantilla puede reemplazar a la plantilla
	global, que fue cargada al comienzo por medio de la propiedad
	<code>velocimacro.library</code>. El valor por defecto, falso
	(<code>false</code>), evita que los Velocimacros definidos en una
	plantilla reemplacen a los que fueron cargados al inicio.
    </p>

   <p>
   <code>velocimacro.permissions.allow.inline.local.scope</code> -
	Con valores posibles verdadero y falso (true y false), valor por
	defecto falso, esta propiedad dice si los Velocimacros definidos
	inline son 'visibles' únicamente para la plantilla que los define.
	Usted puede usar esta característica para hacer algunos trucos de
	VM - si un VM global llama a otro VM global, con ancance inline, una
	plantilla puede definir una implementación privada del segundo VM,
	que será llamada por el primer VM cuando sea invocado en esa
	plantilla. Ninguna de las otras templates es afectada.
    </p>

    <p>
	<code>velocimacro.context.localscope</code> -
	Con valores posibles verdadero y falso (true y false), valor por
	defecto falso. Cuando es verdadera cualquier modificación al
	contexto por medio de un #set() dentro de un Velocimacro se
	considera local a ese Velocimacro y no afecta permanentemente al
	contexto.
    </p>

    <p>
	<code>velocimacro.library.autoreload</code> - Esta propiedad
	controla el cargado automático de la libreria de Velocimacros. El
	valor por defecto es <code>false</code>. Cuando es verdadero
	(<code>true</code>) la librería fuente de un Velocimacro que ha sido
	invocado será verificada para comprobar que no haya cambiado, y si
	lo ha hecho será recargada. Esta característica le permite cambiar y
	probar librerías de macros sin necesidad de reiniciar la aplicación
	o el contenedor de servlets, de la misma manera que se hace con
	plantillas normales.
	Este modo solo funciona cuando el caché esta <i>apagado</i>
	en los cargadores de recursos( e.g. <code>file.resource.loader.cache
		= false</code>).
	Esta característica esta pensada para el proceso de desarrollo, no
	el de producción.
	This property
    </p>

	<strong>Cosas y Casos de Velocimacros</strong>

	<p>
	Actualmente los Velocimacros deben ser definidos antes de ser
	utilizados por primera vez dentro de una plantilla. Esto significa
	que sus declaraciones de #macro() deben aparecerantes de que usted
	utilice los Velocimacros.
    </p>

	<p>
	Esto es importante recordarlo cuando usted intenta hacerle #parse()
	a una plantilla que contiene directivas #macro(). Como el #parse()
	ocurre en tiempo de ejecución, y el parser decide si un elemento que
	parece una VM es realmente un VM cuando esta haciendo el #parse(),
	entonces probablemente el #parse() de un conjunto de declaraciones
	no funciona como se esperaría. Para evitar este problema,
	simplemente utilice la propiedad
	<code>velocimacro.library</code>para cargar todos sus VM cuando se
	inicie la aplicación.
    </p>
 </section>

<section name="Escapando Directivas VTL">
<p>
Las directivas de VTL se pueden escapar con el palote invertido o
backslash ("\") de manera similar a como se escapan las referencias de
VTL válidas.
</p>

<source><![CDATA[
## #include( "a.txt" ) se muestra como <contenidos de a.txt>
#include( "a.txt" )

## \#include( "a.txt" ) se muestra como \#include( "a.txt" )
\#include( "a.txt" )

## \\#include ( "a.txt" ) se muestra como \<contenidos de a.txt>
\\#include ( "a.txt" )
]]></source>

<p>
Se debe tener especial cuidado cuando se escapan directivas de VTL que
contienen varios elementos de script en una misma directiva (como en las
sentencias if-else-end). A continuación seencuentra un ejemplo de un
condicional típico de VTL:
  </p>

<source><![CDATA[
#if( $jazz )
    Vyacheslav Ganelin
#end
]]></source>

  <p>
  Si <em>$jazz</em> es cierto la salida es
  </p>
<source><![CDATA[
Vyacheslav Ganelin
]]></source>

  <p>
  Si <em>$jazz</em> es fals, no hay salida. Escapar elementos de script
  altera la salida. Considere el siguiente caso:
  </p>

<source><![CDATA[
\#if( $jazz )
    Vyacheslav Ganelin
\#end
]]></source>

<p>
Sin importar si <em>$jazz</em> es verdadero o falso, la salida será:
</p>

 <source><![CDATA[
 #if($ jazz )
     Vyacheslav Ganelin
 #end
 ]]></source>

 <p>
 De hecho, como todos los elementos de script están escapados,
 <em>$jazz</em> nunca se evalúa por su valor booleano.
 Suponga que los palotes invertidos preceden a elementos de script que
 están legitimamente escapados:
  </p>

<source><![CDATA[
\\#if( $jazz )
   Vyacheslav Ganelin
\\#end
]]></source>

<p>
En este caso, si <em>$jazz</em> es verdadero, la salida es
</p>

<source><![CDATA[
\ Vyacheslav Ganelin
\
]]></source>

<p>
Para entender esto tenga en cuenta que <code>#if( arg )</code>, cuando
es terminado por un caracter de fin de línea (retorno) omitirá ese
caracter de la salida. Por lo tanto, el cuerpo del bloque
<code>#if()</code> va a continuación del primer '\', que se generó a
partir del '\\' que precedía el <code>#if()</code> dentro de la
pantilla. El último \ está en una línea distinta que el texto porqué hay
un retorno después de 'Ganelin', por lo que el \\ final, que precede el
<code>#end</code> hace parte del cuerpo del bloque.
  </p>

  <p>
  Si <em>$jazz</em> es falso, no hay salida. Tenga en cuenta que las
  cosas dejan de funcionar si los elementos de script no son escapados
  de manera correcta.
  </p>

<source><![CDATA[
\\\#if( $jazz )
    Vyacheslave Ganelin
\\#end
]]></source>

  <p>
  Aquí el <em>#if</em> esta escapado, pero hay un <em>#end</em> que
  sobra; al haber demasiados cierres (end) sin sus correspondientes
  aperturas (foreach ó if) se generará un error de procesamiento.
  </p>

 </section>

<section name="VTL: Asuntos de Formato">

<p>
A pesar de que el VTL mostrado en esta guía del usuario se muestra en la
mayoría de los casos con cambios de línea y espacios en blanco, el VTL
que se muestra a continuación
    </p>

<source><![CDATA[
#set( $imperial = ["Munetaka","Koreyasu","Hisakira","Morikune"] )
#foreach( $shogun in $imperial )
    $shogun
#end
]]></source>

<p>
es tan válido como el siguiente trozo de código que Geir Magnusson Jr.
publicó a la lista de correo de usuarios de Velocity para ilustrar un
punto sin ninguna relación:
</p>

<source><![CDATA[
Enviame #set($foo = ["$10 y ","un pastel"])#foreach($a in $foo)$a #end
por favor.
]]></source>

<p>
El comportamiento de Velocity es el de ingnorar el espacio vacío de
exceso. La directiva descrita anteriormente puede reescribirse como:
</p>

<source><![CDATA[
Enviame
#set( $foo = ["$10 y ","un pastel"] )
#foreach( $a in $foo )
$a
#end
por favor.
]]></source>

    <p>
    o como
    </p>

<source><![CDATA[
Enviame
#set($foo       = ["$10 y ","un pastel"])
                 #foreach           ($a in $foo )$a
	#end por favor.
]]></source>

<p>
En cada caso la salida será la misma
    </p>

</section>

<section name="Otras Características y Miscelánea">

<subsection name="Matemáticas">

<p>
Velocity tiene varias funciones matemáticas incluidas que pueden ser
utilizadas en plantillas con la directiva <em>set</em>. Las siguientes
ecuaciones son ejemplos de suma, resta, multiplicación y división
respectivamente:
</p>

<source><![CDATA[
#set( $foo = $bar + 3 )
#set( $foo = $bar - 4 )
#set( $foo = $bar * 6 )
#set( $foo = $bar / 2 )
]]></source>

<p>
Cuando se realiza una división el resultado es un entero. El residuo se
puede obtener utilizando el operador módulo (<em>%</em>).
  </p>

<source><![CDATA[
#set( $foo = $bar % 5 )
]]></source>

<p>
Solo los enteros (...-2, -1, 0, 1, 2...) son válidos cuando se realizan
operaciones matemáticas en Velocity; cuando un no-entero se usa, se
escribe el dato al log y se retorna null como salida.
</p>

  </subsection>

<subsection name="El Operador de Rango">

<p>
El operador de rango se puede usar en conjunción con las directivas
<em>#set</em> y <em>#foreach</em>. Es muy útil por su capacidad para
crear arreglos de objetos compuestos por enteros. La construcción del
operador rango es como sigue:
</p>

<source><![CDATA[
[n..m]
]]></source>

<p>
Tanto <em>n</em> como <em>m</em> debe ser o producir enteros. El hecho
de que <em>m</em> sea mayor o menor que <em>n</em> no importa; en ese
caso el rango cimplemente contará hacía abajo. A continuación se
muestran varios ejemplos de uso del operador rango:
</p>

<source><![CDATA[
Primer ejemplo:
#foreach( $foo in [1..5] )
$foo
#end

Segundo ejemplo:
#foreach( $bar in [2..-2] )
$bar
#end

Tercer ejemplo:
#set( $arr = [0..1] )
#foreach( $i in $arr )
$i
#end

Cuarto ejemplo:
[1..3]
]]></source>

  <p>
  Produce lo siguiente:
  </p>

  <source><![CDATA[
Primer ejemplo:
1 2 3 4 5

Segundo ejemplo:
2 1 0 -1 -2

Tercer ejemplo:
0 1

Cuarto ejemplo:
[1..3]
]]></source>

<p>
enga en cuenta que el operador de rango solamente produce un arreglo
cuando se utiliza junto con las directivas <em>#set</em> y
<em>#foreach</em>, como se demuestra en el cuarto ejemplo.
</p>

<p>
Los diseñadores de páginas preocupados con hacer los tamaños de las
tablas iguales, pero con información que puede no se suficiente para
llenar la tabla, encontrarán el operador de rango particularmente útil.
</p>

  </subsection>

<subsection name="Temas Avanzados: Escapando y !">

<p>
Cuando una referencia se hace silenciona con el caracter <em>!</em> y el
caracter <em>!</em> viene precedido por un caracter de escape
<em>\</em> la referencia se maneja de una manera diferente. Observe las
diferencias entre el escape sencillo y el caso especial en el que
<em>\</em> precede a <em>!</em>:
</p>

<source><![CDATA[
#set( $foo = "bar" )
$\!foo
$\!{foo}
$\\!foo
$\\\!foo
]]></source>

  <p>
   Se muestra como:
  </p>

<source><![CDATA[
$!foo
$!{foo}
$\!foo
$\\!foo
]]></source>

  <p>
   A diferencia del escape normal, donde <em>\</em> precede a <em>$</em>:
  </p>

<source><![CDATA[
\$foo
\$!foo
\$!{foo}
\\$!{foo}
]]></source>

  <p>
  Se muestra como:
  </p>

<source><![CDATA[
\$foo
\$!foo
\$!{foo}
\bar
]]></source>

 </subsection>

<subsection name="Miscelánea de Velocimacro">

<p>
Esta sección contiene un conjunto de preguntas frecuentes (FAQ)
relacionadas con Velocimacros. Esta sección cambiará con el tiempo, por
lo que es bueno revisar si hay información nueva de cuando en cuando.
</p>

<p>
Nota : A través de esta sección 'Velocimacro' será abreviado como 'VM'.
</p>

<strong>¿Puedo usar una directiva u otro VM como argumento para un VM?</strong>

<p>
Ejemplo : <code>#center( #bold("hola") )</code>
</p>

<p>
No.  Una directiva no es un argumento válido para una directiva y, para
la mayoría de los propósitos prácticos, un VM es una directiva.
</p>

<p>
<i>Sin embargo...</i>, hay cosas que usted puede hacer. Una solución
sencilla es aprovechar el hecho de que la doble comilla (") muestra sus
contenidos, por lo que usted puede hacer algo como
</p>

<source><![CDATA[
#set($cosas = "#bold('hola')" )
#center( $cosas )
]]></source>

<p>
Puede tener un paso...
</p>

<source><![CDATA[
#center( "#bold( 'hola' )" )
]]></source>

<p>
Tenga en cuenta que en segundo ejemplo el argumentos es evaluado <i>
	dentro</i> de la VM, no a nivel del llamador. En otras palabras, el
argumento para el VM es pasado completo y evaluado dentro del VM al que
se le pasa. Esto le permite hacer cosas como :
</p>

<source><![CDATA[

#macro( interno $foo )
  interno : $foo
#end

#macro( externo $foo )
   #set($bar = "externolala")
   externo : $foo
#end

#set($bar = 'calltimelala')
#externo( "#interno($bar)" )

]]></source>

<p>
Donde la salida es
</p>

<source><![CDATA[
externo : interno : externolala
]]></source>

<p>
la evaluación de "#interno($bar)" se lleva a cabo dentro de #externo(),
por lo que el valor $bar establecido dentro de #externo() es el que se
utiliza.
</p>

<p>
Estas es una característica intencional y celosamente protegina - los
argumentos se pasan por nombre a los VM para que usted le pueda
'entregar' a los VMs referencias con estado como
</p>

<source><![CDATA[
#macro( foo $color )
  <tr bgcolor=$color><td>Hola</td></tr>
  <tr bgcolor=$color><td>Todos</td></tr>
#end

#foo( $bar.colorFila() )
]]></source>

<p>
Y lograr que colorFila() se llame varias veces, en lugar de solo una.
Par evitar que eso ocurra invoque el método fuera del VM y pásele el
valor al VM.
</p>

<source><![CDATA[
#set($color = $bar.colorFila())
#foo( $color )
]]></source>


<strong>¿Puedo registrar Velocimacros por medio de #parse() ? </strong>

<p>
Actualmente, los Velocimacros deben ser definidos antes de ser usados
por primera vez dentro de una plantilla. Esto significa que sus
declaraciones de #macro() deben venir antes de que usted use los
Velocimacros.
</p>

    <p>
	Esto es importante recordarlo cuando usted intenta hacerle #parse()
	a una plantilla que contiene directivas #macro(). Como el #parse()
	ocurre en tiempo de ejecución, y el parser decide si un elemento que
	parece una VM es realmente un VM cuando esta haciendo el #parse(),
	entonces probablemente el #parse() de un conjunto de declaraciones
	no funciona como se esperaría. Para evitar este problema,
	simplemente utilice la propiedad
	<code>velocimacro.library</code>para cargar todos sus VM cuando se
	inicie la aplicación.
    </p>


	<strong>¿Qué es la auto recarga de Velocimacros?</strong>

	<p>
	Existe una propiedad, pensada para usarse en <i>desarrollo</i>, no
	en producción :
  </p>

  <p>
  <code>velocimacro.library.autoreload</code>
  </p>

  <p>
  que tiene como valor por defecto falso. Cuando se hace verdadera
  <em>junto con</em> <code>&lt;tipo&gt;.resource.loader.cache = false</code>
  (where &lt;tipo&gt; es el nombre del cargador de recursos que usted
  esta utilizando, como 'file' para archivos) entonces el motor de
  Velocity recargará automáticamente los cambios en su librerías en el
  momento en que los haga para que usted no tenga que reinicar el motor
  de servlets o la aplicación, o hacer otros trucos para lograr que sus
  Velocimacros se recarguen.
    </p>

	<p>
	A continuación se muestra un conjunto sencillo de propiedades de
	configuración.
    </p>

    <source><![CDATA[
    file.resource.loader.path = templates
    file.resource.loader.cache = false
    velocimacro.library.autoreload = true
    ]]></source>

	<p>No utilice esto en producción</p>

</subsection>

<subsection name="Concatenación de Cadenas">

<p>
Una pregunta común que los desarrolladores formulan es <i>¿Cómo
	concateno cadenas de caracteres? ¿Existe algún análogo al operador
	'+' en Java?</i>
   </p>

   <p>
   Para concatenar referencias en VTL usted solo tiene que 'ponerlos
   juntos'. El contenido del contexto  en donde usted desee juntar las
   referencias es importante, por lo que ilustraremos con algunos
   ejemplos.
   </p>

   <p>
   En el código regular de una plantilla (cuando usted lo mezcla con
   contenido normal)
   </p>

   <source><![CDATA[
   #set( $tam = "Big" )
   #set( $nombre = "Ben" )

   El reloj es $tam$nombre.
   ]]></source>

   <p>
   	y la salida será 'El reloj es BigBen'. Para caso más interesantes,
	como cuando ested desea concatenar las cadenas que pasará a un
	método, o establecer el valor de una nueva referencia use
   </p>

   <source><![CDATA[
      #set( $tam = "Big" )
      #set( $nombre = "Ben" )

	  #set($reloj = "$tam$nombre" )

	 	El reloj es $reloj.
    ]]></source>

	<p>
	Que resultará en la mismo que el ejemplo anterior. Como un ejemplo
	final, cuando usted desea mezclar cadenas 'estáticas' con sus
	referencias usted puede necesitar 'referencias formales':
    </p>

    <source><![CDATA[
	  #set( $tam = "Big" )
      #set( $nombre = "Ben" )

	  #set($reloj = "${tam}Alto$nombre" )

	  El reloj es $reloj.
    ]]></source>

	<p>
	Ahora el resultado es 'El reloj es BigAltoBen'. La notación formal
	es necesaria para que el procesador de las plantillas sepa que usted
	quiso usar la referencia '$tam', en lugar de '$tamAlto', que sería
	lo que entendería si los corchetes '{}' no estuvieran presentes.
    </p>
</subsection>

</section>

<section name="Retroalimentación">

<p>
Si encuentra algún error en este manual o tiene algún otro comentario o
retroalimentación relacionada con la guía del usuario de Velocity, por
favor envie un correo a <a
	href="mailto:velocity-user@jakarta.apache.org">La lista de usuarios
	de Velocity</a>.
Gracias!
  </p>

</section>

</body>
</document>
