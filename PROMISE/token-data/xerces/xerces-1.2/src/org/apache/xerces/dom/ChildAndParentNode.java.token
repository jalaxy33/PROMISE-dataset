package
org
.
apache
.
xerces
.
dom
;
import
java
.
io
.
*
;
import
org
.
w3c
.
dom
.
*
;
import
org
.
w3c
.
dom
.
events
.
*
;
import
org
.
apache
.
xerces
.
dom
.
*
;
import
org
.
apache
.
xerces
.
dom
.
events
.
*
;
public
abstract
class
ChildAndParentNode
extends
ChildNode
{
static
final
long
serialVersionUID
=
0
;
protected
DocumentImpl
ownerDocument
;
protected
ChildNode
firstChild
=
null
;
protected
transient
int
nodeListLength
=
-
1
;
protected
transient
ChildNode
nodeListNode
;
protected
transient
int
nodeListIndex
=
-
1
;
protected
ChildAndParentNode
(
DocumentImpl
ownerDocument
)
{
super
(
ownerDocument
)
;
this
.
ownerDocument
=
ownerDocument
;
}
public
ChildAndParentNode
(
)
{
}
public
Node
cloneNode
(
boolean
deep
)
{
ChildAndParentNode
newnode
=
(
ChildAndParentNode
)
super
.
cloneNode
(
deep
)
;
newnode
.
ownerDocument
=
ownerDocument
;
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
newnode
.
firstChild
=
null
;
newnode
.
nodeListIndex
=
-
1
;
newnode
.
nodeListLength
=
-
1
;
if
(
deep
)
{
for
(
Node
child
=
firstChild
;
child
!=
null
;
child
=
child
.
getNextSibling
(
)
)
{
newnode
.
appendChild
(
child
.
cloneNode
(
true
)
)
;
}
}
return
newnode
;
}
public
Document
getOwnerDocument
(
)
{
return
ownerDocument
;
}
DocumentImpl
ownerDocument
(
)
{
return
ownerDocument
;
}
void
setOwnerDocument
(
DocumentImpl
doc
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
for
(
Node
child
=
firstChild
;
child
!=
null
;
child
=
child
.
getNextSibling
(
)
)
{
(
(
NodeImpl
)
child
)
.
setOwnerDocument
(
doc
)
;
}
ownerDocument
=
doc
;
}
public
boolean
hasChildNodes
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
firstChild
!=
null
;
}
public
NodeList
getChildNodes
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
this
;
}
public
Node
getFirstChild
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
firstChild
;
}
public
Node
getLastChild
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
lastChild
(
)
;
}
final
ChildNode
lastChild
(
)
{
return
firstChild
!=
null
?
firstChild
.
previousSibling
:
null
;
}
final
void
lastChild
(
ChildNode
node
)
{
if
(
firstChild
!=
null
)
{
firstChild
.
previousSibling
=
node
;
}
}
public
Node
insertBefore
(
Node
newChild
,
Node
refChild
)
throws
DOMException
{
return
internalInsertBefore
(
newChild
,
refChild
,
MUTATION_ALL
)
;
}
Node
internalInsertBefore
(
Node
newChild
,
Node
refChild
,
int
mutationMask
)
throws
DOMException
{
if
(
isReadOnly
(
)
)
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
boolean
errorChecking
=
ownerDocument
.
errorChecking
;
if
(
errorChecking
&&
newChild
.
getOwnerDocument
(
)
!=
ownerDocument
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
WRONG_DOCUMENT_ERR
,
"DOM005 Wrong document"
)
;
}
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
if
(
errorChecking
)
{
boolean
treeSafe
=
true
;
for
(
NodeImpl
a
=
parentNode
(
)
;
treeSafe
&&
a
!=
null
;
a
=
a
.
parentNode
(
)
)
{
treeSafe
=
newChild
!=
a
;
}
if
(
!
treeSafe
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
if
(
refChild
!=
null
&&
refChild
.
getParentNode
(
)
!=
this
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NOT_FOUND_ERR
,
"DOM008 Not found"
)
;
}
}
if
(
newChild
.
getNodeType
(
)
==
Node
.
DOCUMENT_FRAGMENT_NODE
)
{
for
(
Node
kid
=
newChild
.
getFirstChild
(
)
;
kid
!=
null
;
kid
=
kid
.
getNextSibling
(
)
)
{
if
(
errorChecking
&&
!
ownerDocument
.
isKidOK
(
this
,
kid
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
}
while
(
newChild
.
hasChildNodes
(
)
)
{
insertBefore
(
newChild
.
getFirstChild
(
)
,
refChild
)
;
}
}
else
if
(
errorChecking
&&
(
!
(
newChild
instanceof
ChildNode
)
||
!
ownerDocument
.
isKidOK
(
this
,
newChild
)
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
else
{
ChildNode
newInternal
=
(
ChildNode
)
newChild
;
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
&&
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
}
Node
oldparent
=
newInternal
.
parentNode
(
)
;
if
(
oldparent
!=
null
)
{
oldparent
.
removeChild
(
newInternal
)
;
}
ChildNode
refInternal
=
(
ChildNode
)
refChild
;
newInternal
.
ownerNode
=
this
;
newInternal
.
isOwned
(
true
)
;
if
(
firstChild
==
null
)
{
firstChild
=
newInternal
;
newInternal
.
isFirstChild
(
true
)
;
newInternal
.
previousSibling
=
newInternal
;
}
else
{
if
(
refInternal
==
null
)
{
ChildNode
lastChild
=
firstChild
.
previousSibling
;
lastChild
.
nextSibling
=
newInternal
;
newInternal
.
previousSibling
=
lastChild
;
firstChild
.
previousSibling
=
newInternal
;
}
else
{
if
(
refChild
==
firstChild
)
{
firstChild
.
isFirstChild
(
false
)
;
newInternal
.
nextSibling
=
firstChild
;
newInternal
.
previousSibling
=
firstChild
.
previousSibling
;
firstChild
.
previousSibling
=
newInternal
;
firstChild
=
newInternal
;
newInternal
.
isFirstChild
(
true
)
;
}
else
{
ChildNode
prev
=
refInternal
.
previousSibling
;
newInternal
.
nextSibling
=
refInternal
;
prev
.
nextSibling
=
newInternal
;
refInternal
.
previousSibling
=
newInternal
;
newInternal
.
previousSibling
=
prev
;
}
}
}
changed
(
)
;
if
(
nodeListLength
!=
-
1
)
{
nodeListLength
++
;
}
if
(
nodeListIndex
!=
-
1
)
{
if
(
nodeListNode
==
refInternal
)
{
nodeListNode
=
newInternal
;
}
else
{
nodeListIndex
=
-
1
;
}
}
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
if
(
(
mutationMask
&
MUTATION_LOCAL
)
!=
0
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_INSERTED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_INSERTED
,
true
,
false
,
this
,
null
,
null
,
null
)
;
newInternal
.
dispatchEvent
(
me
)
;
}
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_INSERTED_INTO_DOCUMENT
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
NodeImpl
eventAncestor
=
this
;
if
(
enclosingAttr
!=
null
)
eventAncestor
=
(
NodeImpl
)
(
enclosingAttr
.
node
.
getOwnerElement
(
)
)
;
if
(
eventAncestor
!=
null
)
{
NodeImpl
p
=
eventAncestor
;
while
(
p
!=
null
)
{
eventAncestor
=
p
;
if
(
p
.
getNodeType
(
)
==
ATTRIBUTE_NODE
)
p
=
(
ElementImpl
)
(
(
AttrImpl
)
p
)
.
getOwnerElement
(
)
;
else
p
=
p
.
parentNode
(
)
;
}
if
(
eventAncestor
.
getNodeType
(
)
==
Node
.
DOCUMENT_NODE
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_INSERTED_INTO_DOCUMENT
,
false
,
false
,
null
,
null
,
null
,
null
)
;
dispatchEventToSubtree
(
newInternal
,
me
)
;
}
}
}
}
if
(
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
dispatchAggregateEvents
(
enclosingAttr
)
;
}
}
return
newChild
;
}
public
Node
removeChild
(
Node
oldChild
)
throws
DOMException
{
return
internalRemoveChild
(
oldChild
,
MUTATION_ALL
)
;
}
Node
internalRemoveChild
(
Node
oldChild
,
int
mutationMask
)
throws
DOMException
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
if
(
ownerDocument
.
errorChecking
&&
oldChild
!=
null
&&
oldChild
.
getParentNode
(
)
!=
this
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NOT_FOUND_ERR
,
"DOM008 Not found"
)
;
}
ownerDocument
.
removedChildNode
(
oldChild
)
;
ChildNode
oldInternal
=
(
ChildNode
)
oldChild
;
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
if
(
(
mutationMask
&
MUTATION_LOCAL
)
!=
0
)
{
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_REMOVED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_REMOVED
,
true
,
false
,
this
,
null
,
null
,
null
)
;
oldInternal
.
dispatchEvent
(
me
)
;
}
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_REMOVED_FROM_DOCUMENT
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
NodeImpl
eventAncestor
=
this
;
if
(
enclosingAttr
!=
null
)
eventAncestor
=
(
NodeImpl
)
enclosingAttr
.
node
.
getOwnerElement
(
)
;
if
(
eventAncestor
!=
null
)
{
for
(
NodeImpl
p
=
eventAncestor
.
parentNode
(
)
;
p
!=
null
;
p
=
p
.
parentNode
(
)
)
{
eventAncestor
=
p
;
}
if
(
eventAncestor
.
getNodeType
(
)
==
Node
.
DOCUMENT_NODE
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_REMOVED_FROM_DOCUMENT
,
false
,
false
,
null
,
null
,
null
,
null
)
;
dispatchEventToSubtree
(
oldInternal
,
me
)
;
}
}
}
}
}
if
(
nodeListLength
!=
-
1
)
{
nodeListLength
--
;
}
if
(
nodeListIndex
!=
-
1
)
{
if
(
nodeListNode
==
oldInternal
)
{
nodeListIndex
--
;
nodeListNode
=
oldInternal
.
previousSibling
(
)
;
}
else
{
nodeListIndex
=
-
1
;
}
}
if
(
oldInternal
==
firstChild
)
{
oldInternal
.
isFirstChild
(
false
)
;
firstChild
=
oldInternal
.
nextSibling
;
if
(
firstChild
!=
null
)
{
firstChild
.
isFirstChild
(
true
)
;
firstChild
.
previousSibling
=
oldInternal
.
previousSibling
;
}
}
else
{
ChildNode
prev
=
oldInternal
.
previousSibling
;
ChildNode
next
=
oldInternal
.
nextSibling
;
prev
.
nextSibling
=
next
;
if
(
next
==
null
)
{
firstChild
.
previousSibling
=
prev
;
}
else
{
next
.
previousSibling
=
prev
;
}
}
oldInternal
.
ownerNode
=
ownerDocument
;
oldInternal
.
isOwned
(
false
)
;
oldInternal
.
nextSibling
=
null
;
oldInternal
.
previousSibling
=
null
;
changed
(
)
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
if
(
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
dispatchAggregateEvents
(
enclosingAttr
)
;
}
return
oldInternal
;
}
public
Node
replaceChild
(
Node
newChild
,
Node
oldChild
)
throws
DOMException
{
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
}
internalInsertBefore
(
newChild
,
oldChild
,
MUTATION_LOCAL
)
;
internalRemoveChild
(
oldChild
,
MUTATION_LOCAL
)
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
dispatchAggregateEvents
(
enclosingAttr
)
;
}
return
oldChild
;
}
public
int
getLength
(
)
{
if
(
nodeListLength
==
-
1
)
{
ChildNode
node
;
if
(
nodeListIndex
!=
-
1
&&
nodeListNode
!=
null
)
{
nodeListLength
=
nodeListIndex
;
node
=
nodeListNode
;
}
else
{
node
=
firstChild
;
nodeListLength
=
0
;
}
for
(
;
node
!=
null
;
node
=
node
.
nextSibling
)
{
nodeListLength
++
;
}
}
return
nodeListLength
;
}
public
Node
item
(
int
index
)
{
if
(
nodeListIndex
!=
-
1
&&
nodeListNode
!=
null
)
{
if
(
nodeListIndex
<
index
)
{
while
(
nodeListIndex
<
index
&&
nodeListNode
!=
null
)
{
nodeListIndex
++
;
nodeListNode
=
nodeListNode
.
nextSibling
;
}
}
else
if
(
nodeListIndex
>
index
)
{
while
(
nodeListIndex
>
index
&&
nodeListNode
!=
null
)
{
nodeListIndex
--
;
nodeListNode
=
nodeListNode
.
previousSibling
(
)
;
}
}
return
nodeListNode
;
}
nodeListNode
=
firstChild
;
for
(
nodeListIndex
=
0
;
nodeListIndex
<
index
&&
nodeListNode
!=
null
;
nodeListIndex
++
)
{
nodeListNode
=
nodeListNode
.
nextSibling
;
}
return
nodeListNode
;
}
public
void
normalize
(
)
{
Node
kid
;
for
(
kid
=
firstChild
;
kid
!=
null
;
kid
=
kid
.
getNextSibling
(
)
)
{
kid
.
normalize
(
)
;
}
}
public
void
setReadOnly
(
boolean
readOnly
,
boolean
deep
)
{
super
.
setReadOnly
(
readOnly
,
deep
)
;
if
(
deep
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
for
(
ChildNode
mykid
=
firstChild
;
mykid
!=
null
;
mykid
=
mykid
.
nextSibling
)
{
if
(
!
(
mykid
instanceof
EntityReference
)
)
{
mykid
.
setReadOnly
(
readOnly
,
true
)
;
}
}
}
}
protected
void
synchronizeChildren
(
)
{
needsSyncChildren
(
false
)
;
}
protected
final
void
synchronizeChildren
(
int
nodeIndex
)
{
boolean
orig
=
ownerDocument
.
mutationEvents
;
ownerDocument
.
mutationEvents
=
false
;
needsSyncChildren
(
false
)
;
DeferredDocumentImpl
ownerDocument
=
(
DeferredDocumentImpl
)
this
.
ownerDocument
;
ChildNode
first
=
null
;
ChildNode
last
=
null
;
for
(
int
index
=
ownerDocument
.
getLastChild
(
nodeIndex
)
;
index
!=
-
1
;
index
=
ownerDocument
.
getPrevSibling
(
index
)
)
{
ChildNode
node
=
(
ChildNode
)
ownerDocument
.
getNodeObject
(
index
)
;
if
(
last
==
null
)
{
last
=
node
;
}
else
{
first
.
previousSibling
=
node
;
}
node
.
ownerNode
=
this
;
node
.
isOwned
(
true
)
;
node
.
nextSibling
=
first
;
first
=
node
;
}
if
(
last
!=
null
)
{
firstChild
=
first
;
first
.
isFirstChild
(
true
)
;
lastChild
(
last
)
;
}
ownerDocument
.
mutationEvents
=
orig
;
}
private
void
writeObject
(
ObjectOutputStream
out
)
throws
IOException
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
out
.
defaultWriteObject
(
)
;
}
private
void
readObject
(
ObjectInputStream
ois
)
throws
ClassNotFoundException
,
IOException
{
ois
.
defaultReadObject
(
)
;
needsSyncChildren
(
false
)
;
nodeListLength
=
-
1
;
nodeListIndex
=
-
1
;
}
}
