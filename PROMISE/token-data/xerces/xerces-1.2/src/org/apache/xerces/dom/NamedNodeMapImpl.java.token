package
org
.
apache
.
xerces
.
dom
;
import
java
.
io
.
*
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Enumeration
;
import
org
.
w3c
.
dom
.
*
;
public
class
NamedNodeMapImpl
implements
NamedNodeMap
,
Serializable
{
static
final
long
serialVersionUID
=
-
7039242451046758020L
;
protected
short
flags
;
protected
final
static
short
READONLY
=
0x1
<<
0
;
protected
final
static
short
CHANGED
=
0x1
<<
1
;
protected
final
static
short
HASDEFAULTS
=
0x1
<<
2
;
protected
Vector
nodes
;
protected
NodeImpl
ownerNode
;
protected
NamedNodeMapImpl
(
NodeImpl
ownerNode
)
{
this
.
ownerNode
=
ownerNode
;
}
public
int
getLength
(
)
{
return
(
nodes
!=
null
)
?
nodes
.
size
(
)
:
0
;
}
public
Node
item
(
int
index
)
{
return
(
nodes
!=
null
&&
index
<
nodes
.
size
(
)
)
?
(
Node
)
(
nodes
.
elementAt
(
index
)
)
:
null
;
}
public
Node
getNamedItem
(
String
name
)
{
int
i
=
findNamePoint
(
name
,
0
)
;
return
(
i
<
0
)
?
null
:
(
Node
)
(
nodes
.
elementAt
(
i
)
)
;
}
public
Node
getNamedItemNS
(
String
namespaceURI
,
String
localName
)
{
int
i
=
findNamePoint
(
namespaceURI
,
localName
)
;
return
(
i
<
0
)
?
null
:
(
Node
)
(
nodes
.
elementAt
(
i
)
)
;
}
public
Node
setNamedItem
(
Node
arg
)
throws
DOMException
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
if
(
arg
.
getOwnerDocument
(
)
!=
ownerNode
.
ownerDocument
(
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
WRONG_DOCUMENT_ERR
,
"DOM005 Wrong document"
)
;
}
int
i
=
findNamePoint
(
arg
.
getNodeName
(
)
,
0
)
;
NodeImpl
previous
=
null
;
if
(
i
>=
0
)
{
previous
=
(
NodeImpl
)
nodes
.
elementAt
(
i
)
;
nodes
.
setElementAt
(
arg
,
i
)
;
}
else
{
i
=
-
1
-
i
;
if
(
null
==
nodes
)
{
nodes
=
new
Vector
(
5
,
10
)
;
}
nodes
.
insertElementAt
(
arg
,
i
)
;
}
return
previous
;
}
public
Node
setNamedItemNS
(
Node
arg
)
throws
DOMException
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
if
(
arg
.
getOwnerDocument
(
)
!=
ownerNode
.
ownerDocument
(
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
WRONG_DOCUMENT_ERR
,
"DOM005 Wrong document"
)
;
}
int
i
=
findNamePoint
(
arg
.
getNamespaceURI
(
)
,
arg
.
getLocalName
(
)
)
;
NodeImpl
previous
=
null
;
if
(
i
>=
0
)
{
previous
=
(
NodeImpl
)
nodes
.
elementAt
(
i
)
;
nodes
.
setElementAt
(
arg
,
i
)
;
}
else
{
i
=
findNamePoint
(
arg
.
getNodeName
(
)
,
0
)
;
if
(
i
>=
0
)
{
previous
=
(
NodeImpl
)
nodes
.
elementAt
(
i
)
;
nodes
.
insertElementAt
(
arg
,
i
)
;
}
else
{
i
=
-
1
-
i
;
if
(
null
==
nodes
)
{
nodes
=
new
Vector
(
5
,
10
)
;
}
nodes
.
insertElementAt
(
arg
,
i
)
;
}
}
return
previous
;
}
public
Node
removeNamedItem
(
String
name
)
throws
DOMException
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
int
i
=
findNamePoint
(
name
,
0
)
;
if
(
i
<
0
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NOT_FOUND_ERR
,
"DOM008 Not found"
)
;
}
NodeImpl
n
=
(
NodeImpl
)
nodes
.
elementAt
(
i
)
;
nodes
.
removeElementAt
(
i
)
;
return
n
;
}
public
Node
removeNamedItemNS
(
String
namespaceURI
,
String
name
)
throws
DOMException
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
int
i
=
findNamePoint
(
namespaceURI
,
name
)
;
if
(
i
<
0
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NOT_FOUND_ERR
,
"DOM008 Not found"
)
;
}
NodeImpl
n
=
(
NodeImpl
)
nodes
.
elementAt
(
i
)
;
nodes
.
removeElementAt
(
i
)
;
return
n
;
}
public
NamedNodeMapImpl
cloneMap
(
NodeImpl
ownerNode
)
{
NamedNodeMapImpl
newmap
=
new
NamedNodeMapImpl
(
ownerNode
)
;
newmap
.
cloneContent
(
this
)
;
return
newmap
;
}
protected
void
cloneContent
(
NamedNodeMapImpl
srcmap
)
{
if
(
srcmap
.
nodes
!=
null
)
{
nodes
=
new
Vector
(
srcmap
.
nodes
.
size
(
)
)
;
for
(
int
i
=
0
;
i
<
srcmap
.
nodes
.
size
(
)
;
++
i
)
{
NodeImpl
n
=
(
NodeImpl
)
srcmap
.
nodes
.
elementAt
(
i
)
;
NodeImpl
clone
=
(
NodeImpl
)
n
.
cloneNode
(
true
)
;
clone
.
isSpecified
(
n
.
isSpecified
(
)
)
;
nodes
.
insertElementAt
(
clone
,
i
)
;
}
}
}
void
setReadOnly
(
boolean
readOnly
,
boolean
deep
)
{
isReadOnly
(
readOnly
)
;
if
(
deep
&&
nodes
!=
null
)
{
Enumeration
e
=
nodes
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
(
(
NodeImpl
)
e
.
nextElement
(
)
)
.
setReadOnly
(
readOnly
,
deep
)
;
}
}
}
boolean
getReadOnly
(
)
{
return
isReadOnly
(
)
;
}
void
setOwnerDocument
(
DocumentImpl
doc
)
{
if
(
nodes
!=
null
)
{
for
(
int
i
=
0
;
i
<
nodes
.
size
(
)
;
i
++
)
{
(
(
NodeImpl
)
item
(
i
)
)
.
setOwnerDocument
(
doc
)
;
}
}
}
final
boolean
isReadOnly
(
)
{
return
(
flags
&
READONLY
)
!=
0
;
}
final
void
isReadOnly
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
READONLY
:
flags
&
~
READONLY
)
;
}
final
boolean
changed
(
)
{
return
(
flags
&
CHANGED
)
!=
0
;
}
final
void
changed
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
CHANGED
:
flags
&
~
CHANGED
)
;
}
final
boolean
hasDefaults
(
)
{
return
(
flags
&
HASDEFAULTS
)
!=
0
;
}
final
void
hasDefaults
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
HASDEFAULTS
:
flags
&
~
HASDEFAULTS
)
;
}
protected
int
findNamePoint
(
String
name
,
int
start
)
{
int
i
=
0
;
if
(
nodes
!=
null
)
{
int
first
=
start
;
int
last
=
nodes
.
size
(
)
-
1
;
while
(
first
<=
last
)
{
i
=
(
first
+
last
)
/
2
;
int
test
=
name
.
compareTo
(
(
(
Node
)
(
nodes
.
elementAt
(
i
)
)
)
.
getNodeName
(
)
)
;
if
(
test
==
0
)
{
return
i
;
}
else
if
(
test
<
0
)
{
last
=
i
-
1
;
}
else
{
first
=
i
+
1
;
}
}
if
(
first
>
i
)
{
i
=
first
;
}
}
return
-
1
-
i
;
}
protected
int
findNamePoint
(
String
namespaceURI
,
String
name
)
{
if
(
nodes
==
null
)
return
-
1
;
if
(
namespaceURI
==
null
)
return
-
1
;
if
(
name
==
null
)
return
-
1
;
for
(
int
i
=
0
;
i
<
nodes
.
size
(
)
;
i
++
)
{
NodeImpl
a
=
(
NodeImpl
)
nodes
.
elementAt
(
i
)
;
if
(
namespaceURI
.
equals
(
a
.
getNamespaceURI
(
)
)
&&
name
.
equals
(
a
.
getLocalName
(
)
)
)
{
return
i
;
}
}
return
-
1
;
}
}
