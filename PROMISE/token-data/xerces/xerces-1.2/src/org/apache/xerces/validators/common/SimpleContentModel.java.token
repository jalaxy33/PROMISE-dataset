package
org
.
apache
.
xerces
.
validators
.
common
;
import
org
.
apache
.
xerces
.
framework
.
XMLContentSpec
;
import
org
.
apache
.
xerces
.
utils
.
ImplementationMessages
;
import
org
.
apache
.
xerces
.
utils
.
QName
;
import
org
.
apache
.
xerces
.
validators
.
schema
.
EquivClassComparator
;
public
class
SimpleContentModel
implements
XMLContentModel
{
private
QName
fFirstChild
=
new
QName
(
)
;
private
QName
fSecondChild
=
new
QName
(
)
;
private
int
fOp
;
private
boolean
fDTD
;
private
EquivClassComparator
comparator
=
null
;
public
SimpleContentModel
(
QName
firstChild
,
QName
secondChild
,
int
cmOp
)
{
this
(
firstChild
,
secondChild
,
cmOp
,
false
)
;
}
public
SimpleContentModel
(
QName
firstChild
,
QName
secondChild
,
int
cmOp
,
boolean
dtd
)
{
fFirstChild
.
setValues
(
firstChild
)
;
if
(
secondChild
!=
null
)
{
fSecondChild
.
setValues
(
secondChild
)
;
}
else
{
fSecondChild
.
clear
(
)
;
}
fOp
=
cmOp
;
fDTD
=
dtd
;
}
public
int
validateContent
(
QName
children
[
]
,
int
offset
,
int
length
)
throws
Exception
{
switch
(
fOp
)
{
case
XMLContentSpec
.
CONTENTSPECNODE_LEAF
:
if
(
length
==
0
)
return
0
;
if
(
fDTD
)
{
if
(
children
[
offset
]
.
rawname
!=
fFirstChild
.
rawname
)
{
return
0
;
}
}
else
{
if
(
children
[
offset
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
]
.
localpart
!=
fFirstChild
.
localpart
)
return
0
;
}
if
(
length
>
1
)
return
1
;
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_ZERO_OR_ONE
:
if
(
length
==
1
)
{
if
(
fDTD
)
{
if
(
children
[
offset
]
.
rawname
!=
fFirstChild
.
rawname
)
{
return
0
;
}
}
else
{
if
(
children
[
offset
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
]
.
localpart
!=
fFirstChild
.
localpart
)
return
0
;
}
}
if
(
length
>
1
)
return
1
;
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_ZERO_OR_MORE
:
if
(
length
>
0
)
{
if
(
fDTD
)
{
for
(
int
index
=
0
;
index
<
length
;
index
++
)
{
if
(
children
[
offset
+
index
]
.
rawname
!=
fFirstChild
.
rawname
)
{
return
index
;
}
}
}
else
{
for
(
int
index
=
0
;
index
<
length
;
index
++
)
{
if
(
children
[
offset
+
index
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
+
index
]
.
localpart
!=
fFirstChild
.
localpart
)
return
index
;
}
}
}
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_ONE_OR_MORE
:
if
(
length
==
0
)
return
0
;
if
(
fDTD
)
{
for
(
int
index
=
0
;
index
<
length
;
index
++
)
{
if
(
children
[
offset
+
index
]
.
rawname
!=
fFirstChild
.
rawname
)
{
return
index
;
}
}
}
else
{
for
(
int
index
=
0
;
index
<
length
;
index
++
)
{
if
(
children
[
offset
+
index
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
+
index
]
.
localpart
!=
fFirstChild
.
localpart
)
return
index
;
}
}
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_CHOICE
:
if
(
length
==
0
)
return
0
;
if
(
fDTD
)
{
if
(
(
children
[
offset
]
.
rawname
!=
fFirstChild
.
rawname
)
&&
(
children
[
offset
]
.
rawname
!=
fSecondChild
.
rawname
)
)
{
return
0
;
}
}
else
{
if
(
(
children
[
offset
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
]
.
localpart
!=
fFirstChild
.
localpart
)
&&
(
children
[
offset
]
.
uri
!=
fSecondChild
.
uri
||
children
[
offset
]
.
localpart
!=
fSecondChild
.
localpart
)
)
return
0
;
}
if
(
length
>
1
)
return
1
;
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_SEQ
:
if
(
length
==
2
)
{
if
(
fDTD
)
{
if
(
children
[
offset
]
.
rawname
!=
fFirstChild
.
rawname
)
{
return
0
;
}
if
(
children
[
offset
+
1
]
.
rawname
!=
fSecondChild
.
rawname
)
{
return
1
;
}
}
else
{
if
(
children
[
offset
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
]
.
localpart
!=
fFirstChild
.
localpart
)
return
0
;
if
(
children
[
offset
+
1
]
.
uri
!=
fSecondChild
.
uri
||
children
[
offset
+
1
]
.
localpart
!=
fSecondChild
.
localpart
)
return
1
;
}
}
else
{
if
(
length
>
2
)
{
return
2
;
}
return
length
;
}
break
;
default
:
throw
new
CMException
(
ImplementationMessages
.
VAL_CST
)
;
}
return
-
1
;
}
public
int
validateContentSpecial
(
QName
children
[
]
,
int
offset
,
int
length
)
throws
Exception
{
if
(
comparator
==
null
)
{
return
validateContent
(
children
,
offset
,
length
)
;
}
switch
(
fOp
)
{
case
XMLContentSpec
.
CONTENTSPECNODE_LEAF
:
if
(
length
==
0
)
return
0
;
if
(
children
[
offset
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
]
.
localpart
!=
fFirstChild
.
localpart
)
if
(
!
comparator
.
isEquivalentTo
(
children
[
offset
]
,
fFirstChild
)
)
return
0
;
if
(
length
>
1
)
return
1
;
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_ZERO_OR_ONE
:
if
(
length
==
1
&&
(
children
[
offset
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
]
.
localpart
!=
fFirstChild
.
localpart
)
)
if
(
!
comparator
.
isEquivalentTo
(
children
[
offset
]
,
fFirstChild
)
)
return
0
;
if
(
length
>
1
)
return
1
;
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_ZERO_OR_MORE
:
if
(
length
>
0
)
{
for
(
int
index
=
0
;
index
<
length
;
index
++
)
{
if
(
children
[
offset
+
index
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
+
index
]
.
localpart
!=
fFirstChild
.
localpart
)
if
(
!
comparator
.
isEquivalentTo
(
children
[
offset
+
index
]
,
fFirstChild
)
)
return
index
;
}
}
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_ONE_OR_MORE
:
if
(
length
==
0
)
return
0
;
for
(
int
index
=
0
;
index
<
length
;
index
++
)
{
if
(
children
[
offset
+
index
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
+
index
]
.
localpart
!=
fFirstChild
.
localpart
)
if
(
!
comparator
.
isEquivalentTo
(
children
[
offset
+
index
]
,
fFirstChild
)
)
return
index
;
}
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_CHOICE
:
if
(
length
==
0
)
return
0
;
if
(
(
children
[
offset
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
]
.
localpart
!=
fFirstChild
.
localpart
)
&&
(
children
[
offset
]
.
uri
!=
fSecondChild
.
uri
||
children
[
offset
]
.
localpart
!=
fSecondChild
.
localpart
)
)
if
(
!
comparator
.
isEquivalentTo
(
children
[
offset
]
,
fFirstChild
)
&&
!
comparator
.
isEquivalentTo
(
children
[
offset
]
,
fSecondChild
)
)
return
0
;
if
(
length
>
1
)
return
1
;
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_SEQ
:
if
(
length
==
2
)
{
if
(
children
[
offset
]
.
uri
!=
fFirstChild
.
uri
||
children
[
offset
]
.
localpart
!=
fFirstChild
.
localpart
)
if
(
!
comparator
.
isEquivalentTo
(
children
[
offset
]
,
fFirstChild
)
)
return
0
;
if
(
children
[
offset
+
1
]
.
uri
!=
fSecondChild
.
uri
||
children
[
offset
+
1
]
.
localpart
!=
fSecondChild
.
localpart
)
if
(
!
comparator
.
isEquivalentTo
(
children
[
offset
+
1
]
,
fSecondChild
)
)
return
1
;
}
else
{
if
(
length
>
2
)
{
return
2
;
}
return
length
;
}
break
;
default
:
throw
new
CMException
(
ImplementationMessages
.
VAL_CST
)
;
}
return
-
1
;
}
public
void
setEquivClassComparator
(
EquivClassComparator
comparator
)
{
this
.
comparator
=
comparator
;
}
public
int
whatCanGoHere
(
boolean
fullyValid
,
InsertableElementsInfo
info
)
throws
Exception
{
for
(
int
index
=
info
.
insertAt
;
index
<
info
.
childCount
;
index
++
)
{
info
.
curChildren
[
index
]
.
setValues
(
info
.
curChildren
[
index
+
1
]
)
;
}
info
.
childCount
--
;
final
int
failedIndex
=
validateContent
(
info
.
curChildren
,
0
,
info
.
childCount
)
;
if
(
(
failedIndex
!=
-
1
)
&&
(
failedIndex
<
info
.
insertAt
)
)
return
failedIndex
;
info
.
canHoldPCData
=
false
;
if
(
(
fOp
==
XMLContentSpec
.
CONTENTSPECNODE_LEAF
)
||
(
fOp
==
XMLContentSpec
.
CONTENTSPECNODE_ZERO_OR_ONE
)
||
(
fOp
==
XMLContentSpec
.
CONTENTSPECNODE_ZERO_OR_MORE
)
||
(
fOp
==
XMLContentSpec
.
CONTENTSPECNODE_ONE_OR_MORE
)
)
{
info
.
resultsCount
=
1
;
}
else
if
(
(
fOp
==
XMLContentSpec
.
CONTENTSPECNODE_CHOICE
)
||
(
fOp
==
XMLContentSpec
.
CONTENTSPECNODE_SEQ
)
)
{
info
.
resultsCount
=
2
;
}
else
{
throw
new
CMException
(
ImplementationMessages
.
VAL_CST
)
;
}
if
(
(
info
.
results
==
null
)
||
(
info
.
results
.
length
<
info
.
resultsCount
)
)
info
.
results
=
new
boolean
[
info
.
resultsCount
]
;
if
(
(
info
.
possibleChildren
==
null
)
||
(
info
.
possibleChildren
.
length
<
info
.
resultsCount
)
)
{
info
.
possibleChildren
=
new
QName
[
info
.
resultsCount
]
;
for
(
int
i
=
0
;
i
<
info
.
possibleChildren
.
length
;
i
++
)
{
info
.
possibleChildren
[
i
]
=
new
QName
(
)
;
}
}
info
.
possibleChildren
[
0
]
.
setValues
(
fFirstChild
)
;
info
.
results
[
0
]
=
false
;
if
(
info
.
resultsCount
==
2
)
{
info
.
possibleChildren
[
1
]
.
setValues
(
fSecondChild
)
;
info
.
results
[
1
]
=
false
;
}
info
.
isValidEOC
=
false
;
switch
(
fOp
)
{
case
XMLContentSpec
.
CONTENTSPECNODE_LEAF
:
case
XMLContentSpec
.
CONTENTSPECNODE_ZERO_OR_ONE
:
if
(
info
.
childCount
==
0
)
{
info
.
results
[
0
]
=
true
;
}
else
if
(
info
.
childCount
>
0
)
{
if
(
!
fullyValid
&&
(
info
.
insertAt
==
0
)
)
info
.
results
[
0
]
=
true
;
}
if
(
fOp
==
XMLContentSpec
.
CONTENTSPECNODE_LEAF
)
{
if
(
info
.
insertAt
==
0
)
info
.
isValidEOC
=
true
;
}
else
{
info
.
isValidEOC
=
true
;
}
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_ZERO_OR_MORE
:
case
XMLContentSpec
.
CONTENTSPECNODE_ONE_OR_MORE
:
info
.
results
[
0
]
=
true
;
if
(
(
fOp
==
XMLContentSpec
.
CONTENTSPECNODE_ZERO_OR_MORE
)
||
(
info
.
insertAt
>
0
)
)
{
info
.
isValidEOC
=
true
;
}
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_CHOICE
:
if
(
info
.
insertAt
==
0
)
{
if
(
!
fullyValid
&&
(
info
.
childCount
==
0
)
)
{
info
.
results
[
0
]
=
true
;
info
.
results
[
1
]
=
true
;
}
}
if
(
info
.
insertAt
==
1
)
info
.
isValidEOC
=
true
;
break
;
case
XMLContentSpec
.
CONTENTSPECNODE_SEQ
:
if
(
info
.
insertAt
==
0
)
{
if
(
fullyValid
)
{
if
(
info
.
childCount
==
1
)
info
.
results
[
0
]
=
info
.
curChildren
[
0
]
.
uri
==
fSecondChild
.
uri
&&
info
.
curChildren
[
0
]
.
localpart
==
fSecondChild
.
localpart
;
}
else
{
info
.
results
[
0
]
=
true
;
}
}
else
if
(
info
.
insertAt
==
1
)
{
if
(
!
fullyValid
||
(
info
.
childCount
==
1
)
)
info
.
results
[
1
]
=
true
;
}
if
(
info
.
insertAt
==
2
)
info
.
isValidEOC
=
true
;
break
;
default
:
throw
new
CMException
(
ImplementationMessages
.
VAL_CST
)
;
}
return
-
1
;
}
public
ContentLeafNameTypeVector
getContentLeafNameTypeVector
(
)
{
return
null
;
}
}
