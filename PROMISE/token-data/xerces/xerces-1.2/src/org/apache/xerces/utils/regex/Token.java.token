package
org
.
apache
.
xerces
.
utils
.
regex
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Hashtable
;
class
Token
implements
java
.
io
.
Serializable
{
static
final
boolean
COUNTTOKENS
=
true
;
static
int
tokens
=
0
;
static
final
int
CHAR
=
0
;
static
final
int
DOT
=
11
;
static
final
int
CONCAT
=
1
;
static
final
int
UNION
=
2
;
static
final
int
CLOSURE
=
3
;
static
final
int
RANGE
=
4
;
static
final
int
NRANGE
=
5
;
static
final
int
PAREN
=
6
;
static
final
int
EMPTY
=
7
;
static
final
int
ANCHOR
=
8
;
static
final
int
NONGREEDYCLOSURE
=
9
;
static
final
int
STRING
=
10
;
static
final
int
BACKREFERENCE
=
12
;
static
final
int
LOOKAHEAD
=
20
;
static
final
int
NEGATIVELOOKAHEAD
=
21
;
static
final
int
LOOKBEHIND
=
22
;
static
final
int
NEGATIVELOOKBEHIND
=
23
;
static
final
int
INDEPENDENT
=
24
;
static
final
int
MODIFIERGROUP
=
25
;
static
final
int
CONDITION
=
26
;
static
final
int
UTF16_MAX
=
0x10ffff
;
int
type
;
static
protected
Token
token_dot
;
static
protected
Token
token_0to9
;
static
protected
Token
token_wordchars
;
static
protected
Token
token_not_0to9
;
static
protected
Token
token_not_wordchars
;
static
protected
Token
token_spaces
;
static
protected
Token
token_not_spaces
;
static
protected
Token
token_empty
;
static
protected
Token
token_linebeginning
;
static
protected
Token
token_linebeginning2
;
static
protected
Token
token_lineend
;
static
protected
Token
token_stringbeginning
;
static
protected
Token
token_stringend
;
static
protected
Token
token_stringend2
;
static
protected
Token
token_wordedge
;
static
protected
Token
token_not_wordedge
;
static
protected
Token
token_wordbeginning
;
static
protected
Token
token_wordend
;
static
{
Token
.
token_empty
=
new
Token
(
Token
.
EMPTY
)
;
Token
.
token_linebeginning
=
Token
.
createAnchor
(
'^'
)
;
Token
.
token_linebeginning2
=
Token
.
createAnchor
(
'@'
)
;
Token
.
token_lineend
=
Token
.
createAnchor
(
'$'
)
;
Token
.
token_stringbeginning
=
Token
.
createAnchor
(
'A'
)
;
Token
.
token_stringend
=
Token
.
createAnchor
(
'z'
)
;
Token
.
token_stringend2
=
Token
.
createAnchor
(
'Z'
)
;
Token
.
token_wordedge
=
Token
.
createAnchor
(
'b'
)
;
Token
.
token_not_wordedge
=
Token
.
createAnchor
(
'B'
)
;
Token
.
token_wordbeginning
=
Token
.
createAnchor
(
'<'
)
;
Token
.
token_wordend
=
Token
.
createAnchor
(
'>'
)
;
Token
.
token_dot
=
new
Token
(
Token
.
DOT
)
;
Token
.
token_0to9
=
Token
.
createRange
(
)
;
Token
.
token_0to9
.
addRange
(
'0'
,
'9'
)
;
Token
.
token_wordchars
=
Token
.
createRange
(
)
;
Token
.
token_wordchars
.
addRange
(
'0'
,
'9'
)
;
Token
.
token_wordchars
.
addRange
(
'A'
,
'Z'
)
;
Token
.
token_wordchars
.
addRange
(
'_'
,
'_'
)
;
Token
.
token_wordchars
.
addRange
(
'a'
,
'z'
)
;
Token
.
token_spaces
=
Token
.
createRange
(
)
;
Token
.
token_spaces
.
addRange
(
'\t'
,
'\t'
)
;
Token
.
token_spaces
.
addRange
(
'\n'
,
'\n'
)
;
Token
.
token_spaces
.
addRange
(
'\f'
,
'\f'
)
;
Token
.
token_spaces
.
addRange
(
'\r'
,
'\r'
)
;
Token
.
token_spaces
.
addRange
(
' '
,
' '
)
;
Token
.
token_not_0to9
=
Token
.
complementRanges
(
Token
.
token_0to9
)
;
Token
.
token_not_wordchars
=
Token
.
complementRanges
(
Token
.
token_wordchars
)
;
Token
.
token_not_spaces
=
Token
.
complementRanges
(
Token
.
token_spaces
)
;
}
static
Token
.
ParenToken
createLook
(
int
type
,
Token
child
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
ParenToken
(
type
,
child
,
0
)
;
}
static
Token
.
ParenToken
createParen
(
Token
child
,
int
pnumber
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
ParenToken
(
Token
.
PAREN
,
child
,
pnumber
)
;
}
static
Token
.
ClosureToken
createClosure
(
Token
tok
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
ClosureToken
(
Token
.
CLOSURE
,
tok
)
;
}
static
Token
.
ClosureToken
createNGClosure
(
Token
tok
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
ClosureToken
(
Token
.
NONGREEDYCLOSURE
,
tok
)
;
}
static
Token
.
ConcatToken
createConcat
(
Token
tok1
,
Token
tok2
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
ConcatToken
(
tok1
,
tok2
)
;
}
static
Token
.
UnionToken
createConcat
(
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
UnionToken
(
Token
.
CONCAT
)
;
}
static
Token
.
UnionToken
createUnion
(
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
UnionToken
(
Token
.
UNION
)
;
}
static
Token
createEmpty
(
)
{
return
Token
.
token_empty
;
}
static
RangeToken
createRange
(
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
RangeToken
(
Token
.
RANGE
)
;
}
static
RangeToken
createNRange
(
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
RangeToken
(
Token
.
NRANGE
)
;
}
static
Token
.
CharToken
createChar
(
int
ch
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
CharToken
(
Token
.
CHAR
,
ch
)
;
}
static
private
Token
.
CharToken
createAnchor
(
int
ch
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
CharToken
(
Token
.
ANCHOR
,
ch
)
;
}
static
Token
.
StringToken
createBackReference
(
int
refno
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
StringToken
(
Token
.
BACKREFERENCE
,
null
,
refno
)
;
}
static
Token
.
StringToken
createString
(
String
str
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
StringToken
(
Token
.
STRING
,
str
,
0
)
;
}
static
Token
.
ModifierToken
createModifierGroup
(
Token
child
,
int
add
,
int
mask
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
ModifierToken
(
child
,
add
,
mask
)
;
}
static
Token
.
ConditionToken
createCondition
(
int
refno
,
Token
condition
,
Token
yespat
,
Token
nopat
)
{
if
(
COUNTTOKENS
)
Token
.
tokens
++
;
return
new
Token
.
ConditionToken
(
refno
,
condition
,
yespat
,
nopat
)
;
}
protected
Token
(
int
type
)
{
this
.
type
=
type
;
}
int
size
(
)
{
return
0
;
}
Token
getChild
(
int
index
)
{
return
null
;
}
void
addChild
(
Token
tok
)
{
throw
new
RuntimeException
(
"Not supported."
)
;
}
protected
void
addRange
(
int
start
,
int
end
)
{
throw
new
RuntimeException
(
"Not supported."
)
;
}
protected
void
sortRanges
(
)
{
throw
new
RuntimeException
(
"Not supported."
)
;
}
protected
void
compactRanges
(
)
{
throw
new
RuntimeException
(
"Not supported."
)
;
}
protected
void
mergeRanges
(
Token
tok
)
{
throw
new
RuntimeException
(
"Not supported."
)
;
}
protected
void
subtractRanges
(
Token
tok
)
{
throw
new
RuntimeException
(
"Not supported."
)
;
}
protected
void
intersectRanges
(
Token
tok
)
{
throw
new
RuntimeException
(
"Not supported."
)
;
}
static
Token
complementRanges
(
Token
tok
)
{
return
RangeToken
.
complementRanges
(
tok
)
;
}
void
setMin
(
int
min
)
{
}
void
setMax
(
int
max
)
{
}
int
getMin
(
)
{
return
-
1
;
}
int
getMax
(
)
{
return
-
1
;
}
int
getReferenceNumber
(
)
{
return
0
;
}
String
getString
(
)
{
return
null
;
}
int
getParenNumber
(
)
{
return
0
;
}
int
getChar
(
)
{
return
-
1
;
}
public
String
toString
(
)
{
return
this
.
toString
(
0
)
;
}
public
String
toString
(
int
options
)
{
return
this
.
type
==
Token
.
DOT
?
"."
:
""
;
}
final
int
getMinLength
(
)
{
switch
(
this
.
type
)
{
case
CONCAT
:
int
sum
=
0
;
for
(
int
i
=
0
;
i
<
this
.
size
(
)
;
i
++
)
sum
+=
this
.
getChild
(
i
)
.
getMinLength
(
)
;
return
sum
;
case
CONDITION
:
case
UNION
:
if
(
this
.
size
(
)
==
0
)
return
0
;
int
ret
=
this
.
getChild
(
0
)
.
getMinLength
(
)
;
for
(
int
i
=
1
;
i
<
this
.
size
(
)
;
i
++
)
{
int
min
=
this
.
getChild
(
i
)
.
getMinLength
(
)
;
if
(
min
<
ret
)
ret
=
min
;
}
return
ret
;
case
CLOSURE
:
case
NONGREEDYCLOSURE
:
if
(
this
.
getMin
(
)
>=
0
)
return
this
.
getMin
(
)
*
this
.
getChild
(
0
)
.
getMinLength
(
)
;
return
0
;
case
EMPTY
:
case
ANCHOR
:
return
0
;
case
DOT
:
case
CHAR
:
case
RANGE
:
case
NRANGE
:
return
1
;
case
INDEPENDENT
:
case
PAREN
:
case
MODIFIERGROUP
:
return
this
.
getChild
(
0
)
.
getMinLength
(
)
;
case
BACKREFERENCE
:
return
0
;
case
STRING
:
return
this
.
getString
(
)
.
length
(
)
;
case
LOOKAHEAD
:
case
NEGATIVELOOKAHEAD
:
case
LOOKBEHIND
:
case
NEGATIVELOOKBEHIND
:
return
0
;
default
:
throw
new
RuntimeException
(
"Token#getMinLength(): Invalid Type: "
+
this
.
type
)
;
}
}
final
int
getMaxLength
(
)
{
switch
(
this
.
type
)
{
case
CONCAT
:
int
sum
=
0
;
for
(
int
i
=
0
;
i
<
this
.
size
(
)
;
i
++
)
{
int
d
=
this
.
getChild
(
i
)
.
getMaxLength
(
)
;
if
(
d
<
0
)
return
-
1
;
sum
+=
d
;
}
return
sum
;
case
CONDITION
:
case
UNION
:
if
(
this
.
size
(
)
==
0
)
return
0
;
int
ret
=
this
.
getChild
(
0
)
.
getMaxLength
(
)
;
for
(
int
i
=
1
;
ret
>=
0
&&
i
<
this
.
size
(
)
;
i
++
)
{
int
max
=
this
.
getChild
(
i
)
.
getMaxLength
(
)
;
if
(
max
<
0
)
{
ret
=
-
1
;
break
;
}
if
(
max
>
ret
)
ret
=
max
;
}
return
ret
;
case
CLOSURE
:
case
NONGREEDYCLOSURE
:
if
(
this
.
getMax
(
)
>=
0
)
return
this
.
getMax
(
)
*
this
.
getChild
(
0
)
.
getMaxLength
(
)
;
return
-
1
;
case
EMPTY
:
case
ANCHOR
:
return
0
;
case
CHAR
:
return
1
;
case
DOT
:
case
RANGE
:
case
NRANGE
:
return
2
;
case
INDEPENDENT
:
case
PAREN
:
case
MODIFIERGROUP
:
return
this
.
getChild
(
0
)
.
getMaxLength
(
)
;
case
BACKREFERENCE
:
return
-
1
;
case
STRING
:
return
this
.
getString
(
)
.
length
(
)
;
case
LOOKAHEAD
:
case
NEGATIVELOOKAHEAD
:
case
LOOKBEHIND
:
case
NEGATIVELOOKBEHIND
:
return
0
;
default
:
throw
new
RuntimeException
(
"Token#getMaxLength(): Invalid Type: "
+
this
.
type
)
;
}
}
static
final
int
FC_CONTINUE
=
0
;
static
final
int
FC_TERMINAL
=
1
;
static
final
int
FC_ANY
=
2
;
private
static
final
boolean
isSet
(
int
options
,
int
flag
)
{
return
(
options
&
flag
)
==
flag
;
}
final
int
analyzeFirstCharacter
(
RangeToken
result
,
int
options
)
{
switch
(
this
.
type
)
{
case
CONCAT
:
int
ret
=
FC_CONTINUE
;
for
(
int
i
=
0
;
i
<
this
.
size
(
)
;
i
++
)
if
(
(
ret
=
this
.
getChild
(
i
)
.
analyzeFirstCharacter
(
result
,
options
)
)
!=
FC_CONTINUE
)
break
;
return
ret
;
case
UNION
:
if
(
this
.
size
(
)
==
0
)
return
FC_CONTINUE
;
int
ret2
=
FC_CONTINUE
;
boolean
hasEmpty
=
false
;
for
(
int
i
=
0
;
i
<
this
.
size
(
)
;
i
++
)
{
ret2
=
this
.
getChild
(
i
)
.
analyzeFirstCharacter
(
result
,
options
)
;
if
(
ret2
==
FC_ANY
)
break
;
else
if
(
ret2
==
FC_CONTINUE
)
hasEmpty
=
true
;
}
return
hasEmpty
?
FC_CONTINUE
:
ret2
;
case
CONDITION
:
int
ret3
=
this
.
getChild
(
0
)
.
analyzeFirstCharacter
(
result
,
options
)
;
if
(
this
.
size
(
)
==
1
)
return
FC_CONTINUE
;
if
(
ret3
==
FC_ANY
)
return
ret3
;
int
ret4
=
this
.
getChild
(
1
)
.
analyzeFirstCharacter
(
result
,
options
)
;
if
(
ret4
==
FC_ANY
)
return
ret4
;
return
ret3
==
FC_CONTINUE
||
ret4
==
FC_CONTINUE
?
FC_CONTINUE
:
FC_TERMINAL
;
case
CLOSURE
:
case
NONGREEDYCLOSURE
:
this
.
getChild
(
0
)
.
analyzeFirstCharacter
(
result
,
options
)
;
return
FC_CONTINUE
;
case
EMPTY
:
case
ANCHOR
:
return
FC_CONTINUE
;
case
CHAR
:
int
ch
=
this
.
getChar
(
)
;
result
.
addRange
(
ch
,
ch
)
;
if
(
ch
<
0x10000
&&
isSet
(
options
,
RegularExpression
.
IGNORE_CASE
)
)
{
ch
=
Character
.
toUpperCase
(
(
char
)
ch
)
;
result
.
addRange
(
ch
,
ch
)
;
ch
=
Character
.
toLowerCase
(
(
char
)
ch
)
;
result
.
addRange
(
ch
,
ch
)
;
}
return
FC_TERMINAL
;
case
DOT
:
if
(
isSet
(
options
,
RegularExpression
.
SINGLE_LINE
)
)
{
return
FC_CONTINUE
;
}
else
{
return
FC_CONTINUE
;
}
case
RANGE
:
if
(
isSet
(
options
,
RegularExpression
.
IGNORE_CASE
)
)
{
result
.
mergeRanges
(
(
(
RangeToken
)
this
)
.
getCaseInsensitiveToken
(
)
)
;
}
else
{
result
.
mergeRanges
(
this
)
;
}
return
FC_TERMINAL
;
case
NRANGE
:
if
(
isSet
(
options
,
RegularExpression
.
IGNORE_CASE
)
)
{
result
.
mergeRanges
(
Token
.
complementRanges
(
(
(
RangeToken
)
this
)
.
getCaseInsensitiveToken
(
)
)
)
;
}
else
{
result
.
mergeRanges
(
Token
.
complementRanges
(
this
)
)
;
}
return
FC_TERMINAL
;
case
INDEPENDENT
:
case
PAREN
:
return
this
.
getChild
(
0
)
.
analyzeFirstCharacter
(
result
,
options
)
;
case
MODIFIERGROUP
:
options
|=
(
(
ModifierToken
)
this
)
.
getOptions
(
)
;
options
&=
~
(
(
ModifierToken
)
this
)
.
getOptionsMask
(
)
;
return
this
.
getChild
(
0
)
.
analyzeFirstCharacter
(
result
,
options
)
;
case
BACKREFERENCE
:
result
.
addRange
(
0
,
UTF16_MAX
)
;
return
FC_ANY
;
case
STRING
:
int
cha
=
this
.
getString
(
)
.
charAt
(
0
)
;
int
ch2
;
if
(
REUtil
.
isHighSurrogate
(
cha
)
&&
this
.
getString
(
)
.
length
(
)
>=
2
&&
REUtil
.
isLowSurrogate
(
(
ch2
=
this
.
getString
(
)
.
charAt
(
1
)
)
)
)
cha
=
REUtil
.
composeFromSurrogates
(
cha
,
ch2
)
;
result
.
addRange
(
cha
,
cha
)
;
if
(
cha
<
0x10000
&&
isSet
(
options
,
RegularExpression
.
IGNORE_CASE
)
)
{
cha
=
Character
.
toUpperCase
(
(
char
)
cha
)
;
result
.
addRange
(
cha
,
cha
)
;
cha
=
Character
.
toLowerCase
(
(
char
)
cha
)
;
result
.
addRange
(
cha
,
cha
)
;
}
return
FC_TERMINAL
;
case
LOOKAHEAD
:
case
NEGATIVELOOKAHEAD
:
case
LOOKBEHIND
:
case
NEGATIVELOOKBEHIND
:
return
FC_CONTINUE
;
default
:
throw
new
RuntimeException
(
"Token#analyzeHeadCharacter(): Invalid Type: "
+
this
.
type
)
;
}
}
private
final
boolean
isShorterThan
(
Token
tok
)
{
if
(
tok
==
null
)
return
false
;
int
mylength
;
if
(
this
.
type
==
STRING
)
mylength
=
this
.
getString
(
)
.
length
(
)
;
else
throw
new
RuntimeException
(
"Internal Error: Illegal type: "
+
this
.
type
)
;
int
otherlength
;
if
(
tok
.
type
==
STRING
)
otherlength
=
tok
.
getString
(
)
.
length
(
)
;
else
throw
new
RuntimeException
(
"Internal Error: Illegal type: "
+
tok
.
type
)
;
return
mylength
<
otherlength
;
}
static
class
FixedStringContainer
{
Token
token
=
null
;
int
options
=
0
;
FixedStringContainer
(
)
{
}
}
final
void
findFixedString
(
FixedStringContainer
container
,
int
options
)
{
switch
(
this
.
type
)
{
case
CONCAT
:
Token
prevToken
=
null
;
int
prevOptions
=
0
;
for
(
int
i
=
0
;
i
<
this
.
size
(
)
;
i
++
)
{
this
.
getChild
(
i
)
.
findFixedString
(
container
,
options
)
;
if
(
prevToken
==
null
||
prevToken
.
isShorterThan
(
container
.
token
)
)
{
prevToken
=
container
.
token
;
prevOptions
=
container
.
options
;
}
}
container
.
token
=
prevToken
;
container
.
options
=
prevOptions
;
return
;
case
UNION
:
case
CLOSURE
:
case
NONGREEDYCLOSURE
:
case
EMPTY
:
case
ANCHOR
:
case
RANGE
:
case
DOT
:
case
NRANGE
:
case
BACKREFERENCE
:
case
LOOKAHEAD
:
case
NEGATIVELOOKAHEAD
:
case
LOOKBEHIND
:
case
NEGATIVELOOKBEHIND
:
case
CONDITION
:
container
.
token
=
null
;
return
;
case
CHAR
:
container
.
token
=
null
;
return
;
case
STRING
:
container
.
token
=
this
;
container
.
options
=
options
;
return
;
case
INDEPENDENT
:
case
PAREN
:
this
.
getChild
(
0
)
.
findFixedString
(
container
,
options
)
;
return
;
case
MODIFIERGROUP
:
options
|=
(
(
ModifierToken
)
this
)
.
getOptions
(
)
;
options
&=
~
(
(
ModifierToken
)
this
)
.
getOptionsMask
(
)
;
this
.
getChild
(
0
)
.
findFixedString
(
container
,
options
)
;
return
;
default
:
throw
new
RuntimeException
(
"Token#findFixedString(): Invalid Type: "
+
this
.
type
)
;
}
}
boolean
match
(
int
ch
)
{
throw
new
RuntimeException
(
"NFAArrow#match(): Internal error: "
+
this
.
type
)
;
}
static
protected
Hashtable
categories
=
new
Hashtable
(
)
;
static
protected
Hashtable
categories2
=
null
;
static
final
String
[
]
categoryNames
=
{
"Cn"
,
"Lu"
,
"Ll"
,
"Lt"
,
"Lm"
,
"Lo"
,
"Mn"
,
"Me"
,
"Mc"
,
"Nd"
,
"Nl"
,
"No"
,
"Zs"
,
"Zl"
,
"Zp"
,
"Cc"
,
"Cf"
,
null
,
"Co"
,
"Cs"
,
"Pd"
,
"Ps"
,
"Pe"
,
"Pc"
,
"Po"
,
"Sm"
,
"Sc"
,
"Sk"
,
"So"
,
"L"
,
"M"
,
"N"
,
"Z"
,
"C"
,
"P"
,
"S"
,
}
;
static
final
int
CHAR_LETTER
=
29
;
static
final
int
CHAR_MARK
=
30
;
static
final
int
CHAR_NUMBER
=
31
;
static
final
int
CHAR_SEPARATOR
=
32
;
static
final
int
CHAR_OTHER
=
33
;
static
final
int
CHAR_PUNCTUATION
=
34
;
static
final
int
CHAR_SYMBOL
=
35
;
static
final
String
[
]
blockNames
=
{
"Basic Latin"
,
"Latin-1 Supplement"
,
"Latin Extended-A"
,
"Latin Extended-B"
,
"IPA Extensions"
,
"Spacing Modifier Letters"
,
"Combining Diacritical Marks"
,
"Greek"
,
"Cyrillic"
,
"Armenian"
,
"Hebrew"
,
"Arabic"
,
"Devanagari"
,
"Bengali"
,
"Gurmukhi"
,
"Gujarati"
,
"Oriya"
,
"Tamil"
,
"Telugu"
,
"Kannada"
,
"Malayalam"
,
"Thai"
,
"Lao"
,
"Tibetan"
,
"Georgian"
,
"Hangul Jamo"
,
"Latin Extended Additional"
,
"Greek Extended"
,
"General Punctuation"
,
"Superscripts and Subscripts"
,
"Currency Symbols"
,
"Combining Marks for Symbols"
,
"Letterlike Symbols"
,
"Number Forms"
,
"Arrows"
,
"Mathematical Operators"
,
"Miscellaneous Technical"
,
"Control Pictures"
,
"Optical Character Recognition"
,
"Enclosed Alphanumerics"
,
"Box Drawing"
,
"Block Elements"
,
"Geometric Shapes"
,
"Miscellaneous Symbols"
,
"Dingbats"
,
"CJK Symbols and Punctuation"
,
"Hiragana"
,
"Katakana"
,
"Bopomofo"
,
"Hangul Compatibility Jamo"
,
"Kanbun"
,
"Enclosed CJK Letters and Months"
,
"CJK Compatibility"
,
"CJK Unified Ideographs"
,
"Hangul Syllables"
,
"High Surrogates"
,
"High Private Use Surrogates"
,
"Low Surrogates"
,
"Private Use"
,
"CJK Compatibility Ideographs"
,
"Alphabetic Presentation Forms"
,
"Arabic Presentation Forms-A"
,
"Combining Half Marks"
,
"CJK Compatibility Forms"
,
"Small Form Variants"
,
"Arabic Presentation Forms-B"
,
"Specials"
,
"Halfwidth and Fullwidth Forms"
,
}
;
static
final
String
blockRanges
=
" ÿĀſƀɏɐʯʰ˿"
+
"̀ͯͰϿЀӿ԰֏֐׿؀ۿ"
+
"ऀॿঀ৿਀੿઀૿଀୿஀௿"
+
"ఀ౿ಀ೿ഀൿ฀๿຀໿ༀ྿"
+
"ႠჿᄀᇿḀỿἀ῿ ⁯⁰₟"
+
"₠⃏⃐⃿℀⅏⅐↏←⇿∀⋿"
+
"⌀⏿␀␿⑀⑟①⓿─╿▀▟"
+
"■◿☀⛿✀➿　〿぀ゟ゠ヿ"
+
"㄀ㄯ㄰㆏㆐㆟㈀㋿㌀㏿一鿿"
+
