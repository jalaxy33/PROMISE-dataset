package
org
.
apache
.
xerces
.
dom
;
import
java
.
io
.
*
;
import
java
.
util
.
Vector
;
import
org
.
w3c
.
dom
.
*
;
import
org
.
apache
.
xerces
.
dom
.
events
.
EventImpl
;
import
org
.
apache
.
xerces
.
dom
.
events
.
MutationEventImpl
;
import
org
.
w3c
.
dom
.
events
.
*
;
public
abstract
class
NodeImpl
implements
Node
,
NodeList
,
EventTarget
,
Cloneable
,
Serializable
{
static
final
long
serialVersionUID
=
-
6316591992167219696L
;
public
static
final
short
ELEMENT_DEFINITION_NODE
=
-
1
;
protected
NodeImpl
ownerNode
;
protected
short
flags
;
protected
final
static
short
READONLY
=
0x1
<<
0
;
protected
final
static
short
SYNCDATA
=
0x1
<<
1
;
protected
final
static
short
SYNCCHILDREN
=
0x1
<<
2
;
protected
final
static
short
OWNED
=
0x1
<<
3
;
protected
final
static
short
FIRSTCHILD
=
0x1
<<
4
;
protected
final
static
short
SPECIFIED
=
0x1
<<
5
;
protected
final
static
short
IGNORABLEWS
=
0x1
<<
6
;
protected
final
static
short
SETVALUE
=
0x1
<<
7
;
protected
NodeImpl
(
DocumentImpl
ownerDocument
)
{
ownerNode
=
ownerDocument
;
}
public
NodeImpl
(
)
{
}
public
abstract
short
getNodeType
(
)
;
public
abstract
String
getNodeName
(
)
;
public
String
getNodeValue
(
)
{
return
null
;
}
public
void
setNodeValue
(
String
x
)
throws
DOMException
{
}
public
Node
appendChild
(
Node
newChild
)
throws
DOMException
{
return
insertBefore
(
newChild
,
null
)
;
}
public
Node
cloneNode
(
boolean
deep
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
NodeImpl
newnode
;
try
{
newnode
=
(
NodeImpl
)
clone
(
)
;
}
catch
(
CloneNotSupportedException
e
)
{
return
null
;
}
newnode
.
ownerNode
=
ownerDocument
(
)
;
newnode
.
isOwned
(
false
)
;
newnode
.
isReadOnly
(
false
)
;
return
newnode
;
}
public
Document
getOwnerDocument
(
)
{
if
(
isOwned
(
)
)
{
return
ownerNode
.
ownerDocument
(
)
;
}
else
{
return
(
Document
)
ownerNode
;
}
}
DocumentImpl
ownerDocument
(
)
{
if
(
isOwned
(
)
)
{
return
ownerNode
.
ownerDocument
(
)
;
}
else
{
return
(
DocumentImpl
)
ownerNode
;
}
}
void
setOwnerDocument
(
DocumentImpl
doc
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
if
(
!
isOwned
(
)
)
{
ownerNode
=
doc
;
}
}
public
Node
getParentNode
(
)
{
return
null
;
}
NodeImpl
parentNode
(
)
{
return
null
;
}
public
Node
getNextSibling
(
)
{
return
null
;
}
public
Node
getPreviousSibling
(
)
{
return
null
;
}
ChildNode
previousSibling
(
)
{
return
null
;
}
public
NamedNodeMap
getAttributes
(
)
{
return
null
;
}
public
boolean
hasAttributes
(
)
{
return
false
;
}
public
boolean
hasChildNodes
(
)
{
return
false
;
}
public
NodeList
getChildNodes
(
)
{
return
this
;
}
public
Node
getFirstChild
(
)
{
return
null
;
}
public
Node
getLastChild
(
)
{
return
null
;
}
public
Node
insertBefore
(
Node
newChild
,
Node
refChild
)
throws
DOMException
{
throw
new
DOMExceptionImpl
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
public
Node
removeChild
(
Node
oldChild
)
throws
DOMException
{
throw
new
DOMExceptionImpl
(
DOMException
.
NOT_FOUND_ERR
,
"DOM008 Not found"
)
;
}
public
Node
replaceChild
(
Node
newChild
,
Node
oldChild
)
throws
DOMException
{
throw
new
DOMExceptionImpl
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
public
int
getLength
(
)
{
return
0
;
}
public
Node
item
(
int
index
)
{
return
null
;
}
public
void
normalize
(
)
{
}
public
boolean
supports
(
String
feature
,
String
version
)
{
return
ownerDocument
(
)
.
getImplementation
(
)
.
hasFeature
(
feature
,
version
)
;
}
public
String
getNamespaceURI
(
)
{
return
null
;
}
public
String
getPrefix
(
)
{
return
null
;
}
public
void
setPrefix
(
String
prefix
)
throws
DOMException
{
throw
new
DOMExceptionImpl
(
DOMException
.
NAMESPACE_ERR
,
"DOM003 Namespace error"
)
;
}
public
String
getLocalName
(
)
{
return
null
;
}
protected
final
static
boolean
MUTATIONEVENTS
=
true
;
protected
final
static
int
MUTATION_NONE
=
0x00
;
protected
final
static
int
MUTATION_LOCAL
=
0x01
;
protected
final
static
int
MUTATION_AGGREGATE
=
0x02
;
protected
final
static
int
MUTATION_ALL
=
0xffff
;
class
LEntry
{
String
type
;
EventListener
listener
;
boolean
useCapture
;
LEntry
(
String
type
,
EventListener
listener
,
boolean
useCapture
)
{
this
.
type
=
type
;
this
.
listener
=
listener
;
this
.
useCapture
=
useCapture
;
}
}
;
public
void
addEventListener
(
String
type
,
EventListener
listener
,
boolean
useCapture
)
{
if
(
type
==
null
||
type
.
equals
(
""
)
||
listener
==
null
)
return
;
removeEventListener
(
type
,
listener
,
useCapture
)
;
Vector
nodeListeners
=
ownerDocument
(
)
.
getEventListeners
(
this
)
;
if
(
nodeListeners
==
null
)
{
nodeListeners
=
new
Vector
(
)
;
ownerDocument
(
)
.
setEventListeners
(
this
,
nodeListeners
)
;
}
nodeListeners
.
addElement
(
new
LEntry
(
type
,
listener
,
useCapture
)
)
;
LCount
lc
=
LCount
.
lookup
(
type
)
;
if
(
useCapture
)
++
lc
.
captures
;
else
++
lc
.
bubbles
;
}
public
void
removeEventListener
(
String
type
,
EventListener
listener
,
boolean
useCapture
)
{
Vector
nodeListeners
=
ownerDocument
(
)
.
getEventListeners
(
this
)
;
if
(
nodeListeners
==
null
||
type
==
null
||
type
.
equals
(
""
)
||
listener
==
null
)
return
;
for
(
int
i
=
nodeListeners
.
size
(
)
-
1
;
i
>=
0
;
--
i
)
{
LEntry
le
=
(
LEntry
)
(
nodeListeners
.
elementAt
(
i
)
)
;
if
(
le
.
useCapture
==
useCapture
&&
le
.
listener
==
listener
&&
le
.
type
.
equals
(
type
)
)
{
nodeListeners
.
removeElementAt
(
i
)
;
if
(
nodeListeners
.
size
(
)
==
0
)
ownerDocument
(
)
.
setEventListeners
(
this
,
null
)
;
LCount
lc
=
LCount
.
lookup
(
type
)
;
if
(
useCapture
)
--
lc
.
captures
;
else
--
lc
.
bubbles
;
break
;
}
}
}
public
boolean
dispatchEvent
(
Event
event
)
{
if
(
event
==
null
)
return
false
;
EventImpl
evt
=
(
EventImpl
)
event
;
if
(
!
evt
.
initialized
||
evt
.
type
==
null
||
evt
.
type
.
equals
(
""
)
)
throw
new
DOMExceptionImpl
(
DOMExceptionImpl
.
UNSPECIFIED_EVENT_TYPE
,
"DOM010 Unspecified event type"
)
;
LCount
lc
=
LCount
.
lookup
(
evt
.
getType
(
)
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
==
0
)
return
evt
.
preventDefault
;
evt
.
target
=
this
;
evt
.
stopPropagation
=
false
;
evt
.
preventDefault
=
false
;
Vector
pv
=
new
Vector
(
10
,
10
)
;
Node
p
=
this
,
n
=
p
.
getParentNode
(
)
;
while
(
n
!=
null
)
{
pv
.
addElement
(
n
)
;
p
=
n
;
n
=
n
.
getParentNode
(
)
;
}
if
(
lc
.
captures
>
0
)
{
evt
.
eventPhase
=
Event
.
CAPTURING_PHASE
;
for
(
int
j
=
pv
.
size
(
)
-
1
;
j
>=
0
;
--
j
)
{
if
(
evt
.
stopPropagation
)
break
;
NodeImpl
nn
=
(
NodeImpl
)
pv
.
elementAt
(
j
)
;
evt
.
currentNode
=
nn
;
Vector
nodeListeners
=
ownerDocument
(
)
.
getEventListeners
(
nn
)
;
if
(
nodeListeners
!=
null
)
{
Vector
nl
=
(
Vector
)
(
nodeListeners
.
clone
(
)
)
;
for
(
int
i
=
nl
.
size
(
)
-
1
;
i
>=
0
;
--
i
)
{
LEntry
le
=
(
LEntry
)
(
nl
.
elementAt
(
i
)
)
;
if
(
le
.
useCapture
&&
le
.
type
.
equals
(
evt
.
type
)
)
try
{
le
.
listener
.
handleEvent
(
evt
)
;
}
catch
(
Exception
e
)
{
}
}
}
}
}
if
(
lc
.
bubbles
>
0
)
{
evt
.
eventPhase
=
Event
.
AT_TARGET
;
evt
.
currentNode
=
this
;
Vector
nodeListeners
=
ownerDocument
(
)
.
getEventListeners
(
this
)
;
if
(
!
evt
.
stopPropagation
&&
nodeListeners
!=
null
)
{
Vector
nl
=
(
Vector
)
nodeListeners
.
clone
(
)
;
for
(
int
i
=
nl
.
size
(
)
-
1
;
i
>=
0
;
--
i
)
{
LEntry
le
=
(
LEntry
)
nl
.
elementAt
(
i
)
;
if
(
le
!=
null
&&
!
le
.
useCapture
&&
le
.
type
.
equals
(
evt
.
type
)
)
try
{
le
.
listener
.
handleEvent
(
evt
)
;
}
catch
(
Exception
e
)
{
}
}
}
if
(
evt
.
bubbles
)
{
evt
.
eventPhase
=
Event
.
BUBBLING_PHASE
;
for
(
int
j
=
0
;
j
<
pv
.
size
(
)
;
++
j
)
{
if
(
evt
.
stopPropagation
)
break
;
NodeImpl
nn
=
(
NodeImpl
)
pv
.
elementAt
(
j
)
;
evt
.
currentNode
=
nn
;
nodeListeners
=
ownerDocument
(
)
.
getEventListeners
(
nn
)
;
if
(
nodeListeners
!=
null
)
{
Vector
nl
=
(
Vector
)
(
nodeListeners
.
clone
(
)
)
;
for
(
int
i
=
nl
.
size
(
)
-
1
;
i
>=
0
;
--
i
)
{
LEntry
le
=
(
LEntry
)
(
nl
.
elementAt
(
i
)
)
;
if
(
!
le
.
useCapture
&&
le
.
type
.
equals
(
evt
.
type
)
)
try
{
le
.
listener
.
handleEvent
(
evt
)
;
}
catch
(
Exception
e
)
{
}
}
}
}
}
}
if
(
lc
.
defaults
>
0
&&
(
!
evt
.
cancelable
||
!
evt
.
preventDefault
)
)
{
}
return
evt
.
preventDefault
;
}
void
dispatchEventToSubtree
(
Node
n
,
Event
e
)
{
if
(
MUTATIONEVENTS
&&
ownerDocument
(
)
.
mutationEvents
)
{
Vector
nodeListeners
=
ownerDocument
(
)
.
getEventListeners
(
this
)
;
if
(
nodeListeners
==
null
||
n
==
null
)
return
;
(
(
NodeImpl
)
n
)
.
dispatchEvent
(
e
)
;
if
(
n
.
getNodeType
(
)
==
Node
.
ELEMENT_NODE
)
{
NamedNodeMap
a
=
n
.
getAttributes
(
)
;
for
(
int
i
=
a
.
getLength
(
)
-
1
;
i
>=
0
;
--
i
)
dispatchEventToSubtree
(
a
.
item
(
i
)
,
e
)
;
}
dispatchEventToSubtree
(
n
.
getFirstChild
(
)
,
e
)
;
dispatchEventToSubtree
(
n
.
getNextSibling
(
)
,
e
)
;
}
}
class
EnclosingAttr
{
AttrImpl
node
;
String
oldvalue
;
}
EnclosingAttr
getEnclosingAttr
(
)
{
if
(
MUTATIONEVENTS
&&
ownerDocument
(
)
.
mutationEvents
)
{
NodeImpl
eventAncestor
=
this
;
while
(
true
)
{
if
(
eventAncestor
==
null
)
return
null
;
int
type
=
eventAncestor
.
getNodeType
(
)
;
if
(
type
==
Node
.
ATTRIBUTE_NODE
)
{
EnclosingAttr
retval
=
new
EnclosingAttr
(
)
;
retval
.
node
=
(
AttrImpl
)
eventAncestor
;
retval
.
oldvalue
=
retval
.
node
.
getNodeValue
(
)
;
return
retval
;
}
else
if
(
type
==
Node
.
ENTITY_REFERENCE_NODE
)
eventAncestor
=
eventAncestor
.
parentNode
(
)
;
else
return
null
;
}
}
return
null
;
}
void
dispatchAggregateEvents
(
EnclosingAttr
ea
)
{
if
(
ea
!=
null
)
dispatchAggregateEvents
(
ea
.
node
,
ea
.
oldvalue
)
;
else
dispatchAggregateEvents
(
null
,
null
)
;
}
void
dispatchAggregateEvents
(
AttrImpl
enclosingAttr
,
String
oldvalue
)
{
if
(
MUTATIONEVENTS
&&
ownerDocument
(
)
.
mutationEvents
)
{
Vector
nodeListeners
=
ownerDocument
(
)
.
getEventListeners
(
this
)
;
if
(
nodeListeners
==
null
)
return
;
NodeImpl
owner
=
null
;
if
(
enclosingAttr
!=
null
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
owner
=
(
(
NodeImpl
)
(
enclosingAttr
.
getOwnerElement
(
)
)
)
;
if
(
owner
!=
null
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
,
true
,
false
,
null
,
oldvalue
,
enclosingAttr
.
getNodeValue
(
)
,
enclosingAttr
.
getNodeName
(
)
)
;
owner
.
dispatchEvent
(
me
)
;
}
}
}
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_SUBTREE_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_SUBTREE_MODIFIED
,
true
,
false
,
null
,
null
,
null
,
null
)
;
if
(
enclosingAttr
!=
null
)
{
enclosingAttr
.
dispatchEvent
(
me
)
;
if
(
owner
!=
null
)
owner
.
dispatchEvent
(
me
)
;
}
else
dispatchEvent
(
me
)
;
}
}
}
public
void
setReadOnly
(
boolean
readOnly
,
boolean
deep
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
isReadOnly
(
readOnly
)
;
}
public
boolean
getReadOnly
(
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
return
isReadOnly
(
)
;
}
public
void
setUserData
(
Object
data
)
{
ownerDocument
(
)
.
setUserData
(
this
,
data
)
;
}
public
Object
getUserData
(
)
{
return
ownerDocument
(
)
.
getUserData
(
this
)
;
}
protected
void
changed
(
)
{
ownerDocument
(
)
.
changed
(
)
;
}
protected
int
changes
(
)
{
return
ownerDocument
(
)
.
changes
(
)
;
}
protected
void
synchronizeData
(
)
{
needsSyncData
(
false
)
;
}
final
boolean
isReadOnly
(
)
{
return
(
flags
&
READONLY
)
!=
0
;
}
final
void
isReadOnly
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
READONLY
:
flags
&
~
READONLY
)
;
}
final
boolean
needsSyncData
(
)
{
return
(
flags
&
SYNCDATA
)
!=
0
;
}
final
void
needsSyncData
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
SYNCDATA
:
flags
&
~
SYNCDATA
)
;
}
final
boolean
needsSyncChildren
(
)
{
return
(
flags
&
SYNCCHILDREN
)
!=
0
;
}
final
void
needsSyncChildren
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
SYNCCHILDREN
:
flags
&
~
SYNCCHILDREN
)
;
}
final
boolean
isOwned
(
)
{
return
(
flags
&
OWNED
)
!=
0
;
}
final
void
isOwned
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
OWNED
:
flags
&
~
OWNED
)
;
}
final
boolean
isFirstChild
(
)
{
return
(
flags
&
FIRSTCHILD
)
!=
0
;
}
final
void
isFirstChild
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
FIRSTCHILD
:
flags
&
~
FIRSTCHILD
)
;
}
final
boolean
isSpecified
(
)
{
return
(
flags
&
SPECIFIED
)
!=
0
;
}
final
void
isSpecified
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
SPECIFIED
:
flags
&
~
SPECIFIED
)
;
}
final
boolean
internalIsIgnorableWhitespace
(
)
{
return
(
flags
&
IGNORABLEWS
)
!=
0
;
}
final
void
isIgnorableWhitespace
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
IGNORABLEWS
:
flags
&
~
IGNORABLEWS
)
;
}
final
boolean
setValueCalled
(
)
{
return
(
flags
&
SETVALUE
)
!=
0
;
}
final
void
setValueCalled
(
boolean
value
)
{
flags
=
(
short
)
(
value
?
flags
|
SETVALUE
:
flags
&
~
SETVALUE
)
;
}
public
String
toString
(
)
{
return
"["
+
getNodeName
(
)
+
": "
+
getNodeValue
(
)
+
"]"
;
}
private
void
writeObject
(
ObjectOutputStream
out
)
throws
IOException
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
out
.
defaultWriteObject
(
)
;
}
}
