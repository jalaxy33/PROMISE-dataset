package
org
.
apache
.
xerces
.
utils
;
import
org
.
apache
.
xerces
.
readers
.
XMLEntityHandler
;
public
final
class
CharDataChunk
implements
StringPool
.
StringProducer
{
public
static
final
int
CHUNK_SHIFT
=
14
;
public
static
final
int
CHUNK_SIZE
=
(
1
<<
CHUNK_SHIFT
)
;
public
static
final
int
CHUNK_MASK
=
CHUNK_SIZE
-
1
;
public
static
CharDataChunk
createChunk
(
StringPool
stringPool
,
CharDataChunk
prev
)
{
CharDataChunk
newChunk
=
null
;
synchronized
(
CharDataChunk
.
class
)
{
newChunk
=
fgFreeChunks
;
if
(
newChunk
!=
null
)
{
fgFreeChunks
=
newChunk
.
fNextChunk
;
}
else
{
newChunk
=
new
CharDataChunk
(
)
;
}
}
newChunk
.
fStringPool
=
stringPool
;
newChunk
.
fRefCount
=
1
;
newChunk
.
fChunk
=
prev
==
null
?
0
:
prev
.
fChunk
+
1
;
newChunk
.
fNextChunk
=
null
;
newChunk
.
fPreviousChunk
=
prev
;
if
(
prev
!=
null
)
{
prev
.
setNextChunk
(
newChunk
)
;
}
return
newChunk
;
}
public
CharDataChunk
chunkFor
(
int
offset
)
{
int
firstChunk
=
offset
>
>
CHUNK_SHIFT
;
if
(
firstChunk
==
fChunk
)
return
this
;
CharDataChunk
dataChunk
=
fPreviousChunk
;
while
(
firstChunk
!=
dataChunk
.
fChunk
)
dataChunk
=
dataChunk
.
fPreviousChunk
;
return
dataChunk
;
}
public
char
[
]
toCharArray
(
)
{
return
fData
;
}
public
void
setCharArray
(
char
[
]
data
)
{
fData
=
data
;
}
public
CharDataChunk
nextChunk
(
)
{
return
fNextChunk
;
}
public
boolean
clearPreviousChunk
(
)
{
if
(
fPreviousChunk
!=
null
)
{
fPreviousChunk
.
clearNextChunk
(
)
;
fPreviousChunk
.
removeRef
(
)
;
fPreviousChunk
=
null
;
return
true
;
}
return
false
;
}
public
void
releaseChunk
(
)
{
removeRef
(
)
;
}
public
int
addString
(
int
offset
,
int
length
)
{
int
chunk
=
offset
>
>
CHUNK_SHIFT
;
if
(
chunk
!=
fChunk
)
{
if
(
fPreviousChunk
==
null
)
throw
new
RuntimeException
(
new
ImplementationMessages
(
)
.
createMessage
(
null
,
ImplementationMessages
.
INT_PCN
,
0
,
null
)
)
;
return
fPreviousChunk
.
addString
(
offset
,
length
)
;
}
int
lastChunk
=
(
offset
+
length
-
1
)
>
>
CHUNK_SHIFT
;
if
(
chunk
==
lastChunk
)
{
addRef
(
)
;
return
fStringPool
.
addString
(
this
,
offset
&
CHUNK_MASK
,
length
)
;
}
String
str
=
toString
(
offset
&
CHUNK_MASK
,
length
)
;
return
fStringPool
.
addString
(
str
)
;
}
public
int
addSymbol
(
int
offset
,
int
length
,
int
hashcode
)
{
int
chunk
=
offset
>
>
CHUNK_SHIFT
;
if
(
chunk
!=
fChunk
)
{
if
(
fPreviousChunk
==
null
)
throw
new
RuntimeException
(
new
ImplementationMessages
(
)
.
createMessage
(
null
,
ImplementationMessages
.
INT_PCN
,
0
,
null
)
)
;
return
fPreviousChunk
.
addSymbol
(
offset
,
length
,
hashcode
)
;
}
int
lastChunk
=
(
offset
+
length
-
1
)
>
>
CHUNK_SHIFT
;
int
index
=
offset
&
CHUNK_MASK
;
if
(
chunk
==
lastChunk
)
{
if
(
hashcode
==
0
)
hashcode
=
StringHasher
.
hashChars
(
fData
,
index
,
length
)
;
int
symbol
=
fStringPool
.
lookupSymbol
(
this
,
offset
&
CHUNK_MASK
,
length
,
hashcode
)
;
if
(
symbol
==
-
1
)
{
String
str
=
toString
(
offset
&
CHUNK_MASK
,
length
)
;
symbol
=
fStringPool
.
addNewSymbol
(
str
,
hashcode
)
;
}
return
symbol
;
}
String
str
=
toString
(
offset
&
CHUNK_MASK
,
length
)
;
return
fStringPool
.
addSymbol
(
str
)
;
}
public
void
append
(
XMLEntityHandler
.
CharBuffer
charBuffer
,
int
offset
,
int
length
)
{
CharDataChunk
dataChunk
=
chunkFor
(
offset
)
;
int
index
=
offset
&
CHUNK_MASK
;
int
nbytes
=
(
index
+
length
<=
CHUNK_SIZE
)
?
length
:
CHUNK_SIZE
-
index
;
while
(
true
)
{
charBuffer
.
append
(
dataChunk
.
fData
,
index
,
nbytes
)
;
length
-=
nbytes
;
if
(
length
==
0
)
break
;
dataChunk
=
dataChunk
.
fNextChunk
;
index
=
0
;
nbytes
=
length
<=
CHUNK_SIZE
?
length
:
CHUNK_SIZE
;
}
}
public
String
toString
(
int
offset
,
int
length
)
{
if
(
offset
+
length
<=
CHUNK_SIZE
)
{
return
new
String
(
fData
,
offset
,
length
)
;
}
StringBuffer
sb
=
new
StringBuffer
(
length
)
;
int
nbytes
=
CHUNK_SIZE
-
offset
;
sb
.
append
(
fData
,
offset
,
nbytes
)
;
length
-=
nbytes
;
CharDataChunk
aChunk
=
fNextChunk
;
do
{
nbytes
=
length
<=
CHUNK_SIZE
?
length
:
CHUNK_SIZE
;
sb
.
append
(
aChunk
.
fData
,
0
,
nbytes
)
;
length
-=
nbytes
;
aChunk
=
aChunk
.
fNextChunk
;
}
while
(
length
>
0
)
;
String
retval
=
sb
.
toString
(
)
;
sb
=
null
;
return
retval
;
}
public
void
releaseString
(
int
offset
,
int
length
)
{
removeRef
(
)
;
}
public
boolean
equalsString
(
int
offset
,
int
length
,
char
[
]
strChars
,
int
strOffset
,
int
strLength
)
{
if
(
length
!=
strLength
)
return
false
;
if
(
offset
+
length
<=
CHUNK_SIZE
)
{
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
if
(
fData
[
offset
++
]
!=
strChars
[
strOffset
++
]
)
return
false
;
}
return
true
;
}
int
nbytes
=
CHUNK_SIZE
-
offset
;
length
-=
nbytes
;
while
(
nbytes
--
>
0
)
{
if
(
fData
[
offset
++
]
!=
strChars
[
strOffset
++
]
)
return
false
;
}
CharDataChunk
aChunk
=
fNextChunk
;
do
{
offset
=
0
;
nbytes
=
length
<=
CHUNK_SIZE
?
length
:
CHUNK_SIZE
;
length
-=
nbytes
;
while
(
nbytes
--
>
0
)
{
if
(
aChunk
.
fData
[
offset
++
]
!=
strChars
[
strOffset
++
]
)
return
false
;
}
aChunk
=
aChunk
.
fNextChunk
;
}
while
(
length
>
0
)
;
return
true
;
}
private
CharDataChunk
(
)
{
}
private
void
addRef
(
)
{
fRefCount
++
;
}
private
void
removeRef
(
)
{
fRefCount
--
;
if
(
fRefCount
==
0
)
{
fStringPool
=
null
;
fChunk
=
-
1
;
fPreviousChunk
=
null
;
synchronized
(
CharDataChunk
.
class
)
{
fNextChunk
=
null
;
fgFreeChunks
=
this
;
}
}
}
private
void
clearNextChunk
(
)
{
if
(
fNextChunk
!=
null
)
fNextChunk
.
removeRef
(
)
;
fNextChunk
=
null
;
}
private
void
setNextChunk
(
CharDataChunk
nextChunk
)
{
if
(
fNextChunk
!=
null
)
{
throw
new
RuntimeException
(
"CharDataChunk::setNextChunk"
)
;
}
nextChunk
.
addRef
(
)
;
fNextChunk
=
nextChunk
;
}
private
StringPool
fStringPool
;
private
int
fRefCount
;
private
int
fChunk
;
private
char
[
]
fData
=
null
;
private
CharDataChunk
fNextChunk
;
private
CharDataChunk
fPreviousChunk
;
private
static
CharDataChunk
fgFreeChunks
=
null
;
}
