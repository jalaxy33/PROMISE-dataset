package
org
.
apache
.
xerces
.
dom
;
import
org
.
w3c
.
dom
.
*
;
import
org
.
apache
.
xerces
.
dom
.
events
.
MutationEventImpl
;
import
org
.
w3c
.
dom
.
events
.
*
;
public
abstract
class
CharacterDataImpl
extends
ChildNode
{
static
final
long
serialVersionUID
=
7931170150428474230L
;
protected
String
data
;
private
static
transient
NodeList
singletonNodeList
=
new
NodeList
(
)
{
public
Node
item
(
int
index
)
{
return
null
;
}
public
int
getLength
(
)
{
return
0
;
}
}
;
protected
CharacterDataImpl
(
DocumentImpl
ownerDocument
,
String
data
)
{
super
(
ownerDocument
)
;
this
.
data
=
data
;
}
public
NodeList
getChildNodes
(
)
{
return
singletonNodeList
;
}
public
String
getNodeValue
(
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
return
data
;
}
void
setNodeValueInternal
(
String
value
)
{
setValueCalled
(
true
)
;
setNodeValue
(
value
)
;
setValueCalled
(
false
)
;
}
public
void
setNodeValue
(
String
value
)
{
if
(
isReadOnly
(
)
)
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
String
oldvalue
=
value
;
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
}
this
.
data
=
value
;
if
(
!
setValueCalled
(
)
)
{
ownerDocument
(
)
.
replacedText
(
this
)
;
}
if
(
MUTATIONEVENTS
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_CHARACTER_DATA_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_CHARACTER_DATA_MODIFIED
,
true
,
false
,
null
,
oldvalue
,
value
,
null
)
;
dispatchEvent
(
me
)
;
}
dispatchAggregateEvents
(
enclosingAttr
)
;
}
}
public
String
getData
(
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
return
data
;
}
public
int
getLength
(
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
return
data
.
length
(
)
;
}
public
void
appendData
(
String
data
)
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
setNodeValue
(
this
.
data
+
data
)
;
}
public
void
deleteData
(
int
offset
,
int
count
)
throws
DOMException
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
if
(
count
<
0
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
INDEX_SIZE_ERR
,
"DOM004 Index out of bounds"
)
;
}
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
int
tailLength
=
Math
.
max
(
data
.
length
(
)
-
count
-
offset
,
0
)
;
try
{
setNodeValueInternal
(
data
.
substring
(
0
,
offset
)
+
(
tailLength
>
0
?
data
.
substring
(
offset
+
count
,
offset
+
count
+
tailLength
)
:
""
)
)
;
ownerDocument
(
)
.
deletedText
(
this
,
offset
,
count
)
;
}
catch
(
StringIndexOutOfBoundsException
e
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
INDEX_SIZE_ERR
,
"DOM004 Index out of bounds"
)
;
}
}
public
void
insertData
(
int
offset
,
String
data
)
throws
DOMException
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
try
{
setNodeValueInternal
(
new
StringBuffer
(
this
.
data
)
.
insert
(
offset
,
data
)
.
toString
(
)
)
;
ownerDocument
(
)
.
insertedText
(
this
,
offset
,
data
.
length
(
)
)
;
}
catch
(
StringIndexOutOfBoundsException
e
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
INDEX_SIZE_ERR
,
"DOM004 Index out of bounds"
)
;
}
}
public
void
replaceData
(
int
offset
,
int
count
,
String
data
)
throws
DOMException
{
deleteData
(
offset
,
count
)
;
insertData
(
offset
,
data
)
;
}
public
void
setData
(
String
value
)
throws
DOMException
{
setNodeValue
(
value
)
;
}
public
String
substringData
(
int
offset
,
int
count
)
throws
DOMException
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
int
length
=
data
.
length
(
)
;
if
(
count
<
0
||
offset
<
0
||
offset
>
length
-
1
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
INDEX_SIZE_ERR
,
"DOM004 Index out of bounds"
)
;
}
int
tailIndex
=
Math
.
min
(
offset
+
count
,
length
)
;
return
data
.
substring
(
offset
,
tailIndex
)
;
}
}
