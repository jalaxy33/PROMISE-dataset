package
org
.
apache
.
xerces
.
validators
.
common
;
import
org
.
apache
.
xerces
.
framework
.
XMLContentSpec
;
import
org
.
apache
.
xerces
.
utils
.
QName
;
import
org
.
apache
.
xerces
.
validators
.
schema
.
EquivClassComparator
;
public
class
MixedContentModel
implements
XMLContentModel
{
private
int
fCount
;
private
QName
fChildren
[
]
;
private
int
fChildrenType
[
]
;
private
EquivClassComparator
comparator
=
null
;
private
boolean
fOrdered
;
private
boolean
fDTD
;
public
MixedContentModel
(
QName
childList
[
]
,
int
childListType
[
]
,
int
offset
,
int
length
)
throws
CMException
{
this
(
childList
,
childListType
,
offset
,
length
,
false
,
false
)
;
}
public
MixedContentModel
(
QName
childList
[
]
,
int
childListType
[
]
,
int
offset
,
int
length
,
boolean
ordered
)
throws
CMException
{
this
(
childList
,
childListType
,
offset
,
length
,
ordered
,
false
)
;
}
public
MixedContentModel
(
QName
childList
[
]
,
int
childListType
[
]
,
int
offset
,
int
length
,
boolean
ordered
,
boolean
dtd
)
throws
CMException
{
fCount
=
length
;
fChildren
=
new
QName
[
fCount
]
;
fChildrenType
=
new
int
[
fCount
]
;
for
(
int
i
=
0
;
i
<
fCount
;
i
++
)
{
fChildren
[
i
]
=
new
QName
(
childList
[
offset
+
i
]
)
;
fChildrenType
[
i
]
=
childListType
[
offset
+
i
]
;
}
fOrdered
=
ordered
;
fDTD
=
dtd
;
}
public
int
validateContent
(
QName
children
[
]
,
int
offset
,
int
length
)
throws
Exception
{
if
(
fOrdered
)
{
int
inIndex
=
0
;
for
(
int
outIndex
=
0
;
outIndex
<
length
;
outIndex
++
)
{
final
QName
curChild
=
children
[
offset
+
outIndex
]
;
if
(
curChild
.
localpart
==
-
1
)
{
continue
;
}
int
type
=
fChildrenType
[
inIndex
]
;
if
(
type
==
XMLContentSpec
.
CONTENTSPECNODE_LEAF
)
{
if
(
fDTD
)
{
if
(
fChildren
[
inIndex
]
.
rawname
!=
children
[
offset
+
outIndex
]
.
rawname
)
{
return
outIndex
;
}
}
else
{
if
(
fChildren
[
inIndex
]
.
uri
!=
children
[
offset
+
outIndex
]
.
uri
&&
fChildren
[
inIndex
]
.
localpart
!=
children
[
offset
+
outIndex
]
.
localpart
)
{
return
outIndex
;
}
}
}
else
if
(
type
==
XMLContentSpec
.
CONTENTSPECNODE_ANY
)
{
int
uri
=
fChildren
[
inIndex
]
.
uri
;
if
(
uri
!=
-
1
&&
uri
!=
children
[
outIndex
]
.
uri
)
{
return
outIndex
;
}
}
else
if
(
type
==
XMLContentSpec
.
CONTENTSPECNODE_ANY_LOCAL
)
{
if
(
children
[
outIndex
]
.
uri
!=
-
1
)
{
return
outIndex
;
}
}
else
if
(
type
==
XMLContentSpec
.
CONTENTSPECNODE_ANY_OTHER
)
{
if
(
fChildren
[
inIndex
]
.
uri
==
children
[
outIndex
]
.
uri
)
{
return
outIndex
;
}
}
inIndex
++
;
}
}
else
{
for
(
int
outIndex
=
0
;
outIndex
<
length
;
outIndex
++
)
{
final
QName
curChild
=
children
[
offset
+
outIndex
]
;
if
(
curChild
.
localpart
==
-
1
)
continue
;
int
inIndex
=
0
;
for
(
;
inIndex
<
fCount
;
inIndex
++
)
{
int
type
=
fChildrenType
[
inIndex
]
;
if
(
type
==
XMLContentSpec
.
CONTENTSPECNODE_LEAF
)
{
if
(
fDTD
)
{
if
(
curChild
.
rawname
==
fChildren
[
inIndex
]
.
rawname
)
{
break
;
}
}
else
{
if
(
curChild
.
uri
==
fChildren
[
inIndex
]
.
uri
&&
curChild
.
localpart
==
fChildren
[
inIndex
]
.
localpart
)
break
;
}
}
else
if
(
type
==
XMLContentSpec
.
CONTENTSPECNODE_ANY
)
{
int
uri
=
fChildren
[
inIndex
]
.
uri
;
if
(
uri
==
-
1
||
uri
==
children
[
outIndex
]
.
uri
)
{
break
;
}
}
else
if
(
type
==
XMLContentSpec
.
CONTENTSPECNODE_ANY_LOCAL
)
{
if
(
children
[
outIndex
]
.
uri
==
-
1
)
{
break
;
}
}
else
if
(
type
==
XMLContentSpec
.
CONTENTSPECNODE_ANY_OTHER
)
{
if
(
fChildren
[
inIndex
]
.
uri
!=
children
[
outIndex
]
.
uri
)
{
break
;
}
}
}
if
(
inIndex
==
fCount
)
return
outIndex
;
}
}
return
-
1
;
}
public
int
validateContentSpecial
(
QName
children
[
]
,
int
offset
,
int
length
)
throws
Exception
{
return
validateContent
(
children
,
offset
,
length
)
;
}
public
void
setEquivClassComparator
(
EquivClassComparator
comparator
)
{
this
.
comparator
=
comparator
;
}
public
int
whatCanGoHere
(
boolean
fullyValid
,
InsertableElementsInfo
info
)
throws
Exception
{
for
(
int
index
=
info
.
insertAt
;
index
<
info
.
childCount
;
index
++
)
info
.
curChildren
[
index
]
=
info
.
curChildren
[
index
+
1
]
;
info
.
childCount
--
;
final
int
failedIndex
=
validateContent
(
info
.
curChildren
,
0
,
info
.
childCount
)
;
if
(
(
failedIndex
!=
-
1
)
&&
(
failedIndex
<
info
.
insertAt
)
)
return
failedIndex
;
info
.
canHoldPCData
=
true
;
info
.
isValidEOC
=
true
;
info
.
resultsCount
=
fCount
;
if
(
(
info
.
results
==
null
)
||
(
info
.
results
.
length
<
info
.
resultsCount
)
)
info
.
results
=
new
boolean
[
info
.
resultsCount
]
;
if
(
(
info
.
possibleChildren
==
null
)
||
(
info
.
possibleChildren
.
length
<
info
.
resultsCount
)
)
{
info
.
possibleChildren
=
new
QName
[
info
.
resultsCount
]
;
for
(
int
i
=
0
;
i
<
info
.
possibleChildren
.
length
;
i
++
)
{
info
.
possibleChildren
[
i
]
=
new
QName
(
)
;
}
}
boolean
bStatus
=
true
;
if
(
fullyValid
&&
(
failedIndex
<
info
.
childCount
)
)
bStatus
=
false
;
for
(
int
index
=
0
;
index
<
fCount
;
index
++
)
{
info
.
possibleChildren
[
index
]
.
setValues
(
fChildren
[
index
]
)
;
info
.
results
[
index
]
=
bStatus
;
}
return
-
1
;
}
public
ContentLeafNameTypeVector
getContentLeafNameTypeVector
(
)
{
return
null
;
}
}
