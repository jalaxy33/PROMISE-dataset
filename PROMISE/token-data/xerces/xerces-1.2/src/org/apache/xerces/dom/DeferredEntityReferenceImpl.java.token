package
org
.
apache
.
xerces
.
dom
;
import
org
.
w3c
.
dom
.
*
;
public
class
DeferredEntityReferenceImpl
extends
EntityReferenceImpl
implements
DeferredNode
{
static
final
long
serialVersionUID
=
390319091370032223L
;
protected
transient
int
fNodeIndex
;
DeferredEntityReferenceImpl
(
DeferredDocumentImpl
ownerDocument
,
int
nodeIndex
)
{
super
(
ownerDocument
,
null
)
;
fNodeIndex
=
nodeIndex
;
needsSyncData
(
true
)
;
needsSyncChildren
(
true
)
;
}
public
int
getNodeIndex
(
)
{
return
fNodeIndex
;
}
protected
void
synchronizeData
(
)
{
needsSyncData
(
false
)
;
DeferredDocumentImpl
ownerDocument
=
(
DeferredDocumentImpl
)
this
.
ownerDocument
;
name
=
ownerDocument
.
getNodeNameString
(
fNodeIndex
)
;
}
protected
void
synchronizeChildren
(
)
{
needsSyncChildren
(
false
)
;
DocumentType
doctype
=
ownerDocument
.
getDoctype
(
)
;
boolean
found
=
false
;
if
(
doctype
!=
null
)
{
boolean
orig
=
ownerDocument
.
mutationEvents
;
ownerDocument
.
mutationEvents
=
false
;
NamedNodeMap
entities
=
doctype
.
getEntities
(
)
;
if
(
entities
!=
null
)
{
Entity
entity
=
(
Entity
)
entities
.
getNamedItem
(
getNodeName
(
)
)
;
if
(
entity
!=
null
)
{
found
=
true
;
boolean
ro
=
isReadOnly
(
)
;
isReadOnly
(
false
)
;
Node
child
=
entity
.
getFirstChild
(
)
;
while
(
child
!=
null
)
{
appendChild
(
child
.
cloneNode
(
true
)
)
;
child
=
child
.
getNextSibling
(
)
;
}
if
(
ro
)
{
setReadOnly
(
true
,
true
)
;
}
}
}
ownerDocument
(
)
.
mutationEvents
=
orig
;
}
if
(
!
found
)
{
isReadOnly
(
false
)
;
synchronizeChildren
(
fNodeIndex
)
;
setReadOnly
(
true
,
true
)
;
}
}
protected
void
synchronize
(
)
{
}
}
