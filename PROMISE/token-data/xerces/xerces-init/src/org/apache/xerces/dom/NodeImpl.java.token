package
org
.
apache
.
xerces
.
dom
;
import
java
.
io
.
*
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Vector
;
import
org
.
w3c
.
dom
.
*
;
import
org
.
apache
.
xerces
.
dom
.
traversal
.
NodeIteratorImpl
;
import
org
.
apache
.
xerces
.
domx
.
events
.
*
;
import
org
.
apache
.
xerces
.
dom
.
events
.
*
;
public
abstract
class
NodeImpl
implements
Node
,
NodeList
,
EventTarget
,
Cloneable
,
Serializable
{
static
final
long
serialVersionUID
=
2815829867052120872L
;
public
static
final
short
ELEMENT_DEFINITION_NODE
=
-
1
;
protected
DocumentImpl
ownerDocument
;
protected
NodeImpl
parentNode
;
protected
NodeImpl
previousSibling
;
protected
NodeImpl
nextSibling
;
protected
String
name
;
protected
String
value
;
protected
boolean
readOnly
;
protected
Object
userData
;
protected
NodeImpl
firstChild
;
protected
NodeImpl
lastChild
;
protected
transient
boolean
syncChildren
;
protected
transient
boolean
syncData
;
int
changes
=
0
;
protected
static
int
[
]
kidOK
;
static
{
kidOK
=
new
int
[
13
]
;
kidOK
[
DOCUMENT_NODE
]
=
1
<<
ELEMENT_NODE
|
1
<<
PROCESSING_INSTRUCTION_NODE
|
1
<<
COMMENT_NODE
|
1
<<
DOCUMENT_TYPE_NODE
;
kidOK
[
DOCUMENT_FRAGMENT_NODE
]
=
kidOK
[
ENTITY_NODE
]
=
kidOK
[
ENTITY_REFERENCE_NODE
]
=
kidOK
[
ELEMENT_NODE
]
=
1
<<
ELEMENT_NODE
|
1
<<
PROCESSING_INSTRUCTION_NODE
|
1
<<
COMMENT_NODE
|
1
<<
TEXT_NODE
|
1
<<
CDATA_SECTION_NODE
|
1
<<
ENTITY_REFERENCE_NODE
|
1
<<
ATTRIBUTE_NODE
;
kidOK
[
ATTRIBUTE_NODE
]
=
1
<<
TEXT_NODE
|
1
<<
ENTITY_REFERENCE_NODE
;
kidOK
[
DOCUMENT_TYPE_NODE
]
=
kidOK
[
PROCESSING_INSTRUCTION_NODE
]
=
kidOK
[
COMMENT_NODE
]
=
kidOK
[
TEXT_NODE
]
=
kidOK
[
CDATA_SECTION_NODE
]
=
kidOK
[
NOTATION_NODE
]
=
0
;
}
protected
NodeImpl
(
DocumentImpl
ownerDocument
,
String
name
,
String
value
)
{
this
.
ownerDocument
=
ownerDocument
;
this
.
name
=
name
;
this
.
value
=
value
;
}
public
NodeImpl
(
)
{
}
public
abstract
short
getNodeType
(
)
;
public
String
getNodeName
(
)
{
if
(
syncData
)
{
synchronizeData
(
)
;
}
return
name
;
}
public
void
setNodeValue
(
String
value
)
{
if
(
readOnly
)
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"NO_MODIFICATION_ALLOWED_ERR"
)
;
if
(
syncData
)
{
synchronizeData
(
)
;
}
String
oldvalue
=
this
.
value
;
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
}
this
.
value
=
value
;
if
(
MUTATIONEVENTS
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_CHARACTER_DATA_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_CHARACTER_DATA_MODIFIED
,
true
,
false
,
null
,
oldvalue
,
value
,
null
)
;
dispatchEvent
(
me
)
;
}
dispatchAggregateEvents
(
enclosingAttr
)
;
}
}
public
String
getNodeValue
(
)
{
if
(
syncData
)
{
synchronizeData
(
)
;
}
return
value
;
}
public
Node
appendChild
(
Node
newChild
)
throws
DOMException
{
return
insertBefore
(
newChild
,
null
)
;
}
public
Node
cloneNode
(
boolean
deep
)
{
if
(
syncData
)
{
synchronizeData
(
)
;
}
if
(
syncChildren
)
{
synchronizeChildren
(
)
;
}
NodeImpl
newnode
;
try
{
newnode
=
(
NodeImpl
)
clone
(
)
;
}
catch
(
CloneNotSupportedException
e
)
{
return
null
;
}
newnode
.
readOnly
=
false
;
newnode
.
parentNode
=
null
;
newnode
.
previousSibling
=
null
;
newnode
.
nextSibling
=
null
;
newnode
.
firstChild
=
null
;
newnode
.
lastChild
=
null
;
if
(
deep
)
{
for
(
NodeImpl
child
=
(
NodeImpl
)
getFirstChild
(
)
;
child
!=
null
;
child
=
(
NodeImpl
)
child
.
getNextSibling
(
)
)
{
newnode
.
appendChild
(
child
.
cloneNode
(
true
)
)
;
}
}
return
newnode
;
}
public
Document
getOwnerDocument
(
)
{
return
ownerDocument
;
}
public
Node
getParentNode
(
)
{
return
parentNode
;
}
public
Node
getNextSibling
(
)
{
return
nextSibling
;
}
public
Node
getPreviousSibling
(
)
{
return
previousSibling
;
}
public
NamedNodeMap
getAttributes
(
)
{
return
null
;
}
public
boolean
hasChildNodes
(
)
{
if
(
syncChildren
)
{
synchronizeChildren
(
)
;
}
return
firstChild
!=
null
;
}
public
NodeList
getChildNodes
(
)
{
if
(
syncChildren
)
{
synchronizeChildren
(
)
;
}
return
this
;
}
public
Node
getFirstChild
(
)
{
if
(
syncChildren
)
{
synchronizeChildren
(
)
;
}
return
firstChild
;
}
public
Node
getLastChild
(
)
{
if
(
syncChildren
)
{
synchronizeChildren
(
)
;
}
return
lastChild
;
}
public
Node
insertBefore
(
Node
newChild
,
Node
refChild
)
throws
DOMException
{
return
internalInsertBefore
(
newChild
,
refChild
,
MUTATION_ALL
)
;
}
Node
internalInsertBefore
(
Node
newChild
,
Node
refChild
,
int
mutationMask
)
throws
DOMException
{
if
(
readOnly
)
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"NO_MODIFICATION_ALLOWED_ERR"
)
;
if
(
!
(
newChild
instanceof
NodeImpl
)
||
!
(
newChild
.
getOwnerDocument
(
)
==
ownerDocument
||
(
getNodeType
(
)
==
Node
.
DOCUMENT_NODE
&&
newChild
.
getOwnerDocument
(
)
==
(
Document
)
this
)
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
WRONG_DOCUMENT_ERR
,
"WRONG_DOCUMENT_ERR"
)
;
}
if
(
syncChildren
)
{
synchronizeChildren
(
)
;
}
NodeImpl
newInternal
=
(
NodeImpl
)
newChild
;
boolean
treeSafe
=
true
;
for
(
NodeImpl
a
=
parentNode
;
treeSafe
&&
a
!=
null
;
a
=
a
.
parentNode
)
{
treeSafe
=
newInternal
!=
a
;
}
if
(
!
treeSafe
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"HIERARCHY_REQUEST_ERR"
)
;
}
if
(
refChild
!=
null
&&
refChild
.
getParentNode
(
)
!=
this
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NOT_FOUND_ERR
,
"NOT_FOUND_ERR"
)
;
}
if
(
newInternal
.
getNodeType
(
)
==
Node
.
DOCUMENT_FRAGMENT_NODE
)
{
for
(
Node
kid
=
newInternal
.
getFirstChild
(
)
;
kid
!=
null
;
kid
=
kid
.
getNextSibling
(
)
)
{
if
(
!
ownerDocument
.
isKidOK
(
this
,
kid
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"HIERARCHY_REQUEST_ERR"
)
;
}
}
while
(
newInternal
.
hasChildNodes
(
)
)
{
insertBefore
(
newInternal
.
getFirstChild
(
)
,
refChild
)
;
}
}
else
if
(
!
ownerDocument
.
isKidOK
(
this
,
newInternal
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"HIERARCHY_REQUEST_ERR"
)
;
}
else
{
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
&&
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
}
Node
oldparent
=
newInternal
.
getParentNode
(
)
;
if
(
oldparent
!=
null
)
{
oldparent
.
removeChild
(
newInternal
)
;
}
NodeImpl
prev
;
prev
=
(
refChild
==
null
)
?
lastChild
:
(
(
NodeImpl
)
refChild
)
.
previousSibling
;
newInternal
.
parentNode
=
this
;
newInternal
.
previousSibling
=
prev
;
if
(
prev
==
null
)
{
firstChild
=
newInternal
;
}
else
{
prev
.
nextSibling
=
newInternal
;
}
newInternal
.
nextSibling
=
(
NodeImpl
)
refChild
;
if
(
refChild
==
null
)
{
lastChild
=
newInternal
;
}
else
{
(
(
NodeImpl
)
refChild
)
.
previousSibling
=
newInternal
;
}
changed
(
)
;
if
(
MUTATIONEVENTS
)
{
if
(
(
mutationMask
&
MUTATION_LOCAL
)
!=
0
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_INSERTED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_INSERTED
,
true
,
false
,
this
,
null
,
null
,
null
)
;
newInternal
.
dispatchEvent
(
me
)
;
}
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_INSERTED_INTO_DOCUMENT
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
NodeImpl
eventAncestor
=
this
;
if
(
enclosingAttr
!=
null
)
eventAncestor
=
(
NodeImpl
)
(
enclosingAttr
.
node
.
getOwnerElement
(
)
)
;
if
(
eventAncestor
!=
null
)
{
NodeImpl
p
=
eventAncestor
;
while
(
p
!=
null
)
{
eventAncestor
=
p
;
if
(
p
.
getNodeType
(
)
==
ATTRIBUTE_NODE
)
p
=
(
ElementImpl
)
(
(
(
AttrImpl
)
p
)
.
getOwnerElement
(
)
)
;
else
p
=
p
.
parentNode
;
}
if
(
eventAncestor
.
getNodeType
(
)
==
Node
.
DOCUMENT_NODE
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_INSERTED_INTO_DOCUMENT
,
false
,
false
,
null
,
null
,
null
,
null
)
;
dispatchEventToSubtree
(
newInternal
,
me
)
;
}
}
}
}
if
(
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
dispatchAggregateEvents
(
enclosingAttr
)
;
}
}
return
newInternal
;
}
public
Node
removeChild
(
Node
oldChild
)
throws
DOMException
{
return
internalRemoveChild
(
oldChild
,
MUTATION_ALL
)
;
}
Node
internalRemoveChild
(
Node
oldChild
,
int
mutationMask
)
throws
DOMException
{
if
(
readOnly
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"NO_MODIFICATION_ALLOWED_ERR"
)
;
}
if
(
oldChild
!=
null
&&
oldChild
.
getParentNode
(
)
!=
this
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NOT_FOUND_ERR
,
"NOT_FOUND_ERR"
)
;
}
Enumeration
iterators
=
ownerDocument
.
getNodeIterators
(
)
;
if
(
iterators
!=
null
)
{
while
(
iterators
.
hasMoreElements
(
)
)
{
(
(
NodeIteratorImpl
)
iterators
.
nextElement
(
)
)
.
removeNode
(
oldChild
)
;
}
}
NodeImpl
oldInternal
=
(
NodeImpl
)
oldChild
;
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
if
(
(
mutationMask
&
MUTATION_LOCAL
)
!=
0
)
{
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_REMOVED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_REMOVED
,
true
,
false
,
this
,
null
,
null
,
null
)
;
oldInternal
.
dispatchEvent
(
me
)
;
}
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_REMOVED_FROM_DOCUMENT
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
NodeImpl
eventAncestor
=
this
;
if
(
enclosingAttr
!=
null
)
eventAncestor
=
(
NodeImpl
)
(
enclosingAttr
.
node
.
getOwnerElement
(
)
)
;
if
(
eventAncestor
!=
null
)
{
for
(
NodeImpl
p
=
eventAncestor
.
parentNode
;
p
!=
null
;
p
=
p
.
parentNode
)
{
eventAncestor
=
p
;
}
if
(
eventAncestor
.
getNodeType
(
)
==
Node
.
DOCUMENT_NODE
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_REMOVED_FROM_DOCUMENT
,
false
,
false
,
null
,
null
,
null
,
null
)
;
dispatchEventToSubtree
(
oldInternal
,
me
)
;
}
}
}
}
}
NodeImpl
prev
=
oldInternal
.
previousSibling
;
NodeImpl
next
=
oldInternal
.
nextSibling
;
if
(
prev
!=
null
)
{
prev
.
nextSibling
=
next
;
}
else
{
firstChild
=
next
;
}
if
(
next
!=
null
)
{
next
.
previousSibling
=
prev
;
}
else
{
lastChild
=
prev
;
}
oldInternal
.
parentNode
=
null
;
oldInternal
.
nextSibling
=
null
;
oldInternal
.
previousSibling
=
null
;
changed
(
)
;
if
(
MUTATIONEVENTS
)
{
if
(
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
dispatchAggregateEvents
(
enclosingAttr
)
;
}
return
oldInternal
;
}
public
Node
replaceChild
(
Node
newChild
,
Node
oldChild
)
throws
DOMException
{
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
}
internalInsertBefore
(
newChild
,
oldChild
,
MUTATION_LOCAL
)
;
internalRemoveChild
(
oldChild
,
MUTATION_LOCAL
)
;
if
(
MUTATIONEVENTS
)
{
dispatchAggregateEvents
(
enclosingAttr
)
;
}
return
oldChild
;
}
public
int
getLength
(
)
{
int
count
=
0
;
for
(
NodeImpl
node
=
firstChild
;
node
!=
null
;
node
=
node
.
nextSibling
)
{
count
++
;
}
return
count
;
}
public
Node
item
(
int
index
)
{
NodeImpl
node
=
firstChild
;
for
(
int
i
=
0
;
i
<
index
&&
node
!=
null
;
i
++
)
{
node
=
node
.
nextSibling
;
}
return
node
;
}
public
boolean
supports
(
String
feature
,
String
version
)
{
return
ownerDocument
.
getImplementation
(
)
.
hasFeature
(
feature
,
version
)
;
}
public
String
getNamespaceURI
(
)
{
return
null
;
}
public
String
getPrefix
(
)
{
return
null
;
}
public
void
setPrefix
(
String
prefix
)
throws
DOMException
{
}
public
String
getLocalName
(
)
{
if
(
syncData
)
{
synchronizeData
(
)
;
}
return
name
;
}
protected
final
static
boolean
MUTATIONEVENTS
=
true
;
protected
final
static
int
MUTATION_NONE
=
0x00
;
protected
final
static
int
MUTATION_LOCAL
=
0x01
;
protected
final
static
int
MUTATION_AGGREGATE
=
0x02
;
protected
final
static
int
MUTATION_ALL
=
0xffff
;
Vector
nodeListeners
=
null
;
class
LEntry
{
String
type
;
EventListener
listener
;
boolean
useCapture
;
LEntry
(
String
type
,
EventListener
listener
,
boolean
useCapture
)
{
this
.
type
=
type
;
this
.
listener
=
listener
;
this
.
useCapture
=
useCapture
;
}
}
;
public
void
addEventListener
(
String
type
,
EventListener
listener
,
boolean
useCapture
)
{
if
(
type
==
null
||
type
.
equals
(
""
)
||
listener
==
null
)
return
;
removeEventListener
(
type
,
listener
,
useCapture
)
;
if
(
nodeListeners
==
null
)
nodeListeners
=
new
Vector
(
)
;
nodeListeners
.
addElement
(
new
LEntry
(
type
,
listener
,
useCapture
)
)
;
LCount
lc
=
LCount
.
lookup
(
type
)
;
if
(
useCapture
)
++
lc
.
captures
;
else
++
lc
.
bubbles
;
}
public
void
removeEventListener
(
String
type
,
EventListener
listener
,
boolean
useCapture
)
{
if
(
nodeListeners
==
null
||
type
==
null
||
type
.
equals
(
""
)
||
listener
==
null
)
return
;
for
(
int
i
=
nodeListeners
.
size
(
)
-
1
;
i
>=
0
;
--
i
)
{
LEntry
le
=
(
LEntry
)
(
nodeListeners
.
elementAt
(
i
)
)
;
if
(
le
.
useCapture
==
useCapture
&&
le
.
listener
==
listener
&&
le
.
type
.
equals
(
type
)
)
{
nodeListeners
.
removeElementAt
(
i
)
;
if
(
nodeListeners
.
size
(
)
==
0
)
nodeListeners
=
null
;
LCount
lc
=
LCount
.
lookup
(
type
)
;
if
(
useCapture
)
--
lc
.
captures
;
else
--
lc
.
bubbles
;
break
;
}
}
}
protected
void
finalize
(
)
throws
Throwable
{
super
.
finalize
(
)
;
if
(
nodeListeners
!=
null
)
for
(
int
i
=
nodeListeners
.
size
(
)
-
1
;
i
>=
0
;
--
i
)
{
LEntry
le
=
(
LEntry
)
(
nodeListeners
.
elementAt
(
i
)
)
;
LCount
lc
=
LCount
.
lookup
(
le
.
type
)
;
if
(
le
.
useCapture
)
--
lc
.
captures
;
else
--
lc
.
bubbles
;
}
}
public
boolean
dispatchEvent
(
Event
event
)
{
if
(
event
==
null
)
return
false
;
EventImpl
evt
=
(
EventImpl
)
event
;
if
(
!
evt
.
initialized
||
evt
.
type
==
null
||
evt
.
type
.
equals
(
""
)
)
throw
new
DOMExceptionImpl
(
DOMExceptionImpl
.
UNSPECIFIED_EVENT_TYPE
,
""
)
;
LCount
lc
=
LCount
.
lookup
(
evt
.
getType
(
)
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
==
0
)
return
evt
.
preventDefault
;
evt
.
target
=
this
;
evt
.
stopPropagation
=
false
;
evt
.
preventDefault
=
false
;
Vector
pv
=
new
Vector
(
10
,
10
)
;
Node
p
=
this
,
n
=
p
.
getParentNode
(
)
;
while
(
n
!=
null
)
{
pv
.
addElement
(
n
)
;
p
=
n
;
n
=
n
.
getParentNode
(
)
;
}
if
(
lc
.
captures
>
0
)
{
evt
.
eventPhase
=
Event
.
CAPTURING_PHASE
;
for
(
int
j
=
pv
.
size
(
)
-
1
;
j
>=
0
;
--
j
)
{
if
(
evt
.
stopPropagation
)
break
;
NodeImpl
nn
=
(
NodeImpl
)
pv
.
elementAt
(
j
)
;
evt
.
currentNode
=
nn
;
if
(
nn
.
nodeListeners
!=
null
)
{
Vector
nl
=
(
Vector
)
(
nn
.
nodeListeners
.
clone
(
)
)
;
for
(
int
i
=
nl
.
size
(
)
-
1
;
i
>=
0
;
--
i
)
{
LEntry
le
=
(
LEntry
)
(
nl
.
elementAt
(
i
)
)
;
if
(
le
.
useCapture
&&
le
.
type
.
equals
(
evt
.
type
)
)
try
{
le
.
listener
.
handleEvent
(
evt
)
;
}
catch
(
Exception
e
)
{
}
}
}
}
}
if
(
lc
.
bubbles
>
0
)
{
evt
.
eventPhase
=
Event
.
AT_TARGET
;
evt
.
currentNode
=
this
;
if
(
!
evt
.
stopPropagation
&&
nodeListeners
!=
null
)
{
Vector
nl
=
(
Vector
)
nodeListeners
.
clone
(
)
;
for
(
int
i
=
nl
.
size
(
)
-
1
;
i
>=
0
;
--
i
)
{
LEntry
le
=
(
LEntry
)
nl
.
elementAt
(
i
)
;
if
(
le
!=
null
&&
!
le
.
useCapture
&&
le
.
type
.
equals
(
evt
.
type
)
)
try
{
le
.
listener
.
handleEvent
(
evt
)
;
}
catch
(
Exception
e
)
{
}
}
}
if
(
evt
.
bubbles
)
{
evt
.
eventPhase
=
Event
.
BUBBLING_PHASE
;
for
(
int
j
=
0
;
j
<
pv
.
size
(
)
;
++
j
)
{
if
(
evt
.
stopPropagation
)
break
;
NodeImpl
nn
=
(
NodeImpl
)
pv
.
elementAt
(
j
)
;
evt
.
currentNode
=
nn
;
if
(
nn
.
nodeListeners
!=
null
)
{
Vector
nl
=
(
Vector
)
(
nn
.
nodeListeners
.
clone
(
)
)
;
for
(
int
i
=
nl
.
size
(
)
-
1
;
i
>=
0
;
--
i
)
{
LEntry
le
=
(
LEntry
)
(
nl
.
elementAt
(
i
)
)
;
if
(
!
le
.
useCapture
&&
le
.
type
.
equals
(
evt
.
type
)
)
try
{
le
.
listener
.
handleEvent
(
evt
)
;
}
catch
(
Exception
e
)
{
}
}
}
}
}
}
if
(
lc
.
defaults
>
0
&&
(
!
evt
.
cancelable
||
!
evt
.
preventDefault
)
)
{
}
return
evt
.
preventDefault
;
}
void
dispatchEventToSubtree
(
NodeImpl
n
,
Event
e
)
{
if
(
MUTATIONEVENTS
)
{
if
(
nodeListeners
==
null
||
n
==
null
)
return
;
n
.
dispatchEvent
(
e
)
;
if
(
n
.
getNodeType
(
)
==
Node
.
ELEMENT_NODE
)
{
NamedNodeMap
a
=
n
.
getAttributes
(
)
;
for
(
int
i
=
a
.
getLength
(
)
-
1
;
i
>=
0
;
--
i
)
dispatchEventToSubtree
(
(
(
NodeImpl
)
a
.
item
(
i
)
)
,
e
)
;
}
dispatchEventToSubtree
(
n
.
firstChild
,
e
)
;
dispatchEventToSubtree
(
n
.
nextSibling
,
e
)
;
}
}
class
EnclosingAttr
{
AttrImpl
node
;
String
oldvalue
;
}
EnclosingAttr
getEnclosingAttr
(
)
{
if
(
MUTATIONEVENTS
)
{
NodeImpl
eventAncestor
=
this
;
while
(
true
)
{
if
(
eventAncestor
==
null
)
return
null
;
int
type
=
eventAncestor
.
getNodeType
(
)
;
if
(
type
==
Node
.
ATTRIBUTE_NODE
)
{
EnclosingAttr
retval
=
new
EnclosingAttr
(
)
;
retval
.
node
=
(
AttrImpl
)
eventAncestor
;
retval
.
oldvalue
=
retval
.
node
.
getNodeValue
(
)
;
return
retval
;
}
else
if
(
type
==
Node
.
ENTITY_REFERENCE_NODE
)
eventAncestor
=
eventAncestor
.
parentNode
;
else
return
null
;
}
}
return
null
;
}
void
dispatchAggregateEvents
(
EnclosingAttr
ea
)
{
if
(
ea
!=
null
)
dispatchAggregateEvents
(
ea
.
node
,
ea
.
oldvalue
)
;
else
dispatchAggregateEvents
(
null
,
null
)
;
}
void
dispatchAggregateEvents
(
AttrImpl
enclosingAttr
,
String
oldvalue
)
{
if
(
MUTATIONEVENTS
)
{
if
(
nodeListeners
==
null
)
return
;
NodeImpl
owner
=
null
;
if
(
enclosingAttr
!=
null
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
owner
=
(
(
NodeImpl
)
(
enclosingAttr
.
getOwnerElement
(
)
)
)
;
if
(
owner
!=
null
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
,
true
,
false
,
null
,
oldvalue
,
enclosingAttr
.
getNodeValue
(
)
,
enclosingAttr
.
getNodeName
(
)
)
;
owner
.
dispatchEvent
(
me
)
;
}
}
}
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_SUBTREE_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_SUBTREE_MODIFIED
,
true
,
false
,
null
,
null
,
null
,
null
)
;
if
(
enclosingAttr
!=
null
)
{
enclosingAttr
.
dispatchEvent
(
me
)
;
if
(
owner
!=
null
)
owner
.
dispatchEvent
(
me
)
;
}
else
dispatchEvent
(
me
)
;
}
}
}
public
void
setReadOnly
(
boolean
readOnly
,
boolean
deep
)
{
if
(
syncData
)
{
synchronizeData
(
)
;
}
this
.
readOnly
=
readOnly
;
if
(
deep
)
{
if
(
syncChildren
)
{
synchronizeChildren
(
)
;
}
for
(
NodeImpl
mykid
=
firstChild
;
mykid
!=
null
;
mykid
=
mykid
.
nextSibling
)
{
if
(
!
(
mykid
instanceof
EntityReference
)
)
{
mykid
.
setReadOnly
(
readOnly
,
true
)
;
}
}
}
}
public
boolean
getReadOnly
(
)
{
if
(
syncData
)
{
synchronizeData
(
)
;
}
return
readOnly
;
}
public
void
setUserData
(
Object
data
)
{
userData
=
data
;
}
public
Object
getUserData
(
)
{
return
userData
;
}
protected
void
synchronizeChildren
(
)
{
}
protected
void
synchronizeData
(
)
{
}
protected
void
changed
(
)
{
++
changes
;
if
(
parentNode
!=
null
)
{
parentNode
.
changed
(
)
;
}
}
public
String
toString
(
)
{
return
"["
+
getNodeName
(
)
+
": "
+
getNodeValue
(
)
+
"]"
;
}
private
void
writeObject
(
ObjectOutputStream
out
)
throws
IOException
{
if
(
syncData
)
{
synchronizeData
(
)
;
}
if
(
syncChildren
)
{
synchronizeChildren
(
)
;
}
out
.
defaultWriteObject
(
)
;
}
}
