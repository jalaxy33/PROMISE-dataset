package
org
.
apache
.
xerces
.
readers
;
import
org
.
apache
.
xerces
.
framework
.
XMLErrorReporter
;
import
org
.
apache
.
xerces
.
utils
.
ChunkyByteArray
;
import
org
.
apache
.
xerces
.
utils
.
StringPool
;
import
java
.
util
.
Stack
;
public
abstract
class
XMLDeclRecognizer
{
public
static
void
registerDefaultRecognizers
(
Stack
recognizerStack
)
{
recognizerStack
.
push
(
new
EBCDICRecognizer
(
)
)
;
recognizerStack
.
push
(
new
UCSRecognizer
(
)
)
;
recognizerStack
.
push
(
new
UTF8Recognizer
(
)
)
;
}
public
abstract
XMLEntityHandler
.
EntityReader
recognize
(
XMLEntityReaderFactory
readerFactory
,
XMLEntityHandler
entityHandler
,
XMLErrorReporter
errorReporter
,
boolean
sendCharDataAsCharArray
,
StringPool
stringPool
,
ChunkyByteArray
data
,
boolean
xmlDecl
,
boolean
allowJavaEncodingName
)
throws
Exception
;
protected
int
prescanXMLDeclOrTextDecl
(
XMLEntityHandler
.
EntityReader
entityReader
,
boolean
xmlDecl
)
throws
Exception
{
if
(
!
entityReader
.
lookingAtChar
(
'<'
,
true
)
)
{
return
-
1
;
}
if
(
!
entityReader
.
lookingAtChar
(
'?'
,
true
)
)
{
return
-
1
;
}
if
(
!
entityReader
.
skippedString
(
xml_string
)
)
{
return
-
1
;
}
entityReader
.
skipPastSpaces
(
)
;
boolean
single
;
char
qchar
;
if
(
entityReader
.
skippedString
(
version_string
)
)
{
entityReader
.
skipPastSpaces
(
)
;
if
(
!
entityReader
.
lookingAtChar
(
'='
,
true
)
)
{
return
-
1
;
}
entityReader
.
skipPastSpaces
(
)
;
int
versionIndex
=
entityReader
.
scanStringLiteral
(
)
;
if
(
versionIndex
<
0
)
{
return
-
1
;
}
if
(
!
entityReader
.
lookingAtSpace
(
true
)
)
{
return
-
1
;
}
entityReader
.
skipPastSpaces
(
)
;
}
else
if
(
xmlDecl
)
{
return
-
1
;
}
if
(
!
entityReader
.
skippedString
(
encoding_string
)
)
{
return
-
1
;
}
entityReader
.
skipPastSpaces
(
)
;
if
(
!
entityReader
.
lookingAtChar
(
'='
,
true
)
)
{
return
-
1
;
}
entityReader
.
skipPastSpaces
(
)
;
int
encodingIndex
=
entityReader
.
scanStringLiteral
(
)
;
return
encodingIndex
;
}
private
static
final
char
[
]
xml_string
=
{
'x'
,
'm'
,
'l'
}
;
private
static
final
char
[
]
version_string
=
{
'v'
,
'e'
,
'r'
,
's'
,
'i'
,
'o'
,
'n'
}
;
private
static
final
char
[
]
encoding_string
=
{
'e'
,
'n'
,
'c'
,
'o'
,
'd'
,
'i'
,
'n'
,
'g'
}
;
}
