package
org
.
apache
.
xerces
.
validators
.
datatype
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Vector
;
public
class
RealValidator
implements
InternalDatatypeValidator
{
double
fMaxInclusive
=
0
;
boolean
fIsMaxInclusive
=
false
;
double
fMaxExclusive
=
0
;
boolean
fIsMaxExclusive
=
false
;
double
fMinInclusive
=
0
;
boolean
fIsMinInclusive
=
false
;
double
fMinExclusive
=
0
;
boolean
fIsMinExclusive
=
false
;
double
fMinAbsoluteValue
=
0
;
boolean
fIsMinAbsoluteValue
=
false
;
double
fMaxAbsoluteValue
=
0
;
boolean
fIsMaxAbsoluteValue
=
false
;
double
fEnumValues
[
]
=
null
;
boolean
fHasEnums
=
false
;
RealValidator
fBaseValidator
=
null
;
private
DatatypeMessageProvider
fMessageProvider
=
new
DatatypeMessageProvider
(
)
;
private
Locale
fLocale
=
null
;
public
void
validate
(
String
content
)
throws
InvalidDatatypeValueException
{
double
d
=
0
;
try
{
d
=
Double
.
valueOf
(
content
)
.
doubleValue
(
)
;
}
catch
(
NumberFormatException
nfe
)
{
throw
new
InvalidDatatypeValueException
(
getErrorString
(
DatatypeMessageProvider
.
NotReal
,
DatatypeMessageProvider
.
MSG_NONE
,
new
Object
[
]
{
content
}
)
)
;
}
boundsCheck
(
d
)
;
if
(
fHasEnums
)
enumCheck
(
d
)
;
}
public
void
validate
(
int
contentIndex
)
throws
InvalidDatatypeValueException
{
}
boolean
ensureFacetsAreConsistent
(
Hashtable
facets
)
{
boolean
facetsAreConsistent
=
true
;
for
(
Enumeration
e
=
facets
.
keys
(
)
;
facetsAreConsistent
&&
e
.
hasMoreElements
(
)
;
)
{
String
key
=
(
String
)
e
.
nextElement
(
)
;
String
value
=
null
;
if
(
key
.
equals
(
DatatypeValidator
.
ENUMERATION
)
)
continue
;
value
=
(
String
)
facets
.
get
(
key
)
;
double
realValue
=
0
;
try
{
realValue
=
Double
.
valueOf
(
value
)
.
doubleValue
(
)
;
}
catch
(
NumberFormatException
nfe
)
{
facetsAreConsistent
=
false
;
}
if
(
key
.
equals
(
DatatypeValidator
.
MININCLUSIVE
)
&&
fIsMinInclusive
)
{
facetsAreConsistent
=
fMinInclusive
<=
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
MINEXCLUSIVE
)
&&
fIsMinExclusive
)
{
facetsAreConsistent
=
fMinExclusive
<
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
MAXINCLUSIVE
)
&&
fIsMaxInclusive
)
{
facetsAreConsistent
=
fMaxInclusive
>=
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
MAXEXCLUSIVE
)
&&
fIsMaxExclusive
)
{
facetsAreConsistent
=
fMaxExclusive
>
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
MINABSOLUTEVALUE
)
&&
fIsMinAbsoluteValue
)
{
facetsAreConsistent
=
fMinAbsoluteValue
<=
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
MAXABSOLUTEVALUE
)
&&
fIsMaxAbsoluteValue
)
{
facetsAreConsistent
=
fMaxAbsoluteValue
>=
realValue
;
}
}
return
facetsAreConsistent
;
}
public
void
setFacets
(
Hashtable
facets
)
throws
UnknownFacetException
,
IllegalFacetException
,
IllegalFacetValueException
{
if
(
fBaseValidator
!=
null
)
if
(
!
fBaseValidator
.
ensureFacetsAreConsistent
(
facets
)
)
throw
new
IllegalFacetValueException
(
getErrorString
(
DatatypeMessageProvider
.
FacetsInconsistent
,
DatatypeMessageProvider
.
MSG_NONE
,
null
)
)
;
fIsMinInclusive
=
fIsMinExclusive
=
fIsMaxInclusive
=
fIsMaxExclusive
=
fHasEnums
=
false
;
for
(
Enumeration
e
=
facets
.
keys
(
)
;
e
.
hasMoreElements
(
)
;
)
{
String
key
=
(
String
)
e
.
nextElement
(
)
;
String
value
=
null
;
if
(
key
.
equals
(
DatatypeValidator
.
ENUMERATION
)
)
continue
;
value
=
(
String
)
facets
.
get
(
key
)
;
double
realValue
=
0
;
try
{
realValue
=
Double
.
valueOf
(
value
)
.
doubleValue
(
)
;
}
catch
(
NumberFormatException
nfe
)
{
throw
new
IllegalFacetValueException
(
getErrorString
(
DatatypeMessageProvider
.
IllegalFacetValue
,
DatatypeMessageProvider
.
MSG_NONE
,
new
Object
[
]
{
value
,
key
}
)
)
;
}
if
(
key
.
equals
(
DatatypeValidator
.
MININCLUSIVE
)
)
{
fIsMinInclusive
=
true
;
fMinInclusive
=
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
MINEXCLUSIVE
)
)
{
fIsMinExclusive
=
true
;
fMinExclusive
=
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
MAXINCLUSIVE
)
)
{
fIsMaxInclusive
=
true
;
fMaxInclusive
=
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
MAXEXCLUSIVE
)
)
{
fIsMaxExclusive
=
true
;
fMaxExclusive
=
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
MINABSOLUTEVALUE
)
)
{
fIsMinAbsoluteValue
=
true
;
fMinAbsoluteValue
=
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
MAXABSOLUTEVALUE
)
)
{
fIsMaxAbsoluteValue
=
true
;
fMaxAbsoluteValue
=
realValue
;
}
else
if
(
key
.
equals
(
DatatypeValidator
.
ENUMERATION
)
)
{
}
else
if
(
key
.
equals
(
DatatypeValidator
.
PRECISION
)
||
key
.
equals
(
DatatypeValidator
.
SCALE
)
||
key
.
equals
(
DatatypeValidator
.
LENGTH
)
||
key
.
equals
(
DatatypeValidator
.
MAXLENGTH
)
||
key
.
equals
(
DatatypeValidator
.
LITERAL
)
||
key
.
equals
(
DatatypeValidator
.
LEXICALREPRESENTATION
)
||
key
.
equals
(
DatatypeValidator
.
LEXICAL
)
)
throw
new
IllegalFacetException
(
getErrorString
(
DatatypeMessageProvider
.
IllegalRealFacet
,
DatatypeMessageProvider
.
MSG_NONE
,
null
)
)
;
else
throw
new
UnknownFacetException
(
getErrorString
(
DatatypeMessageProvider
.
UnknownFacet
,
DatatypeMessageProvider
.
MSG_NONE
,
new
Object
[
]
{
key
}
)
)
;
}
Vector
v
=
(
Vector
)
facets
.
get
(
DatatypeValidator
.
ENUMERATION
)
;
if
(
v
!=
null
)
{
fHasEnums
=
true
;
fEnumValues
=
new
double
[
v
.
size
(
)
]
;
for
(
int
i
=
0
;
i
<
v
.
size
(
)
;
i
++
)
try
{
fEnumValues
[
i
]
=
Double
.
valueOf
(
(
String
)
v
.
elementAt
(
i
)
)
.
doubleValue
(
)
;
boundsCheck
(
fEnumValues
[
i
]
)
;
}
catch
(
InvalidDatatypeValueException
idve
)
{
throw
new
IllegalFacetValueException
(
getErrorString
(
DatatypeMessageProvider
.
InvalidEnumValue
,
DatatypeMessageProvider
.
MSG_NONE
,
new
Object
[
]
{
v
.
elementAt
(
i
)
}
)
)
;
}
catch
(
NumberFormatException
nfe
)
{
System
.
out
.
println
(
"Internal Error parsing enumerated values for real type"
)
;
}
}
}
public
void
setFacets
(
int
facets
[
]
)
throws
UnknownFacetException
,
IllegalFacetException
,
IllegalFacetValueException
{
}
public
void
setBasetype
(
DatatypeValidator
base
)
{
fBaseValidator
=
(
RealValidator
)
base
;
}
private
void
boundsCheck
(
double
d
)
throws
InvalidDatatypeValueException
{
boolean
minOk
=
false
;
boolean
maxOk
=
false
;
if
(
fIsMaxInclusive
)
maxOk
=
(
d
<=
fMaxInclusive
)
;
else
if
(
fIsMaxExclusive
)
maxOk
=
(
d
<
fMaxExclusive
)
;
else
maxOk
=
(
!
fIsMaxInclusive
&&
!
fIsMaxExclusive
)
;
if
(
fIsMinInclusive
)
minOk
=
(
d
>=
fMinInclusive
)
;
else
if
(
fIsMinExclusive
)
minOk
=
(
d
>
fMinInclusive
)
;
else
minOk
=
(
!
fIsMinInclusive
&&
!
fIsMinExclusive
)
;
if
(
!
(
minOk
&&
maxOk
)
)
throw
new
InvalidDatatypeValueException
(
getErrorString
(
DatatypeMessageProvider
.
OutOfBounds
,
DatatypeMessageProvider
.
MSG_NONE
,
new
Object
[
]
{
new
Double
(
d
)
}
)
)
;
}
private
void
enumCheck
(
double
v
)
throws
InvalidDatatypeValueException
{
for
(
int
i
=
0
;
i
<
fEnumValues
.
length
;
i
++
)
{
if
(
v
==
fEnumValues
[
i
]
)
return
;
}
throw
new
InvalidDatatypeValueException
(
getErrorString
(
DatatypeMessageProvider
.
NotAnEnumValue
,
DatatypeMessageProvider
.
MSG_NONE
,
new
Object
[
]
{
new
Double
(
v
)
}
)
)
;
}
public
void
setLocale
(
Locale
locale
)
{
}
private
String
getErrorString
(
int
major
,
int
minor
,
Object
args
[
]
)
{
try
{
return
fMessageProvider
.
createMessage
(
fLocale
,
major
,
minor
,
args
)
;
}
catch
(
Exception
e
)
{
return
"Illegal Errorcode "
+
minor
;
}
}
}
