package
org
.
apache
.
xerces
.
dom
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
xerces
.
framework
.
XMLAttrList
;
import
org
.
apache
.
xerces
.
utils
.
StringPool
;
import
org
.
w3c
.
dom
.
*
;
public
class
DeferredDocumentImpl
extends
DocumentImpl
{
static
final
long
serialVersionUID
=
5186323580749626857L
;
private
static
final
boolean
DEBUG_PRINT_TABLES
=
false
;
private
static
final
boolean
DEBUG_IDS
=
false
;
protected
static
final
int
CHUNK_SHIFT
=
11
;
protected
static
final
int
CHUNK_SIZE
=
(
1
<<
CHUNK_SHIFT
)
;
protected
static
final
int
CHUNK_MASK
=
CHUNK_SIZE
-
1
;
protected
static
final
int
INITIAL_CHUNK_COUNT
=
(
1
<<
(
16
-
CHUNK_SHIFT
)
)
;
protected
transient
int
fNodeCount
=
0
;
protected
transient
byte
fNodeType
[
]
[
]
;
protected
transient
int
fNodeName
[
]
[
]
;
protected
transient
int
fNodeValue
[
]
[
]
;
protected
transient
int
fNodeParent
[
]
[
]
;
protected
transient
int
fNodeFirstChild
[
]
[
]
;
protected
transient
int
fNodeLastChild
[
]
[
]
;
protected
transient
int
fNodePrevSib
[
]
[
]
;
protected
transient
int
fNodeNextSib
[
]
[
]
;
protected
transient
int
fIdCount
;
protected
transient
int
fIdName
[
]
;
protected
transient
int
fIdElement
[
]
;
protected
transient
StringPool
fStringPool
;
protected
boolean
fNamespacesEnabled
=
false
;
public
DeferredDocumentImpl
(
StringPool
stringPool
)
{
this
(
stringPool
,
false
)
;
}
public
DeferredDocumentImpl
(
StringPool
stringPool
,
boolean
namespacesEnabled
)
{
this
(
stringPool
,
namespacesEnabled
,
false
)
;
}
public
DeferredDocumentImpl
(
StringPool
stringPool
,
boolean
namespaces
,
boolean
grammarAccess
)
{
super
(
grammarAccess
)
;
fStringPool
=
stringPool
;
syncData
=
true
;
syncChildren
=
true
;
fNamespacesEnabled
=
namespaces
;
}
boolean
getNamespacesEnabled
(
)
{
return
fNamespacesEnabled
;
}
public
int
createDocument
(
)
{
int
nodeIndex
=
createNode
(
Node
.
DOCUMENT_NODE
)
;
return
nodeIndex
;
}
public
int
createDocumentType
(
int
rootElementNameIndex
,
int
publicId
,
int
systemId
)
{
int
nodeIndex
=
createNode
(
Node
.
DOCUMENT_TYPE_NODE
)
;
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
fNodeName
[
chunk
]
[
index
]
=
rootElementNameIndex
;
int
extraDataIndex
=
createNode
(
Node
.
TEXT_NODE
)
;
int
echunk
=
extraDataIndex
>
>
CHUNK_SHIFT
;
int
eindex
=
extraDataIndex
&
CHUNK_MASK
;
fNodeValue
[
chunk
]
[
index
]
=
extraDataIndex
;
fNodeFirstChild
[
echunk
]
[
eindex
]
=
publicId
;
fNodeLastChild
[
echunk
]
[
eindex
]
=
systemId
;
return
nodeIndex
;
}
public
int
createNotation
(
int
notationName
,
int
publicId
,
int
systemId
)
throws
Exception
{
int
nodeIndex
=
createNode
(
Node
.
NOTATION_NODE
)
;
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
int
extraDataIndex
=
createNode
(
Node
.
TEXT_NODE
)
;
int
echunk
=
extraDataIndex
>
>
CHUNK_SHIFT
;
int
eindex
=
extraDataIndex
&
CHUNK_MASK
;
fNodeValue
[
chunk
]
[
index
]
=
extraDataIndex
;
fNodeName
[
chunk
]
[
index
]
=
notationName
;
fNodeFirstChild
[
echunk
]
[
eindex
]
=
publicId
;
fNodeLastChild
[
echunk
]
[
eindex
]
=
systemId
;
return
nodeIndex
;
}
public
int
createEntity
(
int
entityName
,
int
publicId
,
int
systemId
,
int
notationName
)
throws
Exception
{
int
nodeIndex
=
createNode
(
Node
.
ENTITY_NODE
)
;
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
int
extraDataIndex
=
createNode
(
Node
.
TEXT_NODE
)
;
int
echunk
=
extraDataIndex
>
>
CHUNK_SHIFT
;
int
eindex
=
extraDataIndex
&
CHUNK_MASK
;
fNodeValue
[
chunk
]
[
index
]
=
extraDataIndex
;
fNodeName
[
chunk
]
[
index
]
=
entityName
;
fNodeFirstChild
[
echunk
]
[
eindex
]
=
publicId
;
fNodeLastChild
[
echunk
]
[
eindex
]
=
systemId
;
fNodePrevSib
[
echunk
]
[
eindex
]
=
notationName
;
return
nodeIndex
;
}
public
int
createEntityReference
(
int
nameIndex
)
throws
Exception
{
int
nodeIndex
=
createNode
(
Node
.
ENTITY_REFERENCE_NODE
)
;
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
fNodeName
[
chunk
]
[
index
]
=
nameIndex
;
return
nodeIndex
;
}
public
int
createElement
(
int
elementNameIndex
,
XMLAttrList
attrList
,
int
attrListIndex
)
{
int
elementNodeIndex
=
createNode
(
Node
.
ELEMENT_NODE
)
;
int
elementChunk
=
elementNodeIndex
>
>
CHUNK_SHIFT
;
int
elementIndex
=
elementNodeIndex
&
CHUNK_MASK
;
fNodeName
[
elementChunk
]
[
elementIndex
]
=
elementNameIndex
;
if
(
attrListIndex
!=
-
1
)
{
int
first
=
attrList
.
getFirstAttr
(
attrListIndex
)
;
int
lastAttrNodeIndex
=
-
1
;
int
lastAttrChunk
=
-
1
;
int
lastAttrIndex
=
-
1
;
for
(
int
index
=
first
;
index
!=
-
1
;
index
=
attrList
.
getNextAttr
(
index
)
)
{
int
attrNodeIndex
=
createAttribute
(
attrList
.
getAttrName
(
index
)
,
attrList
.
getAttValue
(
index
)
,
attrList
.
isSpecified
(
index
)
)
;
int
attrChunk
=
attrNodeIndex
>
>
CHUNK_SHIFT
;
int
attrIndex
=
attrNodeIndex
&
CHUNK_MASK
;
fNodeParent
[
attrChunk
]
[
attrIndex
]
=
elementNodeIndex
;
if
(
index
==
first
)
{
fNodeValue
[
elementChunk
]
[
elementIndex
]
=
attrNodeIndex
;
}
else
{
fNodeNextSib
[
lastAttrChunk
]
[
lastAttrIndex
]
=
attrNodeIndex
;
fNodePrevSib
[
attrChunk
]
[
attrIndex
]
=
lastAttrNodeIndex
;
}
lastAttrNodeIndex
=
attrNodeIndex
;
lastAttrChunk
=
attrChunk
;
lastAttrIndex
=
attrIndex
;
}
}
return
elementNodeIndex
;
}
public
int
createAttribute
(
int
attrNameIndex
,
int
attrValueIndex
,
boolean
specified
)
{
int
nodeIndex
=
createNode
(
NodeImpl
.
ATTRIBUTE_NODE
)
;
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
fNodeName
[
chunk
]
[
index
]
=
attrNameIndex
;
fNodeValue
[
chunk
]
[
index
]
=
specified
?
1
:
0
;
int
textNodeIndex
=
createTextNode
(
attrValueIndex
,
false
)
;
appendChild
(
nodeIndex
,
textNodeIndex
)
;
return
nodeIndex
;
}
public
int
createElementDefinition
(
int
elementNameIndex
)
{
int
nodeIndex
=
createNode
(
NodeImpl
.
ELEMENT_DEFINITION_NODE
)
;
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
fNodeName
[
chunk
]
[
index
]
=
elementNameIndex
;
return
nodeIndex
;
}
public
int
createTextNode
(
int
dataIndex
,
boolean
ignorableWhitespace
)
{
int
nodeIndex
=
createNode
(
Node
.
TEXT_NODE
)
;
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
fNodeValue
[
chunk
]
[
index
]
=
dataIndex
;
fNodeFirstChild
[
chunk
]
[
index
]
=
ignorableWhitespace
?
1
:
0
;
return
nodeIndex
;
}
public
int
createCDATASection
(
int
dataIndex
,
boolean
ignorableWhitespace
)
{
int
nodeIndex
=
createNode
(
Node
.
CDATA_SECTION_NODE
)
;
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
fNodeValue
[
chunk
]
[
index
]
=
dataIndex
;
fNodeFirstChild
[
chunk
]
[
index
]
=
ignorableWhitespace
?
1
:
0
;
return
nodeIndex
;
}
public
int
createProcessingInstruction
(
int
targetIndex
,
int
dataIndex
)
{
int
nodeIndex
=
createNode
(
Node
.
PROCESSING_INSTRUCTION_NODE
)
;
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
fNodeName
[
chunk
]
[
index
]
=
targetIndex
;
fNodeValue
[
chunk
]
[
index
]
=
dataIndex
;
return
nodeIndex
;
}
public
int
createComment
(
int
dataIndex
)
{
int
nodeIndex
=
createNode
(
Node
.
COMMENT_NODE
)
;
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
fNodeValue
[
chunk
]
[
index
]
=
dataIndex
;
return
nodeIndex
;
}
public
void
appendChild
(
int
parentIndex
,
int
childIndex
)
{
int
pchunk
=
parentIndex
>
>
CHUNK_SHIFT
;
int
pindex
=
parentIndex
&
CHUNK_MASK
;
int
chunk
=
childIndex
>
>
CHUNK_SHIFT
;
int
index
=
childIndex
&
CHUNK_MASK
;
fNodeParent
[
chunk
]
[
index
]
=
parentIndex
;
int
prev
=
fNodeLastChild
[
pchunk
]
[
pindex
]
;
fNodePrevSib
[
chunk
]
[
index
]
=
prev
;
if
(
prev
==
-
1
)
{
fNodeFirstChild
[
pchunk
]
[
pindex
]
=
childIndex
;
}
else
{
int
chnk
=
prev
>
>
CHUNK_SHIFT
;
int
indx
=
prev
&
CHUNK_MASK
;
fNodeNextSib
[
chnk
]
[
indx
]
=
childIndex
;
}
fNodeLastChild
[
pchunk
]
[
pindex
]
=
childIndex
;
}
public
int
setAttributeNode
(
int
elemIndex
,
int
attrIndex
)
{
int
echunk
=
elemIndex
>
>
CHUNK_SHIFT
;
int
eindex
=
elemIndex
&
CHUNK_MASK
;
int
achunk
=
attrIndex
>
>
CHUNK_SHIFT
;
int
aindex
=
attrIndex
&
CHUNK_MASK
;
String
attrName
=
fStringPool
.
toString
(
fNodeName
[
achunk
]
[
aindex
]
)
;
int
oldAttrIndex
=
fNodeValue
[
echunk
]
[
eindex
]
;
int
oachunk
=
-
1
;
int
oaindex
=
-
1
;
while
(
oldAttrIndex
!=
-
1
)
{
oachunk
=
oldAttrIndex
>
>
CHUNK_SHIFT
;
oaindex
=
oldAttrIndex
&
CHUNK_MASK
;
String
oldAttrName
=
fStringPool
.
toString
(
fNodeName
[
oachunk
]
[
oaindex
]
)
;
if
(
oldAttrName
.
equals
(
attrName
)
)
{
break
;
}
oldAttrIndex
=
fNodeNextSib
[
oachunk
]
[
oaindex
]
;
}
if
(
oldAttrIndex
!=
-
1
)
{
int
prevIndex
=
fNodePrevSib
[
oachunk
]
[
oaindex
]
;
int
nextIndex
=
fNodeNextSib
[
oachunk
]
[
oaindex
]
;
if
(
prevIndex
==
-
1
)
{
fNodeValue
[
echunk
]
[
eindex
]
=
nextIndex
;
}
else
{
int
pchunk
=
prevIndex
>
>
CHUNK_SHIFT
;
int
pindex
=
prevIndex
&
CHUNK_MASK
;
fNodeNextSib
[
pchunk
]
[
pindex
]
=
nextIndex
;
}
if
(
nextIndex
!=
-
1
)
{
int
nchunk
=
nextIndex
>
>
CHUNK_SHIFT
;
int
nindex
=
nextIndex
&
CHUNK_MASK
;
fNodePrevSib
[
nchunk
]
[
nindex
]
=
prevIndex
;
}
fNodePrevSib
[
oachunk
]
[
oaindex
]
=
-
1
;
fNodeNextSib
[
oachunk
]
[
oaindex
]
=
-
1
;
}
int
nextIndex
=
fNodeValue
[
echunk
]
[
eindex
]
;
fNodeValue
[
echunk
]
[
eindex
]
=
attrIndex
;
fNodeNextSib
[
achunk
]
[
aindex
]
=
nextIndex
;
if
(
nextIndex
!=
-
1
)
{
int
nchunk
=
nextIndex
>
>
CHUNK_SHIFT
;
int
nindex
=
nextIndex
&
CHUNK_MASK
;
fNodePrevSib
[
nchunk
]
[
nindex
]
=
attrIndex
;
}
return
oldAttrIndex
;
}
public
int
insertBefore
(
int
parentIndex
,
int
newChildIndex
,
int
refChildIndex
)
{
if
(
refChildIndex
==
-
1
)
{
appendChild
(
parentIndex
,
newChildIndex
)
;
return
newChildIndex
;
}
int
pchunk
=
parentIndex
>
>
CHUNK_SHIFT
;
int
pindex
=
parentIndex
&
CHUNK_MASK
;
int
nchunk
=
newChildIndex
>
>
CHUNK_SHIFT
;
int
nindex
=
newChildIndex
&
CHUNK_MASK
;
int
rchunk
=
refChildIndex
>
>
CHUNK_SHIFT
;
int
rindex
=
refChildIndex
&
CHUNK_MASK
;
int
firstIndex
=
getFirstChild
(
parentIndex
)
;
if
(
firstIndex
==
refChildIndex
)
{
fNodeFirstChild
[
pchunk
]
[
pindex
]
=
newChildIndex
;
}
int
prevIndex
=
getPreviousSibling
(
refChildIndex
)
;
if
(
prevIndex
!=
-
1
)
{
int
chunk
=
prevIndex
>
>
CHUNK_SHIFT
;
int
index
=
prevIndex
&
CHUNK_MASK
;
fNodeNextSib
[
chunk
]
[
index
]
=
newChildIndex
;
}
fNodePrevSib
[
nchunk
]
[
nindex
]
=
prevIndex
;
fNodeNextSib
[
nchunk
]
[
nindex
]
=
refChildIndex
;
fNodePrevSib
[
rchunk
]
[
rindex
]
=
newChildIndex
;
return
newChildIndex
;
}
public
void
setAsFirstChild
(
int
parentIndex
,
int
childIndex
)
{
int
pchunk
=
parentIndex
>
>
CHUNK_SHIFT
;
int
pindex
=
parentIndex
&
CHUNK_MASK
;
int
chunk
=
childIndex
>
>
CHUNK_SHIFT
;
int
index
=
childIndex
&
CHUNK_MASK
;
fNodeFirstChild
[
pchunk
]
[
pindex
]
=
childIndex
;
int
next
=
childIndex
;
while
(
next
!=
-
1
)
{
childIndex
=
next
;
next
=
fNodeNextSib
[
chunk
]
[
index
]
;
chunk
=
next
>
>
CHUNK_SHIFT
;
index
=
next
&
CHUNK_MASK
;
}
fNodeLastChild
[
pchunk
]
[
pindex
]
=
childIndex
;
}
public
int
getParentNode
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
-
1
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
return
fNodeParent
[
chunk
]
[
index
]
;
}
public
int
getFirstChild
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
-
1
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
return
fNodeFirstChild
[
chunk
]
[
index
]
;
}
public
int
getLastChild
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
-
1
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
int
lastChild
=
fNodeLastChild
[
chunk
]
[
index
]
;
if
(
lastChild
!=
-
1
&&
fNodeType
[
chunk
]
[
index
]
==
Node
.
TEXT_NODE
)
{
int
previousIndex
=
fNodePrevSib
[
chunk
]
[
index
]
;
chunk
=
previousIndex
>
>
CHUNK_SHIFT
;
index
=
previousIndex
&
CHUNK_MASK
;
if
(
previousIndex
!=
-
1
&&
fNodeType
[
chunk
]
[
index
]
==
Node
.
TEXT_NODE
)
{
while
(
previousIndex
!=
-
1
&&
fNodeType
[
chunk
]
[
index
]
==
Node
.
TEXT_NODE
)
{
nodeIndex
=
previousIndex
;
previousIndex
=
fNodePrevSib
[
chunk
]
[
index
]
;
chunk
=
previousIndex
>
>
CHUNK_SHIFT
;
index
=
previousIndex
&
CHUNK_MASK
;
}
return
nodeIndex
;
}
}
return
lastChild
;
}
public
int
getPreviousSibling
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
-
1
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
int
previousIndex
=
fNodePrevSib
[
chunk
]
[
index
]
;
if
(
previousIndex
!=
-
1
&&
fNodeType
[
chunk
]
[
index
]
!=
Node
.
TEXT_NODE
)
{
chunk
=
previousIndex
>
>
CHUNK_SHIFT
;
index
=
previousIndex
&
CHUNK_MASK
;
if
(
fNodeType
[
chunk
]
[
index
]
==
Node
.
TEXT_NODE
)
{
while
(
previousIndex
!=
-
1
&&
fNodeType
[
chunk
]
[
index
]
==
Node
.
TEXT_NODE
)
{
nodeIndex
=
previousIndex
;
previousIndex
=
fNodePrevSib
[
chunk
]
[
index
]
;
chunk
=
previousIndex
>
>
CHUNK_SHIFT
;
index
=
previousIndex
&
CHUNK_MASK
;
}
return
nodeIndex
;
}
}
return
previousIndex
;
}
public
int
getNextSibling
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
-
1
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
nodeIndex
=
fNodeNextSib
[
chunk
]
[
index
]
;
while
(
nodeIndex
!=
-
1
&&
fNodeType
[
chunk
]
[
index
]
==
Node
.
TEXT_NODE
)
{
nodeIndex
=
fNodeNextSib
[
chunk
]
[
index
]
;
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
index
=
nodeIndex
&
CHUNK_MASK
;
}
return
nodeIndex
;
}
public
int
getRealNextSibling
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
-
1
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
return
fNodeNextSib
[
chunk
]
[
index
]
;
}
public
int
lookupElementDefinition
(
int
elementNameIndex
)
{
if
(
fNodeCount
>
1
)
{
int
docTypeIndex
=
-
1
;
for
(
int
index
=
getFirstChild
(
0
)
;
index
!=
-
1
;
index
=
getNextSibling
(
index
)
)
{
if
(
getNodeType
(
index
)
==
Node
.
DOCUMENT_TYPE_NODE
)
{
docTypeIndex
=
index
;
break
;
}
}
for
(
int
index
=
getFirstChild
(
docTypeIndex
)
;
index
!=
-
1
;
index
=
getNextSibling
(
index
)
)
{
if
(
getNodeName
(
index
)
==
elementNameIndex
)
{
return
index
;
}
}
}
return
-
1
;
}
public
int
getAttributeList
(
int
elementNodeIndex
)
{
if
(
elementNodeIndex
==
-
1
)
{
return
-
1
;
}
int
chunk
=
elementNodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
elementNodeIndex
&
CHUNK_MASK
;
return
fNodeValue
[
chunk
]
[
index
]
;
}
public
DeferredNode
getNodeObject
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
null
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
int
type
=
fNodeType
[
chunk
]
[
index
]
;
DeferredNode
node
=
null
;
switch
(
type
)
{
case
Node
.
ATTRIBUTE_NODE
:
{
node
=
new
DeferredAttrImpl
(
this
,
nodeIndex
)
;
break
;
}
case
Node
.
CDATA_SECTION_NODE
:
{
node
=
new
DeferredCDATASectionImpl
(
this
,
nodeIndex
)
;
break
;
}
case
Node
.
COMMENT_NODE
:
{
node
=
new
DeferredCommentImpl
(
this
,
nodeIndex
)
;
break
;
}
case
Node
.
DOCUMENT_TYPE_NODE
:
{
node
=
new
DeferredDocumentTypeImpl
(
this
,
nodeIndex
)
;
docType
=
(
DocumentTypeImpl
)
node
;
break
;
}
case
Node
.
ELEMENT_NODE
:
{
if
(
DEBUG_IDS
)
{
System
.
out
.
println
(
"getNodeObject(ELEMENT_NODE): "
+
nodeIndex
)
;
}
node
=
new
DeferredElementImpl
(
this
,
nodeIndex
)
;
if
(
docElement
==
null
)
{
docElement
=
(
ElementImpl
)
node
;
}
if
(
fIdElement
!=
null
)
{
int
idIndex
=
DeferredDocumentImpl
.
binarySearch
(
fIdElement
,
0
,
fIdCount
,
nodeIndex
)
;
while
(
idIndex
!=
-
1
)
{
if
(
DEBUG_IDS
)
{
System
.
out
.
println
(
"  id index: "
+
idIndex
)
;
System
.
out
.
println
(
"  fIdName["
+
idIndex
+
"]: "
+
fIdName
[
idIndex
]
)
;
}
int
nameIndex
=
fIdName
[
idIndex
]
;
if
(
nameIndex
!=
-
1
)
{
String
name
=
fStringPool
.
toString
(
nameIndex
)
;
if
(
DEBUG_IDS
)
{
System
.
out
.
println
(
"  name: "
+
name
)
;
System
.
out
.
print
(
"getNodeObject()#"
)
;
}
putIdentifier0
(
name
,
(
Element
)
node
)
;
fIdName
[
idIndex
]
=
-
1
;
}
if
(
idIndex
<
fIdCount
&&
fIdElement
[
idIndex
+
1
]
==
nodeIndex
)
{
idIndex
++
;
}
else
{
idIndex
=
-
1
;
}
}
}
break
;
}
case
Node
.
ENTITY_NODE
:
{
node
=
new
DeferredEntityImpl
(
this
,
nodeIndex
)
;
break
;
}
case
Node
.
ENTITY_REFERENCE_NODE
:
{
node
=
new
DeferredEntityReferenceImpl
(
this
,
nodeIndex
)
;
break
;
}
case
Node
.
NOTATION_NODE
:
{
node
=
new
DeferredNotationImpl
(
this
,
nodeIndex
)
;
break
;
}
case
Node
.
PROCESSING_INSTRUCTION_NODE
:
{
node
=
new
DeferredProcessingInstructionImpl
(
this
,
nodeIndex
)
;
break
;
}
case
Node
.
TEXT_NODE
:
{
node
=
new
DeferredTextImpl
(
this
,
nodeIndex
)
;
break
;
}
case
NodeImpl
.
ELEMENT_DEFINITION_NODE
:
{
node
=
new
DeferredElementDefinitionImpl
(
this
,
nodeIndex
)
;
break
;
}
}
if
(
node
!=
null
)
{
return
node
;
}
throw
new
IllegalArgumentException
(
)
;
}
public
String
getNodeNameString
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
null
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
int
nameIndex
=
fNodeName
[
chunk
]
[
index
]
;
if
(
nameIndex
==
-
1
)
{
return
null
;
}
return
fStringPool
.
toString
(
nameIndex
)
;
}
public
String
getNodeValueString
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
null
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
int
valueIndex
=
fNodeValue
[
chunk
]
[
index
]
;
if
(
valueIndex
==
-
1
)
{
return
null
;
}
return
fStringPool
.
toString
(
valueIndex
)
;
}
public
int
getNodeName
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
-
1
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
return
fNodeName
[
chunk
]
[
index
]
;
}
public
int
getNodeValue
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
-
1
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
return
fNodeValue
[
chunk
]
[
index
]
;
}
public
short
getNodeType
(
int
nodeIndex
)
{
if
(
nodeIndex
==
-
1
)
{
return
-
1
;
}
int
chunk
=
nodeIndex
>
>
CHUNK_SHIFT
;
int
index
=
nodeIndex
&
CHUNK_MASK
;
return
fNodeType
[
chunk
]
[
index
]
;
}
public
void
putIdentifier
(
int
nameIndex
,
int
elementNodeIndex
)
{
if
(
DEBUG_IDS
)
{
System
.
out
.
println
(
"putIdentifier("
+
nameIndex
+
", "
+
elementNodeIndex
+
')'
+
" // "
+
fStringPool
.
toString
(
nameIndex
)
+
", "
+
fStringPool
.
toString
(
fNodeName
[
elementNodeIndex
>
>
CHUNK_SHIFT
]
[
elementNodeIndex
&
CHUNK_MASK
]
)
)
;
}
if
(
fIdName
==
null
)
{
fIdName
=
new
int
[
64
]
;
fIdElement
=
new
int
[
64
]
;
}
if
(
fIdCount
==
fIdName
.
length
)
{
int
idName
[
]
=
new
int
[
fIdCount
*
2
]
;
System
.
arraycopy
(
fIdName
,
0
,
idName
,
0
,
fIdCount
)
;
fIdName
=
idName
;
int
idElement
[
]
=
new
int
[
idName
.
length
]
;
System
.
arraycopy
(
fIdElement
,
0
,
idElement
,
0
,
fIdCount
)
;
fIdElement
=
idElement
;
}
fIdName
[
fIdCount
]
=
nameIndex
;
fIdElement
[
fIdCount
]
=
elementNodeIndex
;
fIdCount
++
;
}
public
void
print
(
)
{
if
(
DEBUG_PRINT_TABLES
)
{
System
.
out
.
println
(
"# start table"
)
;
for
(
int
i
=
0
;
i
<
fNodeCount
;
i
++
)
{
if
(
i
%
10
==
0
)
{
System
.
out
.
println
(
"num\ttype\tname\tval\tpar\tfch\tlch\tpsib\tnsib"
)
;
}
System
.
out
.
print
(
i
)
;
System
.
out
.
print
(
'\t'
)
;
System
.
out
.
print
(
fNodeType
[
0
]
[
i
]
)
;
System
.
out
.
print
(
'\t'
)
;
System
.
out
.
print
(
fNodeName
[
0
]
[
i
]
)
;
System
.
out
.
print
(
'\t'
)
;
System
.
out
.
print
(
fNodeValue
[
0
]
[
i
]
)
;
System
.
out
.
print
(
'\t'
)
;
System
.
out
.
print
(
fNodeParent
[
0
]
[
i
]
)
;
System
.
out
.
print
(
'\t'
)
;
System
.
out
.
print
(
fNodeFirstChild
[
0
]
[
i
]
)
;
System
.
out
.
print
(
'\t'
)
;
System
.
out
.
print
(
fNodeLastChild
[
0
]
[
i
]
)
;
System
.
out
.
print
(
'\t'
)
;
System
.
out
.
print
(
fNodePrevSib
[
0
]
[
i
]
)
;
System
.
out
.
print
(
'\t'
)
;
System
.
out
.
print
(
fNodeNextSib
[
0
]
[
i
]
)
;
System
.
out
.
println
(
)
;
}
System
.
out
.
println
(
"# end table"
)
;
}
}
protected
StringPool
getStringPool
(
)
{
return
fStringPool
;
}
protected
void
synchronizeData
(
)
{
syncData
=
false
;
if
(
fIdElement
!=
null
)
{
IntVector
path
=
new
IntVector
(
)
;
for
(
int
i
=
0
;
i
<
fIdCount
;
i
++
)
{
int
elementNodeIndex
=
fIdElement
[
i
]
;
int
idNameIndex
=
fIdName
[
i
]
;
if
(
idNameIndex
==
-
1
)
{
continue
;
}
path
.
removeAllElements
(
)
;
int
index
=
elementNodeIndex
;
do
{
path
.
addElement
(
index
)
;
index
=
getParentNode
(
index
)
;
}
while
(
index
!=
-
1
)
;
Node
place
=
this
;
for
(
int
j
=
path
.
size
(
)
-
2
;
j
>=
0
;
j
--
)
{
index
=
path
.
elementAt
(
j
)
;
Node
child
=
place
.
getFirstChild
(
)
;
while
(
child
!=
null
)
{
if
(
child
instanceof
DeferredNode
)
{
int
nodeIndex
=
(
(
DeferredNode
)
child
)
.
getNodeIndex
(
)
;
if
(
nodeIndex
==
index
)
{
place
=
child
;
break
;
}
}
child
=
child
.
getNextSibling
(
)
;
}
}
Element
element
=
(
Element
)
place
;
String
name
=
fStringPool
.
toString
(
idNameIndex
)
;
putIdentifier0
(
name
,
element
)
;
fIdName
[
i
]
=
-
1
;
while
(
fIdElement
[
i
+
1
]
==
elementNodeIndex
)
{
name
=
fStringPool
.
toString
(
fIdName
[
++
i
]
)
;
putIdentifier0
(
name
,
element
)
;
}
}
}
}
protected
void
synchronizeChildren
(
)
{
syncChildren
=
false
;
NodeImpl
last
=
null
;
for
(
int
index
=
getFirstChild
(
0
)
;
index
!=
-
1
;
index
=
getNextSibling
(
index
)
)
{
NodeImpl
node
=
(
NodeImpl
)
getNodeObject
(
index
)
;
if
(
last
==
null
)
{
firstChild
=
node
;
}
else
{
last
.
nextSibling
=
node
;
}
node
.
parentNode
=
this
;
node
.
previousSibling
=
last
;
last
=
node
;
int
type
=
node
.
getNodeType
(
)
;
if
(
type
==
Node
.
ELEMENT_NODE
)
{
docElement
=
(
ElementImpl
)
node
;
}
else
if
(
type
==
Node
.
DOCUMENT_TYPE_NODE
)
{
docType
=
(
DocumentTypeImpl
)
node
;
}
}
if
(
last
!=
null
)
{
lastChild
=
last
;
}
}
protected
boolean
ensureCapacity
(
int
chunk
,
int
index
)
{
if
(
fNodeType
==
null
)
{
fNodeType
=
new
byte
[
INITIAL_CHUNK_COUNT
]
[
]
;
fNodeName
=
new
int
[
INITIAL_CHUNK_COUNT
]
[
]
;
fNodeValue
=
new
int
[
INITIAL_CHUNK_COUNT
]
[
]
;
fNodeParent
=
new
int
[
INITIAL_CHUNK_COUNT
]
[
]
;
fNodeFirstChild
=
new
int
[
INITIAL_CHUNK_COUNT
]
[
]
;
fNodeLastChild
=
new
int
[
INITIAL_CHUNK_COUNT
]
[
]
;
fNodePrevSib
=
new
int
[
INITIAL_CHUNK_COUNT
]
[
]
;
fNodeNextSib
=
new
int
[
INITIAL_CHUNK_COUNT
]
[
]
;
}
try
{
return
fNodeType
[
chunk
]
[
index
]
!=
0
;
}
catch
(
ArrayIndexOutOfBoundsException
ex
)
{
int
newsize
=
chunk
*
2
;
byte
[
]
[
]
newByteArray
=
new
byte
[
newsize
]
[
]
;
System
.
arraycopy
(
fNodeType
,
0
,
newByteArray
,
0
,
chunk
)
;
fNodeType
=
newByteArray
;
int
[
]
[
]
newIntArray
=
new
int
[
newsize
]
[
]
;
System
.
arraycopy
(
fNodeName
,
0
,
newIntArray
,
0
,
chunk
)
;
fNodeName
=
newIntArray
;
newIntArray
=
new
int
[
newsize
]
[
]
;
System
.
arraycopy
(
fNodeValue
,
0
,
newIntArray
,
0
,
chunk
)
;
fNodeValue
=
newIntArray
;
newIntArray
=
new
int
[
newsize
]
[
]
;
System
.
arraycopy
(
fNodeParent
,
0
,
newIntArray
,
0
,
chunk
)
;
fNodeParent
=
newIntArray
;
newIntArray
=
new
int
[
newsize
]
[
]
;
System
.
arraycopy
(
fNodeFirstChild
,
0
,
newIntArray
,
0
,
chunk
)
;
fNodeFirstChild
=
newIntArray
;
newIntArray
=
new
int
[
newsize
]
[
]
;
System
.
arraycopy
(
fNodeLastChild
,
0
,
newIntArray
,
0
,
chunk
)
;
fNodeLastChild
=
newIntArray
;
newIntArray
=
new
int
[
newsize
]
[
]
;
System
.
arraycopy
(
fNodePrevSib
,
0
,
newIntArray
,
0
,
chunk
)
;
fNodePrevSib
=
newIntArray
;
newIntArray
=
new
int
[
newsize
]
[
]
;
System
.
arraycopy
(
fNodeNextSib
,
0
,
newIntArray
,
0
,
chunk
)
;
fNodeNextSib
=
newIntArray
;
}
catch
(
NullPointerException
ex
)
{
}
fNodeType
[
chunk
]
=
new
byte
[
CHUNK_SIZE
]
;
fNodeName
[
chunk
]
=
new
int
[
CHUNK_SIZE
]
;
fNodeValue
[
chunk
]
=
new
int
[
CHUNK_SIZE
]
;
fNodeParent
[
chunk
]
=
new
int
[
CHUNK_SIZE
]
;
fNodeFirstChild
[
chunk
]
=
new
int
[
CHUNK_SIZE
]
;
fNodeLastChild
[
chunk
]
=
new
int
[
CHUNK_SIZE
]
;
fNodePrevSib
[
chunk
]
=
new
int
[
CHUNK_SIZE
]
;
fNodeNextSib
[
chunk
]
=
new
int
[
CHUNK_SIZE
]
;
return
true
;
}
protected
int
createNode
(
short
nodeType
)
{
int
chunk
=
fNodeCount
>
>
CHUNK_SHIFT
;
int
index
=
fNodeCount
&
CHUNK_MASK
;
ensureCapacity
(
chunk
,
index
)
;
fNodeType
[
chunk
]
[
index
]
=
(
byte
)
nodeType
;
fNodeName
[
chunk
]
[
index
]
=
-
1
;
fNodeValue
[
chunk
]
[
index
]
=
-
1
;
fNodeParent
[
chunk
]
[
index
]
=
-
1
;
fNodeFirstChild
[
chunk
]
[
index
]
=
-
1
;
fNodeLastChild
[
chunk
]
[
index
]
=
-
1
;
fNodePrevSib
[
chunk
]
[
index
]
=
-
1
;
fNodeNextSib
[
chunk
]
[
index
]
=
-
1
;
return
fNodeCount
++
;
}
protected
static
int
binarySearch
(
final
int
values
[
]
,
int
start
,
int
end
,
int
target
)
{
if
(
DEBUG_IDS
)
{
System
.
out
.
println
(
"binarySearch(), target: "
+
target
)
;
}
while
(
start
<=
end
)
{
int
middle
=
(
start
+
end
)
/
2
;
int
value
=
values
[
middle
]
;
if
(
DEBUG_IDS
)
{
System
.
out
.
print
(
"  value: "
+
value
+
", target: "
+
target
+
" // "
)
;
print
(
values
,
start
,
end
,
middle
,
target
)
;
}
if
(
value
==
target
)
{
while
(
middle
>
0
&&
values
[
middle
-
1
]
==
target
)
{
middle
--
;
}
if
(
DEBUG_IDS
)
{
System
.
out
.
println
(
"FOUND AT "
+
middle
)
;
}
return
middle
;
}
if
(
value
>
target
)
{
end
=
middle
-
1
;
}
else
{
start
=
middle
+
1
;
}
}
if
(
DEBUG_IDS
)
{
System
.
out
.
println
(
"NOT FOUND!"
)
;
}
return
-
1
;
}
private
void
putIdentifier0
(
String
idName
,
Element
element
)
{
if
(
DEBUG_IDS
)
{
System
.
out
.
println
(
"putIdentifier0("
+
idName
+
", "
+
element
+
')'
)
;
}
if
(
identifiers
==
null
)
{
identifiers
=
new
java
.
util
.
Hashtable
(
)
;
}
identifiers
.
put
(
idName
,
element
)
;
}
private
static
void
print
(
int
values
[
]
,
int
start
,
int
end
,
int
middle
,
int
target
)
{
if
(
DEBUG_IDS
)
{
System
.
out
.
print
(
start
)
;
System
.
out
.
print
(
" ["
)
;
for
(
int
i
=
start
;
i
<
end
;
i
++
)
{
if
(
middle
==
i
)
{
System
.
out
.
print
(
"!"
)
;
}
System
.
out
.
print
(
values
[
i
]
)
;
if
(
values
[
i
]
==
target
)
{
System
.
out
.
print
(
"*"
)
;
}
if
(
i
<
end
-
1
)
{
System
.
out
.
print
(
" "
)
;
}
}
System
.
out
.
println
(
"] "
+
end
)
;
}
}
static
class
IntVector
{
private
int
data
[
]
;
private
int
size
;
public
int
size
(
)
{
return
size
;
}
public
int
elementAt
(
int
index
)
{
return
data
[
index
]
;
}
public
void
addElement
(
int
element
)
{
ensureCapacity
(
size
+
1
)
;
data
[
size
++
]
=
element
;
}
public
void
removeAllElements
(
)
{
size
=
0
;
}
private
void
ensureCapacity
(
int
newsize
)
{
if
(
data
==
null
)
{
data
=
new
int
[
newsize
+
15
]
;
}
else
if
(
newsize
>
data
.
length
)
{
int
newdata
[
]
=
new
int
[
newsize
+
15
]
;
System
.
arraycopy
(
data
,
0
,
newdata
,
0
,
data
.
length
)
;
data
=
newdata
;
}
}
}
}
