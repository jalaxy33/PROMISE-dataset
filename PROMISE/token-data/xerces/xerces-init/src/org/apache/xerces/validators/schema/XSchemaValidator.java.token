package
org
.
apache
.
xerces
.
validators
.
schema
;
import
org
.
apache
.
xerces
.
framework
.
XMLAttrList
;
import
org
.
apache
.
xerces
.
framework
.
XMLContentSpecNode
;
import
org
.
apache
.
xerces
.
framework
.
XMLErrorReporter
;
import
org
.
apache
.
xerces
.
framework
.
XMLValidator
;
import
org
.
apache
.
xerces
.
readers
.
XMLEntityHandler
;
import
org
.
apache
.
xerces
.
utils
.
ChunkyCharArray
;
import
org
.
apache
.
xerces
.
utils
.
NamespacesScope
;
import
org
.
apache
.
xerces
.
utils
.
StringPool
;
import
org
.
apache
.
xerces
.
utils
.
XMLCharacterProperties
;
import
org
.
apache
.
xerces
.
utils
.
XMLMessages
;
import
org
.
apache
.
xerces
.
utils
.
ImplementationMessages
;
import
org
.
xml
.
sax
.
Locator
;
import
org
.
xml
.
sax
.
InputSource
;
import
org
.
xml
.
sax
.
SAXParseException
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Stack
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
XMLContentModel
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
SimpleContentModel
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
MixedContentModel
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
DFAContentModel
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
CMException
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
CMNode
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
CMLeaf
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
CMUniOp
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
CMBinOp
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
InsertableElementsInfo
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
EntityPool
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
ElementDeclPool
;
import
org
.
apache
.
xerces
.
dom
.
DocumentImpl
;
import
org
.
apache
.
xerces
.
dom
.
DocumentTypeImpl
;
import
org
.
apache
.
xerces
.
parsers
.
DOMParser
;
import
org
.
w3c
.
dom
.
Document
;
import
org
.
w3c
.
dom
.
DocumentType
;
import
org
.
w3c
.
dom
.
Element
;
import
org
.
w3c
.
dom
.
Node
;
import
org
.
w3c
.
dom
.
NodeList
;
import
org
.
xml
.
sax
.
EntityResolver
;
import
org
.
xml
.
sax
.
ErrorHandler
;
import
org
.
xml
.
sax
.
SAXException
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
DatatypeValidator
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
InvalidDatatypeValueException
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
IllegalFacetException
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
IllegalFacetValueException
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
UnknownFacetException
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
BooleanValidator
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
IntegerValidator
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
StringValidator
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
RealValidator
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
DecimalValidator
;
import
org
.
apache
.
xerces
.
msg
.
SchemaMessages
;
public
class
XSchemaValidator
implements
XMLValidator
{
private
static
final
boolean
PRINT_EXCEPTION_STACK_TRACE
=
false
;
private
static
final
boolean
DEBUG_PRINT_ATTRIBUTES
=
false
;
private
static
final
boolean
DEBUG_PRINT_CONTENT
=
false
;
private
static
final
boolean
DEBUG_PAREN_DEPTH
=
false
;
private
static
final
boolean
DEBUG_MARKUP_DEPTH
=
false
;
private
boolean
fValidationEnabled
=
false
;
private
boolean
fDynamicValidation
=
false
;
private
boolean
fValidationEnabledByDynamic
=
false
;
private
boolean
fDynamicDisabledByValidation
=
false
;
private
boolean
fValidating
=
false
;
private
boolean
fWarningOnDuplicateAttDef
=
false
;
private
boolean
fWarningOnUndeclaredElements
=
false
;
private
EntityPool
fEntityPool
=
null
;
private
ElementDeclPool
fElementDeclPool
=
null
;
private
int
fStandaloneReader
=
-
1
;
private
int
[
]
fElementTypeStack
=
new
int
[
8
]
;
private
int
[
]
fContentSpecTypeStack
=
new
int
[
8
]
;
private
int
[
]
fElementChildCount
=
new
int
[
8
]
;
private
int
[
]
[
]
fElementChildren
=
new
int
[
8
]
[
]
;
private
int
fElementDepth
=
-
1
;
private
NamespacesScope
fNamespacesScope
=
null
;
private
boolean
fNamespacesEnabled
=
false
;
private
int
fRootElementType
=
-
1
;
private
int
fAttrIndex
=
-
1
;
private
XMLErrorReporter
fErrorReporter
=
null
;
private
XMLEntityHandler
fEntityHandler
=
null
;
private
StringPool
fStringPool
=
null
;
private
boolean
fBufferDatatype
=
false
;
private
StringBuffer
fDatatypeBuffer
=
new
StringBuffer
(
)
;
private
DatatypeValidatorRegistry
fDatatypeRegistry
=
new
DatatypeValidatorRegistry
(
)
;
private
int
fTypeCount
=
0
;
private
int
fGroupCount
=
0
;
private
int
fModelGroupCount
=
0
;
private
int
fAttributeGroupCount
=
0
;
private
Hashtable
fForwardRefs
=
new
Hashtable
(
)
;
private
Hashtable
fAttrGroupUses
=
new
Hashtable
(
)
;
private
static
final
String
ELT_COMMENT
=
"comment"
;
private
static
final
String
ELT_DATATYPEDECL
=
"datatype"
;
private
static
final
String
ELT_ARCHETYPEDECL
=
"archetype"
;
private
static
final
String
ELT_ELEMENTDECL
=
"element"
;
private
static
final
String
ELT_GROUP
=
"group"
;
private
static
final
String
ELT_ATTRGROUPDECL
=
"attrGroup"
;
private
static
final
String
ELT_ATTRGROUPREF
=
"attrGroupRef"
;
private
static
final
String
ELT_MODELGROUPDECL
=
"modelGroup"
;
private
static
final
String
ELT_MODELGROUPREF
=
"modelGroupRef"
;
private
static
final
String
ELT_TEXTENTITYDECL
=
"textEntity"
;
private
static
final
String
ELT_EXTERNALENTITYDECL
=
"externalEntity"
;
private
static
final
String
ELT_UNPARSEDENTITYDECL
=
"unparsedEntity"
;
private
static
final
String
ELT_NOTATIONDECL
=
"notation"
;
private
static
final
String
ELT_REFINES
=
"refines"
;
private
static
final
String
ELT_ATTRIBUTEDECL
=
"attribute"
;
private
static
final
String
ATT_NAME
=
"name"
;
private
static
final
String
ATT_CONTENT
=
"content"
;
private
static
final
String
ATT_MODEL
=
"model"
;
private
static
final
String
ATT_ORDER
=
"order"
;
private
static
final
String
ATT_TYPE
=
"type"
;
private
static
final
String
ATT_DEFAULT
=
"default"
;
private
static
final
String
ATT_FIXED
=
"fixed"
;
private
static
final
String
ATT_COLLECTION
=
"collection"
;
private
static
final
String
ATT_REF
=
"ref"
;
private
static
final
String
ATT_ARCHREF
=
"archRef"
;
private
static
final
String
ATT_SCHEMAABBREV
=
"schemaAbbrev"
;
private
static
final
String
ATT_SCHEMANAME
=
"schemaName"
;
private
static
final
String
ATT_MINOCCURS
=
"minOccurs"
;
private
static
final
String
ATT_MAXOCCURS
=
"maxOccurs"
;
private
static
final
String
ATT_EXPORT
=
"export"
;
private
static
final
String
ATTVAL_ANY
=
"any"
;
private
static
final
String
ATTVAL_MIXED
=
"mixed"
;
private
static
final
String
ATTVAL_EMPTY
=
"empty"
;
private
static
final
String
ATTVAL_CHOICE
=
"choice"
;
private
static
final
String
ATTVAL_SEQ
=
"seq"
;
private
static
final
String
ATTVAL_ALL
=
"all"
;
private
static
final
String
ATTVAL_ELEMONLY
=
"elemOnly"
;
private
static
final
String
ATTVAL_TEXTONLY
=
"textOnly"
;
private
Document
fSchemaDocument
;
public
XSchemaValidator
(
StringPool
stringPool
,
XMLErrorReporter
errorReporter
,
XMLEntityHandler
entityHandler
)
{
fEntityPool
=
new
EntityPool
(
stringPool
,
errorReporter
,
true
)
;
fElementDeclPool
=
new
ElementDeclPool
(
stringPool
,
errorReporter
)
;
fErrorReporter
=
errorReporter
;
fEntityHandler
=
entityHandler
;
fStringPool
=
stringPool
;
fDatatypeRegistry
.
initializeRegistry
(
)
;
}
public
void
reset
(
StringPool
stringPool
,
XMLErrorReporter
errorReporter
,
XMLEntityHandler
entityHandler
)
throws
Exception
{
fEntityPool
.
reset
(
stringPool
)
;
fValidating
=
fValidationEnabled
;
fElementDeclPool
.
reset
(
stringPool
)
;
fRootElementType
=
-
1
;
fAttrIndex
=
-
1
;
fStandaloneReader
=
-
1
;
fElementDepth
=
-
1
;
fErrorReporter
=
errorReporter
;
fEntityHandler
=
entityHandler
;
fStringPool
=
stringPool
;
fSchemaDocument
=
null
;
}
public
Document
getSchemaDocument
(
)
{
return
fSchemaDocument
;
}
public
void
setValidationEnabled
(
boolean
flag
)
{
fValidationEnabled
=
flag
;
fValidationEnabledByDynamic
=
false
;
if
(
fValidationEnabled
)
{
if
(
fDynamicDisabledByValidation
)
{
fDynamicValidation
=
true
;
fDynamicDisabledByValidation
=
false
;
}
}
else
if
(
fDynamicValidation
)
{
fDynamicValidation
=
false
;
fDynamicDisabledByValidation
=
true
;
}
fValidating
=
fValidationEnabled
;
}
public
boolean
getValidationEnabled
(
)
{
return
fValidationEnabled
;
}
public
void
setDynamicValidationEnabled
(
boolean
flag
)
{
fDynamicValidation
=
flag
;
fDynamicDisabledByValidation
=
false
;
if
(
fDynamicValidation
)
{
if
(
!
fValidationEnabled
)
{
fValidationEnabledByDynamic
=
true
;
fValidationEnabled
=
true
;
}
}
else
if
(
fValidationEnabledByDynamic
)
{
fValidationEnabled
=
false
;
fValidationEnabledByDynamic
=
false
;
}
}
public
boolean
getDynamicValidationEnabled
(
)
{
return
fDynamicValidation
;
}
public
void
setNamespacesEnabled
(
boolean
flag
)
{
fNamespacesEnabled
=
flag
;
}
public
boolean
getNamespacesEnabled
(
)
{
return
fNamespacesEnabled
;
}
public
void
setWarningOnDuplicateAttDef
(
boolean
flag
)
{
fWarningOnDuplicateAttDef
=
flag
;
}
public
boolean
getWarningOnDuplicateAttDef
(
)
{
return
fWarningOnDuplicateAttDef
;
}
public
void
setWarningOnUndeclaredElements
(
boolean
flag
)
{
fWarningOnUndeclaredElements
=
flag
;
}
public
boolean
getWarningOnUndeclaredElements
(
)
{
return
fWarningOnUndeclaredElements
;
}
private
boolean
usingStandaloneReader
(
)
{
return
fStandaloneReader
==
-
1
||
fEntityHandler
.
getReaderId
(
)
==
fStandaloneReader
;
}
private
boolean
invalidStandaloneAttDef
(
int
elementTypeIndex
,
int
attrNameIndex
)
{
if
(
fStandaloneReader
==
-
1
)
return
false
;
if
(
elementTypeIndex
==
-
1
)
return
false
;
int
attDefIndex
=
fElementDeclPool
.
getAttDef
(
elementTypeIndex
,
attrNameIndex
)
;
return
fElementDeclPool
.
getAttDefIsExternal
(
attDefIndex
)
;
}
public
boolean
notationDeclared
(
int
notationNameIndex
)
{
return
fEntityPool
.
lookupNotation
(
notationNameIndex
)
!=
-
1
;
}
protected
void
addRequiredNotation
(
int
notationName
,
Locator
locator
,
int
majorCode
,
int
minorCode
,
Object
[
]
args
)
throws
Exception
{
fEntityPool
.
addRequiredNotation
(
notationName
,
locator
,
majorCode
,
minorCode
,
args
)
;
}
public
void
characters
(
char
[
]
chars
,
int
offset
,
int
length
)
throws
Exception
{
if
(
fValidating
)
{
charDataInContent
(
)
;
if
(
fBufferDatatype
)
fDatatypeBuffer
.
append
(
chars
,
offset
,
length
)
;
}
}
public
void
characters
(
int
stringIndex
)
throws
Exception
{
if
(
fValidating
)
{
charDataInContent
(
)
;
if
(
fBufferDatatype
)
fDatatypeBuffer
.
append
(
fStringPool
.
toString
(
stringIndex
)
)
;
}
}
public
void
ignorableWhitespace
(
char
[
]
chars
,
int
offset
,
int
length
)
throws
Exception
{
if
(
fStandaloneReader
!=
-
1
&&
fValidating
)
{
int
elementIndex
=
getElement
(
peekElementType
(
)
)
;
if
(
fElementDeclPool
.
getElementDeclIsExternal
(
elementIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
)
;
}
}
}
public
void
ignorableWhitespace
(
int
stringIndex
)
throws
Exception
{
if
(
fStandaloneReader
!=
-
1
&&
fValidating
)
{
int
elementIndex
=
getElement
(
peekElementType
(
)
)
;
if
(
fElementDeclPool
.
getElementDeclIsExternal
(
elementIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
)
;
}
}
}
public
int
getElement
(
int
elementTypeIndex
)
{
int
elementIndex
=
fElementDeclPool
.
getElement
(
elementTypeIndex
)
;
return
elementIndex
;
}
public
int
getElementType
(
int
elementIndex
)
throws
Exception
{
int
name
=
fElementDeclPool
.
getElementType
(
elementIndex
)
;
return
name
;
}
public
int
getContentSpecType
(
int
elementIndex
)
{
int
contentspecType
=
fElementDeclPool
.
getContentSpecType
(
elementIndex
)
;
return
contentspecType
;
}
public
int
getContentSpec
(
int
elementIndex
)
{
int
contentspec
=
fElementDeclPool
.
getContentSpec
(
elementIndex
)
;
return
contentspec
;
}
public
String
getContentSpecAsString
(
int
elementIndex
)
{
String
contentspec
=
fElementDeclPool
.
getContentSpecAsString
(
elementIndex
)
;
return
contentspec
;
}
public
void
getContentSpecNode
(
int
contentSpecIndex
,
XMLContentSpecNode
csn
)
{
fElementDeclPool
.
getContentSpecNode
(
contentSpecIndex
,
csn
)
;
}
public
int
getAttName
(
int
attDefIndex
)
{
int
attName
=
fElementDeclPool
.
getAttName
(
attDefIndex
)
;
return
attName
;
}
public
int
getAttValue
(
int
attDefIndex
)
{
int
attValue
=
fElementDeclPool
.
getAttValue
(
attDefIndex
)
;
return
attValue
;
}
public
int
lookupEntity
(
int
entityNameIndex
)
{
int
entityIndex
=
fEntityPool
.
lookupEntity
(
entityNameIndex
)
;
return
entityIndex
;
}
public
boolean
externalReferenceInContent
(
int
entityIndex
)
throws
Exception
{
boolean
external
=
fEntityPool
.
isExternalEntity
(
entityIndex
)
;
if
(
fStandaloneReader
!=
-
1
&&
fValidating
)
{
if
(
external
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_EXTERNAL_ENTITY_NOT_PERMITTED
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fEntityPool
.
getEntityName
(
entityIndex
)
)
;
}
else
if
(
fEntityPool
.
getEntityDeclIsExternal
(
entityIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fEntityPool
.
getEntityName
(
entityIndex
)
)
;
}
}
return
external
;
}
public
int
valueOfReferenceInAttValue
(
int
entityIndex
)
throws
Exception
{
if
(
fStandaloneReader
!=
-
1
&&
fValidating
&&
fEntityPool
.
getEntityDeclIsExternal
(
entityIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fEntityPool
.
getEntityName
(
entityIndex
)
)
;
}
int
entityValue
=
fEntityPool
.
getEntityValue
(
entityIndex
)
;
return
entityValue
;
}
public
boolean
isExternalEntity
(
int
entityIndex
)
{
boolean
external
=
fEntityPool
.
isExternalEntity
(
entityIndex
)
;
return
external
;
}
public
boolean
isUnparsedEntity
(
int
entityIndex
)
{
boolean
external
=
fEntityPool
.
isUnparsedEntity
(
entityIndex
)
;
return
external
;
}
public
int
getEntityName
(
int
entityIndex
)
{
int
name
=
fEntityPool
.
getEntityName
(
entityIndex
)
;
return
name
;
}
public
int
getEntityValue
(
int
entityIndex
)
{
int
value
=
fEntityPool
.
getEntityValue
(
entityIndex
)
;
return
value
;
}
public
String
getPublicIdOfEntity
(
int
entityIndex
)
{
int
publicId
=
fEntityPool
.
getPublicId
(
entityIndex
)
;
return
fStringPool
.
toString
(
publicId
)
;
}
public
int
getPublicIdIndexOfEntity
(
int
entityIndex
)
{
int
publicId
=
fEntityPool
.
getPublicId
(
entityIndex
)
;
return
publicId
;
}
public
String
getSystemIdOfEntity
(
int
entityIndex
)
{
int
systemId
=
fEntityPool
.
getSystemId
(
entityIndex
)
;
return
fStringPool
.
toString
(
systemId
)
;
}
public
int
getSystemIdIndexOfEntity
(
int
entityIndex
)
{
int
systemId
=
fEntityPool
.
getSystemId
(
entityIndex
)
;
return
systemId
;
}
public
int
getNotationName
(
int
entityIndex
)
{
int
name
=
fEntityPool
.
getNotationName
(
entityIndex
)
;
return
name
;
}
public
int
lookupParameterEntity
(
int
peNameIndex
)
throws
Exception
{
throw
new
RuntimeException
(
"cannot happen 26"
)
;
}
public
boolean
isExternalParameterEntity
(
int
peIndex
)
{
throw
new
RuntimeException
(
"cannot happen 27"
)
;
}
public
int
getParameterEntityValue
(
int
peIndex
)
{
throw
new
RuntimeException
(
"cannot happen 28"
)
;
}
public
String
getPublicIdOfParameterEntity
(
int
peIndex
)
{
throw
new
RuntimeException
(
"cannot happen 29"
)
;
}
public
String
getSystemIdOfParameterEntity
(
int
peIndex
)
{
throw
new
RuntimeException
(
"cannot happen 30"
)
;
}
public
void
rootElementSpecified
(
int
rootElementType
)
throws
Exception
{
if
(
fValidating
)
{
fRootElementType
=
rootElementType
;
if
(
fRootElementType
!=
-
1
&&
rootElementType
!=
fRootElementType
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ROOT_ELEMENT_TYPE
,
XMLMessages
.
VC_ROOT_ELEMENT_TYPE
,
fRootElementType
,
rootElementType
)
;
}
}
}
public
boolean
attributeSpecified
(
int
elementTypeIndex
,
XMLAttrList
attrList
,
int
attrNameIndex
,
Locator
attrNameLocator
,
int
attValueIndex
)
throws
Exception
{
int
attDefIndex
=
fElementDeclPool
.
getAttDef
(
elementTypeIndex
,
attrNameIndex
)
;
if
(
attDefIndex
==
-
1
)
{
if
(
fValidating
)
{
Object
[
]
args
=
{
fStringPool
.
toString
(
elementTypeIndex
)
,
fStringPool
.
toString
(
attrNameIndex
)
}
;
fErrorReporter
.
reportError
(
attrNameLocator
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_ATTRIBUTE_NOT_DECLARED
,
XMLMessages
.
VC_ATTRIBUTE_VALUE_TYPE
,
args
,
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
)
;
}
int
attType
=
fStringPool
.
addSymbol
(
"CDATA"
)
;
if
(
fAttrIndex
==
-
1
)
fAttrIndex
=
attrList
.
startAttrList
(
)
;
return
attrList
.
addAttr
(
attrNameIndex
,
attValueIndex
,
attType
,
true
,
true
)
!=
-
1
;
}
int
attType
=
fElementDeclPool
.
getAttType
(
attDefIndex
)
;
if
(
attType
!=
fStringPool
.
addSymbol
(
"CDATA"
)
)
{
int
enumIndex
=
fElementDeclPool
.
getEnumeration
(
attDefIndex
)
;
attValueIndex
=
normalizeAttributeValue
(
elementTypeIndex
,
attrNameIndex
,
attValueIndex
,
attType
,
enumIndex
)
;
}
if
(
fAttrIndex
==
-
1
)
fAttrIndex
=
attrList
.
startAttrList
(
)
;
return
attrList
.
addAttr
(
attrNameIndex
,
attValueIndex
,
attType
,
true
,
true
)
!=
-
1
;
}
public
boolean
startElement
(
int
elementTypeIndex
,
XMLAttrList
attrList
)
throws
Exception
{
int
attrIndex
=
fAttrIndex
;
fAttrIndex
=
-
1
;
int
elementIndex
=
fElementDeclPool
.
getElement
(
elementTypeIndex
)
;
int
contentSpecType
=
(
elementIndex
==
-
1
)
?
-
1
:
fElementDeclPool
.
getContentSpecType
(
elementIndex
)
;
if
(
contentSpecType
==
-
1
&&
fValidating
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ELEMENT_NOT_DECLARED
,
XMLMessages
.
VC_ELEMENT_VALID
,
elementTypeIndex
)
;
}
if
(
elementIndex
!=
-
1
)
{
attrIndex
=
fElementDeclPool
.
addDefaultAttributes
(
elementIndex
,
attrList
,
attrIndex
,
fValidating
,
fStandaloneReader
!=
-
1
)
;
}
checkAttributes
(
elementIndex
,
attrList
,
attrIndex
)
;
if
(
fValidating
&&
contentSpecType
==
fStringPool
.
addSymbol
(
"DATATYPE"
)
)
{
fBufferDatatype
=
true
;
fDatatypeBuffer
.
setLength
(
0
)
;
}
pushElement
(
elementTypeIndex
,
contentSpecType
)
;
return
contentSpecType
==
fStringPool
.
addSymbol
(
"CHILDREN"
)
;
}
public
boolean
endElement
(
int
elementTypeIndex
)
throws
Exception
{
if
(
fValidating
)
{
int
elementIndex
=
fElementDeclPool
.
getElement
(
elementTypeIndex
)
;
if
(
elementIndex
!=
-
1
&&
fElementDeclPool
.
getContentSpecType
(
elementIndex
)
!=
-
1
)
{
int
childCount
=
peekChildCount
(
)
;
int
result
=
checkContent
(
elementIndex
,
childCount
,
peekChildren
(
)
)
;
if
(
result
!=
-
1
)
{
int
majorCode
=
result
!=
childCount
?
XMLMessages
.
MSG_CONTENT_INVALID
:
XMLMessages
.
MSG_CONTENT_INCOMPLETE
;
reportRecoverableXMLError
(
majorCode
,
0
,
fStringPool
.
toString
(
elementTypeIndex
)
,
fElementDeclPool
.
getContentSpecAsString
(
elementIndex
)
)
;
}
}
fBufferDatatype
=
false
;
}
popElement
(
)
;
return
peekContentSpecType
(
)
==
fStringPool
.
addSymbol
(
"CHILDREN"
)
;
}
private
int
normalizeAttributeValue
(
int
elementTypeIndex
,
int
attrNameIndex
,
int
attValueIndex
,
int
attType
,
int
enumIndex
)
throws
Exception
{
String
attValue
=
fStringPool
.
toString
(
attValueIndex
)
;
if
(
attType
==
fStringPool
.
addSymbol
(
"ID"
)
)
{
String
newAttValue
=
attValue
.
trim
(
)
;
if
(
fValidating
)
{
attValueIndex
=
fStringPool
.
addSymbol
(
newAttValue
)
;
if
(
newAttValue
!=
attValue
&&
invalidStandaloneAttDef
(
elementTypeIndex
,
attrNameIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fStringPool
.
toString
(
attrNameIndex
)
,
attValue
,
newAttValue
)
;
}
if
(
!
XMLCharacterProperties
.
validName
(
newAttValue
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ID_INVALID
,
XMLMessages
.
VC_ID
,
fStringPool
.
toString
(
attrNameIndex
)
,
newAttValue
)
;
}
if
(
elementTypeIndex
!=
-
1
&&
!
fElementDeclPool
.
addId
(
attValueIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ID_NOT_UNIQUE
,
XMLMessages
.
VC_ID
,
fStringPool
.
toString
(
attrNameIndex
)
,
newAttValue
)
;
}
}
else
if
(
newAttValue
!=
attValue
)
{
attValueIndex
=
fStringPool
.
addSymbol
(
newAttValue
)
;
}
}
else
if
(
attType
==
fStringPool
.
addSymbol
(
"IDREF"
)
)
{
String
newAttValue
=
attValue
.
trim
(
)
;
if
(
fValidating
)
{
attValueIndex
=
fStringPool
.
addSymbol
(
newAttValue
)
;
if
(
newAttValue
!=
attValue
&&
invalidStandaloneAttDef
(
elementTypeIndex
,
attrNameIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fStringPool
.
toString
(
attrNameIndex
)
,
attValue
,
newAttValue
)
;
}
if
(
!
XMLCharacterProperties
.
validName
(
newAttValue
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_IDREF_INVALID
,
XMLMessages
.
VC_IDREF
,
fStringPool
.
toString
(
attrNameIndex
)
,
newAttValue
)
;
}
if
(
elementTypeIndex
!=
-
1
)
fElementDeclPool
.
addIdRef
(
attValueIndex
)
;
}
else
if
(
newAttValue
!=
attValue
)
{
attValueIndex
=
fStringPool
.
addSymbol
(
newAttValue
)
;
}
}
else
if
(
attType
==
fStringPool
.
addSymbol
(
"IDREFS"
)
)
{
StringTokenizer
tokenizer
=
new
StringTokenizer
(
attValue
)
;
StringBuffer
sb
=
new
StringBuffer
(
attValue
.
length
(
)
)
;
boolean
ok
=
true
;
if
(
tokenizer
.
hasMoreTokens
(
)
)
{
while
(
true
)
{
String
idName
=
tokenizer
.
nextToken
(
)
;
if
(
fValidating
)
{
if
(
!
XMLCharacterProperties
.
validName
(
idName
)
)
{
ok
=
false
;
}
if
(
elementTypeIndex
!=
-
1
)
fElementDeclPool
.
addIdRef
(
fStringPool
.
addSymbol
(
idName
)
)
;
}
sb
.
append
(
idName
)
;
if
(
!
tokenizer
.
hasMoreTokens
(
)
)
break
;
sb
.
append
(
' '
)
;
}
}
String
newAttValue
=
sb
.
toString
(
)
;
if
(
fValidating
&&
(
!
ok
||
newAttValue
.
length
(
)
==
0
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_IDREFS_INVALID
,
XMLMessages
.
VC_IDREF
,
fStringPool
.
toString
(
attrNameIndex
)
,
newAttValue
)
;
}
if
(
!
newAttValue
.
equals
(
attValue
)
)
{
attValueIndex
=
fStringPool
.
addString
(
newAttValue
)
;
if
(
fValidating
&&
invalidStandaloneAttDef
(
elementTypeIndex
,
attrNameIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fStringPool
.
toString
(
attrNameIndex
)
,
attValue
,
newAttValue
)
;
}
}
}
else
if
(
attType
==
fStringPool
.
addSymbol
(
"ENTITY"
)
)
{
String
newAttValue
=
attValue
.
trim
(
)
;
if
(
fValidating
)
{
attValueIndex
=
fStringPool
.
addSymbol
(
newAttValue
)
;
if
(
newAttValue
!=
attValue
&&
invalidStandaloneAttDef
(
elementTypeIndex
,
attrNameIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fStringPool
.
toString
(
attrNameIndex
)
,
attValue
,
newAttValue
)
;
}
int
entity
=
fEntityPool
.
lookupEntity
(
attValueIndex
)
;
if
(
entity
==
-
1
||
!
fEntityPool
.
isUnparsedEntity
(
entity
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ENTITY_INVALID
,
XMLMessages
.
VC_ENTITY_NAME
,
fStringPool
.
toString
(
attrNameIndex
)
,
newAttValue
)
;
}
}
else
if
(
newAttValue
!=
attValue
)
{
attValueIndex
=
fStringPool
.
addSymbol
(
newAttValue
)
;
}
}
else
if
(
attType
==
fStringPool
.
addSymbol
(
"ENTITIES"
)
)
{
StringTokenizer
tokenizer
=
new
StringTokenizer
(
attValue
)
;
StringBuffer
sb
=
new
StringBuffer
(
attValue
.
length
(
)
)
;
boolean
ok
=
true
;
if
(
tokenizer
.
hasMoreTokens
(
)
)
{
while
(
true
)
{
String
entityName
=
tokenizer
.
nextToken
(
)
;
if
(
fValidating
)
{
int
entity
=
fEntityPool
.
lookupEntity
(
fStringPool
.
addSymbol
(
entityName
)
)
;
if
(
entity
==
-
1
||
!
fEntityPool
.
isUnparsedEntity
(
entity
)
)
{
ok
=
false
;
}
}
sb
.
append
(
entityName
)
;
if
(
!
tokenizer
.
hasMoreTokens
(
)
)
break
;
sb
.
append
(
' '
)
;
}
}
String
newAttValue
=
sb
.
toString
(
)
;
if
(
fValidating
&&
(
!
ok
||
newAttValue
.
length
(
)
==
0
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ENTITIES_INVALID
,
XMLMessages
.
VC_ENTITY_NAME
,
fStringPool
.
toString
(
attrNameIndex
)
,
newAttValue
)
;
}
if
(
!
newAttValue
.
equals
(
attValue
)
)
{
attValueIndex
=
fStringPool
.
addString
(
newAttValue
)
;
if
(
fValidating
&&
invalidStandaloneAttDef
(
elementTypeIndex
,
attrNameIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fStringPool
.
toString
(
attrNameIndex
)
,
attValue
,
newAttValue
)
;
}
}
}
else
if
(
attType
==
fStringPool
.
addSymbol
(
"NMTOKEN"
)
)
{
String
newAttValue
=
attValue
.
trim
(
)
;
if
(
fValidating
)
{
attValueIndex
=
fStringPool
.
addSymbol
(
newAttValue
)
;
if
(
newAttValue
!=
attValue
&&
invalidStandaloneAttDef
(
elementTypeIndex
,
attrNameIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fStringPool
.
toString
(
attrNameIndex
)
,
attValue
,
newAttValue
)
;
}
if
(
!
XMLCharacterProperties
.
validNmtoken
(
newAttValue
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_NMTOKEN_INVALID
,
XMLMessages
.
VC_NAME_TOKEN
,
fStringPool
.
toString
(
attrNameIndex
)
,
newAttValue
)
;
}
}
else
if
(
newAttValue
!=
attValue
)
{
attValueIndex
=
fStringPool
.
addSymbol
(
newAttValue
)
;
}
}
else
if
(
attType
==
fStringPool
.
addSymbol
(
"NMTOKENS"
)
)
{
StringTokenizer
tokenizer
=
new
StringTokenizer
(
attValue
)
;
StringBuffer
sb
=
new
StringBuffer
(
attValue
.
length
(
)
)
;
boolean
ok
=
true
;
if
(
tokenizer
.
hasMoreTokens
(
)
)
{
while
(
true
)
{
String
nmtoken
=
tokenizer
.
nextToken
(
)
;
if
(
fValidating
&&
!
XMLCharacterProperties
.
validNmtoken
(
nmtoken
)
)
{
ok
=
false
;
}
sb
.
append
(
nmtoken
)
;
if
(
!
tokenizer
.
hasMoreTokens
(
)
)
break
;
sb
.
append
(
' '
)
;
}
}
String
newAttValue
=
sb
.
toString
(
)
;
if
(
fValidating
&&
(
!
ok
||
newAttValue
.
length
(
)
==
0
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_NMTOKENS_INVALID
,
XMLMessages
.
VC_NAME_TOKEN
,
fStringPool
.
toString
(
attrNameIndex
)
,
newAttValue
)
;
}
if
(
!
newAttValue
.
equals
(
attValue
)
)
{
attValueIndex
=
fStringPool
.
addString
(
newAttValue
)
;
if
(
fValidating
&&
invalidStandaloneAttDef
(
elementTypeIndex
,
attrNameIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fStringPool
.
toString
(
attrNameIndex
)
,
attValue
,
newAttValue
)
;
}
}
}
else
if
(
attType
==
fStringPool
.
addSymbol
(
"NOTATION"
)
||
attType
==
fStringPool
.
addSymbol
(
"ENUMERATION"
)
)
{
String
newAttValue
=
attValue
.
trim
(
)
;
if
(
fValidating
)
{
attValueIndex
=
fStringPool
.
addSymbol
(
newAttValue
)
;
if
(
newAttValue
!=
attValue
&&
invalidStandaloneAttDef
(
elementTypeIndex
,
attrNameIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE
,
XMLMessages
.
VC_STANDALONE_DOCUMENT_DECLARATION
,
fStringPool
.
toString
(
attrNameIndex
)
,
attValue
,
newAttValue
)
;
}
if
(
!
fStringPool
.
stringInList
(
enumIndex
,
attValueIndex
)
)
{
reportRecoverableXMLError
(
XMLMessages
.
MSG_ATTRIBUTE_VALUE_NOT_IN_LIST
,
attType
==
fStringPool
.
addSymbol
(
"NOTATION"
)
?
XMLMessages
.
VC_NOTATION_ATTRIBUTES
:
XMLMessages
.
VC_ENUMERATION
,
fStringPool
.
toString
(
attrNameIndex
)
,
newAttValue
,
fStringPool
.
stringListAsString
(
enumIndex
)
)
;
}
}
else
if
(
newAttValue
!=
attValue
)
{
attValueIndex
=
fStringPool
.
addSymbol
(
newAttValue
)
;
}
}
else
if
(
attType
==
fStringPool
.
addSymbol
(
"DATATYPE"
)
)
{
try
{
String
type
=
fStringPool
.
toString
(
enumIndex
)
;
DatatypeValidator
v
=
fDatatypeRegistry
.
getValidatorFor
(
type
)
;
if
(
v
!=
null
)
v
.
validate
(
attValue
)
;
else
reportSchemaError
(
SchemaMessageProvider
.
NoValidatorFor
,
new
Object
[
]
{
type
}
)
;
}
catch
(
InvalidDatatypeValueException
idve
)
{
reportSchemaError
(
SchemaMessageProvider
.
IncorrectDatatype
,
new
Object
[
]
{
idve
.
getMessage
(
)
}
)
;
}
catch
(
Exception
e
)
{
e
.
printStackTrace
(
)
;
System
.
out
.
println
(
"Internal error in attribute datatype validation"
)
;
}
}
else
{
throw
new
RuntimeException
(
"cannot happen 1"
)
;
}
return
attValueIndex
;
}
private
void
pushElement
(
int
elementTypeIndex
,
int
contentSpecType
)
{
if
(
fElementDepth
>=
0
)
{
int
[
]
children
=
fElementChildren
[
fElementDepth
]
;
int
childCount
=
fElementChildCount
[
fElementDepth
]
;
if
(
children
==
null
)
{
children
=
fElementChildren
[
fElementDepth
]
=
new
int
[
8
]
;
childCount
=
0
;
}
else
if
(
childCount
==
children
.
length
)
{
int
[
]
newChildren
=
new
int
[
childCount
*
2
]
;
System
.
arraycopy
(
children
,
0
,
newChildren
,
0
,
childCount
)
;
children
=
fElementChildren
[
fElementDepth
]
=
newChildren
;
}
children
[
childCount
++
]
=
elementTypeIndex
;
fElementChildCount
[
fElementDepth
]
=
childCount
;
}
fElementDepth
++
;
if
(
fElementDepth
==
fElementTypeStack
.
length
)
{
int
[
]
newStack
=
new
int
[
fElementDepth
*
2
]
;
System
.
arraycopy
(
fElementTypeStack
,
0
,
newStack
,
0
,
fElementDepth
)
;
fElementTypeStack
=
newStack
;
newStack
=
new
int
[
fElementDepth
*
2
]
;
System
.
arraycopy
(
fContentSpecTypeStack
,
0
,
newStack
,
0
,
fElementDepth
)
;
fContentSpecTypeStack
=
newStack
;
newStack
=
new
int
[
fElementDepth
*
2
]
;
System
.
arraycopy
(
fElementChildCount
,
0
,
newStack
,
0
,
fElementDepth
)
;
fElementChildCount
=
newStack
;
int
[
]
[
]
newContentStack
=
new
int
[
fElementDepth
*
2
]
[
]
;
System
.
arraycopy
(
fElementChildren
,
0
,
newContentStack
,
0
,
fElementDepth
)
;
fElementChildren
=
newContentStack
;
}
fElementTypeStack
[
fElementDepth
]
=
elementTypeIndex
;
fContentSpecTypeStack
[
fElementDepth
]
=
contentSpecType
;
fElementChildCount
[
fElementDepth
]
=
0
;
}
private
void
charDataInContent
(
)
{
int
[
]
children
=
fElementChildren
[
fElementDepth
]
;
int
childCount
=
fElementChildCount
[
fElementDepth
]
;
if
(
children
==
null
)
{
children
=
fElementChildren
[
fElementDepth
]
=
new
int
[
8
]
;
childCount
=
0
;
}
else
if
(
childCount
==
children
.
length
)
{
int
[
]
newChildren
=
new
int
[
childCount
*
2
]
;
System
.
arraycopy
(
children
,
0
,
newChildren
,
0
,
childCount
)
;
children
=
fElementChildren
[
fElementDepth
]
=
newChildren
;
}
children
[
childCount
++
]
=
-
1
;
fElementChildCount
[
fElementDepth
]
=
childCount
;
}
private
int
peekElementType
(
)
{
return
fElementTypeStack
[
fElementDepth
]
;
}
private
int
peekContentSpecType
(
)
{
if
(
fElementDepth
<
0
)
return
-
1
;
return
fContentSpecTypeStack
[
fElementDepth
]
;
}
private
int
peekChildCount
(
)
{
return
fElementChildCount
[
fElementDepth
]
;
}
private
int
[
]
peekChildren
(
)
{
return
fElementChildren
[
fElementDepth
]
;
}
private
void
popElement
(
)
throws
Exception
{
if
(
fElementDepth
<
0
)
throw
new
RuntimeException
(
"Element stack underflow"
)
;
if
(
--
fElementDepth
<
0
)
{
if
(
fValidating
)
checkIDRefNames
(
)
;
}
}
private
void
checkAttributes
(
int
elementIndex
,
XMLAttrList
attrList
,
int
attrIndex
)
throws
Exception
{
if
(
DEBUG_PRINT_ATTRIBUTES
)
{
int
elementTypeIndex
=
fElementDeclPool
.
getElementType
(
elementIndex
)
;
String
elementType
=
fStringPool
.
toString
(
elementTypeIndex
)
;
System
.
out
.
print
(
"checkAttributes: <"
+
elementType
)
;
if
(
attrIndex
!=
-
1
)
{
int
index
=
attrList
.
getFirstAttr
(
attrIndex
)
;
while
(
index
!=
-
1
)
{
int
attNameIndex
=
attrList
.
getAttrName
(
index
)
;
if
(
attNameIndex
!=
-
1
)
{
int
adIndex
=
fElementDeclPool
.
getAttDef
(
elementTypeIndex
,
attNameIndex
)
;
if
(
adIndex
!=
-
1
)
System
.
out
.
println
(
fStringPool
.
toString
(
getAttName
(
adIndex
)
)
+
" "
+
fElementDeclPool
.
getAttType
(
adIndex
)
+
" "
+
fElementDeclPool
.
getEnumeration
(
adIndex
)
)
;
else
System
.
out
.
println
(
"Missing adIndex for "
+
fStringPool
.
toString
(
attNameIndex
)
)
;
}
else
System
.
out
.
println
(
"Missing attNameIndex"
)
;
System
.
out
.
print
(
" "
+
fStringPool
.
toString
(
attrList
.
getAttrName
(
index
)
)
+
"=\""
+
fStringPool
.
toString
(
attrList
.
getAttValue
(
index
)
)
+
"\""
)
;
index
=
attrList
.
getNextAttr
(
index
)
;
}
}
System
.
out
.
println
(
">"
)
;
}
}
public
int
checkContent
(
int
elementIndex
,
int
childCount
,
int
[
]
children
)
throws
Exception
{
final
int
elementTypeIndex
=
fElementDeclPool
.
getElementType
(
elementIndex
)
;
if
(
DEBUG_PRINT_CONTENT
)
{
String
strTmp
=
fStringPool
.
toString
(
elementTypeIndex
)
;
System
.
out
.
println
(
"Name: "
+
strTmp
+
", Count: "
+
childCount
+
", ContentSpec: "
+
fElementDeclPool
.
getContentSpecAsString
(
elementIndex
)
)
;
for
(
int
index
=
0
;
index
<
childCount
&&
index
<
10
;
index
++
)
{
if
(
index
==
0
)
System
.
out
.
print
(
"  ("
)
;
String
childName
=
(
children
[
index
]
==
-
1
)
?
"#PCDATA"
:
fStringPool
.
toString
(
children
[
index
]
)
;
if
(
index
+
1
==
childCount
)
System
.
out
.
println
(
childName
+
")"
)
;
else
if
(
index
+
1
==
10
)
System
.
out
.
println
(
childName
+
",...)"
)
;
else
System
.
out
.
print
(
childName
+
","
)
;
}
}
final
int
contentSpec
=
fElementDeclPool
.
getContentSpecType
(
elementIndex
)
;
if
(
contentSpec
==
fStringPool
.
addSymbol
(
"EMPTY"
)
)
{
if
(
childCount
!=
0
)
return
0
;
}
else
if
(
contentSpec
==
fStringPool
.
addSymbol
(
"ANY"
)
)
{
}
else
if
(
contentSpec
==
fStringPool
.
addSymbol
(
"MIXED"
)
||
contentSpec
==
fStringPool
.
addSymbol
(
"CHILDREN"
)
)
{
XMLContentModel
cmElem
=
null
;
try
{
cmElem
=
getContentModel
(
elementIndex
)
;
return
cmElem
.
validateContent
(
childCount
,
children
)
;
}
catch
(
CMException
excToCatch
)
{
int
majorCode
=
excToCatch
.
getErrorCode
(
)
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
ImplementationMessages
.
XERCES_IMPLEMENTATION_DOMAIN
,
majorCode
,
0
,
null
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
}
else
if
(
contentSpec
==
-
1
)
{
Object
[
]
args
=
{
fStringPool
.
toString
(
elementTypeIndex
)
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_ELEMENT_NOT_DECLARED
,
XMLMessages
.
VC_ELEMENT_VALID
,
args
,
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
)
;
}
else
if
(
contentSpec
==
fStringPool
.
addSymbol
(
"DATATYPE"
)
)
{
XMLContentModel
cmElem
=
null
;
try
{
cmElem
=
getContentModel
(
elementIndex
)
;
return
cmElem
.
validateContent
(
1
,
new
int
[
]
{
fStringPool
.
addString
(
fDatatypeBuffer
.
toString
(
)
)
}
)
;
}
catch
(
CMException
cme
)
{
System
.
out
.
println
(
"Internal Error in datatype validation"
)
;
}
catch
(
InvalidDatatypeValueException
idve
)
{
reportSchemaError
(
SchemaMessageProvider
.
DatatypeError
,
new
Object
[
]
{
idve
.
getMessage
(
)
}
)
;
}
}
else
{
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
ImplementationMessages
.
XERCES_IMPLEMENTATION_DOMAIN
,
ImplementationMessages
.
VAL_CST
,
0
,
null
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
return
-
1
;
}
public
void
checkIDRefNames
(
)
throws
Exception
{
fElementDeclPool
.
checkIdRefs
(
)
;
}
public
int
whatCanGoHere
(
int
elementIndex
,
boolean
fullyValid
,
InsertableElementsInfo
info
)
throws
Exception
{
if
(
(
info
.
insertAt
>
info
.
childCount
)
||
(
info
.
curChildren
==
null
)
||
(
info
.
childCount
<
1
)
||
(
info
.
childCount
>
info
.
curChildren
.
length
)
)
{
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
ImplementationMessages
.
XERCES_IMPLEMENTATION_DOMAIN
,
ImplementationMessages
.
VAL_WCGHI
,
0
,
null
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
int
retVal
=
0
;
try
{
final
XMLContentModel
cmElem
=
getContentModel
(
elementIndex
)
;
retVal
=
cmElem
.
whatCanGoHere
(
fullyValid
,
info
)
;
}
catch
(
CMException
excToCatch
)
{
int
majorCode
=
excToCatch
.
getErrorCode
(
)
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
ImplementationMessages
.
XERCES_IMPLEMENTATION_DOMAIN
,
majorCode
,
0
,
null
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
return
retVal
;
}
private
final
XMLContentModel
createChildModel
(
int
elementIndex
)
throws
CMException
{
XMLContentSpecNode
specNode
=
new
XMLContentSpecNode
(
)
;
int
contentSpecIndex
=
fElementDeclPool
.
getContentSpec
(
elementIndex
)
;
fElementDeclPool
.
getContentSpecNode
(
contentSpecIndex
,
specNode
)
;
if
(
specNode
.
value
==
-
1
)
throw
new
CMException
(
ImplementationMessages
.
VAL_NPCD
)
;
if
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
)
{
return
new
SimpleContentModel
(
specNode
.
value
,
-
1
,
specNode
.
type
)
;
}
else
if
(
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
)
||
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
)
)
{
XMLContentSpecNode
specLeft
=
new
XMLContentSpecNode
(
)
;
XMLContentSpecNode
specRight
=
new
XMLContentSpecNode
(
)
;
fElementDeclPool
.
getContentSpecNode
(
specNode
.
value
,
specLeft
)
;
fElementDeclPool
.
getContentSpecNode
(
specNode
.
otherValue
,
specRight
)
;
if
(
(
specLeft
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
)
&&
(
specRight
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
)
)
{
return
new
SimpleContentModel
(
specLeft
.
value
,
specRight
.
value
,
specNode
.
type
)
;
}
}
else
if
(
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_ONE
)
||
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
)
||
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_ONE_OR_MORE
)
)
{
XMLContentSpecNode
specLeft
=
new
XMLContentSpecNode
(
)
;
fElementDeclPool
.
getContentSpecNode
(
specNode
.
value
,
specLeft
)
;
if
(
specLeft
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
)
{
return
new
SimpleContentModel
(
specLeft
.
value
,
-
1
,
specNode
.
type
)
;
}
}
else
{
throw
new
CMException
(
ImplementationMessages
.
VAL_CST
)
;
}
fLeafCount
=
0
;
fEpsilonIndex
=
fStringPool
.
addSymbol
(
"<<CMNODE_EPSILON>>"
)
;
CMNode
cmn
=
buildSyntaxTree
(
contentSpecIndex
,
specNode
)
;
return
new
DFAContentModel
(
fStringPool
,
cmn
,
fLeafCount
)
;
}
public
XMLContentModel
getContentModel
(
int
elementIndex
)
throws
CMException
{
XMLContentModel
cmRet
=
fElementDeclPool
.
getContentModel
(
elementIndex
)
;
if
(
cmRet
!=
null
)
return
cmRet
;
final
int
contentSpec
=
fElementDeclPool
.
getContentSpecType
(
elementIndex
)
;
if
(
contentSpec
==
fStringPool
.
addSymbol
(
"MIXED"
)
)
{
XMLContentSpecNode
specNode
=
new
XMLContentSpecNode
(
)
;
int
contentSpecIndex
=
fElementDeclPool
.
getContentSpec
(
elementIndex
)
;
makeContentList
(
contentSpecIndex
,
specNode
)
;
cmRet
=
new
MixedContentModel
(
fCount
,
fContentList
)
;
}
else
if
(
contentSpec
==
fStringPool
.
addSymbol
(
"CHILDREN"
)
)
{
cmRet
=
createChildModel
(
elementIndex
)
;
}
else
if
(
contentSpec
==
fStringPool
.
addSymbol
(
"DATATYPE"
)
)
{
cmRet
=
new
DatatypeContentModel
(
fDatatypeRegistry
,
fElementDeclPool
,
fStringPool
,
elementIndex
)
;
}
else
{
throw
new
CMException
(
ImplementationMessages
.
VAL_CST
)
;
}
fElementDeclPool
.
setContentModel
(
elementIndex
,
cmRet
)
;
return
cmRet
;
}
private
int
fLeafCount
=
0
;
private
int
fEpsilonIndex
=
-
1
;
private
final
CMNode
buildSyntaxTree
(
int
startNode
,
XMLContentSpecNode
specNode
)
throws
CMException
{
CMNode
nodeRet
=
null
;
getContentSpecNode
(
startNode
,
specNode
)
;
if
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
)
{
nodeRet
=
new
CMLeaf
(
specNode
.
type
,
specNode
.
value
,
fLeafCount
++
)
;
}
else
{
final
int
leftNode
=
specNode
.
value
;
final
int
rightNode
=
specNode
.
otherValue
;
if
(
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
)
||
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
)
)
{
nodeRet
=
new
CMBinOp
(
specNode
.
type
,
buildSyntaxTree
(
leftNode
,
specNode
)
,
buildSyntaxTree
(
rightNode
,
specNode
)
)
;
}
else
if
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
)
{
nodeRet
=
new
CMUniOp
(
specNode
.
type
,
buildSyntaxTree
(
leftNode
,
specNode
)
)
;
}
else
if
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_ONE
)
{
nodeRet
=
new
CMBinOp
(
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
,
buildSyntaxTree
(
leftNode
,
specNode
)
,
new
CMLeaf
(
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
,
fEpsilonIndex
)
)
;
}
else
if
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_ONE_OR_MORE
)
{
nodeRet
=
new
CMBinOp
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
buildSyntaxTree
(
leftNode
,
specNode
)
,
new
CMUniOp
(
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
,
buildSyntaxTree
(
leftNode
,
specNode
)
)
)
;
}
else
{
throw
new
CMException
(
ImplementationMessages
.
VAL_CST
)
;
}
}
return
nodeRet
;
}
private
int
fCount
=
0
;
private
int
[
]
fContentList
=
new
int
[
64
]
;
private
final
void
makeContentList
(
int
startNode
,
XMLContentSpecNode
specNode
)
throws
CMException
{
while
(
true
)
{
fCount
=
0
;
try
{
fCount
=
buildContentList
(
startNode
,
0
,
specNode
)
;
}
catch
(
IndexOutOfBoundsException
excToCatch
)
{
fContentList
=
new
int
[
fContentList
.
length
*
2
]
;
fCount
=
0
;
continue
;
}
break
;
}
}
private
final
int
buildContentList
(
int
startNode
,
int
count
,
XMLContentSpecNode
specNode
)
throws
CMException
{
fElementDeclPool
.
getContentSpecNode
(
startNode
,
specNode
)
;
if
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
)
{
fContentList
[
count
++
]
=
specNode
.
value
;
return
count
;
}
final
int
leftNode
=
specNode
.
value
;
final
int
rightNode
=
specNode
.
otherValue
;
if
(
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
)
||
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
)
)
{
count
=
buildContentList
(
leftNode
,
count
,
specNode
)
;
count
=
buildContentList
(
rightNode
,
count
,
specNode
)
;
}
else
if
(
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_ONE
)
||
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
)
||
(
specNode
.
type
==
XMLContentSpecNode
.
CONTENTSPECNODE_ONE_OR_MORE
)
)
{
count
=
buildContentList
(
leftNode
,
count
,
specNode
)
;
}
else
{
throw
new
CMException
(
ImplementationMessages
.
VAL_CST
)
;
}
return
count
;
}
protected
void
reportRecoverableXMLError
(
int
majorCode
,
int
minorCode
)
throws
Exception
{
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
majorCode
,
minorCode
,
null
,
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
)
;
}
protected
void
reportRecoverableXMLError
(
int
majorCode
,
int
minorCode
,
int
stringIndex1
)
throws
Exception
{
Object
[
]
args
=
{
fStringPool
.
toString
(
stringIndex1
)
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
majorCode
,
minorCode
,
args
,
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
)
;
}
protected
void
reportRecoverableXMLError
(
int
majorCode
,
int
minorCode
,
String
string1
)
throws
Exception
{
Object
[
]
args
=
{
string1
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
majorCode
,
minorCode
,
args
,
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
)
;
}
protected
void
reportRecoverableXMLError
(
int
majorCode
,
int
minorCode
,
int
stringIndex1
,
int
stringIndex2
)
throws
Exception
{
Object
[
]
args
=
{
fStringPool
.
toString
(
stringIndex1
)
,
fStringPool
.
toString
(
stringIndex2
)
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
majorCode
,
minorCode
,
args
,
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
)
;
}
protected
void
reportRecoverableXMLError
(
int
majorCode
,
int
minorCode
,
String
string1
,
String
string2
)
throws
Exception
{
Object
[
]
args
=
{
string1
,
string2
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
majorCode
,
minorCode
,
args
,
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
)
;
}
protected
void
reportRecoverableXMLError
(
int
majorCode
,
int
minorCode
,
String
string1
,
String
string2
,
String
string3
)
throws
Exception
{
Object
[
]
args
=
{
string1
,
string2
,
string3
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
majorCode
,
minorCode
,
args
,
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
)
;
}
private
static
final
int
CONTENTSPECNODE_ZERO_TO_N
=
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
+
1
;
private
static
final
int
CONTENTSPECNODE_M_TO_N
=
CONTENTSPECNODE_ZERO_TO_N
+
1
;
private
static
final
int
CONTENTSPECNODE_M_OR_MORE
=
CONTENTSPECNODE_M_TO_N
+
1
;
private
DOMParser
fSchemaParser
=
null
;
public
void
loadSchema
(
String
uri
)
{
String
systemId
=
fEntityHandler
.
expandSystemId
(
uri
)
;
if
(
fSchemaParser
==
null
)
{
fSchemaParser
=
new
DOMParser
(
)
{
public
void
ignorableWhitespace
(
char
ch
[
]
,
int
start
,
int
length
)
{
}
public
void
ignorableWhitespace
(
int
dataIdx
)
{
}
}
;
fSchemaParser
.
setEntityResolver
(
new
Resolver
(
)
)
;
fSchemaParser
.
setErrorHandler
(
new
ErrorHandler
(
)
)
;
}
try
{
fSchemaParser
.
setFeature
(
"http://xml.org/sax/features/validation"
,
true
)
;
fSchemaParser
.
setFeature
(
"http://apache.org/xml/features/dom/defer-node-expansion"
,
false
)
;
fSchemaParser
.
parse
(
systemId
)
;
}
catch
(
SAXException
se
)
{
se
.
getException
(
)
.
printStackTrace
(
)
;
System
.
err
.
println
(
"error parsing schema file"
)
;
System
.
exit
(
1
)
;
}
catch
(
Exception
e
)
{
e
.
printStackTrace
(
)
;
System
.
err
.
println
(
"error parsing schema file"
)
;
System
.
exit
(
1
)
;
}
fSchemaDocument
=
fSchemaParser
.
getDocument
(
)
;
if
(
fSchemaDocument
==
null
)
{
System
.
err
.
println
(
"error: couldn't load schema file!"
)
;
return
;
}
try
{
Element
root
=
fSchemaDocument
.
getDocumentElement
(
)
;
traverseSchema
(
root
)
;
}
catch
(
Exception
e
)
{
e
.
printStackTrace
(
System
.
err
)
;
System
.
exit
(
1
)
;
}
}
private
void
traverseSchema
(
Element
root
)
throws
Exception
{
if
(
root
==
null
)
{
return
;
}
for
(
Element
child
=
XUtil
.
getFirstChildElement
(
root
)
;
child
!=
null
;
child
=
XUtil
.
getNextSiblingElement
(
child
)
)
{
String
name
=
child
.
getNodeName
(
)
;
if
(
name
.
equals
(
ELT_COMMENT
)
)
{
traverseComment
(
child
)
;
}
else
if
(
name
.
equals
(
ELT_DATATYPEDECL
)
)
{
traverseDatatypeDecl
(
child
)
;
}
else
if
(
name
.
equals
(
ELT_ARCHETYPEDECL
)
)
{
traverseTypeDecl
(
child
)
;
}
else
if
(
name
.
equals
(
ELT_ELEMENTDECL
)
)
{
traverseElementDecl
(
child
)
;
}
else
if
(
name
.
equals
(
ELT_ATTRGROUPDECL
)
)
{
traverseAttrGroup
(
child
)
;
}
else
if
(
name
.
equals
(
ELT_MODELGROUPDECL
)
)
{
traverseModelGroup
(
child
)
;
}
else
if
(
name
.
equals
(
ELT_TEXTENTITYDECL
)
||
name
.
equals
(
ELT_EXTERNALENTITYDECL
)
||
name
.
equals
(
ELT_UNPARSEDENTITYDECL
)
)
{
int
entityName
=
fStringPool
.
addSymbol
(
child
.
getAttribute
(
ATT_NAME
)
)
;
if
(
name
.
equals
(
ELT_TEXTENTITYDECL
)
)
{
int
value
=
fStringPool
.
addString
(
child
.
getFirstChild
(
)
.
getNodeValue
(
)
)
;
fEntityPool
.
addEntityDecl
(
entityName
,
value
,
-
1
,
-
1
,
-
1
,
-
1
,
true
)
;
}
else
{
int
publicId
=
fStringPool
.
addString
(
child
.
getAttribute
(
"public"
)
)
;
int
systemId
=
fStringPool
.
addString
(
child
.
getAttribute
(
"system"
)
)
;
if
(
name
.
equals
(
ELT_EXTERNALENTITYDECL
)
)
{
fEntityPool
.
addEntityDecl
(
entityName
,
-
1
,
-
1
,
publicId
,
systemId
,
-
1
,
true
)
;
}
else
{
int
notationName
=
fStringPool
.
addSymbol
(
child
.
getAttribute
(
"notation"
)
)
;
fEntityPool
.
addEntityDecl
(
entityName
,
-
1
,
-
1
,
publicId
,
systemId
,
notationName
,
true
)
;
}
}
}
else
if
(
name
.
equals
(
ELT_NOTATIONDECL
)
)
{
int
notationName
=
fStringPool
.
addSymbol
(
child
.
getAttribute
(
ATT_NAME
)
)
;
int
publicId
=
fStringPool
.
addString
(
child
.
getAttribute
(
"public"
)
)
;
int
systemId
=
fStringPool
.
addString
(
child
.
getAttribute
(
"system"
)
)
;
fEntityPool
.
addNotationDecl
(
notationName
,
publicId
,
systemId
,
true
)
;
}
}
cleanupForwardReferences
(
)
;
}
private
void
cleanupForwardReferences
(
)
{
for
(
java
.
util
.
Enumeration
keys
=
fForwardRefs
.
keys
(
)
;
keys
.
hasMoreElements
(
)
;
)
{
Object
k
=
keys
.
nextElement
(
)
;
int
ik
=
(
(
Integer
)
k
)
.
intValue
(
)
;
cleanupForwardReferencesTo
(
ik
)
;
}
}
private
void
cleanupForwardReferencesTo
(
int
r
)
{
Vector
referrers
=
(
Vector
)
fForwardRefs
.
get
(
new
Integer
(
r
)
)
;
if
(
referrers
==
null
)
return
;
for
(
int
i
=
0
;
i
<
referrers
.
size
(
)
;
i
++
)
{
int
ref
=
(
(
Integer
)
referrers
.
elementAt
(
i
)
)
.
intValue
(
)
;
fElementDeclPool
.
copyAtts
(
r
,
(
(
Integer
)
referrers
.
elementAt
(
i
)
)
.
intValue
(
)
)
;
}
}
private
void
traverseComment
(
Element
comment
)
{
return
;
}
private
int
traverseTypeDecl
(
Element
typeDecl
)
throws
Exception
{
String
typeName
=
typeDecl
.
getAttribute
(
ATT_NAME
)
;
String
content
=
typeDecl
.
getAttribute
(
ATT_CONTENT
)
;
String
model
=
typeDecl
.
getAttribute
(
ATT_MODEL
)
;
String
order
=
typeDecl
.
getAttribute
(
ATT_ORDER
)
;
String
type
=
typeDecl
.
getAttribute
(
ATT_TYPE
)
;
String
deflt
=
typeDecl
.
getAttribute
(
ATT_DEFAULT
)
;
String
fixed
=
typeDecl
.
getAttribute
(
ATT_FIXED
)
;
String
schemaAbbrev
=
typeDecl
.
getAttribute
(
ATT_SCHEMAABBREV
)
;
String
schemaName
=
typeDecl
.
getAttribute
(
ATT_SCHEMANAME
)
;
if
(
typeName
.
equals
(
""
)
)
{
typeName
=
"http://www.apache.org/xml/xerces/internalType"
+
fTypeCount
++
;
}
if
(
type
.
equals
(
""
)
)
{
if
(
!
schemaAbbrev
.
equals
(
""
)
)
reportSchemaError
(
SchemaMessageProvider
.
AttMissingType
,
new
Object
[
]
{
"schemaAbbrev"
}
)
;
if
(
!
schemaName
.
equals
(
""
)
)
reportSchemaError
(
SchemaMessageProvider
.
AttMissingType
,
new
Object
[
]
{
"schemaName"
}
)
;
if
(
!
deflt
.
equals
(
""
)
)
reportSchemaError
(
SchemaMessageProvider
.
AttMissingType
,
new
Object
[
]
{
"default"
}
)
;
if
(
!
fixed
.
equals
(
""
)
)
reportSchemaError
(
SchemaMessageProvider
.
AttMissingType
,
new
Object
[
]
{
"fixed"
}
)
;
}
else
{
if
(
fDatatypeRegistry
.
getValidatorFor
(
type
)
!=
null
)
reportSchemaError
(
SchemaMessageProvider
.
NotADatatype
,
new
Object
[
]
{
type
}
)
;
if
(
!
content
.
equals
(
ATTVAL_TEXTONLY
)
)
reportSchemaError
(
SchemaMessageProvider
.
TextOnlyContentWithType
,
null
)
;
}
Element
child
=
XUtil
.
getFirstChildElement
(
typeDecl
)
;
Element
refines
=
null
;
if
(
child
!=
null
&&
child
.
getNodeName
(
)
.
equals
(
ELT_REFINES
)
)
{
reportSchemaError
(
SchemaMessageProvider
.
FeatureUnsupported
,
new
Object
[
]
{
"Refinement"
}
)
;
refines
=
child
;
child
=
XUtil
.
getNextSiblingElement
(
child
)
;
}
int
contentSpecType
=
0
;
int
csnType
=
0
;
boolean
mixedContent
=
false
;
boolean
elementContent
=
false
;
boolean
textContent
=
false
;
boolean
buildAll
=
false
;
int
allChildren
[
]
=
null
;
int
allChildCount
=
0
;
int
left
=
-
2
;
int
right
=
-
2
;
boolean
hadContent
=
false
;
if
(
order
.
equals
(
ATTVAL_CHOICE
)
)
{
csnType
=
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
;
contentSpecType
=
fStringPool
.
addSymbol
(
"CHILDREN"
)
;
}
else
if
(
order
.
equals
(
ATTVAL_SEQ
)
)
{
csnType
=
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
;
contentSpecType
=
fStringPool
.
addSymbol
(
"CHILDREN"
)
;
}
else
if
(
order
.
equals
(
ATTVAL_ALL
)
)
{
buildAll
=
true
;
allChildren
=
new
int
[
(
(
org
.
apache
.
xerces
.
dom
.
NodeImpl
)
typeDecl
)
.
getLength
(
)
]
;
allChildCount
=
0
;
}
if
(
content
.
equals
(
ATTVAL_EMPTY
)
)
{
contentSpecType
=
fStringPool
.
addSymbol
(
"EMPTY"
)
;
left
=
-
1
;
}
else
if
(
content
.
equals
(
ATTVAL_ANY
)
)
{
contentSpecType
=
fStringPool
.
addSymbol
(
"ANY"
)
;
left
=
-
1
;
}
else
if
(
content
.
equals
(
ATTVAL_MIXED
)
)
{
contentSpecType
=
fStringPool
.
addSymbol
(
"MIXED"
)
;
mixedContent
=
true
;
csnType
=
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
;
}
else
if
(
content
.
equals
(
ATTVAL_ELEMONLY
)
)
{
elementContent
=
true
;
}
else
if
(
content
.
equals
(
ATTVAL_TEXTONLY
)
)
{
textContent
=
true
;
}
if
(
mixedContent
)
{
left
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
,
-
1
,
-
1
,
false
)
;
}
Vector
uses
=
new
Vector
(
)
;
for
(
;
child
!=
null
;
child
=
XUtil
.
getNextSiblingElement
(
child
)
)
{
int
index
=
-
2
;
hadContent
=
true
;
String
childName
=
child
.
getNodeName
(
)
;
if
(
childName
.
equals
(
ELT_ELEMENTDECL
)
)
{
if
(
child
.
getAttribute
(
ATT_REF
)
.
equals
(
""
)
)
{
if
(
elementContent
)
reportSchemaError
(
SchemaMessageProvider
.
FeatureUnsupported
,
new
Object
[
]
{
"Nesting element declarations"
}
)
;
else
reportSchemaError
(
SchemaMessageProvider
.
NestedOnlyInElemOnly
,
null
)
;
}
else
if
(
mixedContent
||
elementContent
)
{
index
=
traverseElementRef
(
child
)
;
}
else
{
reportSchemaError
(
SchemaMessageProvider
.
EltRefOnlyInMixedElemOnly
,
null
)
;
}
}
else
if
(
childName
.
equals
(
ELT_GROUP
)
)
{
if
(
elementContent
&&
!
buildAll
)
{
int
groupNameIndex
=
traverseGroup
(
child
)
;
index
=
getContentSpec
(
getElement
(
groupNameIndex
)
)
;
}
else
if
(
!
elementContent
)
reportSchemaError
(
SchemaMessageProvider
.
OnlyInEltContent
,
new
Object
[
]
{
"group"
}
)
;
else
reportSchemaError
(
SchemaMessageProvider
.
OrderIsAll
,
new
Object
[
]
{
"group"
}
)
;
}
else
if
(
childName
.
equals
(
ELT_MODELGROUPREF
)
)
{
if
(
elementContent
&&
!
buildAll
)
{
int
modelGroupNameIndex
=
traverseModelGroup
(
child
)
;
index
=
getContentSpec
(
getElement
(
modelGroupNameIndex
)
)
;
if
(
index
==
-
1
)
reportSchemaError
(
SchemaMessageProvider
.
FeatureUnsupported
,
new
Object
[
]
{
"Forward reference to model group"
}
)
;
index
=
expandContentModel
(
index
,
child
)
;
}
else
if
(
!
elementContent
)
reportSchemaError
(
SchemaMessageProvider
.
OnlyInEltContent
,
new
Object
[
]
{
"modelGroupRef"
}
)
;
else
reportSchemaError
(
SchemaMessageProvider
.
OrderIsAll
,
new
Object
[
]
{
"modelGroupRef"
}
)
;
}
else
if
(
childName
.
equals
(
ELT_ATTRIBUTEDECL
)
||
childName
.
equals
(
ELT_ATTRGROUPREF
)
)
{
break
;
}
else
{
if
(
type
.
equals
(
""
)
)
reportSchemaError
(
SchemaMessageProvider
.
DatatypeWithType
,
null
)
;
else
reportSchemaError
(
SchemaMessageProvider
.
DatatypeQualUnsupported
,
new
Object
[
]
{
childName
}
)
;
}
uses
.
addElement
(
new
Integer
(
index
)
)
;
if
(
buildAll
)
{
allChildren
[
allChildCount
++
]
=
index
;
}
else
if
(
left
==
-
2
)
{
left
=
index
;
}
else
if
(
right
==
-
2
)
{
right
=
index
;
}
else
{
left
=
fElementDeclPool
.
addContentSpecNode
(
csnType
,
left
,
right
,
false
)
;
right
=
index
;
}
}
if
(
buildAll
)
{
left
=
buildAllModel
(
allChildren
,
allChildCount
)
;
}
else
{
if
(
hadContent
&&
right
!=
-
2
)
left
=
fElementDeclPool
.
addContentSpecNode
(
csnType
,
left
,
right
,
false
)
;
if
(
mixedContent
&&
hadContent
)
{
left
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
,
left
,
-
1
,
false
)
;
}
}
int
typeNameIndex
=
fStringPool
.
addSymbol
(
typeName
)
;
int
typeIndex
=
fElementDeclPool
.
addElementDecl
(
typeNameIndex
,
contentSpecType
,
left
,
false
)
;
for
(
int
x
=
0
;
x
<
uses
.
size
(
)
;
x
++
)
addUse
(
typeNameIndex
,
(
Integer
)
uses
.
elementAt
(
x
)
)
;
for
(
;
child
!=
null
;
child
=
XUtil
.
getNextSiblingElement
(
child
)
)
{
String
childName
=
child
.
getNodeName
(
)
;
if
(
childName
.
equals
(
ELT_ATTRIBUTEDECL
)
)
{
traverseAttributeDecl
(
child
,
typeIndex
)
;
}
else
if
(
childName
.
equals
(
ELT_ATTRGROUPREF
)
)
{
int
index
=
traverseAttrGroupRef
(
child
)
;
if
(
getContentSpec
(
getElement
(
index
)
)
==
-
1
)
{
reportSchemaError
(
SchemaMessageProvider
.
FeatureUnsupported
,
new
Object
[
]
{
"Forward References to attrGroup"
}
)
;
Vector
v
=
null
;
Integer
i
=
new
Integer
(
index
)
;
if
(
(
v
=
(
Vector
)
fForwardRefs
.
get
(
i
)
)
==
null
)
v
=
new
Vector
(
)
;
v
.
addElement
(
new
Integer
(
typeNameIndex
)
)
;
fForwardRefs
.
put
(
i
,
v
)
;
addUse
(
typeNameIndex
,
index
)
;
}
else
fElementDeclPool
.
copyAtts
(
index
,
typeNameIndex
)
;
}
}
return
typeNameIndex
;
}
private
int
traverseGroup
(
Element
groupDecl
)
throws
Exception
{
String
groupName
=
groupDecl
.
getAttribute
(
ATT_NAME
)
;
String
collection
=
groupDecl
.
getAttribute
(
ATT_COLLECTION
)
;
String
order
=
groupDecl
.
getAttribute
(
ATT_ORDER
)
;
if
(
groupName
.
equals
(
""
)
)
{
groupName
=
"http://www.apache.org/xml/xerces/internalGroup"
+
fGroupCount
++
;
}
Element
child
=
XUtil
.
getFirstChildElement
(
groupDecl
)
;
int
contentSpecType
=
0
;
int
csnType
=
0
;
boolean
buildAll
=
false
;
int
allChildren
[
]
=
null
;
int
allChildCount
=
0
;
if
(
order
.
equals
(
ATTVAL_CHOICE
)
)
{
csnType
=
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
;
contentSpecType
=
fStringPool
.
addSymbol
(
"CHILDREN"
)
;
}
else
if
(
order
.
equals
(
ATTVAL_SEQ
)
)
{
csnType
=
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
;
contentSpecType
=
fStringPool
.
addSymbol
(
"CHILDREN"
)
;
}
else
if
(
order
.
equals
(
ATTVAL_ALL
)
)
{
buildAll
=
true
;
allChildren
=
new
int
[
(
(
org
.
apache
.
xerces
.
dom
.
NodeImpl
)
groupDecl
)
.
getLength
(
)
]
;
allChildCount
=
0
;
}
int
left
=
-
2
;
int
right
=
-
2
;
boolean
hadContent
=
false
;
int
groupIndices
[
]
=
new
int
[
(
(
org
.
apache
.
xerces
.
dom
.
NodeImpl
)
groupDecl
)
.
getLength
(
)
]
;
int
numGroups
=
0
;
for
(
;
child
!=
null
;
child
=
XUtil
.
getNextSiblingElement
(
child
)
)
{
int
index
=
-
2
;
hadContent
=
true
;
String
childName
=
child
.
getNodeName
(
)
;
if
(
childName
.
equals
(
ELT_ELEMENTDECL
)
)
{
if
(
child
.
getAttribute
(
ATT_REF
)
.
equals
(
""
)
)
reportSchemaError
(
SchemaMessageProvider
.
FeatureUnsupported
,
new
Object
[
]
{
"Nesting element declarations"
}
)
;
else
index
=
traverseElementRef
(
child
)
;
}
else
if
(
childName
.
equals
(
ELT_GROUP
)
)
{
if
(
!
buildAll
)
{
int
groupNameIndex
=
traverseGroup
(
child
)
;
groupIndices
[
numGroups
++
]
=
groupNameIndex
;
index
=
getContentSpec
(
getElement
(
groupNameIndex
)
)
;
}
else
reportSchemaError
(
SchemaMessageProvider
.
OrderIsAll
,
new
Object
[
]
{
"group"
}
)
;
}
else
if
(
childName
.
equals
(
ELT_MODELGROUPREF
)
)
{
if
(
!
buildAll
)
{
int
modelGroupNameIndex
=
traverseModelGroupRef
(
child
)
;
index
=
getContentSpec
(
getElement
(
modelGroupNameIndex
)
)
;
index
=
expandContentModel
(
index
,
child
)
;
}
else
reportSchemaError
(
SchemaMessageProvider
.
OrderIsAll
,
new
Object
[
]
{
"modelGroupRef"
}
)
;
}
else
{
reportSchemaError
(
SchemaMessageProvider
.
GroupContentRestricted
,
new
Object
[
]
{
"group"
,
childName
}
)
;
}
if
(
buildAll
)
{
allChildren
[
allChildCount
++
]
=
index
;
}
else
if
(
left
==
-
2
)
{
left
=
index
;
}
else
if
(
right
==
-
2
)
{
right
=
index
;
}
else
{
left
=
fElementDeclPool
.
addContentSpecNode
(
csnType
,
left
,
right
,
false
)
;
right
=
index
;
}
}
if
(
buildAll
)
{
left
=
buildAllModel
(
allChildren
,
allChildCount
)
;
}
else
{
if
(
hadContent
&&
right
!=
-
2
)
left
=
fElementDeclPool
.
addContentSpecNode
(
csnType
,
left
,
right
,
false
)
;
}
left
=
expandContentModel
(
left
,
groupDecl
)
;
int
groupNameIndex
=
fStringPool
.
addSymbol
(
groupName
)
;
int
groupIndex
=
fElementDeclPool
.
addElementDecl
(
groupNameIndex
,
contentSpecType
,
left
,
false
)
;
return
groupNameIndex
;
}
private
int
traverseModelGroup
(
Element
modelGroupDecl
)
throws
Exception
{
String
modelGroupName
=
modelGroupDecl
.
getAttribute
(
ATT_NAME
)
;
String
order
=
modelGroupDecl
.
getAttribute
(
ATT_ORDER
)
;
if
(
modelGroupName
.
equals
(
""
)
)
{
modelGroupName
=
"http://www.apache.org/xml/xerces/internalModelGroup"
+
fModelGroupCount
++
;
}
Element
child
=
XUtil
.
getFirstChildElement
(
modelGroupDecl
)
;
int
contentSpecType
=
0
;
int
csnType
=
0
;
boolean
buildAll
=
false
;
int
allChildren
[
]
=
null
;
int
allChildCount
=
0
;
if
(
order
.
equals
(
ATTVAL_CHOICE
)
)
{
csnType
=
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
;
contentSpecType
=
fStringPool
.
addSymbol
(
"CHILDREN"
)
;
}
else
if
(
order
.
equals
(
ATTVAL_SEQ
)
)
{
csnType
=
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
;
contentSpecType
=
fStringPool
.
addSymbol
(
"CHILDREN"
)
;
}
else
if
(
order
.
equals
(
ATTVAL_ALL
)
)
{
buildAll
=
true
;
allChildren
=
new
int
[
(
(
org
.
apache
.
xerces
.
dom
.
NodeImpl
)
modelGroupDecl
)
.
getLength
(
)
]
;
allChildCount
=
0
;
}
int
left
=
-
2
;
int
right
=
-
2
;
boolean
hadContent
=
false
;
for
(
;
child
!=
null
;
child
=
XUtil
.
getNextSiblingElement
(
child
)
)
{
int
index
=
-
2
;
hadContent
=
true
;
String
childName
=
child
.
getNodeName
(
)
;
if
(
childName
.
equals
(
ELT_ELEMENTDECL
)
)
{
if
(
child
.
getAttribute
(
ATT_REF
)
.
equals
(
""
)
)
reportSchemaError
(
SchemaMessageProvider
.
FeatureUnsupported
,
new
Object
[
]
{
"Nesting element declarations"
}
)
;
else
{
index
=
traverseElementRef
(
child
)
;
}
}
else
if
(
childName
.
equals
(
ELT_GROUP
)
)
{
int
groupNameIndex
=
traverseGroup
(
child
)
;
index
=
getContentSpec
(
getElement
(
groupNameIndex
)
)
;
}
else
if
(
childName
.
equals
(
ELT_MODELGROUPREF
)
)
{
int
modelGroupNameIndex
=
traverseModelGroupRef
(
child
)
;
index
=
getContentSpec
(
getElement
(
modelGroupNameIndex
)
)
;
index
=
expandContentModel
(
index
,
child
)
;
}
else
{
reportSchemaError
(
SchemaMessageProvider
.
GroupContentRestricted
,
new
Object
[
]
{
"modelGroup"
,
childName
}
)
;
}
if
(
buildAll
)
{
allChildren
[
allChildCount
++
]
=
index
;
}
else
if
(
left
==
-
2
)
{
left
=
index
;
}
else
if
(
right
==
-
2
)
{
right
=
index
;
}
else
{
left
=
fElementDeclPool
.
addContentSpecNode
(
csnType
,
left
,
right
,
false
)
;
right
=
index
;
}
}
if
(
buildAll
)
{
left
=
buildAllModel
(
allChildren
,
allChildCount
)
;
}
else
{
if
(
hadContent
&&
right
!=
-
2
)
left
=
fElementDeclPool
.
addContentSpecNode
(
csnType
,
left
,
right
,
false
)
;
}
left
=
expandContentModel
(
left
,
modelGroupDecl
)
;
int
modelGroupNameIndex
=
fStringPool
.
addSymbol
(
modelGroupName
)
;
int
modelGroupIndex
=
fElementDeclPool
.
addElementDecl
(
modelGroupNameIndex
,
contentSpecType
,
left
,
false
)
;
return
modelGroupNameIndex
;
}
private
int
traverseModelGroupRef
(
Element
modelGroupRef
)
{
String
name
=
modelGroupRef
.
getAttribute
(
ATT_NAME
)
;
int
index
=
fStringPool
.
addSymbol
(
name
)
;
return
index
;
}
public
int
traverseDatatypeDecl
(
Element
datatypeDecl
)
{
int
newTypeName
=
fStringPool
.
addSymbol
(
datatypeDecl
.
getAttribute
(
ATT_NAME
)
)
;
int
export
=
fStringPool
.
addSymbol
(
datatypeDecl
.
getAttribute
(
ATT_EXPORT
)
)
;
Element
datatypeChild
=
XUtil
.
getFirstChildElement
(
datatypeDecl
)
;
int
basetype
=
fStringPool
.
addSymbol
(
datatypeChild
.
getNodeName
(
)
)
;
DatatypeValidator
baseValidator
=
fDatatypeRegistry
.
getValidatorFor
(
datatypeChild
.
getAttribute
(
ATT_NAME
)
)
;
if
(
baseValidator
==
null
)
{
reportSchemaError
(
SchemaMessageProvider
.
UnknownBaseDatatype
,
new
Object
[
]
{
datatypeChild
.
getAttribute
(
ATT_NAME
)
,
datatypeDecl
.
getAttribute
(
ATT_NAME
)
}
)
;
return
-
1
;
}
int
numFacets
=
0
;
int
numEnumerationLiterals
=
0
;
Hashtable
facetData
=
new
Hashtable
(
)
;
Vector
enumData
=
new
Vector
(
)
;
Node
facet
=
datatypeChild
.
getNextSibling
(
)
;
while
(
facet
!=
null
)
{
if
(
facet
.
getNodeType
(
)
==
Node
.
ELEMENT_NODE
)
{
numFacets
++
;
if
(
facet
.
getNodeName
(
)
.
equals
(
DatatypeValidator
.
ENUMERATION
)
)
{
Node
literal
=
XUtil
.
getFirstChildElement
(
facet
)
;
while
(
literal
!=
null
)
{
numEnumerationLiterals
++
;
enumData
.
addElement
(
literal
.
getFirstChild
(
)
.
getNodeValue
(
)
)
;
literal
=
XUtil
.
getNextSiblingElement
(
literal
)
;
}
}
else
{
facetData
.
put
(
facet
.
getNodeName
(
)
,
facet
.
getFirstChild
(
)
.
getNodeValue
(
)
)
;
}
}
facet
=
facet
.
getNextSibling
(
)
;
}
if
(
numEnumerationLiterals
>
0
)
{
facetData
.
put
(
DatatypeValidator
.
ENUMERATION
,
enumData
)
;
}
try
{
DatatypeValidator
newValidator
=
(
DatatypeValidator
)
baseValidator
.
getClass
(
)
.
newInstance
(
)
;
if
(
numFacets
>
0
)
newValidator
.
setFacets
(
facetData
)
;
fDatatypeRegistry
.
addValidator
(
fStringPool
.
toString
(
newTypeName
)
,
newValidator
)
;
}
catch
(
Exception
e
)
{
reportSchemaError
(
SchemaMessageProvider
.
DatatypeError
,
new
Object
[
]
{
e
.
getMessage
(
)
}
)
;
}
return
-
1
;
}
private
int
traverseElementDecl
(
Element
elementDecl
)
throws
Exception
{
int
contentSpecType
=
-
1
;
int
contentSpecNodeIndex
=
-
1
;
int
typeNameIndex
=
-
1
;
String
name
=
elementDecl
.
getAttribute
(
ATT_NAME
)
;
String
ref
=
elementDecl
.
getAttribute
(
ATT_REF
)
;
String
archRef
=
elementDecl
.
getAttribute
(
ATT_ARCHREF
)
;
String
type
=
elementDecl
.
getAttribute
(
ATT_TYPE
)
;
String
schemaAbbrev
=
elementDecl
.
getAttribute
(
ATT_SCHEMAABBREV
)
;
String
schemaName
=
elementDecl
.
getAttribute
(
ATT_SCHEMANAME
)
;
String
minOccurs
=
elementDecl
.
getAttribute
(
ATT_MINOCCURS
)
;
String
maxOccurs
=
elementDecl
.
getAttribute
(
ATT_MAXOCCURS
)
;
String
export
=
elementDecl
.
getAttribute
(
ATT_EXPORT
)
;
int
attrCount
=
0
;
if
(
!
ref
.
equals
(
""
)
)
attrCount
++
;
if
(
!
type
.
equals
(
""
)
)
attrCount
++
;
if
(
!
archRef
.
equals
(
""
)
)
attrCount
++
;
if
(
attrCount
>
1
)
reportSchemaError
(
SchemaMessageProvider
.
OneOfTypeRefArchRef
,
null
)
;
if
(
!
ref
.
equals
(
""
)
||
!
archRef
.
equals
(
""
)
)
{
if
(
XUtil
.
getFirstChildElement
(
elementDecl
)
!=
null
)
reportSchemaError
(
SchemaMessageProvider
.
NoContentForRef
,
null
)
;
int
typeName
=
(
!
ref
.
equals
(
""
)
)
?
fStringPool
.
addSymbol
(
ref
)
:
fStringPool
.
addSymbol
(
archRef
)
;
contentSpecNodeIndex
=
getContentSpec
(
getElement
(
typeName
)
)
;
contentSpecType
=
getContentSpecType
(
getElement
(
typeName
)
)
;
int
elementNameIndex
=
fStringPool
.
addSymbol
(
name
)
;
int
elementIndex
=
-
1
;
if
(
contentSpecNodeIndex
==
-
1
)
{
contentSpecType
=
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
;
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
,
elementNameIndex
,
-
1
,
false
)
;
fElementDeclPool
.
addElementDecl
(
elementNameIndex
,
contentSpecType
,
contentSpecNodeIndex
,
true
)
;
reportSchemaError
(
SchemaMessageProvider
.
FeatureUnsupported
,
new
Object
[
]
{
"Forward references to archetypes"
}
)
;
Vector
v
=
null
;
Integer
i
=
new
Integer
(
typeName
)
;
if
(
(
v
=
(
Vector
)
fForwardRefs
.
get
(
i
)
)
==
null
)
v
=
new
Vector
(
)
;
v
.
addElement
(
new
Integer
(
elementNameIndex
)
)
;
fForwardRefs
.
put
(
i
,
v
)
;
addUse
(
elementNameIndex
,
typeName
)
;
}
else
{
fElementDeclPool
.
addElementDecl
(
elementNameIndex
,
contentSpecType
,
contentSpecNodeIndex
,
true
)
;
fElementDeclPool
.
copyAtts
(
typeName
,
elementNameIndex
)
;
}
return
elementNameIndex
;
}
Element
content
=
XUtil
.
getFirstChildElement
(
elementDecl
)
;
if
(
content
!=
null
)
{
String
contentName
=
content
.
getNodeName
(
)
;
if
(
contentName
.
equals
(
ELT_ARCHETYPEDECL
)
)
{
typeNameIndex
=
traverseTypeDecl
(
content
)
;
contentSpecNodeIndex
=
getContentSpec
(
getElement
(
typeNameIndex
)
)
;
contentSpecType
=
getContentSpecType
(
getElement
(
typeNameIndex
)
)
;
}
else
if
(
contentName
.
equals
(
ELT_DATATYPEDECL
)
)
{
reportSchemaError
(
SchemaMessageProvider
.
FeatureUnsupported
,
new
Object
[
]
{
"Nesting datatype declarations"
}
)
;
}
else
if
(
!
type
.
equals
(
""
)
)
{
contentSpecType
=
fStringPool
.
addSymbol
(
"DATATYPE"
)
;
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
,
fStringPool
.
addSymbol
(
content
.
getAttribute
(
ATT_NAME
)
)
,
-
1
,
false
)
;
contentSpecNodeIndex
=
expandContentModel
(
contentSpecNodeIndex
,
content
)
;
}
else
if
(
type
.
equals
(
""
)
)
{
contentSpecType
=
fStringPool
.
addSymbol
(
"CHILDREN"
)
;
int
leftIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
,
fStringPool
.
addSymbol
(
content
.
getAttribute
(
ATT_NAME
)
)
,
-
1
,
false
)
;
contentSpecNodeIndex
=
expandContentModel
(
contentSpecNodeIndex
,
content
)
;
}
else
{
System
.
out
.
println
(
"unhandled case in element decl code"
)
;
}
}
else
if
(
!
type
.
equals
(
""
)
)
{
contentSpecType
=
fStringPool
.
addSymbol
(
"DATATYPE"
)
;
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
,
fStringPool
.
addSymbol
(
type
)
,
-
1
,
false
)
;
contentSpecNodeIndex
=
expandContentModel
(
contentSpecNodeIndex
,
elementDecl
)
;
}
int
elementNameIndex
=
fStringPool
.
addSymbol
(
elementDecl
.
getAttribute
(
ATT_NAME
)
)
;
int
elementIndex
=
fElementDeclPool
.
addElementDecl
(
elementNameIndex
,
contentSpecType
,
contentSpecNodeIndex
,
true
)
;
fElementDeclPool
.
copyAtts
(
typeNameIndex
,
elementNameIndex
)
;
return
elementNameIndex
;
}
private
int
traverseElementRef
(
Element
elementRef
)
{
String
elementName
=
elementRef
.
getAttribute
(
ATT_REF
)
;
int
elementTypeIndex
=
fStringPool
.
addSymbol
(
elementName
)
;
int
contentSpecNodeIndex
=
0
;
try
{
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
,
elementTypeIndex
,
-
1
,
false
)
;
contentSpecNodeIndex
=
expandContentModel
(
contentSpecNodeIndex
,
elementRef
)
;
}
catch
(
Exception
e
)
{
e
.
printStackTrace
(
)
;
}
return
contentSpecNodeIndex
;
}
private
void
traverseAttributeDecl
(
Element
attrDecl
,
int
elementIndex
)
throws
Exception
{
int
attName
=
fStringPool
.
addSymbol
(
attrDecl
.
getAttribute
(
ATT_NAME
)
)
;
int
attType
=
-
1
;
int
enumeration
=
-
1
;
String
datatype
=
attrDecl
.
getAttribute
(
ATT_TYPE
)
;
if
(
datatype
.
equals
(
""
)
)
{
attType
=
fStringPool
.
addSymbol
(
"CDATA"
)
;
}
else
{
if
(
datatype
.
equals
(
"string"
)
)
{
attType
=
fStringPool
.
addSymbol
(
"CDATA"
)
;
}
else
if
(
datatype
.
equals
(
"ID"
)
)
{
attType
=
fStringPool
.
addSymbol
(
"ID"
)
;
}
else
if
(
datatype
.
equals
(
"IDREF"
)
)
{
attType
=
fStringPool
.
addSymbol
(
"IDREF"
)
;
}
else
if
(
datatype
.
equals
(
"IDREFS"
)
)
{
attType
=
fStringPool
.
addSymbol
(
"IDREFS"
)
;
}
else
if
(
datatype
.
equals
(
"ENTITY"
)
)
{
attType
=
fStringPool
.
addSymbol
(
"ENTITY"
)
;
}
else
if
(
datatype
.
equals
(
"ENTITIES"
)
)
{
attType
=
fStringPool
.
addSymbol
(
"ENTITIES"
)
;
}
else
if
(
datatype
.
equals
(
"NMTOKEN"
)
)
{
Element
e
=
XUtil
.
getFirstChildElement
(
attrDecl
,
"enumeration"
)
;
if
(
e
==
null
)
{
attType
=
fStringPool
.
addSymbol
(
"NMTOKEN"
)
;
}
else
{
attType
=
fStringPool
.
addSymbol
(
"ENUMERATION"
)
;
enumeration
=
fStringPool
.
startStringList
(
)
;
for
(
Element
literal
=
XUtil
.
getFirstChildElement
(
e
,
"literal"
)
;
literal
!=
null
;
literal
=
XUtil
.
getNextSiblingElement
(
literal
,
"literal"
)
)
{
int
stringIndex
=
fStringPool
.
addSymbol
(
literal
.
getFirstChild
(
)
.
getNodeValue
(
)
)
;
fStringPool
.
addStringToList
(
enumeration
,
stringIndex
)
;
}
fStringPool
.
finishStringList
(
enumeration
)
;
}
}
else
if
(
datatype
.
equals
(
"NMTOKENS"
)
)
{
attType
=
fStringPool
.
addSymbol
(
"NMTOKENS"
)
;
}
else
if
(
datatype
.
equals
(
ELT_NOTATIONDECL
)
)
{
attType
=
fStringPool
.
addSymbol
(
"NOTATION"
)
;
}
else
{
attType
=
fStringPool
.
addSymbol
(
"DATATYPE"
)
;
enumeration
=
fStringPool
.
addSymbol
(
datatype
)
;
}
}
int
attDefaultType
=
-
1
;
int
attDefaultValue
=
-
1
;
boolean
required
=
attrDecl
.
getAttribute
(
"required"
)
.
equals
(
"true"
)
;
if
(
required
)
{
attDefaultType
=
fStringPool
.
addSymbol
(
"#REQUIRED"
)
;
}
else
{
String
fixed
=
attrDecl
.
getAttribute
(
ATT_FIXED
)
;
if
(
!
fixed
.
equals
(
""
)
)
{
attDefaultType
=
fStringPool
.
addSymbol
(
"#FIXED"
)
;
attDefaultValue
=
fStringPool
.
addString
(
fixed
)
;
}
else
{
String
defaultValue
=
attrDecl
.
getAttribute
(
ATT_DEFAULT
)
;
if
(
!
defaultValue
.
equals
(
""
)
)
{
attDefaultType
=
fStringPool
.
addSymbol
(
""
)
;
attDefaultValue
=
fStringPool
.
addString
(
defaultValue
)
;
}
else
{
attDefaultType
=
fStringPool
.
addSymbol
(
"#IMPLIED"
)
;
}
}
if
(
attType
==
fStringPool
.
addSymbol
(
"DATATYPE"
)
&&
attDefaultValue
!=
-
1
)
{
try
{
String
type
=
fStringPool
.
toString
(
enumeration
)
;
DatatypeValidator
v
=
fDatatypeRegistry
.
getValidatorFor
(
type
)
;
if
(
v
!=
null
)
v
.
validate
(
fStringPool
.
toString
(
attDefaultValue
)
)
;
else
reportSchemaError
(
SchemaMessageProvider
.
NoValidatorFor
,
new
Object
[
]
{
type
}
)
;
}
catch
(
InvalidDatatypeValueException
idve
)
{
reportSchemaError
(
SchemaMessageProvider
.
IncorrectDefaultType
,
new
Object
[
]
{
attrDecl
.
getAttribute
(
ATT_NAME
)
,
idve
.
getMessage
(
)
}
)
;
}
catch
(
Exception
e
)
{
e
.
printStackTrace
(
)
;
System
.
out
.
println
(
"Internal error in attribute datatype validation"
)
;
}
}
}
fElementDeclPool
.
addAttDef
(
elementIndex
,
attName
,
attType
,
enumeration
,
attDefaultType
,
attDefaultValue
,
true
,
true
,
true
)
;
}
private
int
traverseAttrGroup
(
Element
attrGroupDecl
)
throws
Exception
{
String
attrGroupName
=
attrGroupDecl
.
getAttribute
(
ATT_NAME
)
;
if
(
attrGroupName
.
equals
(
""
)
)
{
attrGroupName
=
"http://www.apache.org/xml/xerces/internalGroup"
+
fGroupCount
++
;
}
Element
child
=
XUtil
.
getFirstChildElement
(
attrGroupDecl
)
;
int
groupIndices
[
]
=
new
int
[
(
(
org
.
apache
.
xerces
.
dom
.
NodeImpl
)
attrGroupDecl
)
.
getLength
(
)
]
;
int
numGroups
=
0
;
for
(
;
child
!=
null
;
child
=
XUtil
.
getNextSiblingElement
(
child
)
)
{
String
childName
=
child
.
getNodeName
(
)
;
if
(
childName
.
equals
(
ELT_ATTRGROUPREF
)
)
{
groupIndices
[
numGroups
++
]
=
traverseAttrGroupRef
(
child
)
;
if
(
getContentSpec
(
getElement
(
groupIndices
[
numGroups
-
1
]
)
)
==
-
1
)
{
reportSchemaError
(
SchemaMessageProvider
.
FeatureUnsupported
,
new
Object
[
]
{
"Forward reference to AttrGroup"
}
)
;
}
}
else
if
(
childName
.
equals
(
ELT_ATTRIBUTEDECL
)
)
{
continue
;
}
else
{
reportSchemaError
(
SchemaMessageProvider
.
IllegalAttContent
,
new
Object
[
]
{
childName
}
)
;
}
}
int
attrGroupNameIndex
=
fStringPool
.
addSymbol
(
attrGroupName
)
;
int
attrGroupIndex
=
fElementDeclPool
.
addElementDecl
(
attrGroupNameIndex
,
0
,
0
,
false
)
;
for
(
child
=
XUtil
.
getFirstChildElement
(
attrGroupDecl
)
;
child
!=
null
;
child
=
XUtil
.
getNextSiblingElement
(
child
)
)
{
String
childName
=
child
.
getNodeName
(
)
;
if
(
childName
.
equals
(
ELT_ATTRIBUTEDECL
)
)
{
traverseAttributeDecl
(
child
,
attrGroupIndex
)
;
}
else
if
(
childName
.
equals
(
ELT_ATTRGROUPDECL
)
)
{
int
index
=
traverseAttrGroupRef
(
child
)
;
if
(
getContentSpec
(
getElement
(
index
)
)
==
-
1
)
{
reportSchemaError
(
SchemaMessageProvider
.
FeatureUnsupported
,
new
Object
[
]
{
"Forward reference to AttrGroup"
}
)
;
Vector
v
=
null
;
Integer
i
=
new
Integer
(
index
)
;
if
(
(
v
=
(
Vector
)
fForwardRefs
.
get
(
i
)
)
==
null
)
v
=
new
Vector
(
)
;
v
.
addElement
(
new
Integer
(
attrGroupNameIndex
)
)
;
fForwardRefs
.
put
(
i
,
v
)
;
addUse
(
attrGroupNameIndex
,
index
)
;
}
else
groupIndices
[
numGroups
++
]
=
getContentSpec
(
getElement
(
index
)
)
;
}
}
for
(
int
i
=
0
;
i
<
numGroups
;
i
++
)
{
fElementDeclPool
.
copyAtts
(
groupIndices
[
i
]
,
attrGroupNameIndex
)
;
}
return
attrGroupNameIndex
;
}
private
int
traverseAttrGroupRef
(
Element
attrGroupRef
)
{
String
name
=
attrGroupRef
.
getAttribute
(
ATT_NAME
)
;
int
index
=
fStringPool
.
addSymbol
(
name
)
;
return
index
;
}
private
void
addUse
(
int
def
,
int
use
)
{
addUse
(
def
,
new
Integer
(
use
)
)
;
}
private
void
addUse
(
int
def
,
Integer
use
)
{
Vector
v
=
(
Vector
)
fAttrGroupUses
.
get
(
new
Integer
(
def
)
)
;
if
(
v
==
null
)
v
=
new
Vector
(
)
;
v
.
addElement
(
use
)
;
}
private
int
buildAllModel
(
int
children
[
]
,
int
count
)
throws
Exception
{
if
(
count
>
1
)
{
XMLContentSpecNode
choice
=
new
XMLContentSpecNode
(
)
;
choice
.
type
=
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
;
choice
.
value
=
-
1
;
choice
.
otherValue
=
-
1
;
sort
(
children
,
0
,
count
)
;
int
index
=
buildAllModel
(
children
,
0
,
choice
)
;
return
index
;
}
if
(
count
>
0
)
{
return
children
[
0
]
;
}
return
-
1
;
}
private
int
buildAllModel
(
int
src
[
]
,
int
offset
,
XMLContentSpecNode
choice
)
throws
Exception
{
if
(
src
.
length
-
offset
==
2
)
{
int
seqIndex
=
createSeq
(
src
)
;
if
(
choice
.
value
==
-
1
)
{
choice
.
value
=
seqIndex
;
}
else
{
if
(
choice
.
otherValue
!=
-
1
)
{
choice
.
value
=
fElementDeclPool
.
addContentSpecNode
(
choice
.
type
,
choice
.
value
,
choice
.
otherValue
,
false
)
;
}
choice
.
otherValue
=
seqIndex
;
}
swap
(
src
,
offset
,
offset
+
1
)
;
seqIndex
=
createSeq
(
src
)
;
if
(
choice
.
value
==
-
1
)
{
choice
.
value
=
seqIndex
;
}
else
{
if
(
choice
.
otherValue
!=
-
1
)
{
choice
.
value
=
fElementDeclPool
.
addContentSpecNode
(
choice
.
type
,
choice
.
value
,
choice
.
otherValue
,
false
)
;
}
choice
.
otherValue
=
seqIndex
;
}
return
fElementDeclPool
.
addContentSpecNode
(
choice
.
type
,
choice
.
value
,
choice
.
otherValue
,
false
)
;
}
for
(
int
i
=
offset
;
i
<
src
.
length
-
1
;
i
++
)
{
choice
.
value
=
buildAllModel
(
src
,
offset
+
1
,
choice
)
;
choice
.
otherValue
=
-
1
;
sort
(
src
,
offset
,
src
.
length
-
offset
)
;
shift
(
src
,
offset
,
i
+
1
)
;
}
int
choiceIndex
=
buildAllModel
(
src
,
offset
+
1
,
choice
)
;
sort
(
src
,
offset
,
src
.
length
-
offset
)
;
return
choiceIndex
;
}
private
int
createSeq
(
int
src
[
]
)
throws
Exception
{
int
left
=
src
[
0
]
;
int
right
=
src
[
1
]
;
for
(
int
i
=
2
;
i
<
src
.
length
;
i
++
)
{
left
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
left
,
right
,
false
)
;
right
=
src
[
i
]
;
}
return
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
left
,
right
,
false
)
;
}
private
void
shift
(
int
src
[
]
,
int
pos
,
int
offset
)
{
int
temp
=
src
[
offset
]
;
for
(
int
i
=
offset
;
i
>
pos
;
i
--
)
{
src
[
i
]
=
src
[
i
-
1
]
;
}
src
[
pos
]
=
temp
;
}
private
void
sort
(
int
src
[
]
,
final
int
offset
,
final
int
length
)
{
for
(
int
i
=
offset
;
i
<
offset
+
length
-
1
;
i
++
)
{
int
lowest
=
i
;
for
(
int
j
=
i
+
1
;
j
<
offset
+
length
;
j
++
)
{
if
(
src
[
j
]
<
src
[
lowest
]
)
{
lowest
=
j
;
}
}
if
(
lowest
!=
i
)
{
int
temp
=
src
[
i
]
;
src
[
i
]
=
src
[
lowest
]
;
src
[
lowest
]
=
temp
;
}
}
}
private
void
swap
(
int
src
[
]
,
int
i
,
int
j
)
{
int
temp
=
src
[
i
]
;
src
[
i
]
=
src
[
j
]
;
src
[
j
]
=
temp
;
}
private
int
expandContentModel
(
int
contentSpecNodeIndex
,
Element
element
)
throws
Exception
{
int
occurs
=
getOccurrenceCount
(
element
)
;
int
m
=
1
,
n
=
1
;
if
(
!
isSimpleOccurrenceCount
(
occurs
)
)
{
try
{
m
=
Integer
.
parseInt
(
element
.
getAttribute
(
ATT_MINOCCURS
)
)
;
}
catch
(
NumberFormatException
e
)
{
reportSchemaError
(
SchemaMessageProvider
.
ValueNotInteger
,
new
Object
[
]
{
ATT_MINOCCURS
}
)
;
}
try
{
n
=
Integer
.
parseInt
(
element
.
getAttribute
(
ATT_MAXOCCURS
)
)
;
}
catch
(
NumberFormatException
e
)
{
reportSchemaError
(
SchemaMessageProvider
.
ValueNotInteger
,
new
Object
[
]
{
ATT_MAXOCCURS
}
)
;
}
}
switch
(
occurs
)
{
case
XMLContentSpecNode
.
CONTENTSPECNODE_ONE_OR_MORE
:
{
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_ONE_OR_MORE
,
contentSpecNodeIndex
,
-
1
,
false
)
;
break
;
}
case
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
:
{
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
,
contentSpecNodeIndex
,
-
1
,
false
)
;
break
;
}
case
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_ONE
:
{
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_ONE
,
contentSpecNodeIndex
,
-
1
,
false
)
;
break
;
}
case
CONTENTSPECNODE_M_OR_MORE
:
{
int
value
=
contentSpecNodeIndex
;
int
otherValue
=
-
1
;
for
(
int
i
=
1
;
i
<
m
;
i
++
)
{
if
(
otherValue
!=
-
1
)
{
value
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
value
,
otherValue
,
false
)
;
}
otherValue
=
contentSpecNodeIndex
;
}
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
,
contentSpecNodeIndex
,
-
1
,
false
)
;
if
(
otherValue
!=
-
1
)
{
value
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
value
,
otherValue
,
false
)
;
}
otherValue
=
contentSpecNodeIndex
;
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
value
,
otherValue
,
false
)
;
break
;
}
case
CONTENTSPECNODE_M_TO_N
:
{
int
value
=
contentSpecNodeIndex
;
int
otherValue
=
-
1
;
for
(
int
i
=
1
;
i
<
m
;
i
++
)
{
if
(
otherValue
!=
-
1
)
{
value
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
value
,
otherValue
,
false
)
;
}
otherValue
=
contentSpecNodeIndex
;
}
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_ONE
,
contentSpecNodeIndex
,
-
1
,
false
)
;
for
(
int
i
=
n
;
i
>
m
;
i
--
)
{
if
(
otherValue
!=
-
1
)
{
value
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
value
,
otherValue
,
false
)
;
}
otherValue
=
contentSpecNodeIndex
;
}
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
value
,
otherValue
,
false
)
;
break
;
}
case
CONTENTSPECNODE_ZERO_TO_N
:
{
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_ONE
,
contentSpecNodeIndex
,
-
1
,
false
)
;
int
value
=
contentSpecNodeIndex
;
int
otherValue
=
-
1
;
for
(
int
i
=
1
;
i
<
n
;
i
++
)
{
if
(
otherValue
!=
-
1
)
{
value
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
value
,
otherValue
,
false
)
;
}
otherValue
=
contentSpecNodeIndex
;
}
contentSpecNodeIndex
=
fElementDeclPool
.
addContentSpecNode
(
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
,
value
,
otherValue
,
false
)
;
break
;
}
}
return
contentSpecNodeIndex
;
}
private
boolean
isSimpleOccurrenceCount
(
int
occurs
)
{
return
occurs
==
-
1
||
occurs
==
XMLContentSpecNode
.
CONTENTSPECNODE_ONE_OR_MORE
||
occurs
==
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
||
occurs
==
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_ONE
;
}
private
int
getOccurrenceCount
(
Element
element
)
{
String
minOccur
=
element
.
getAttribute
(
ATT_MINOCCURS
)
;
String
maxOccur
=
element
.
getAttribute
(
ATT_MAXOCCURS
)
;
if
(
minOccur
.
equals
(
"0"
)
)
{
if
(
maxOccur
.
equals
(
"1"
)
||
maxOccur
.
length
(
)
==
0
)
{
return
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_ONE
;
}
else
if
(
maxOccur
.
equals
(
"*"
)
)
{
return
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
;
}
else
{
return
CONTENTSPECNODE_ZERO_TO_N
;
}
}
else
if
(
minOccur
.
equals
(
"1"
)
||
minOccur
.
length
(
)
==
0
)
{
if
(
maxOccur
.
equals
(
"*"
)
)
{
return
XMLContentSpecNode
.
CONTENTSPECNODE_ONE_OR_MORE
;
}
else
if
(
!
maxOccur
.
equals
(
"1"
)
&&
maxOccur
.
length
(
)
>
0
)
{
return
CONTENTSPECNODE_M_TO_N
;
}
}
else
{
if
(
maxOccur
.
equals
(
"*"
)
)
{
return
CONTENTSPECNODE_M_OR_MORE
;
}
else
{
return
CONTENTSPECNODE_M_TO_N
;
}
}
return
-
1
;
}
private
void
reportSchemaError
(
int
major
,
Object
args
[
]
)
{
try
{
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
SchemaMessageProvider
.
SCHEMA_DOMAIN
,
major
,
SchemaMessageProvider
.
MSG_NONE
,
args
,
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
)
;
}
catch
(
Exception
e
)
{
e
.
printStackTrace
(
)
;
}
}
static
class
Resolver
implements
EntityResolver
{
private
static
final
String
SYSTEM
[
]
=
{
"http://www.w3.org/XML/Group/1999/09/23-xmlschema/structures/structures.dtd"
,
"http://www.w3.org/XML/Group/1999/09/23-xmlschema/datatypes/datatypes.dtd"
,
}
;
private
static
final
String
PATH
[
]
=
{
"structures.dtd"
,
"datatypes.dtd"
,
}
;
public
InputSource
resolveEntity
(
String
publicId
,
String
systemId
)
throws
IOException
{
for
(
int
i
=
0
;
i
<
SYSTEM
.
length
;
i
++
)
{
if
(
systemId
.
equals
(
SYSTEM
[
i
]
)
)
{
InputSource
source
=
new
InputSource
(
getClass
(
)
.
getResourceAsStream
(
PATH
[
i
]
)
)
;
source
.
setPublicId
(
publicId
)
;
source
.
setSystemId
(
systemId
)
;
return
source
;
}
}
return
null
;
}
}
static
class
ErrorHandler
implements
org
.
xml
.
sax
.
ErrorHandler
{
public
void
warning
(
SAXParseException
ex
)
{
System
.
err
.
println
(
"[Warning] "
+
getLocationString
(
ex
)
+
": "
+
ex
.
getMessage
(
)
)
;
}
public
void
error
(
SAXParseException
ex
)
{
System
.
err
.
println
(
"[Error] "
+
getLocationString
(
ex
)
+
": "
+
ex
.
getMessage
(
)
)
;
}
public
void
fatalError
(
SAXParseException
ex
)
throws
SAXException
{
System
.
err
.
println
(
"[Fatal Error] "
+
getLocationString
(
ex
)
+
": "
+
ex
.
getMessage
(
)
)
;
throw
ex
;
}
private
String
getLocationString
(
SAXParseException
ex
)
{
StringBuffer
str
=
new
StringBuffer
(
)
;
String
systemId_
=
ex
.
getSystemId
(
)
;
if
(
systemId_
!=
null
)
{
int
index
=
systemId_
.
lastIndexOf
(
'/'
)
;
if
(
index
!=
-
1
)
systemId_
=
systemId_
.
substring
(
index
+
1
)
;
str
.
append
(
systemId_
)
;
}
str
.
append
(
':'
)
;
str
.
append
(
ex
.
getLineNumber
(
)
)
;
str
.
append
(
':'
)
;
str
.
append
(
ex
.
getColumnNumber
(
)
)
;
return
str
.
toString
(
)
;
}
}
class
DatatypeValidatorRegistry
{
Hashtable
fRegistry
=
new
Hashtable
(
)
;
String
integerSubtypeTable
[
]
[
]
=
{
{
"non-negative-integer"
,
DatatypeValidator
.
MININCLUSIVE
,
"0"
}
,
{
"postive-integer"
,
DatatypeValidator
.
MININCLUSIVE
,
"1"
}
,
{
"non-positive-integer"
,
DatatypeValidator
.
MAXINCLUSIVE
,
"0"
}
,
{
"negative-integer"
,
DatatypeValidator
.
MAXINCLUSIVE
,
"-1"
}
}
;
void
initializeRegistry
(
)
{
Hashtable
facets
=
null
;
fRegistry
.
put
(
"boolean"
,
new
BooleanValidator
(
)
)
;
DatatypeValidator
integerValidator
=
new
IntegerValidator
(
)
;
fRegistry
.
put
(
"integer"
,
integerValidator
)
;
fRegistry
.
put
(
"string"
,
new
StringValidator
(
)
)
;
fRegistry
.
put
(
"real"
,
new
RealValidator
(
)
)
;
fRegistry
.
put
(
"decimal"
,
new
DecimalValidator
(
)
)
;
DatatypeValidator
v
=
null
;
for
(
int
i
=
0
;
i
<
integerSubtypeTable
.
length
;
i
++
)
{
v
=
new
IntegerValidator
(
)
;
facets
=
new
Hashtable
(
)
;
facets
.
put
(
integerSubtypeTable
[
i
]
[
1
]
,
integerSubtypeTable
[
i
]
[
2
]
)
;
v
.
setBasetype
(
integerValidator
)
;
try
{
v
.
setFacets
(
facets
)
;
}
catch
(
IllegalFacetException
ife
)
{
System
.
out
.
println
(
"Internal error initializing registry - Illegal facet: "
+
integerSubtypeTable
[
i
]
[
0
]
)
;
}
catch
(
IllegalFacetValueException
ifve
)
{
System
.
out
.
println
(
"Internal error initializing registry - Illegal facet value: "
+
integerSubtypeTable
[
i
]
[
0
]
)
;
}
catch
(
UnknownFacetException
ufe
)
{
System
.
out
.
println
(
"Internal error initializing registry - Unknown facet: "
+
integerSubtypeTable
[
i
]
[
0
]
)
;
}
fRegistry
.
put
(
integerSubtypeTable
[
0
]
,
v
)
;
}
}
DatatypeValidator
getValidatorFor
(
String
type
)
{
return
(
DatatypeValidator
)
fRegistry
.
get
(
type
)
;
}
void
addValidator
(
String
name
,
DatatypeValidator
v
)
{
fRegistry
.
put
(
name
,
v
)
;
}
}
}
