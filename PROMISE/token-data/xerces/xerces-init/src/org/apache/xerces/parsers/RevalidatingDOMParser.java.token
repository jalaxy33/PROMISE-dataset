package
org
.
apache
.
xerces
.
parsers
;
import
org
.
apache
.
xerces
.
dom
.
TextImpl
;
import
org
.
apache
.
xerces
.
framework
.
XMLErrorReporter
;
import
org
.
apache
.
xerces
.
framework
.
XMLValidator
;
import
org
.
apache
.
xerces
.
utils
.
StringPool
;
import
org
.
apache
.
xerces
.
utils
.
XMLMessages
;
import
org
.
w3c
.
dom
.
Node
;
import
org
.
w3c
.
dom
.
NodeList
;
public
class
RevalidatingDOMParser
extends
DOMParser
{
private
static
final
boolean
DEBUG_VALIDATE
=
false
;
public
final
Node
validate
(
Node
node
)
{
if
(
node
.
getNodeType
(
)
!=
Node
.
ELEMENT_NODE
)
{
throw
new
IllegalArgumentException
(
"Can't revalidate a non element"
)
;
}
return
recursiveValidate
(
node
,
fValidator
,
fStringPool
)
;
}
private
final
Node
recursiveValidate
(
Node
node
,
XMLValidator
validator
,
StringPool
stringPool
)
{
if
(
DEBUG_VALIDATE
)
{
print
(
node
,
""
)
;
}
int
children
[
]
=
new
int
[
countChildren
(
node
)
]
;
Node
nodes
[
]
=
new
Node
[
children
.
length
]
;
int
count
=
expandChildren
(
node
,
children
,
nodes
,
0
,
stringPool
)
;
int
result
=
-
1
;
int
parentNameIndex
=
stringPool
.
addSymbol
(
node
.
getNodeName
(
)
)
;
int
parentIndex
=
-
1
;
try
{
parentIndex
=
fStringPool
.
getDeclaration
(
parentNameIndex
)
;
result
=
validator
.
checkContent
(
parentIndex
,
count
,
children
)
;
}
catch
(
Exception
e
)
{
if
(
DEBUG_VALIDATE
)
{
e
.
printStackTrace
(
)
;
}
}
Node
errorNode
=
null
;
if
(
result
!=
-
1
)
{
errorNode
=
nodes
[
result
]
;
String
cs
=
validator
.
getContentSpecAsString
(
parentIndex
)
;
int
majorCode
=
result
!=
count
?
XMLMessages
.
MSG_CONTENT_INVALID
:
XMLMessages
.
MSG_CONTENT_INCOMPLETE
;
try
{
Object
[
]
args
=
{
node
.
getNodeName
(
)
,
cs
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
majorCode
,
0
,
args
,
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
)
;
}
catch
(
Exception
e
)
{
}
}
else
{
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
if
(
children
[
i
]
!=
-
1
)
{
Node
child
=
nodes
[
i
]
;
if
(
child
!=
null
)
{
child
=
recursiveValidate
(
child
,
validator
,
stringPool
)
;
if
(
child
!=
null
)
{
errorNode
=
child
;
break
;
}
}
}
}
}
children
=
null
;
nodes
=
null
;
return
errorNode
;
}
private
final
int
expandChildren
(
Node
node
,
int
children
[
]
,
Node
nodes
[
]
,
int
count
,
StringPool
stringPool
)
{
if
(
node
.
hasChildNodes
(
)
)
{
NodeList
childList
=
node
.
getChildNodes
(
)
;
int
childCount
=
childList
.
getLength
(
)
;
for
(
int
i
=
0
;
i
<
childCount
;
i
++
)
{
Node
child
=
childList
.
item
(
i
)
;
int
type
=
child
.
getNodeType
(
)
;
if
(
type
==
Node
.
ELEMENT_NODE
)
{
children
[
count
]
=
stringPool
.
addSymbol
(
child
.
getNodeName
(
)
)
;
nodes
[
count
]
=
child
;
count
++
;
}
else
if
(
type
==
Node
.
TEXT_NODE
)
{
if
(
!
(
child
instanceof
TextImpl
)
||
!
(
(
TextImpl
)
child
)
.
isIgnorableWhitespace
(
)
)
{
children
[
count
]
=
-
1
;
nodes
[
count
]
=
child
;
count
++
;
}
}
else
if
(
type
==
Node
.
ENTITY_REFERENCE_NODE
)
{
count
=
expandChildren
(
child
,
children
,
nodes
,
count
,
stringPool
)
;
}
}
}
return
count
;
}
private
final
int
countChildren
(
Node
node
)
{
int
count
=
0
;
if
(
node
.
hasChildNodes
(
)
)
{
NodeList
children
=
node
.
getChildNodes
(
)
;
count
+=
children
.
getLength
(
)
;
for
(
int
i
=
count
-
1
;
i
>=
0
;
i
--
)
{
Node
child
=
children
.
item
(
i
)
;
if
(
child
.
getNodeType
(
)
==
Node
.
ENTITY_REFERENCE_NODE
)
{
count
+=
countChildren
(
child
)
-
1
;
}
}
}
return
count
;
}
private
static
void
print
(
Node
node
,
String
indent
)
{
if
(
DEBUG_VALIDATE
)
{
if
(
node
==
null
)
{
System
.
out
.
println
(
indent
+
"!!! node == null"
)
;
return
;
}
System
.
out
.
println
(
indent
+
"node: type="
+
type
(
node
.
getNodeType
(
)
)
+
", name="
+
node
.
getNodeName
(
)
+
", value=\""
+
normalize
(
node
.
getNodeValue
(
)
)
+
'"'
)
;
if
(
node
.
hasChildNodes
(
)
)
{
System
.
out
.
println
(
indent
+
'{'
)
;
NodeList
children
=
node
.
getChildNodes
(
)
;
int
count
=
children
.
getLength
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
print
(
children
.
item
(
i
)
,
indent
+
"  "
)
;
}
System
.
out
.
println
(
indent
+
'}'
)
;
}
}
}
private
static
String
normalize
(
String
s
)
{
if
(
DEBUG_VALIDATE
)
{
if
(
s
==
null
)
{
return
"[null]"
;
}
StringBuffer
str
=
new
StringBuffer
(
)
;
int
len
=
s
.
length
(
)
;
for
(
int
i
=
0
;
i
<
len
;
i
++
)
{
if
(
i
>
20
)
{
str
.
append
(
"..."
)
;
break
;
}
char
ch
=
s
.
charAt
(
i
)
;
switch
(
ch
)
{
case
'\r'
:
str
.
append
(
"[\\r]"
)
;
break
;
case
'\n'
:
str
.
append
(
"[\\n]"
)
;
break
;
default
:
str
.
append
(
ch
)
;
}
}
return
str
.
toString
(
)
;
}
return
null
;
}
private
static
String
type
(
int
type
)
{
if
(
DEBUG_VALIDATE
)
{
switch
(
type
)
{
case
Node
.
ATTRIBUTE_NODE
:
return
"ATTR"
;
case
Node
.
ELEMENT_NODE
:
return
"ELEMENT"
;
case
Node
.
TEXT_NODE
:
return
"TEXT"
;
case
Node
.
ENTITY_REFERENCE_NODE
:
return
"ENTITY_REF"
;
}
return
"???"
;
}
return
null
;
}
}
