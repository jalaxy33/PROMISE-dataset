package
org
.
apache
.
xerces
.
dom
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Vector
;
import
org
.
w3c
.
dom
.
*
;
import
org
.
apache
.
xerces
.
domx
.
traversal
.
*
;
import
org
.
apache
.
xerces
.
dom
.
traversal
.
*
;
import
org
.
apache
.
xerces
.
domx
.
events
.
*
;
import
org
.
apache
.
xerces
.
dom
.
events
.
*
;
public
class
DocumentImpl
extends
NodeImpl
implements
Document
,
DocumentTraversal
,
DocumentEvent
{
static
final
long
serialVersionUID
=
515687835542616694L
;
protected
DocumentTypeImpl
docType
;
protected
ElementImpl
docElement
;
protected
Hashtable
identifiers
;
protected
Vector
iterators
;
protected
Vector
treeWalkers
;
protected
boolean
allowGrammarAccess
;
public
DocumentImpl
(
)
{
this
(
false
)
;
}
public
DocumentImpl
(
boolean
grammarAccess
)
{
super
(
null
,
null
,
null
)
;
ownerDocument
=
this
;
allowGrammarAccess
=
grammarAccess
;
}
public
DocumentImpl
(
DocumentType
doctype
)
{
this
(
doctype
,
false
)
;
}
public
DocumentImpl
(
DocumentType
doctype
,
boolean
grammarAccess
)
{
this
(
grammarAccess
)
;
this
.
docType
=
docType
;
if
(
this
.
docType
!=
null
)
{
docType
.
ownerDocument
=
this
;
}
}
public
short
getNodeType
(
)
{
return
Node
.
DOCUMENT_NODE
;
}
public
String
getNodeName
(
)
{
return
"#document"
;
}
public
String
getNodeValue
(
)
{
return
null
;
}
public
Node
cloneNode
(
boolean
deep
)
{
DocumentImpl
newdoc
=
new
DocumentImpl
(
)
;
if
(
deep
)
{
for
(
NodeImpl
n
=
(
NodeImpl
)
getFirstChild
(
)
;
n
!=
null
;
n
=
n
.
nextSibling
)
{
newdoc
.
appendChild
(
newdoc
.
importNode
(
n
,
true
)
)
;
}
}
return
newdoc
;
}
public
Node
insertBefore
(
Node
newChild
,
Node
refChild
)
throws
DOMException
{
int
type
=
newChild
.
getNodeType
(
)
;
if
(
(
type
==
Node
.
ELEMENT_NODE
&&
docElement
!=
null
)
||
(
type
==
Node
.
DOCUMENT_TYPE_NODE
&&
docType
!=
null
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"HIERARCHY_REQUEST_ERR"
)
;
}
super
.
insertBefore
(
newChild
,
refChild
)
;
if
(
type
==
Node
.
ELEMENT_NODE
)
{
docElement
=
(
ElementImpl
)
newChild
;
}
else
if
(
type
==
Node
.
DOCUMENT_TYPE_NODE
)
{
docType
=
(
DocumentTypeImpl
)
newChild
;
}
return
newChild
;
}
public
Node
removeChild
(
Node
oldChild
)
throws
DOMException
{
super
.
removeChild
(
oldChild
)
;
int
type
=
oldChild
.
getNodeType
(
)
;
if
(
type
==
Node
.
ELEMENT_NODE
)
{
docElement
=
null
;
}
else
if
(
type
==
Node
.
DOCUMENT_TYPE_NODE
)
{
docType
=
null
;
}
return
oldChild
;
}
public
void
setNodeValue
(
String
x
)
throws
DOMException
{
throw
new
DOMExceptionImpl
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"NO_MODIFICATION_ALLOWED_ERR"
)
;
}
public
Attr
createAttribute
(
String
name
)
throws
DOMException
{
if
(
!
isXMLName
(
name
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
INVALID_CHARACTER_ERR
,
"INVALID_CHARACTER_ERR"
)
;
}
return
new
AttrImpl
(
this
,
name
)
;
}
public
CDATASection
createCDATASection
(
String
data
)
throws
DOMException
{
return
new
CDATASectionImpl
(
this
,
data
)
;
}
public
Comment
createComment
(
String
data
)
{
return
new
CommentImpl
(
this
,
data
)
;
}
public
DocumentFragment
createDocumentFragment
(
)
{
return
new
DocumentFragmentImpl
(
this
)
;
}
public
Element
createElement
(
String
tagName
)
throws
DOMException
{
if
(
!
isXMLName
(
tagName
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
INVALID_CHARACTER_ERR
,
"INVALID_CHARACTER_ERR"
)
;
}
return
new
ElementImpl
(
this
,
tagName
)
;
}
public
EntityReference
createEntityReference
(
String
name
)
throws
DOMException
{
if
(
!
isXMLName
(
name
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
INVALID_CHARACTER_ERR
,
"INVALID_CHARACTER_ERR"
)
;
}
return
new
EntityReferenceImpl
(
this
,
name
)
;
}
public
ProcessingInstruction
createProcessingInstruction
(
String
target
,
String
data
)
throws
DOMException
{
if
(
!
isXMLName
(
target
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
INVALID_CHARACTER_ERR
,
"INVALID_CHARACTER_ERR"
)
;
}
return
new
ProcessingInstructionImpl
(
this
,
target
,
data
)
;
}
public
Text
createTextNode
(
String
data
)
{
return
new
TextImpl
(
this
,
data
)
;
}
public
DocumentType
getDoctype
(
)
{
if
(
syncChildren
)
{
synchronizeChildren
(
)
;
}
return
docType
;
}
public
Element
getDocumentElement
(
)
{
if
(
syncChildren
)
{
synchronizeChildren
(
)
;
}
return
docElement
;
}
public
NodeList
getElementsByTagName
(
String
tagname
)
{
return
new
DeepNodeListImpl
(
this
,
tagname
)
;
}
public
DOMImplementation
getImplementation
(
)
{
return
DOMImplementationImpl
.
getDOMImplementation
(
)
;
}
public
DocumentType
createDocumentType
(
String
qualifiedName
,
String
publicID
,
String
systemID
)
throws
DOMException
{
if
(
!
isXMLName
(
qualifiedName
)
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
INVALID_CHARACTER_ERR
,
"INVALID_CHARACTER_ERR"
)
;
}
return
new
DocumentTypeImpl
(
this
,
qualifiedName
,
publicID
,
systemID
)
;
}
public
Entity
createEntity
(
String
name
)
throws
DOMException
{
return
new
EntityImpl
(
this
,
name
)
;
}
public
Notation
createNotation
(
String
name
)
throws
DOMException
{
return
new
NotationImpl
(
this
,
name
)
;
}
public
ElementDefinitionImpl
createElementDefinition
(
String
name
)
throws
DOMException
{
return
new
ElementDefinitionImpl
(
this
,
name
)
;
}
public
Node
importNode
(
Node
source
,
boolean
deep
)
throws
DOMException
{
NodeImpl
newnode
=
null
;
int
type
=
source
.
getNodeType
(
)
;
switch
(
type
)
{
case
ELEMENT_NODE
:
{
Element
newelement
=
createElement
(
source
.
getNodeName
(
)
)
;
NamedNodeMap
srcattr
=
source
.
getAttributes
(
)
;
if
(
srcattr
!=
null
)
{
for
(
int
i
=
0
;
i
<
srcattr
.
getLength
(
)
;
i
++
)
{
newelement
.
setAttributeNode
(
(
AttrImpl
)
importNode
(
srcattr
.
item
(
i
)
,
true
)
)
;
}
}
newnode
=
(
NodeImpl
)
newelement
;
break
;
}
case
ATTRIBUTE_NODE
:
{
newnode
=
(
NodeImpl
)
createAttribute
(
source
.
getNodeName
(
)
)
;
break
;
}
case
TEXT_NODE
:
{
newnode
=
(
NodeImpl
)
createTextNode
(
source
.
getNodeValue
(
)
)
;
break
;
}
case
CDATA_SECTION_NODE
:
{
newnode
=
(
NodeImpl
)
createCDATASection
(
source
.
getNodeValue
(
)
)
;
break
;
}
case
ENTITY_REFERENCE_NODE
:
{
newnode
=
(
NodeImpl
)
createEntityReference
(
source
.
getNodeName
(
)
)
;
deep
=
false
;
break
;
}
case
ENTITY_NODE
:
{
Entity
srcentity
=
(
Entity
)
source
;
EntityImpl
newentity
=
(
EntityImpl
)
createEntity
(
source
.
getNodeName
(
)
)
;
newentity
.
setPublicId
(
srcentity
.
getPublicId
(
)
)
;
newentity
.
setSystemId
(
srcentity
.
getSystemId
(
)
)
;
newentity
.
setNotationName
(
srcentity
.
getNotationName
(
)
)
;
newnode
=
newentity
;
break
;
}
case
PROCESSING_INSTRUCTION_NODE
:
{
newnode
=
(
ProcessingInstructionImpl
)
createProcessingInstruction
(
source
.
getNodeName
(
)
,
source
.
getNodeValue
(
)
)
;
break
;
}
case
COMMENT_NODE
:
{
newnode
=
(
NodeImpl
)
createComment
(
source
.
getNodeValue
(
)
)
;
break
;
}
case
DOCUMENT_TYPE_NODE
:
{
DocumentTypeImpl
doctype
=
(
DocumentTypeImpl
)
source
;
DocumentTypeImpl
newdoctype
=
(
DocumentTypeImpl
)
createDocumentType
(
doctype
.
getNodeName
(
)
,
doctype
.
getPublicID
(
)
,
doctype
.
getSystemID
(
)
)
;
NamedNodeMap
smap
=
(
(
DocumentType
)
source
)
.
getEntities
(
)
;
NamedNodeMap
tmap
=
newdoctype
.
getEntities
(
)
;
if
(
smap
!=
null
)
{
for
(
int
i
=
0
;
i
<
smap
.
getLength
(
)
;
i
++
)
{
tmap
.
setNamedItem
(
(
EntityImpl
)
importNode
(
smap
.
item
(
i
)
,
true
)
)
;
}
}
smap
=
(
(
DocumentType
)
source
)
.
getNotations
(
)
;
tmap
=
newdoctype
.
getNotations
(
)
;
if
(
smap
!=
null
)
{
for
(
int
i
=
0
;
i
<
smap
.
getLength
(
)
;
i
++
)
{
tmap
.
setNamedItem
(
(
NotationImpl
)
importNode
(
smap
.
item
(
i
)
,
true
)
)
;
}
}
newnode
=
newdoctype
;
break
;
}
case
DOCUMENT_FRAGMENT_NODE
:
{
newnode
=
(
NodeImpl
)
createDocumentFragment
(
)
;
break
;
}
case
NOTATION_NODE
:
{
Notation
srcnotation
=
(
Notation
)
source
;
NotationImpl
newnotation
=
(
NotationImpl
)
createNotation
(
source
.
getNodeName
(
)
)
;
newnotation
.
setPublicId
(
srcnotation
.
getPublicId
(
)
)
;
newnotation
.
setSystemId
(
srcnotation
.
getSystemId
(
)
)
;
newnode
=
newnotation
;
break
;
}
case
DOCUMENT_NODE
:
default
:
{
throw
new
DOMExceptionImpl
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"HIERARCHY_REQUEST_ERR"
)
;
}
}
if
(
deep
)
{
for
(
Node
srckid
=
source
.
getFirstChild
(
)
;
srckid
!=
null
;
srckid
=
srckid
.
getNextSibling
(
)
)
{
newnode
.
appendChild
(
importNode
(
srckid
,
true
)
)
;
}
}
return
newnode
;
}
public
void
putIdentifier
(
String
idName
,
Element
element
)
{
if
(
element
==
null
)
{
removeIdentifier
(
idName
)
;
}
if
(
syncData
)
{
synchronizeData
(
)
;
}
if
(
identifiers
==
null
)
{
identifiers
=
new
Hashtable
(
)
;
}
identifiers
.
put
(
idName
,
element
)
;
}
public
Element
getIdentifier
(
String
idName
)
{
if
(
syncData
)
{
synchronizeData
(
)
;
}
if
(
identifiers
==
null
)
{
return
null
;
}
return
(
Element
)
identifiers
.
get
(
idName
)
;
}
public
void
removeIdentifier
(
String
idName
)
{
if
(
syncData
)
{
synchronizeData
(
)
;
}
if
(
identifiers
==
null
)
{
return
;
}
identifiers
.
remove
(
idName
)
;
}
public
Enumeration
getIdentifiers
(
)
{
if
(
syncData
)
{
synchronizeData
(
)
;
}
if
(
identifiers
==
null
)
{
identifiers
=
new
Hashtable
(
)
;
}
return
identifiers
.
keys
(
)
;
}
public
Element
createElementNS
(
String
namespaceURI
,
String
qualifiedName
)
throws
DOMException
{
if
(
namespaceURI
==
null
||
namespaceURI
.
equals
(
""
)
)
{
return
new
ElementImpl
(
this
,
qualifiedName
)
;
}
return
new
ElementImpl
(
this
,
namespaceURI
,
qualifiedName
)
;
}
public
Attr
createAttributeNS
(
String
namespaceURI
,
String
qualifiedName
)
throws
DOMException
{
if
(
namespaceURI
==
null
||
namespaceURI
.
equals
(
""
)
)
{
return
new
AttrImpl
(
this
,
qualifiedName
)
;
}
return
new
AttrImpl
(
this
,
namespaceURI
,
qualifiedName
)
;
}
public
NodeList
getElementsByTagNameNS
(
String
namespaceURI
,
String
localName
)
{
return
new
DeepNodeListImpl
(
this
,
namespaceURI
,
localName
)
;
}
public
NodeIterator
createNodeIterator
(
Node
root
,
short
whatToShow
,
NodeFilter
filter
)
{
return
createNodeIterator
(
root
,
whatToShow
,
filter
,
true
)
;
}
public
NodeIterator
createNodeIterator
(
Node
root
,
int
whatToShow
,
NodeFilter
filter
,
boolean
entityReferenceExpansion
)
{
NodeIterator
iterator
=
new
NodeIteratorImpl
(
this
,
root
,
whatToShow
,
filter
,
entityReferenceExpansion
)
;
if
(
iterators
==
null
)
{
iterators
=
new
Vector
(
)
;
}
iterators
.
addElement
(
iterator
)
;
return
iterator
;
}
public
TreeWalker
createTreeWalker
(
Node
root
,
short
whatToShow
,
NodeFilter
filter
)
{
return
createTreeWalker
(
root
,
whatToShow
,
filter
,
true
)
;
}
public
TreeWalker
createTreeWalker
(
Node
root
,
int
whatToShow
,
NodeFilter
filter
,
boolean
entityReferenceExpansion
)
{
if
(
root
==
null
)
{
throw
new
DOMExceptionImpl
(
DOMException
.
NOT_SUPPORTED_ERR
,
"NOT_SUPPORTED_ERR"
)
;
}
TreeWalker
treeWalker
=
new
TreeWalkerImpl
(
root
,
whatToShow
,
filter
,
entityReferenceExpansion
)
;
if
(
treeWalkers
==
null
)
{
treeWalkers
=
new
Vector
(
)
;
}
treeWalkers
.
addElement
(
treeWalker
)
;
return
treeWalker
;
}
public
void
removeNodeIterator
(
NodeIterator
nodeIterator
)
{
if
(
nodeIterator
==
null
)
return
;
if
(
iterators
==
null
)
return
;
iterators
.
removeElement
(
nodeIterator
)
;
}
public
void
removeTreeWalker
(
TreeWalker
treeWalker
)
{
if
(
treeWalker
==
null
)
return
;
if
(
treeWalkers
==
null
)
return
;
treeWalkers
.
removeElement
(
treeWalker
)
;
}
public
Enumeration
getNodeIterators
(
)
{
if
(
iterators
==
null
)
return
null
;
return
iterators
.
elements
(
)
;
}
public
Enumeration
getTreeWalkers
(
)
{
if
(
treeWalkers
==
null
)
return
null
;
return
treeWalkers
.
elements
(
)
;
}
public
void
removeNodeIterators
(
)
{
iterators
=
null
;
}
public
void
removeTreeWalkers
(
)
{
treeWalkers
=
null
;
}
public
Event
createEvent
(
String
type
)
throws
DOMException
{
if
(
"Event"
.
equals
(
type
)
)
return
new
EventImpl
(
)
;
if
(
"MutationEvent"
.
equals
(
type
)
)
return
new
MutationEventImpl
(
)
;
else
throw
new
DOMExceptionImpl
(
DOMExceptionImpl
.
UNSUPPORTED_EVENT_TYPE
,
null
)
;
}
public
static
boolean
isXMLName
(
String
s
)
{
if
(
s
==
null
)
{
return
false
;
}
char
[
]
ca
=
new
char
[
s
.
length
(
)
]
;
s
.
getChars
(
0
,
s
.
length
(
)
,
ca
,
0
)
;
if
(
!
Character
.
isLetter
(
ca
[
0
]
)
&&
"_:"
.
indexOf
(
(
int
)
ca
[
0
]
)
==
-
1
)
{
return
false
;
}
for
(
int
i
=
1
;
i
<
s
.
length
(
)
;
++
i
)
{
char
c
=
ca
[
i
]
;
int
ctype
=
Character
.
getType
(
c
)
;
if
(
!
Character
.
isLetterOrDigit
(
c
)
&&
(
".-_:"
.
indexOf
(
c
)
==
-
1
)
&&
(
!
(
ctype
>=
6
&&
ctype
<=
8
&&
!
(
(
c
>=
0x06dd
&&
c
<=
0x06de
)
||
(
c
>=
0x20dd
&&
c
<=
0x20e0
)
||
c
>=
0x309b
)
)
)
&&
(
!
(
ctype
==
4
&&
!
(
(
c
>=
0x02d0
&&
c
<=
0x0559
)
||
(
c
>=
0x06e5
&&
c
<=
0x06e6
)
||
(
c
>=
0x309b
&&
c
<=
0x309c
)
)
||
c
==
0x00b7
||
c
==
0x0387
)
)
)
{
return
false
;
}
}
return
true
;
}
protected
boolean
isKidOK
(
Node
parent
,
Node
child
)
{
if
(
allowGrammarAccess
&&
parent
.
getNodeType
(
)
==
Node
.
DOCUMENT_TYPE_NODE
)
{
return
child
.
getNodeType
(
)
==
Node
.
ELEMENT_NODE
;
}
return
0
!=
(
kidOK
[
parent
.
getNodeType
(
)
]
&
1
<<
child
.
getNodeType
(
)
)
;
}
}
