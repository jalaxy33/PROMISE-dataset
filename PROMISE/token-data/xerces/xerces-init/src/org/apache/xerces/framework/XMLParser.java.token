package
org
.
apache
.
xerces
.
framework
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
IOException
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
Reader
;
import
java
.
net
.
URL
;
import
java
.
net
.
MalformedURLException
;
import
java
.
util
.
Locale
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
ResourceBundle
;
import
java
.
util
.
Stack
;
import
java
.
util
.
ListResourceBundle
;
import
org
.
apache
.
xerces
.
readers
.
XMLDeclRecognizer
;
import
org
.
apache
.
xerces
.
readers
.
XMLEntityHandler
;
import
org
.
apache
.
xerces
.
readers
.
XMLEntityReaderFactory
;
import
org
.
apache
.
xerces
.
utils
.
ChunkyByteArray
;
import
org
.
apache
.
xerces
.
utils
.
ChunkyCharArray
;
import
org
.
apache
.
xerces
.
utils
.
NamespacesScope
;
import
org
.
apache
.
xerces
.
utils
.
StringPool
;
import
org
.
apache
.
xerces
.
utils
.
XMLCharacterProperties
;
import
org
.
apache
.
xerces
.
utils
.
XMLMessageProvider
;
import
org
.
apache
.
xerces
.
utils
.
XMLMessages
;
import
org
.
apache
.
xerces
.
utils
.
ImplementationMessages
;
import
org
.
apache
.
xerces
.
validators
.
dtd
.
DTDValidator
;
import
org
.
apache
.
xerces
.
validators
.
schema
.
XSchemaValidator
;
import
org
.
apache
.
xerces
.
validators
.
datatype
.
DatatypeMessageProvider
;
import
org
.
apache
.
xerces
.
validators
.
schema
.
SchemaMessageProvider
;
import
org
.
xml
.
sax
.
Configurable
;
import
org
.
xml
.
sax
.
EntityResolver
;
import
org
.
xml
.
sax
.
ErrorHandler
;
import
org
.
xml
.
sax
.
InputSource
;
import
org
.
xml
.
sax
.
Locator
;
import
org
.
xml
.
sax
.
Parser
;
import
org
.
xml
.
sax
.
SAXException
;
import
org
.
xml
.
sax
.
SAXNotRecognizedException
;
import
org
.
xml
.
sax
.
SAXNotSupportedException
;
import
org
.
xml
.
sax
.
SAXParseException
;
import
org
.
xml
.
sax
.
helpers
.
LocatorImpl
;
public
abstract
class
XMLParser
implements
XMLErrorReporter
,
XMLEntityHandler
,
XMLDocumentScanner
.
EventHandler
,
DTDValidator
.
EventHandler
,
Configurable
,
Locator
{
protected
static
final
String
SAX2_FEATURES_PREFIX
=
"http://xml.org/sax/features/"
;
protected
static
final
String
SAX2_PROPERTIES_PREFIX
=
"http://xml.org/sax/properties/"
;
protected
static
final
String
SAX2_HANDLERS_PREFIX
=
"http://xml.org/sax/handlers/"
;
protected
static
final
String
XERCES_FEATURES_PREFIX
=
"http://apache.org/xml/features/"
;
protected
static
final
String
XERCES_PROPERTIES_PREFIX
=
"http://apache.org/xml/properties/"
;
private
static
final
String
RECOGNIZED_FEATURES
[
]
=
{
"http://xml.org/sax/features/validation"
,
"http://xml.org/sax/features/external-general-entities"
,
"http://xml.org/sax/features/external-parameter-entities"
,
"http://xml.org/sax/features/namespaces"
,
"http://apache.org/xml/features/validation/dynamic"
,
"http://apache.org/xml/features/validation/default-attribute-values"
,
"http://apache.org/xml/features/validation/validate-content-models"
,
"http://apache.org/xml/features/validation/validate-datatypes"
,
"http://apache.org/xml/features/validation/warn-on-duplicate-attdef"
,
"http://apache.org/xml/features/validation/warn-on-undeclared-elemdef"
,
"http://apache.org/xml/features/allow-java-encodings"
,
"http://apache.org/xml/features/continue-after-fatal-error"
,
}
;
private
static
final
String
RECOGNIZED_PROPERTIES
[
]
=
{
"http://xml.org/sax/properties/namespace-sep"
,
"http://xml.org/sax/properties/xml-string"
,
}
;
private
static
final
boolean
PRINT_EXCEPTION_STACK_TRACE
=
false
;
private
XMLAttrList
fAttrList
=
null
;
protected
boolean
fParseInProgress
=
false
;
private
boolean
fNeedReset
=
false
;
private
boolean
fContinueAfterFatalError
;
private
ErrorHandler
fErrorHandler
;
private
char
[
]
fCharRefData
=
null
;
private
int
[
]
fElementTypeStack
=
new
int
[
8
]
;
private
int
[
]
fElementEntityStack
=
new
int
[
8
]
;
private
boolean
fCalledStartDocument
=
false
;
private
int
fXMLLang
=
-
1
;
protected
String
fNamespaceSep
=
""
;
protected
XMLValidator
fValidator
=
null
;
protected
DTDValidator
fDTDValidator
=
null
;
protected
XSchemaValidator
fSchemaValidator
=
null
;
private
boolean
fCheckedForSchema
=
false
;
private
Locator
fLocator
=
null
;
private
Locale
fLocale
=
null
;
private
LocatorImpl
fAttrNameLocator
=
null
;
private
boolean
fSeenRootElement
=
false
;
private
boolean
fStandaloneDocument
=
false
;
private
int
fCDATASymbol
=
-
1
;
protected
boolean
fNamespacesEnabled
=
false
;
private
boolean
fSendCharDataAsCharArray
=
false
;
private
boolean
fValidating
=
false
;
private
boolean
fScanningDTD
=
false
;
private
StringPool
.
CharArrayRange
fCurrentElementCharArrayRange
=
null
;
private
static
XMLMessageProvider
fgXMLMessages
=
new
XMLMessages
(
)
;
private
static
XMLMessageProvider
fgImplementationMessages
=
new
ImplementationMessages
(
)
;
private
static
XMLMessageProvider
fgSchemaMessages
=
new
SchemaMessageProvider
(
)
;
private
static
XMLMessageProvider
fgDatatypeMessages
=
new
DatatypeMessageProvider
(
)
;
protected
XMLDocumentScanner
fScanner
=
null
;
protected
StringPool
fStringPool
=
null
;
protected
XMLErrorReporter
fErrorReporter
=
null
;
protected
XMLEntityHandler
fEntityHandler
=
null
;
protected
XMLEntityReaderFactory
fReaderFactory
=
null
;
protected
int
fElementDepth
=
0
;
protected
int
fCurrentElementType
=
-
1
;
protected
int
fCurrentElementEntity
=
-
1
;
protected
boolean
fInElementContent
=
false
;
protected
XMLParser
(
)
{
fStringPool
=
new
StringPool
(
)
;
fErrorReporter
=
this
;
fEntityHandler
=
this
;
fReaderFactory
=
new
XMLEntityReaderFactory
(
)
;
fScanner
=
new
XMLDocumentScanner
(
this
,
fStringPool
,
fErrorReporter
,
fEntityHandler
,
new
ChunkyCharArray
(
fStringPool
)
)
;
XMLCharacterProperties
.
initCharFlags
(
)
;
fAttrList
=
new
XMLAttrList
(
fStringPool
)
;
fLocator
=
this
;
XMLDeclRecognizer
.
registerDefaultRecognizers
(
fRecognizers
)
;
fCDATASymbol
=
fStringPool
.
addSymbol
(
"CDATA"
)
;
fDTDValidator
=
new
DTDValidator
(
this
,
fStringPool
,
fErrorReporter
,
fEntityHandler
)
;
try
{
setContinueAfterFatalError
(
false
)
;
}
catch
(
SAXException
e
)
{
}
}
public
String
[
]
getFeaturesRecognized
(
)
{
return
RECOGNIZED_FEATURES
;
}
public
boolean
isFeatureRecognized
(
String
featureId
)
{
String
[
]
recognizedFeatures
=
getFeaturesRecognized
(
)
;
for
(
int
i
=
0
;
i
<
recognizedFeatures
.
length
;
i
++
)
{
if
(
featureId
.
equals
(
recognizedFeatures
[
i
]
)
)
return
true
;
}
return
false
;
}
public
String
[
]
getPropertiesRecognized
(
)
{
return
RECOGNIZED_PROPERTIES
;
}
public
boolean
isPropertyRecognized
(
String
propertyId
)
{
String
[
]
recognizedProperties
=
getPropertiesRecognized
(
)
;
for
(
int
i
=
0
;
i
<
recognizedProperties
.
length
;
i
++
)
{
if
(
propertyId
.
equals
(
recognizedProperties
[
i
]
)
)
return
true
;
}
return
false
;
}
public
boolean
parseSomeSetup
(
InputSource
source
)
throws
Exception
{
if
(
fNeedReset
)
resetOrCopy
(
)
;
fParseInProgress
=
true
;
fNeedReset
=
true
;
return
fEntityHandler
.
startReadingFromDocument
(
source
)
;
}
public
boolean
parseSome
(
)
throws
Exception
{
if
(
!
fScanner
.
parseSome
(
false
)
)
{
fParseInProgress
=
false
;
return
false
;
}
return
true
;
}
public
void
reset
(
)
throws
Exception
{
fStringPool
.
reset
(
)
;
fAttrList
.
reset
(
fStringPool
)
;
resetCommon
(
)
;
}
public
void
setLocator
(
Locator
locator
)
{
fLocator
=
locator
;
}
public
final
Locator
getLocator
(
)
{
return
fLocator
;
}
public
void
processingInstructionInDTD
(
int
target
,
int
data
)
throws
Exception
{
fStringPool
.
releaseString
(
target
)
;
fStringPool
.
releaseString
(
data
)
;
}
public
void
commentInDTD
(
int
comment
)
throws
Exception
{
fStringPool
.
releaseString
(
comment
)
;
}
public
abstract
void
startDocument
(
int
version
,
int
encoding
,
int
standAlone
)
throws
Exception
;
public
abstract
void
endDocument
(
)
throws
Exception
;
public
abstract
void
startNamespaceDeclScope
(
int
prefix
,
int
uri
)
throws
Exception
;
public
abstract
void
endNamespaceDeclScope
(
int
prefix
)
throws
Exception
;
public
abstract
void
startElement
(
int
elementType
,
XMLAttrList
attrList
,
int
attrListHandle
)
throws
Exception
;
public
abstract
void
endElement
(
int
elementType
)
throws
Exception
;
public
abstract
void
startEntityReference
(
int
entityName
,
int
entityType
,
int
entityContext
)
throws
Exception
;
public
abstract
void
endEntityReference
(
int
entityName
,
int
entityType
,
int
entityContext
)
throws
Exception
;
public
abstract
void
startCDATA
(
)
throws
Exception
;
public
abstract
void
endCDATA
(
)
throws
Exception
;
public
abstract
void
processingInstruction
(
int
target
,
int
data
)
throws
Exception
;
public
abstract
void
comment
(
int
comment
)
throws
Exception
;
public
abstract
void
characters
(
int
data
)
throws
Exception
;
public
abstract
void
characters
(
char
ch
[
]
,
int
start
,
int
length
)
throws
Exception
;
public
abstract
void
ignorableWhitespace
(
int
data
)
throws
Exception
;
public
abstract
void
ignorableWhitespace
(
char
ch
[
]
,
int
start
,
int
length
)
throws
Exception
;
public
abstract
void
startDTD
(
int
rootElementType
,
int
publicId
,
int
systemId
)
throws
Exception
;
public
abstract
void
endDTD
(
)
throws
Exception
;
public
abstract
void
elementDecl
(
int
elementType
,
XMLValidator
.
ContentSpec
contentSpec
)
throws
Exception
;
public
abstract
void
attlistDecl
(
int
elementType
,
int
attrName
,
int
attType
,
String
enumString
,
int
attDefaultType
,
int
attDefaultValue
)
throws
Exception
;
public
abstract
void
internalPEDecl
(
int
entityName
,
int
entityValue
)
throws
Exception
;
public
abstract
void
externalPEDecl
(
int
entityName
,
int
publicId
,
int
systemId
)
throws
Exception
;
public
abstract
void
internalEntityDecl
(
int
entityName
,
int
entityValue
)
throws
Exception
;
public
abstract
void
externalEntityDecl
(
int
entityName
,
int
publicId
,
int
systemId
)
throws
Exception
;
public
abstract
void
unparsedEntityDecl
(
int
entityName
,
int
publicId
,
int
systemId
,
int
notationName
)
throws
Exception
;
public
abstract
void
notationDecl
(
int
notationName
,
int
publicId
,
int
systemId
)
throws
Exception
;
protected
void
setValidation
(
boolean
validate
)
throws
SAXException
{
try
{
fDTDValidator
.
setValidationEnabled
(
validate
)
;
getSchemaValidator
(
)
.
setValidationEnabled
(
validate
)
;
}
catch
(
Exception
ex
)
{
throw
new
SAXException
(
ex
)
;
}
}
protected
boolean
getValidation
(
)
throws
SAXException
{
return
fDTDValidator
.
getValidationEnabled
(
)
;
}
protected
void
setExternalGeneralEntities
(
boolean
expand
)
throws
SAXException
{
if
(
!
expand
)
{
throw
new
SAXNotSupportedException
(
"http://xml.org/sax/features/external-general-entities"
)
;
}
}
protected
boolean
getExternalGeneralEntities
(
)
throws
SAXException
{
return
true
;
}
protected
void
setExternalParameterEntities
(
boolean
expand
)
throws
SAXException
{
if
(
!
expand
)
{
throw
new
SAXNotSupportedException
(
"http://xml.org/sax/features/external-parameter-entities"
)
;
}
}
protected
boolean
getExternalParameterEntities
(
)
throws
SAXException
{
return
true
;
}
protected
void
setNamespaces
(
boolean
process
)
throws
SAXException
{
fNamespacesEnabled
=
process
;
fDTDValidator
.
setNamespacesEnabled
(
process
)
;
getSchemaValidator
(
)
.
setNamespacesEnabled
(
process
)
;
}
protected
boolean
getNamespaces
(
)
throws
SAXException
{
return
fNamespacesEnabled
;
}
protected
void
setValidationDynamic
(
boolean
dynamic
)
throws
SAXException
{
if
(
fParseInProgress
)
{
throw
new
SAXNotSupportedException
(
"http://apache.org/xml/features/validation/dynamic: parse is in progress"
)
;
}
try
{
fDTDValidator
.
setDynamicValidationEnabled
(
dynamic
)
;
getSchemaValidator
(
)
.
setDynamicValidationEnabled
(
dynamic
)
;
}
catch
(
Exception
ex
)
{
throw
new
SAXException
(
ex
)
;
}
}
protected
boolean
getValidationDynamic
(
)
throws
SAXException
{
return
fDTDValidator
.
getDynamicValidationEnabled
(
)
;
}
protected
void
setValidationWarnOnDuplicateAttdef
(
boolean
warn
)
throws
SAXException
{
fDTDValidator
.
setWarningOnDuplicateAttDef
(
warn
)
;
getSchemaValidator
(
)
.
setWarningOnDuplicateAttDef
(
warn
)
;
}
protected
boolean
getValidationWarnOnDuplicateAttdef
(
)
throws
SAXException
{
return
fDTDValidator
.
getWarningOnDuplicateAttDef
(
)
;
}
protected
void
setValidationWarnOnUndeclaredElemdef
(
boolean
warn
)
throws
SAXException
{
fDTDValidator
.
setWarningOnUndeclaredElements
(
warn
)
;
getSchemaValidator
(
)
.
setWarningOnUndeclaredElements
(
warn
)
;
}
protected
boolean
getValidationWarnOnUndeclaredElemdef
(
)
throws
SAXException
{
return
fDTDValidator
.
getWarningOnUndeclaredElements
(
)
;
}
protected
void
setAllowJavaEncodings
(
boolean
allow
)
throws
SAXException
{
setAllowJavaEncodingName
(
allow
)
;
}
protected
boolean
getAllowJavaEncodings
(
)
throws
SAXException
{
return
getAllowJavaEncodingName
(
)
;
}
protected
void
setContinueAfterFatalError
(
boolean
continueAfterFatalError
)
throws
SAXException
{
fContinueAfterFatalError
=
continueAfterFatalError
;
}
protected
boolean
getContinueAfterFatalError
(
)
throws
SAXException
{
return
fContinueAfterFatalError
;
}
protected
void
setNamespaceSep
(
String
separator
)
throws
SAXException
{
if
(
fParseInProgress
)
{
throw
new
SAXNotSupportedException
(
"http://xml.org/sax/properties/namespace-sep: parse is in progress"
)
;
}
fNamespaceSep
=
separator
;
}
protected
String
getNamespaceSep
(
)
throws
SAXException
{
return
fNamespaceSep
;
}
protected
String
getXMLString
(
)
throws
SAXException
{
throw
new
SAXNotSupportedException
(
"http://xml.org/sax/properties/xml-string"
)
;
}
protected
void
resetOrCopy
(
)
throws
Exception
{
fStringPool
=
new
StringPool
(
)
;
fAttrList
=
new
XMLAttrList
(
fStringPool
)
;
resetCommon
(
)
;
}
private
void
resetCommon
(
)
throws
Exception
{
fScanner
.
reset
(
fStringPool
,
new
ChunkyCharArray
(
fStringPool
)
)
;
fValidating
=
false
;
fScanningDTD
=
false
;
resetEntityHandler
(
)
;
fValidator
=
null
;
fDTDValidator
.
reset
(
fStringPool
)
;
if
(
fSchemaValidator
!=
null
)
fSchemaValidator
.
reset
(
fStringPool
,
fErrorReporter
,
fEntityHandler
)
;
fCheckedForSchema
=
false
;
fNeedReset
=
false
;
fCalledStartDocument
=
false
;
fSeenRootElement
=
false
;
fStandaloneDocument
=
false
;
fCDATASymbol
=
fStringPool
.
addSymbol
(
"CDATA"
)
;
fXMLLang
=
-
1
;
fElementDepth
=
0
;
fCurrentElementType
=
-
1
;
fCurrentElementEntity
=
-
1
;
fInElementContent
=
false
;
}
protected
XSchemaValidator
getSchemaValidator
(
)
{
if
(
fSchemaValidator
==
null
)
fSchemaValidator
=
new
XSchemaValidator
(
fStringPool
,
fErrorReporter
,
fEntityHandler
)
;
return
fSchemaValidator
;
}
protected
void
setSendCharDataAsCharArray
(
boolean
flag
)
{
fSendCharDataAsCharArray
=
flag
;
}
public
void
setErrorHandler
(
ErrorHandler
handler
)
{
fErrorHandler
=
handler
;
}
public
void
parse
(
InputSource
source
)
throws
SAXException
,
IOException
{
if
(
fParseInProgress
)
{
throw
new
org
.
xml
.
sax
.
SAXException
(
"parse may not be called while parsing"
)
;
}
try
{
if
(
parseSomeSetup
(
source
)
)
{
fScanner
.
parseSome
(
true
)
;
}
fParseInProgress
=
false
;
}
catch
(
org
.
xml
.
sax
.
SAXException
ex
)
{
fParseInProgress
=
false
;
if
(
PRINT_EXCEPTION_STACK_TRACE
)
ex
.
printStackTrace
(
)
;
throw
ex
;
}
catch
(
IOException
ex
)
{
fParseInProgress
=
false
;
if
(
PRINT_EXCEPTION_STACK_TRACE
)
ex
.
printStackTrace
(
)
;
throw
ex
;
}
catch
(
Exception
ex
)
{
fParseInProgress
=
false
;
if
(
PRINT_EXCEPTION_STACK_TRACE
)
ex
.
printStackTrace
(
)
;
throw
new
org
.
xml
.
sax
.
SAXException
(
ex
)
;
}
}
public
void
parse
(
String
systemId
)
throws
SAXException
,
IOException
{
InputSource
source
=
new
InputSource
(
systemId
)
;
parse
(
source
)
;
try
{
Reader
reader
=
source
.
getCharacterStream
(
)
;
if
(
reader
!=
null
)
{
reader
.
close
(
)
;
}
else
{
InputStream
is
=
source
.
getByteStream
(
)
;
if
(
is
!=
null
)
{
is
.
close
(
)
;
}
}
}
catch
(
IOException
e
)
{
}
}
public
void
setLocale
(
Locale
locale
)
throws
SAXException
{
if
(
fParseInProgress
)
{
throw
new
org
.
xml
.
sax
.
SAXException
(
"setLocale may not be called while parsing"
)
;
}
fLocale
=
locale
;
fgXMLMessages
.
setLocale
(
locale
)
;
fgImplementationMessages
.
setLocale
(
locale
)
;
}
public
void
reportError
(
Locator
locator
,
String
errorDomain
,
int
majorCode
,
int
minorCode
,
Object
args
[
]
,
int
errorType
)
throws
Exception
{
SAXParseException
spe
;
if
(
errorDomain
.
equals
(
XMLMessages
.
XML_DOMAIN
)
)
{
spe
=
new
SAXParseException
(
fgXMLMessages
.
createMessage
(
fLocale
,
majorCode
,
minorCode
,
args
)
,
locator
)
;
}
else
if
(
errorDomain
.
equals
(
XMLMessages
.
XMLNS_DOMAIN
)
)
{
spe
=
new
SAXParseException
(
fgXMLMessages
.
createMessage
(
fLocale
,
majorCode
,
minorCode
,
args
)
,
locator
)
;
}
else
if
(
errorDomain
.
equals
(
ImplementationMessages
.
XERCES_IMPLEMENTATION_DOMAIN
)
)
{
spe
=
new
SAXParseException
(
fgImplementationMessages
.
createMessage
(
fLocale
,
majorCode
,
minorCode
,
args
)
,
locator
)
;
}
else
if
(
errorDomain
.
equals
(
SchemaMessageProvider
.
SCHEMA_DOMAIN
)
)
{
spe
=
new
SAXParseException
(
fgSchemaMessages
.
createMessage
(
fLocale
,
majorCode
,
minorCode
,
args
)
,
locator
)
;
}
else
if
(
errorDomain
.
equals
(
DatatypeMessageProvider
.
DATATYPE_DOMAIN
)
)
{
spe
=
new
SAXParseException
(
fgDatatypeMessages
.
createMessage
(
fLocale
,
majorCode
,
minorCode
,
args
)
,
locator
)
;
}
else
{
throw
new
RuntimeException
(
"Unknown error domain \""
+
errorDomain
+
"\"."
)
;
}
if
(
fErrorHandler
==
null
)
{
if
(
errorType
==
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
&&
!
fContinueAfterFatalError
)
{
throw
spe
;
}
return
;
}
if
(
errorType
==
XMLErrorReporter
.
ERRORTYPE_WARNING
)
{
fErrorHandler
.
warning
(
spe
)
;
}
else
if
(
errorType
==
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
{
fErrorHandler
.
fatalError
(
spe
)
;
if
(
!
fContinueAfterFatalError
)
{
Object
[
]
fatalArgs
=
{
spe
.
getMessage
(
)
}
;
throw
new
SAXException
(
fgImplementationMessages
.
createMessage
(
fLocale
,
ImplementationMessages
.
FATAL_ERROR
,
0
,
fatalArgs
)
)
;
}
}
else
{
fErrorHandler
.
error
(
spe
)
;
}
}
public
void
setFeature
(
String
featureId
,
boolean
state
)
throws
SAXException
{
if
(
featureId
.
startsWith
(
SAX2_FEATURES_PREFIX
)
)
{
String
feature
=
featureId
.
substring
(
SAX2_FEATURES_PREFIX
.
length
(
)
)
;
if
(
feature
.
equals
(
"validation"
)
)
{
setValidation
(
state
)
;
return
;
}
if
(
feature
.
equals
(
"external-general-entities"
)
)
{
setExternalGeneralEntities
(
state
)
;
return
;
}
if
(
feature
.
equals
(
"external-parameter-entities"
)
)
{
setExternalParameterEntities
(
state
)
;
return
;
}
if
(
feature
.
equals
(
"namespaces"
)
)
{
setNamespaces
(
state
)
;
return
;
}
}
else
if
(
featureId
.
startsWith
(
XERCES_FEATURES_PREFIX
)
)
{
String
feature
=
featureId
.
substring
(
XERCES_FEATURES_PREFIX
.
length
(
)
)
;
if
(
feature
.
equals
(
"validation/dynamic"
)
)
{
setValidationDynamic
(
state
)
;
return
;
}
if
(
feature
.
equals
(
"validation/default-attribute-values"
)
)
{
throw
new
SAXNotSupportedException
(
featureId
)
;
}
if
(
feature
.
equals
(
"validation/validate-content-models"
)
)
{
throw
new
SAXNotSupportedException
(
featureId
)
;
}
if
(
feature
.
equals
(
"validation/validate-datatypes"
)
)
{
throw
new
SAXNotSupportedException
(
featureId
)
;
}
if
(
feature
.
equals
(
"validation/warn-on-duplicate-attdef"
)
)
{
setValidationWarnOnDuplicateAttdef
(
state
)
;
return
;
}
if
(
feature
.
equals
(
"validation/warn-on-undeclared-elemdef"
)
)
{
setValidationWarnOnUndeclaredElemdef
(
state
)
;
return
;
}
if
(
feature
.
equals
(
"allow-java-encodings"
)
)
{
setAllowJavaEncodings
(
state
)
;
return
;
}
if
(
feature
.
equals
(
"continue-after-fatal-error"
)
)
{
setContinueAfterFatalError
(
state
)
;
return
;
}
}
throw
new
SAXNotRecognizedException
(
featureId
)
;
}
public
boolean
getFeature
(
String
featureId
)
throws
SAXException
{
if
(
featureId
.
startsWith
(
SAX2_FEATURES_PREFIX
)
)
{
String
feature
=
featureId
.
substring
(
SAX2_FEATURES_PREFIX
.
length
(
)
)
;
if
(
feature
.
equals
(
"validation"
)
)
{
return
getValidation
(
)
;
}
if
(
feature
.
equals
(
"external-general-entities"
)
)
{
return
getExternalGeneralEntities
(
)
;
}
if
(
feature
.
equals
(
"external-parameter-entities"
)
)
{
return
getExternalParameterEntities
(
)
;
}
if
(
feature
.
equals
(
"namespaces"
)
)
{
return
getNamespaces
(
)
;
}
}
else
if
(
featureId
.
startsWith
(
XERCES_FEATURES_PREFIX
)
)
{
String
feature
=
featureId
.
substring
(
XERCES_FEATURES_PREFIX
.
length
(
)
)
;
if
(
feature
.
equals
(
"validation/dynamic"
)
)
{
return
getValidationDynamic
(
)
;
}
if
(
feature
.
equals
(
"validation/default-attribute-values"
)
)
{
throw
new
SAXNotRecognizedException
(
featureId
)
;
}
if
(
feature
.
equals
(
"validation/validate-content-models"
)
)
{
throw
new
SAXNotRecognizedException
(
featureId
)
;
}
if
(
feature
.
equals
(
"validation/validate-datatypes"
)
)
{
throw
new
SAXNotRecognizedException
(
featureId
)
;
}
if
(
feature
.
equals
(
"validation/warn-on-duplicate-attdef"
)
)
{
return
getValidationWarnOnDuplicateAttdef
(
)
;
}
if
(
feature
.
equals
(
"validation/warn-on-undeclared-elemdef"
)
)
{
return
getValidationWarnOnUndeclaredElemdef
(
)
;
}
if
(
feature
.
equals
(
"allow-java-encodings"
)
)
{
return
getAllowJavaEncodings
(
)
;
}
if
(
feature
.
equals
(
"continue-after-fatal-error"
)
)
{
return
getContinueAfterFatalError
(
)
;
}
}
throw
new
SAXNotRecognizedException
(
featureId
)
;
}
public
void
setProperty
(
String
propertyId
,
Object
value
)
throws
SAXException
{
if
(
propertyId
.
startsWith
(
SAX2_PROPERTIES_PREFIX
)
)
{
String
property
=
propertyId
.
substring
(
SAX2_PROPERTIES_PREFIX
.
length
(
)
)
;
if
(
property
.
equals
(
"namespace-sep"
)
)
{
try
{
setNamespaceSep
(
(
String
)
value
)
;
}
catch
(
ClassCastException
e
)
{
throw
new
SAXNotSupportedException
(
propertyId
)
;
}
return
;
}
if
(
property
.
equals
(
"xml-string"
)
)
{
throw
new
SAXNotSupportedException
(
propertyId
)
;
}
}
throw
new
SAXNotRecognizedException
(
propertyId
)
;
}
public
Object
getProperty
(
String
propertyId
)
throws
SAXException
{
if
(
propertyId
.
startsWith
(
SAX2_PROPERTIES_PREFIX
)
)
{
String
property
=
propertyId
.
substring
(
SAX2_PROPERTIES_PREFIX
.
length
(
)
)
;
if
(
property
.
equals
(
"namespace-sep"
)
)
{
return
getNamespaceSep
(
)
;
}
if
(
property
.
equals
(
"xml-string"
)
)
{
return
getXMLString
(
)
;
}
}
throw
new
SAXNotRecognizedException
(
propertyId
)
;
}
public
boolean
validVersionNum
(
String
version
)
{
return
XMLCharacterProperties
.
validVersionNum
(
version
)
;
}
public
boolean
validEncName
(
String
encoding
)
{
return
XMLCharacterProperties
.
validEncName
(
encoding
)
;
}
public
void
callStartDocument
(
int
version
,
int
encoding
,
int
standalone
)
throws
Exception
{
if
(
!
fCalledStartDocument
)
{
startDocument
(
version
,
encoding
,
standalone
)
;
fCalledStartDocument
=
true
;
}
}
public
void
callEndDocument
(
)
throws
Exception
{
if
(
fCalledStartDocument
)
endDocument
(
)
;
}
public
void
callStartElement
(
int
elementType
)
throws
Exception
{
if
(
!
fSeenRootElement
)
{
fSeenRootElement
=
true
;
if
(
fValidator
==
null
)
{
fValidator
=
fDTDValidator
;
}
fValidator
.
rootElementSpecified
(
elementType
)
;
fStringPool
.
resetShuffleCount
(
)
;
}
fInElementContent
=
fValidator
.
startElement
(
elementType
,
fAttrList
)
;
int
attrListHandle
=
fAttrList
.
attrListHandle
(
)
;
if
(
attrListHandle
!=
-
1
)
{
fAttrList
.
endAttrList
(
)
;
if
(
fXMLLang
==
-
1
)
fXMLLang
=
fStringPool
.
addSymbol
(
"xml:lang"
)
;
int
index
=
fAttrList
.
getFirstAttr
(
attrListHandle
)
;
while
(
index
!=
-
1
)
{
if
(
fStringPool
.
equalNames
(
fAttrList
.
getAttrName
(
index
)
,
fXMLLang
)
)
{
fScanner
.
checkXMLLangAttributeValue
(
fAttrList
.
getAttValue
(
index
)
)
;
break
;
}
index
=
fAttrList
.
getNextAttr
(
index
)
;
}
}
startElement
(
elementType
,
fAttrList
,
attrListHandle
)
;
int
elementEntity
=
fEntityHandler
.
getReaderId
(
)
;
if
(
fElementDepth
==
fElementTypeStack
.
length
)
{
int
[
]
newStack
=
new
int
[
fElementDepth
*
2
]
;
System
.
arraycopy
(
fElementTypeStack
,
0
,
newStack
,
0
,
fElementDepth
)
;
fElementTypeStack
=
newStack
;
newStack
=
new
int
[
fElementDepth
*
2
]
;
System
.
arraycopy
(
fElementEntityStack
,
0
,
newStack
,
0
,
fElementDepth
)
;
fElementEntityStack
=
newStack
;
}
fCurrentElementType
=
elementType
;
fCurrentElementEntity
=
elementEntity
;
fElementTypeStack
[
fElementDepth
]
=
elementType
;
fElementEntityStack
[
fElementDepth
]
=
elementEntity
;
fElementDepth
++
;
}
public
boolean
callEndElement
(
int
readerId
)
throws
Exception
{
int
elementType
=
fCurrentElementType
;
if
(
fCurrentElementEntity
!=
readerId
)
{
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_ELEMENT_ENTITY_MISMATCH
,
XMLMessages
.
P78_NOT_WELLFORMED
,
new
Object
[
]
{
fStringPool
.
toString
(
elementType
)
}
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
endElement
(
elementType
)
;
fInElementContent
=
fValidator
.
endElement
(
elementType
)
;
if
(
fElementDepth
--
==
0
)
{
throw
new
RuntimeException
(
"Element stack underflow"
)
;
}
if
(
fElementDepth
==
0
)
{
fCurrentElementType
=
-
1
;
fCurrentElementEntity
=
-
1
;
return
true
;
}
fCurrentElementType
=
fElementTypeStack
[
fElementDepth
-
1
]
;
fCurrentElementEntity
=
fElementEntityStack
[
fElementDepth
-
1
]
;
return
false
;
}
public
void
callProcessingInstruction
(
int
target
,
int
data
)
throws
Exception
{
processingInstruction
(
target
,
data
)
;
}
public
void
callComment
(
int
comment
)
throws
Exception
{
comment
(
comment
)
;
}
public
void
callCharacters
(
int
ch
)
throws
Exception
{
if
(
fCharRefData
==
null
)
fCharRefData
=
new
char
[
2
]
;
int
count
=
(
ch
<
0x10000
)
?
1
:
2
;
if
(
count
==
1
)
fCharRefData
[
0
]
=
(
char
)
ch
;
else
{
fCharRefData
[
0
]
=
(
char
)
(
(
(
ch
-
0x00010000
)
>
>
10
)
+
0xd800
)
;
fCharRefData
[
1
]
=
(
char
)
(
(
(
ch
-
0x00010000
)
&
0x3ff
)
+
0xdc00
)
;
}
if
(
!
fInElementContent
)
fValidator
.
characters
(
fCharRefData
,
0
,
count
)
;
characters
(
fCharRefData
,
0
,
count
)
;
}
public
int
scanAttValue
(
int
elementType
,
int
attrName
)
throws
Exception
{
fAttrNameLocator
=
getLocatorImpl
(
fAttrNameLocator
)
;
int
attValue
=
fScanner
.
scanAttValue
(
elementType
,
attrName
,
fValidating
)
;
if
(
attValue
==
-
1
)
{
return
XMLDocumentScanner
.
RESULT_FAILURE
;
}
if
(
!
fCheckedForSchema
)
{
fCheckedForSchema
=
true
;
if
(
attrName
==
fStringPool
.
addSymbol
(
"xmlns"
)
)
{
fValidator
=
getSchemaValidator
(
)
;
fSchemaValidator
.
loadSchema
(
fStringPool
.
toString
(
attValue
)
)
;
}
}
if
(
!
fValidator
.
attributeSpecified
(
elementType
,
fAttrList
,
attrName
,
fAttrNameLocator
,
attValue
)
)
{
return
XMLDocumentScanner
.
RESULT_DUPLICATE_ATTR
;
}
return
XMLDocumentScanner
.
RESULT_SUCCESS
;
}
public
int
scanElementType
(
XMLEntityHandler
.
EntityReader
entityReader
,
char
fastchar
)
throws
Exception
{
if
(
!
fNamespacesEnabled
)
{
return
entityReader
.
scanName
(
fastchar
)
;
}
int
elementType
=
entityReader
.
scanQName
(
fastchar
)
;
if
(
fNamespacesEnabled
&&
entityReader
.
lookingAtChar
(
':'
,
false
)
)
{
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_TWO_COLONS_IN_QNAME
,
XMLMessages
.
P5_INVALID_CHARACTER
,
null
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
entityReader
.
skipPastNmtoken
(
' '
)
;
}
return
elementType
;
}
public
boolean
scanExpectedElementType
(
XMLEntityHandler
.
EntityReader
entityReader
,
char
fastchar
)
throws
Exception
{
if
(
fCurrentElementCharArrayRange
==
null
)
fCurrentElementCharArrayRange
=
fStringPool
.
createCharArrayRange
(
)
;
fStringPool
.
getCharArrayRange
(
fCurrentElementType
,
fCurrentElementCharArrayRange
)
;
return
entityReader
.
scanExpectedName
(
fastchar
,
fCurrentElementCharArrayRange
)
;
}
public
int
scanAttributeName
(
XMLEntityHandler
.
EntityReader
entityReader
,
int
elementType
)
throws
Exception
{
if
(
!
fSeenRootElement
)
{
fSeenRootElement
=
true
;
if
(
fValidator
==
null
)
{
fValidator
=
fDTDValidator
;
}
fValidator
.
rootElementSpecified
(
elementType
)
;
fStringPool
.
resetShuffleCount
(
)
;
}
if
(
!
fNamespacesEnabled
)
{
return
entityReader
.
scanName
(
'='
)
;
}
int
attrName
=
entityReader
.
scanQName
(
'='
)
;
if
(
entityReader
.
lookingAtChar
(
':'
,
false
)
)
{
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_TWO_COLONS_IN_QNAME
,
XMLMessages
.
P5_INVALID_CHARACTER
,
null
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
entityReader
.
skipPastNmtoken
(
' '
)
;
}
return
attrName
;
}
public
void
scanDoctypeDecl
(
boolean
standalone
)
throws
Exception
{
fScanningDTD
=
true
;
fCheckedForSchema
=
true
;
fStandaloneDocument
=
standalone
;
fValidator
=
fDTDValidator
;
fDTDValidator
.
scanDoctypeDecl
(
standalone
)
;
fScanningDTD
=
false
;
}
public
void
setValidating
(
boolean
flag
)
throws
Exception
{
fValidating
=
flag
;
}
private
LocatorImpl
getLocatorImpl
(
LocatorImpl
fillin
)
{
if
(
fillin
==
null
)
return
new
LocatorImpl
(
this
)
;
fillin
.
setPublicId
(
getPublicId
(
)
)
;
fillin
.
setSystemId
(
getSystemId
(
)
)
;
fillin
.
setLineNumber
(
getLineNumber
(
)
)
;
fillin
.
setColumnNumber
(
getColumnNumber
(
)
)
;
return
fillin
;
}
public
void
processCharacters
(
char
[
]
chars
,
int
offset
,
int
length
)
throws
Exception
{
if
(
fValidating
&&
!
fInElementContent
)
fValidator
.
characters
(
chars
,
offset
,
length
)
;
characters
(
chars
,
offset
,
length
)
;
}
public
void
processCharacters
(
int
data
)
throws
Exception
{
if
(
fValidating
&&
!
fInElementContent
)
fValidator
.
characters
(
data
)
;
characters
(
data
)
;
}
public
void
processWhitespace
(
char
[
]
chars
,
int
offset
,
int
length
)
throws
Exception
{
if
(
fInElementContent
)
{
if
(
fStandaloneDocument
&&
fValidating
)
fValidator
.
ignorableWhitespace
(
chars
,
offset
,
length
)
;
ignorableWhitespace
(
chars
,
offset
,
length
)
;
}
else
{
if
(
fValidating
&&
!
fInElementContent
)
fValidator
.
characters
(
chars
,
offset
,
length
)
;
characters
(
chars
,
offset
,
length
)
;
}
}
public
void
processWhitespace
(
int
data
)
throws
Exception
{
if
(
fInElementContent
)
{
if
(
fStandaloneDocument
&&
fValidating
)
fValidator
.
ignorableWhitespace
(
data
)
;
ignorableWhitespace
(
data
)
;
}
else
{
if
(
fValidating
&&
!
fInElementContent
)
fValidator
.
characters
(
data
)
;
characters
(
data
)
;
}
}
private
class
ReaderState
{
XMLEntityHandler
.
EntityReader
reader
;
InputSource
source
;
int
entityName
;
int
entityType
;
int
entityContext
;
String
publicId
;
String
systemId
;
int
readerId
;
int
depth
;
ReaderState
nextReaderState
;
}
private
ReaderState
fReaderStateFreeList
=
null
;
private
boolean
fAllowJavaEncodingName
=
false
;
private
Stack
fRecognizers
=
new
Stack
(
)
;
private
EntityResolver
fResolver
=
null
;
private
byte
[
]
fEntityTypeStack
=
null
;
private
int
[
]
fEntityNameStack
=
null
;
private
int
fEntityStackDepth
=
0
;
private
Stack
fReaderStack
=
new
Stack
(
)
;
private
XMLEntityHandler
.
EntityReader
fReader
=
null
;
private
InputSource
fSource
=
null
;
private
int
fEntityName
=
-
1
;
private
int
fEntityType
=
-
1
;
private
int
fEntityContext
=
-
1
;
private
String
fPublicId
=
null
;
private
String
fSystemId
=
null
;
private
int
fReaderId
=
-
1
;
private
int
fReaderDepth
=
-
1
;
private
int
fNextReaderId
=
0
;
private
NullReader
fNullReader
=
null
;
private
void
resetEntityHandler
(
)
{
fReaderStack
.
removeAllElements
(
)
;
fEntityStackDepth
=
0
;
fReader
=
null
;
fSource
=
null
;
fEntityName
=
-
1
;
fEntityType
=
-
1
;
fEntityContext
=
-
1
;
fPublicId
=
null
;
fSystemId
=
null
;
fReaderId
=
-
1
;
fReaderDepth
=
-
1
;
fNextReaderId
=
0
;
}
private
void
setAllowJavaEncodingName
(
boolean
flag
)
{
fAllowJavaEncodingName
=
flag
;
}
private
boolean
getAllowJavaEncodingName
(
)
{
return
fAllowJavaEncodingName
;
}
public
XMLEntityHandler
.
EntityReader
getEntityReader
(
)
{
return
fReader
;
}
public
void
addRecognizer
(
XMLDeclRecognizer
recognizer
)
{
fRecognizers
.
push
(
recognizer
)
;
}
public
void
setEntityResolver
(
EntityResolver
resolver
)
{
fResolver
=
resolver
;
}
public
String
expandSystemId
(
String
systemId
)
{
return
expandSystemId
(
systemId
,
fSystemId
)
;
}
private
String
expandSystemId
(
String
systemId
,
String
currentSystemId
)
{
String
id
=
systemId
;
if
(
id
==
null
||
id
.
length
(
)
==
0
)
{
return
systemId
;
}
try
{
URL
url
=
new
URL
(
id
)
;
if
(
url
!=
null
)
{
return
systemId
;
}
}
catch
(
MalformedURLException
e
)
{
}
id
=
fixURI
(
id
)
;
URL
base
=
null
;
URL
url
=
null
;
try
{
if
(
currentSystemId
==
null
)
{
String
dir
;
try
{
dir
=
fixURI
(
System
.
getProperty
(
"user.dir"
)
)
;
}
catch
(
SecurityException
se
)
{
dir
=
""
;
}
if
(
!
dir
.
endsWith
(
"/"
)
)
{
dir
=
dir
+
"/"
;
}
base
=
new
URL
(
"file"
,
""
,
dir
)
;
}
else
{
base
=
new
URL
(
currentSystemId
)
;
}
url
=
new
URL
(
base
,
id
)
;
}
catch
(
Exception
e
)
{
}
if
(
url
==
null
)
{
return
systemId
;
}
return
url
.
toString
(
)
;
}
private
XMLEntityHandler
.
EntityReader
callRecognizers
(
InputSource
source
,
ChunkyByteArray
data
,
boolean
xmlDecl
)
throws
Exception
{
for
(
int
i
=
fRecognizers
.
size
(
)
-
1
;
i
>=
0
;
i
--
)
{
XMLDeclRecognizer
recognizer
=
(
XMLDeclRecognizer
)
fRecognizers
.
elementAt
(
i
)
;
XMLEntityHandler
.
EntityReader
reader
=
recognizer
.
recognize
(
fReaderFactory
,
this
,
fErrorReporter
,
fSendCharDataAsCharArray
,
fStringPool
,
data
,
xmlDecl
,
fAllowJavaEncodingName
)
;
if
(
reader
!=
null
)
{
return
reader
;
}
}
return
null
;
}
private
static
String
fixURI
(
String
str
)
{
str
=
str
.
replace
(
java
.
io
.
File
.
separatorChar
,
'/'
)
;
if
(
str
.
length
(
)
>=
2
)
{
char
ch1
=
str
.
charAt
(
1
)
;
if
(
ch1
==
':'
)
{
char
ch0
=
Character
.
toUpperCase
(
str
.
charAt
(
0
)
)
;
if
(
ch0
>=
'A'
&&
ch0
<=
'Z'
)
{
str
=
"/"
+
str
;
}
}
}
return
str
;
}
private
void
sendEndOfInputNotifications
(
)
throws
Exception
{
boolean
moreToFollow
=
fReaderStack
.
size
(
)
>
1
;
fScanner
.
endOfInput
(
fEntityName
,
moreToFollow
)
;
if
(
fScanningDTD
)
fDTDValidator
.
endOfInput
(
fEntityName
,
moreToFollow
)
;
}
private
void
sendReaderChangeNotifications
(
)
throws
Exception
{
fScanner
.
readerChange
(
fReader
,
fReaderId
)
;
if
(
fScanningDTD
)
fDTDValidator
.
readerChange
(
fReader
,
fReaderId
)
;
}
private
void
sendStartEntityNotifications
(
)
throws
Exception
{
startEntityReference
(
fEntityName
,
fEntityType
,
fEntityContext
)
;
}
private
void
sendEndEntityNotifications
(
)
throws
Exception
{
endEntityReference
(
fEntityName
,
fEntityType
,
fEntityContext
)
;
}
public
boolean
startReadingFromDocument
(
InputSource
source
)
throws
Exception
{
pushEntity
(
false
,
-
2
)
;
fSystemId
=
null
;
pushNullReader
(
)
;
fEntityName
=
-
2
;
fEntityType
=
ENTITYTYPE_DOCUMENT
;
fEntityContext
=
CONTEXT_DOCUMENT
;
fReaderDepth
=
0
;
fReaderId
=
fNextReaderId
++
;
fPublicId
=
source
.
getPublicId
(
)
;
fSystemId
=
source
.
getSystemId
(
)
;
sendStartEntityNotifications
(
)
;
fSystemId
=
expandSystemId
(
fSystemId
,
null
)
;
fSource
=
source
;
boolean
xmlDecl
=
true
;
try
{
createReader
(
xmlDecl
)
;
}
catch
(
java
.
io
.
UnsupportedEncodingException
uee
)
{
String
encoding
=
uee
.
getMessage
(
)
;
if
(
encoding
==
null
)
{
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_ENCODING_REQUIRED
,
XMLMessages
.
P81_REQUIRED
,
null
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
else
if
(
!
XMLCharacterProperties
.
validEncName
(
encoding
)
)
{
Object
[
]
args
=
{
encoding
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_ENCODINGDECL_INVALID
,
XMLMessages
.
P81_INVALID_VALUE
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
else
{
Object
[
]
args
=
{
encoding
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_ENCODING_NOT_SUPPORTED
,
XMLMessages
.
P81_NOT_SUPPORTED
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
fReader
=
null
;
sendReaderChangeNotifications
(
)
;
return
false
;
}
sendReaderChangeNotifications
(
)
;
return
true
;
}
public
void
startReadingFromExternalSubset
(
String
publicId
,
String
systemId
,
int
readerDepth
)
throws
Exception
{
pushEntity
(
true
,
-
1
)
;
pushReader
(
)
;
pushNullReader
(
)
;
fEntityName
=
-
1
;
fEntityType
=
ENTITYTYPE_EXTERNAL_SUBSET
;
fEntityContext
=
CONTEXT_EXTERNAL_SUBSET
;
fReaderDepth
=
readerDepth
;
fReaderId
=
fNextReaderId
++
;
fPublicId
=
publicId
;
fSystemId
=
systemId
;
startReadingFromExternalEntity
(
false
)
;
}
public
void
stopReadingFromExternalSubset
(
)
throws
Exception
{
if
(
!
(
fReader
instanceof
NullReader
)
)
throw
new
RuntimeException
(
"cannot happen 18"
)
;
popReader
(
)
;
sendReaderChangeNotifications
(
)
;
}
public
boolean
startReadingFromEntity
(
int
entityName
,
int
readerDepth
,
int
context
)
throws
Exception
{
if
(
context
>
XMLEntityHandler
.
CONTEXT_IN_CONTENT
)
return
startReadingFromParameterEntity
(
entityName
,
readerDepth
,
context
)
;
int
entityHandle
=
fValidator
.
lookupEntity
(
entityName
)
;
if
(
entityHandle
<
0
)
{
int
minorCode
=
XMLMessages
.
VC_ENTITY_DECLARED
;
int
errorType
=
XMLErrorReporter
.
ERRORTYPE_RECOVERABLE_ERROR
;
if
(
fEntityContext
==
CONTEXT_DOCUMENT
||
fEntityContext
==
CONTEXT_IN_ATTVALUE
)
{
minorCode
=
XMLMessages
.
WFC_ENTITY_DECLARED
;
errorType
=
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
;
}
Object
[
]
args
=
{
fStringPool
.
toString
(
entityName
)
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_ENTITY_NOT_DECLARED
,
minorCode
,
args
,
errorType
)
;
return
false
;
}
if
(
context
==
CONTEXT_IN_CONTENT
)
{
if
(
fValidator
.
isUnparsedEntity
(
entityHandle
)
)
{
Object
[
]
args
=
{
fStringPool
.
toString
(
entityName
)
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_REFERENCE_TO_UNPARSED_ENTITY
,
XMLMessages
.
WFC_PARSED_ENTITY
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
return
false
;
}
}
else
{
if
(
fValidator
.
isExternalEntity
(
entityHandle
)
)
{
Object
[
]
args
=
{
fStringPool
.
toString
(
entityName
)
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_REFERENCE_TO_EXTERNAL_ENTITY
,
XMLMessages
.
WFC_NO_EXTERNAL_ENTITY_REFERENCES
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
return
false
;
}
}
if
(
!
pushEntity
(
false
,
entityName
)
)
{
Object
[
]
args
=
{
fStringPool
.
toString
(
entityName
)
,
entityReferencePath
(
false
,
entityName
)
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_RECURSIVE_REFERENCE
,
XMLMessages
.
WFC_NO_RECURSION
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
return
false
;
}
pushReader
(
)
;
fEntityName
=
entityName
;
fEntityContext
=
context
;
fReaderDepth
=
readerDepth
;
fReaderId
=
fNextReaderId
++
;
if
(
context
!=
CONTEXT_IN_CONTENT
||
!
fValidator
.
externalReferenceInContent
(
entityHandle
)
)
{
fEntityType
=
ENTITYTYPE_INTERNAL
;
fPublicId
=
null
;
fSystemId
=
fSystemId
;
int
value
=
-
1
;
if
(
context
==
CONTEXT_IN_CONTENT
||
context
==
CONTEXT_IN_DEFAULTATTVALUE
)
value
=
fValidator
.
getEntityValue
(
entityHandle
)
;
else
value
=
fValidator
.
valueOfReferenceInAttValue
(
entityHandle
)
;
startReadingFromInternalEntity
(
value
,
false
)
;
return
false
;
}
fEntityType
=
ENTITYTYPE_EXTERNAL
;
fPublicId
=
fValidator
.
getPublicIdOfEntity
(
entityHandle
)
;
fSystemId
=
fValidator
.
getSystemIdOfEntity
(
entityHandle
)
;
return
startReadingFromExternalEntity
(
true
)
;
}
private
boolean
startReadingFromParameterEntity
(
int
peName
,
int
readerDepth
,
int
context
)
throws
Exception
{
int
entityHandle
=
fValidator
.
lookupParameterEntity
(
peName
)
;
if
(
entityHandle
==
-
1
)
{
return
false
;
}
if
(
!
pushEntity
(
true
,
peName
)
)
{
Object
[
]
args
=
{
fStringPool
.
toString
(
peName
)
,
entityReferencePath
(
true
,
peName
)
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_RECURSIVE_PEREFERENCE
,
XMLMessages
.
WFC_NO_RECURSION
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
return
false
;
}
pushReader
(
)
;
fEntityName
=
peName
;
fEntityContext
=
context
;
fReaderDepth
=
readerDepth
;
fReaderId
=
fNextReaderId
++
;
if
(
!
fValidator
.
isExternalParameterEntity
(
entityHandle
)
)
{
fEntityType
=
ENTITYTYPE_INTERNAL_PE
;
fPublicId
=
null
;
fSystemId
=
fSystemId
;
int
value
=
fValidator
.
getParameterEntityValue
(
entityHandle
)
;
startReadingFromInternalEntity
(
value
,
fEntityContext
==
CONTEXT_IN_ENTITYVALUE
?
false
:
true
)
;
return
false
;
}
fEntityType
=
ENTITYTYPE_EXTERNAL_PE
;
fPublicId
=
fValidator
.
getPublicIdOfParameterEntity
(
entityHandle
)
;
fSystemId
=
fValidator
.
getSystemIdOfParameterEntity
(
entityHandle
)
;
return
startReadingFromExternalEntity
(
true
)
;
}
private
void
startReadingFromInternalEntity
(
int
value
,
boolean
addSpaces
)
throws
Exception
{
if
(
fEntityContext
==
CONTEXT_IN_ENTITYVALUE
)
{
}
fSource
=
null
;
sendStartEntityNotifications
(
)
;
fReader
=
fReaderFactory
.
createStringReader
(
this
,
fErrorReporter
,
fSendCharDataAsCharArray
,
getLineNumber
(
)
,
getColumnNumber
(
)
,
value
,
fStringPool
,
addSpaces
)
;
sendReaderChangeNotifications
(
)
;
}
private
boolean
startReadingFromExternalEntity
(
boolean
checkForTextDecl
)
throws
Exception
{
if
(
fEntityContext
==
CONTEXT_IN_ENTITYVALUE
)
{
}
if
(
fEntityContext
==
CONTEXT_IN_DTD_WITHIN_MARKUP
)
{
}
sendStartEntityNotifications
(
)
;
ReaderState
rs
=
(
ReaderState
)
fReaderStack
.
peek
(
)
;
fSystemId
=
expandSystemId
(
fSystemId
,
rs
.
systemId
)
;
fSource
=
fResolver
==
null
?
null
:
fResolver
.
resolveEntity
(
fPublicId
,
fSystemId
)
;
if
(
fSource
==
null
)
{
fSource
=
new
InputSource
(
fSystemId
)
;
if
(
fPublicId
!=
null
)
fSource
.
setPublicId
(
fPublicId
)
;
}
boolean
textDecl
=
false
;
try
{
createReader
(
textDecl
)
;
}
catch
(
java
.
io
.
UnsupportedEncodingException
uee
)
{
String
encoding
=
uee
.
getMessage
(
)
;
if
(
encoding
==
null
)
{
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_ENCODING_REQUIRED
,
XMLMessages
.
P81_REQUIRED
,
null
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
else
if
(
!
XMLCharacterProperties
.
validEncName
(
encoding
)
)
{
Object
[
]
args
=
{
encoding
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_ENCODINGDECL_INVALID
,
XMLMessages
.
P81_INVALID_VALUE
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
else
{
Object
[
]
args
=
{
encoding
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
XMLMessages
.
MSG_ENCODING_NOT_SUPPORTED
,
XMLMessages
.
P81_NOT_SUPPORTED
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
}
}
if
(
fReader
==
null
||
!
checkForTextDecl
)
{
sendReaderChangeNotifications
(
)
;
return
false
;
}
int
readerId
=
fReaderId
;
sendReaderChangeNotifications
(
)
;
boolean
parseTextDecl
=
fReader
.
lookingAtChar
(
'<'
,
false
)
;
if
(
readerId
!=
fReaderId
)
parseTextDecl
=
false
;
return
parseTextDecl
;
}
private
void
createReader
(
boolean
xmlDecl
)
throws
Exception
{
fReader
=
null
;
if
(
fSource
.
getCharacterStream
(
)
!=
null
)
{
fReader
=
fReaderFactory
.
createCharReader
(
this
,
fErrorReporter
,
fSendCharDataAsCharArray
,
fSource
.
getCharacterStream
(
)
,
fStringPool
)
;
return
;
}
if
(
fSource
.
getEncoding
(
)
!=
null
&&
fSource
.
getByteStream
(
)
!=
null
)
{
java
.
io
.
Reader
reader
=
new
InputStreamReader
(
fSource
.
getByteStream
(
)
,
fSource
.
getEncoding
(
)
)
;
fReader
=
fReaderFactory
.
createCharReader
(
this
,
fErrorReporter
,
fSendCharDataAsCharArray
,
reader
,
fStringPool
)
;
return
;
}
InputStream
is
=
fSource
.
getByteStream
(
)
;
if
(
is
==
null
)
{
try
{
URL
url
=
new
URL
(
fSystemId
)
;
is
=
url
.
openStream
(
)
;
}
catch
(
MalformedURLException
mu
)
{
String
errorSystemId
=
fSystemId
;
sendEndEntityNotifications
(
)
;
popReader
(
)
;
popEntity
(
)
;
Object
[
]
args
=
{
errorSystemId
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
ImplementationMessages
.
XERCES_IMPLEMENTATION_DOMAIN
,
ImplementationMessages
.
IO0
,
0
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
return
;
}
catch
(
FileNotFoundException
fnf
)
{
String
errorSystemId
=
fSystemId
;
sendEndEntityNotifications
(
)
;
popReader
(
)
;
popEntity
(
)
;
Object
[
]
args
=
{
errorSystemId
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
ImplementationMessages
.
XERCES_IMPLEMENTATION_DOMAIN
,
ImplementationMessages
.
IO0
,
0
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
return
;
}
}
ChunkyByteArray
data
=
new
ChunkyByteArray
(
is
)
;
XMLEntityHandler
.
EntityReader
reader
=
callRecognizers
(
fSource
,
data
,
xmlDecl
)
;
if
(
reader
==
null
)
{
reader
=
fReaderFactory
.
createUTF8Reader
(
this
,
fErrorReporter
,
fSendCharDataAsCharArray
,
data
,
fStringPool
)
;
}
fReader
=
reader
;
}
private
void
pushNullReader
(
)
{
ReaderState
rs
=
fReaderStateFreeList
;
if
(
rs
==
null
)
rs
=
new
ReaderState
(
)
;
else
fReaderStateFreeList
=
rs
.
nextReaderState
;
if
(
fNullReader
==
null
)
fNullReader
=
new
NullReader
(
)
;
rs
.
reader
=
fNullReader
;
rs
.
source
=
null
;
rs
.
entityName
=
-
1
;
rs
.
entityType
=
-
1
;
rs
.
entityContext
=
-
1
;
rs
.
publicId
=
"Null Entity"
;
rs
.
systemId
=
fSystemId
;
rs
.
readerId
=
fNextReaderId
++
;
rs
.
depth
=
-
1
;
rs
.
nextReaderState
=
null
;
fReaderStack
.
push
(
rs
)
;
}
private
void
pushReader
(
)
{
ReaderState
rs
=
fReaderStateFreeList
;
if
(
rs
==
null
)
rs
=
new
ReaderState
(
)
;
else
fReaderStateFreeList
=
rs
.
nextReaderState
;
rs
.
reader
=
fReader
;
rs
.
source
=
fSource
;
rs
.
entityName
=
fEntityName
;
rs
.
entityType
=
fEntityType
;
rs
.
entityContext
=
fEntityContext
;
rs
.
publicId
=
fPublicId
;
rs
.
systemId
=
fSystemId
;
rs
.
readerId
=
fReaderId
;
rs
.
depth
=
fReaderDepth
;
rs
.
nextReaderState
=
null
;
fReaderStack
.
push
(
rs
)
;
}
private
void
popReader
(
)
{
if
(
fReaderStack
.
empty
(
)
)
throw
new
RuntimeException
(
"cannot happen 19"
)
;
ReaderState
rs
=
(
ReaderState
)
fReaderStack
.
pop
(
)
;
fReader
=
rs
.
reader
;
fSource
=
rs
.
source
;
fEntityName
=
rs
.
entityName
;
fEntityType
=
rs
.
entityType
;
fEntityContext
=
rs
.
entityContext
;
fPublicId
=
rs
.
publicId
;
fSystemId
=
rs
.
systemId
;
fReaderId
=
rs
.
readerId
;
fReaderDepth
=
rs
.
depth
;
rs
.
nextReaderState
=
fReaderStateFreeList
;
fReaderStateFreeList
=
rs
;
}
public
boolean
startEntityDecl
(
boolean
isPE
,
int
entityName
)
throws
Exception
{
if
(
!
pushEntity
(
isPE
,
entityName
)
)
{
int
majorCode
=
isPE
?
XMLMessages
.
MSG_RECURSIVE_PEREFERENCE
:
XMLMessages
.
MSG_RECURSIVE_REFERENCE
;
Object
[
]
args
=
{
fStringPool
.
toString
(
entityName
)
,
entityReferencePath
(
isPE
,
entityName
)
}
;
fErrorReporter
.
reportError
(
fErrorReporter
.
getLocator
(
)
,
XMLMessages
.
XML_DOMAIN
,
majorCode
,
XMLMessages
.
WFC_NO_RECURSION
,
args
,
XMLErrorReporter
.
ERRORTYPE_FATAL_ERROR
)
;
return
false
;
}
return
true
;
}
public
void
endEntityDecl
(
)
throws
Exception
{
popEntity
(
)
;
}
private
boolean
pushEntity
(
boolean
isPE
,
int
entityName
)
throws
Exception
{
if
(
entityName
>=
0
)
{
for
(
int
i
=
0
;
i
<
fEntityStackDepth
;
i
++
)
{
if
(
fEntityNameStack
[
i
]
==
entityName
&&
fEntityTypeStack
[
i
]
==
(
isPE
?
1
:
0
)
)
{
return
false
;
}
}
}
if
(
fEntityTypeStack
==
null
)
{
fEntityTypeStack
=
new
byte
[
8
]
;
fEntityNameStack
=
new
int
[
8
]
;
}
else
if
(
fEntityStackDepth
==
fEntityTypeStack
.
length
)
{
byte
[
]
newTypeStack
=
new
byte
[
fEntityStackDepth
*
2
]
;
System
.
arraycopy
(
fEntityTypeStack
,
0
,
newTypeStack
,
0
,
fEntityStackDepth
)
;
fEntityTypeStack
=
newTypeStack
;
int
[
]
newNameStack
=
new
int
[
fEntityStackDepth
*
2
]
;
System
.
arraycopy
(
fEntityNameStack
,
0
,
newNameStack
,
0
,
fEntityStackDepth
)
;
fEntityNameStack
=
newNameStack
;
}
fEntityTypeStack
[
fEntityStackDepth
]
=
(
byte
)
(
isPE
?
1
:
0
)
;
fEntityNameStack
[
fEntityStackDepth
]
=
entityName
;
fEntityStackDepth
++
;
return
true
;
}
private
String
entityReferencePath
(
boolean
isPE
,
int
entityName
)
{
StringBuffer
sb
=
new
StringBuffer
(
)
;
sb
.
append
(
"(top-level)"
)
;
for
(
int
i
=
0
;
i
<
fEntityStackDepth
;
i
++
)
{
if
(
fEntityNameStack
[
i
]
>=
0
)
{
sb
.
append
(
'-'
)
;
sb
.
append
(
fEntityTypeStack
[
i
]
==
1
?
'%'
:
'&'
)
;
sb
.
append
(
fStringPool
.
toString
(
fEntityNameStack
[
i
]
)
)
;
sb
.
append
(
';'
)
;
}
}
sb
.
append
(
'-'
)
;
sb
.
append
(
isPE
?
'%'
:
'&'
)
;
sb
.
append
(
fStringPool
.
toString
(
entityName
)
)
;
sb
.
append
(
';'
)
;
return
sb
.
toString
(
)
;
}
private
void
popEntity
(
)
throws
Exception
{
fEntityStackDepth
--
;
}
public
int
getReaderId
(
)
{
return
fReaderId
;
}
public
void
setReaderDepth
(
int
depth
)
{
fReaderDepth
=
depth
;
}
public
int
getReaderDepth
(
)
{
return
fReaderDepth
;
}
public
String
getPublicId
(
)
{
return
fPublicId
;
}
public
String
getSystemId
(
)
{
return
fSystemId
;
}
public
int
getLineNumber
(
)
{
return
fReader
.
getLineNumber
(
)
;
}
public
int
getColumnNumber
(
)
{
return
fReader
.
getColumnNumber
(
)
;
}
public
XMLEntityHandler
.
EntityReader
changeReaders
(
)
throws
Exception
{
sendEndOfInputNotifications
(
)
;
sendEndEntityNotifications
(
)
;
popReader
(
)
;
sendReaderChangeNotifications
(
)
;
popEntity
(
)
;
return
fReader
;
}
private
final
class
NullReader
implements
XMLEntityHandler
.
EntityReader
{
public
NullReader
(
)
{
}
public
int
currentOffset
(
)
{
return
-
1
;
}
public
int
getLineNumber
(
)
{
return
-
1
;
}
public
int
getColumnNumber
(
)
{
return
-
1
;
}
public
void
setInCDSect
(
boolean
inCDSect
)
{
}
public
boolean
getInCDSect
(
)
{
return
false
;
}
public
void
append
(
XMLEntityHandler
.
CharBuffer
charBuffer
,
int
offset
,
int
length
)
{
}
public
int
addString
(
int
offset
,
int
length
)
{
return
-
1
;
}
public
int
addSymbol
(
int
offset
,
int
length
)
{
return
-
1
;
}
public
boolean
lookingAtChar
(
char
ch
,
boolean
skipPastChar
)
{
return
false
;
}
public
boolean
lookingAtValidChar
(
boolean
skipPastChar
)
{
return
false
;
}
public
boolean
lookingAtSpace
(
boolean
skipPastChar
)
{
return
false
;
}
public
void
skipToChar
(
char
ch
)
{
}
public
void
skipPastSpaces
(
)
{
}
public
void
skipPastName
(
char
fastcheck
)
{
}
public
void
skipPastNmtoken
(
char
fastcheck
)
{
}
public
boolean
skippedString
(
char
[
]
s
)
{
return
false
;
}
public
int
scanInvalidChar
(
)
{
return
-
1
;
}
public
int
scanCharRef
(
boolean
hex
)
{
return
XMLEntityHandler
.
CHARREF_RESULT_INVALID_CHAR
;
}
public
int
scanStringLiteral
(
)
{
return
XMLEntityHandler
.
STRINGLIT_RESULT_QUOTE_REQUIRED
;
}
public
int
scanAttValue
(
char
qchar
,
boolean
asSymbol
)
{
return
XMLEntityHandler
.
ATTVALUE_RESULT_INVALID_CHAR
;
}
public
int
scanEntityValue
(
int
qchar
,
boolean
createString
)
{
return
XMLEntityHandler
.
ENTITYVALUE_RESULT_INVALID_CHAR
;
}
public
boolean
scanExpectedName
(
char
fastcheck
,
StringPool
.
CharArrayRange
expectedName
)
{
return
false
;
}
public
int
scanQName
(
char
fastcheck
)
{
return
-
1
;
}
public
int
scanName
(
char
fastcheck
)
{
return
-
1
;
}
public
int
scanContent
(
int
elementType
)
throws
Exception
{
return
XMLEntityHandler
.
CONTENT_RESULT_INVALID_CHAR
;
}
}
}
