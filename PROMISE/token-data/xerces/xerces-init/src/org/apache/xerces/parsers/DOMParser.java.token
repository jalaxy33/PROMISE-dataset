package
org
.
apache
.
xerces
.
parsers
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
StringTokenizer
;
import
org
.
apache
.
xerces
.
dom
.
TextImpl
;
import
org
.
apache
.
xerces
.
framework
.
XMLAttrList
;
import
org
.
apache
.
xerces
.
framework
.
XMLContentSpecNode
;
import
org
.
apache
.
xerces
.
framework
.
XMLParser
;
import
org
.
apache
.
xerces
.
framework
.
XMLValidator
;
import
org
.
apache
.
xerces
.
readers
.
XMLEntityHandler
;
import
org
.
apache
.
xerces
.
utils
.
StringPool
;
import
org
.
apache
.
xerces
.
validators
.
schema
.
XUtil
;
import
org
.
apache
.
xerces
.
dom
.
DeferredDocumentImpl
;
import
org
.
apache
.
xerces
.
dom
.
DocumentImpl
;
import
org
.
apache
.
xerces
.
dom
.
DocumentTypeImpl
;
import
org
.
apache
.
xerces
.
dom
.
NodeImpl
;
import
org
.
apache
.
xerces
.
dom
.
EntityImpl
;
import
org
.
apache
.
xerces
.
dom
.
NotationImpl
;
import
org
.
apache
.
xerces
.
dom
.
ElementDefinitionImpl
;
import
org
.
apache
.
xerces
.
dom
.
AttrImpl
;
import
org
.
apache
.
xerces
.
dom
.
TextImpl
;
import
org
.
apache
.
xerces
.
dom
.
ElementImpl
;
import
org
.
w3c
.
dom
.
Attr
;
import
org
.
w3c
.
dom
.
Comment
;
import
org
.
w3c
.
dom
.
Document
;
import
org
.
w3c
.
dom
.
DocumentType
;
import
org
.
w3c
.
dom
.
Element
;
import
org
.
w3c
.
dom
.
Entity
;
import
org
.
w3c
.
dom
.
EntityReference
;
import
org
.
w3c
.
dom
.
Node
;
import
org
.
w3c
.
dom
.
NodeList
;
import
org
.
w3c
.
dom
.
NamedNodeMap
;
import
org
.
w3c
.
dom
.
ProcessingInstruction
;
import
org
.
w3c
.
dom
.
Text
;
import
org
.
xml
.
sax
.
AttributeList
;
import
org
.
xml
.
sax
.
Configurable
;
import
org
.
xml
.
sax
.
InputSource
;
import
org
.
xml
.
sax
.
SAXException
;
import
org
.
xml
.
sax
.
SAXNotRecognizedException
;
import
org
.
xml
.
sax
.
SAXNotSupportedException
;
import
org
.
xml
.
sax
.
SAXParseException
;
public
class
DOMParser
extends
XMLParser
{
public
static
final
String
DEFAULT_DOCUMENT_CLASS_NAME
=
"org.apache.xerces.dom.DocumentImpl"
;
private
static
final
boolean
DEBUG_ATTLIST_DECL
=
false
;
private
static
final
String
RECOGNIZED_FEATURES
[
]
=
{
"http://apache.org/xml/features/dom/defer-node-expansion"
,
"http://apache.org/xml/features/dom/create-entity-ref-nodes"
,
"http://apache.org/xml/features/domx/grammar-access"
,
}
;
private
static
final
String
RECOGNIZED_PROPERTIES
[
]
=
{
"http://apache.org/xml/properties/dom/document-class-name"
,
"http://apache.org/xml/properties/dom/current-element-node"
,
}
;
private
static
final
Hashtable
TYPES
=
new
Hashtable
(
)
;
protected
Document
fDocument
;
protected
DeferredDocumentImpl
fDeferredDocumentImpl
;
protected
int
fDocumentIndex
;
protected
int
fDocumentTypeIndex
;
protected
int
fCurrentNodeIndex
;
protected
DocumentImpl
fDocumentImpl
;
protected
DocumentType
fDocumentType
;
protected
Node
fCurrentElementNode
;
protected
boolean
fWithinElement
;
protected
boolean
fInCDATA
;
private
boolean
fGrammarAccess
;
private
String
fDocumentClassName
;
private
boolean
fDeferNodeExpansion
;
private
boolean
fCreateEntityReferenceNodes
;
protected
int
fAmpIndex
;
protected
int
fLtIndex
;
protected
int
fGtIndex
;
protected
int
fAposIndex
;
protected
int
fQuotIndex
;
private
boolean
fSeenRootElement
;
private
XMLAttrList
fAttrList
;
static
{
String
types
[
]
[
]
=
{
{
"CDATA"
,
"minOccurs"
,
"maxOccurs"
}
,
{
"ENUMERATION"
,
"collection"
,
"order"
,
"export"
}
,
{
"NMTOKEN"
,
"name"
,
"ref"
}
,
}
;
for
(
int
i
=
0
;
i
<
types
.
length
;
i
++
)
{
String
typeName
=
types
[
i
]
[
0
]
;
for
(
int
j
=
1
;
j
<
types
[
i
]
.
length
;
j
++
)
{
TYPES
.
put
(
types
[
i
]
[
j
]
,
typeName
)
;
}
}
}
public
DOMParser
(
)
{
init
(
)
;
try
{
setDocumentClassName
(
DEFAULT_DOCUMENT_CLASS_NAME
)
;
setCreateEntityReferenceNodes
(
true
)
;
setDeferNodeExpansion
(
true
)
;
}
catch
(
SAXException
e
)
{
throw
new
RuntimeException
(
"fatal error constructing DOMParser"
)
;
}
}
public
Document
getDocument
(
)
{
return
fDocument
;
}
public
String
[
]
getFeaturesRecognized
(
)
{
String
superRecognized
[
]
=
super
.
getFeaturesRecognized
(
)
;
String
thisRecognized
[
]
=
RECOGNIZED_FEATURES
;
int
thisLength
=
thisRecognized
.
length
;
if
(
thisLength
==
0
)
{
return
superRecognized
;
}
int
superLength
=
superRecognized
.
length
;
if
(
superLength
==
0
)
{
return
thisRecognized
;
}
String
recognized
[
]
=
new
String
[
superLength
+
thisLength
]
;
System
.
arraycopy
(
superRecognized
,
0
,
recognized
,
0
,
superLength
)
;
System
.
arraycopy
(
thisRecognized
,
0
,
recognized
,
superLength
,
thisLength
)
;
return
recognized
;
}
public
String
[
]
getPropertiesRecognized
(
)
{
String
superRecognized
[
]
=
super
.
getPropertiesRecognized
(
)
;
String
thisRecognized
[
]
=
RECOGNIZED_PROPERTIES
;
int
thisLength
=
thisRecognized
.
length
;
if
(
thisLength
==
0
)
{
return
superRecognized
;
}
int
superLength
=
superRecognized
.
length
;
if
(
superLength
==
0
)
{
return
thisRecognized
;
}
String
recognized
[
]
=
new
String
[
superLength
+
thisLength
]
;
System
.
arraycopy
(
superRecognized
,
0
,
recognized
,
0
,
superLength
)
;
System
.
arraycopy
(
thisRecognized
,
0
,
recognized
,
superLength
,
thisLength
)
;
return
recognized
;
}
public
void
reset
(
)
throws
Exception
{
super
.
reset
(
)
;
init
(
)
;
}
public
void
resetOrCopy
(
)
throws
Exception
{
super
.
resetOrCopy
(
)
;
init
(
)
;
}
protected
void
init
(
)
{
fDocument
=
null
;
fDeferredDocumentImpl
=
null
;
fDocumentIndex
=
-
1
;
fDocumentTypeIndex
=
-
1
;
fCurrentNodeIndex
=
-
1
;
fDocumentImpl
=
null
;
fDocumentType
=
null
;
fCurrentElementNode
=
null
;
fWithinElement
=
false
;
fInCDATA
=
false
;
fAmpIndex
=
fStringPool
.
addSymbol
(
"amp"
)
;
fLtIndex
=
fStringPool
.
addSymbol
(
"lt"
)
;
fGtIndex
=
fStringPool
.
addSymbol
(
"gt"
)
;
fAposIndex
=
fStringPool
.
addSymbol
(
"apos"
)
;
fQuotIndex
=
fStringPool
.
addSymbol
(
"quot"
)
;
setSendCharDataAsCharArray
(
false
)
;
fSeenRootElement
=
false
;
fAttrList
=
new
XMLAttrList
(
fStringPool
)
;
}
protected
void
setDeferNodeExpansion
(
boolean
deferNodeExpansion
)
throws
SAXException
{
fDeferNodeExpansion
=
deferNodeExpansion
;
}
protected
boolean
getDeferNodeExpansion
(
)
throws
SAXException
{
return
fDeferNodeExpansion
;
}
protected
void
setCreateEntityReferenceNodes
(
boolean
create
)
throws
SAXException
{
fCreateEntityReferenceNodes
=
create
;
}
public
boolean
getCreateEntityReferenceNodes
(
)
throws
SAXException
{
return
fCreateEntityReferenceNodes
;
}
protected
void
setDocumentClassName
(
String
documentClassName
)
throws
SAXException
{
if
(
documentClassName
==
null
)
{
documentClassName
=
DEFAULT_DOCUMENT_CLASS_NAME
;
}
try
{
Class
_class
=
Class
.
forName
(
documentClassName
)
;
if
(
!
Document
.
class
.
isAssignableFrom
(
_class
)
)
{
throw
new
IllegalArgumentException
(
"Class, \""
+
documentClassName
+
"\", is not of type org.w3c.dom.Document."
)
;
}
}
catch
(
ClassNotFoundException
e
)
{
throw
new
IllegalArgumentException
(
"Class, \""
+
documentClassName
+
"\", not found."
)
;
}
fDocumentClassName
=
documentClassName
;
if
(
!
documentClassName
.
equals
(
DEFAULT_DOCUMENT_CLASS_NAME
)
)
{
setDeferNodeExpansion
(
false
)
;
}
}
protected
String
getDocumentClassName
(
)
throws
SAXException
{
return
fDocumentClassName
;
}
protected
Element
getCurrentElementNode
(
)
throws
SAXException
{
if
(
fCurrentElementNode
!=
null
&&
fCurrentElementNode
.
getNodeType
(
)
==
Node
.
ELEMENT_NODE
)
{
return
(
Element
)
fCurrentElementNode
;
}
return
null
;
}
public
void
setFeature
(
String
featureId
,
boolean
state
)
throws
SAXException
{
if
(
featureId
.
startsWith
(
SAX2_FEATURES_PREFIX
)
)
{
}
else
if
(
featureId
.
startsWith
(
XERCES_FEATURES_PREFIX
)
)
{
String
feature
=
featureId
.
substring
(
XERCES_FEATURES_PREFIX
.
length
(
)
)
;
if
(
feature
.
equals
(
"dom/defer-node-expansion"
)
)
{
if
(
fParseInProgress
)
{
throw
new
SAXNotSupportedException
(
featureId
+
": parse is in progress"
)
;
}
setDeferNodeExpansion
(
state
)
;
return
;
}
if
(
feature
.
equals
(
"dom/create-entity-ref-nodes"
)
)
{
setCreateEntityReferenceNodes
(
state
)
;
return
;
}
if
(
feature
.
equals
(
"domx/grammar-access"
)
)
{
fGrammarAccess
=
state
;
return
;
}
}
super
.
setFeature
(
featureId
,
state
)
;
}
public
boolean
getFeature
(
String
featureId
)
throws
SAXException
{
if
(
featureId
.
startsWith
(
SAX2_FEATURES_PREFIX
)
)
{
}
else
if
(
featureId
.
startsWith
(
XERCES_FEATURES_PREFIX
)
)
{
String
feature
=
featureId
.
substring
(
XERCES_FEATURES_PREFIX
.
length
(
)
)
;
if
(
feature
.
equals
(
"dom/defer-node-expansion"
)
)
{
return
getDeferNodeExpansion
(
)
;
}
else
if
(
feature
.
equals
(
"dom/create-entity-ref-nodes"
)
)
{
return
getCreateEntityReferenceNodes
(
)
;
}
if
(
feature
.
equals
(
"domx/grammar-access"
)
)
{
return
fGrammarAccess
;
}
}
return
super
.
getFeature
(
featureId
)
;
}
public
void
setProperty
(
String
propertyId
,
Object
value
)
throws
SAXException
{
if
(
propertyId
.
startsWith
(
XERCES_PROPERTIES_PREFIX
)
)
{
String
property
=
propertyId
.
substring
(
XERCES_PROPERTIES_PREFIX
.
length
(
)
)
;
if
(
property
.
equals
(
"dom/current-element-node"
)
)
{
throw
new
SAXNotSupportedException
(
"Property, \""
+
propertyId
+
"\" is read-only."
)
;
}
else
if
(
property
.
equals
(
"dom/document-class-name"
)
)
{
if
(
value
!=
null
&&
!
(
value
instanceof
String
)
)
{
throw
new
SAXNotSupportedException
(
"Property value must be of type java.lang.String."
)
;
}
setDocumentClassName
(
(
String
)
value
)
;
return
;
}
}
super
.
setProperty
(
propertyId
,
value
)
;
}
public
Object
getProperty
(
String
propertyId
)
throws
SAXException
{
if
(
propertyId
.
startsWith
(
XERCES_PROPERTIES_PREFIX
)
)
{
String
property
=
propertyId
.
substring
(
XERCES_PROPERTIES_PREFIX
.
length
(
)
)
;
if
(
property
.
equals
(
"dom/current-element-node"
)
)
{
boolean
throwException
=
false
;
try
{
throwException
=
getFeature
(
XERCES_FEATURES_PREFIX
+
"dom/defer-node-expansion"
)
;
}
catch
(
SAXNotSupportedException
e
)
{
}
catch
(
SAXNotRecognizedException
e
)
{
}
if
(
throwException
)
{
throw
new
SAXNotSupportedException
(
"Current element node cannot be queried when node expansion is deferred."
)
;
}
return
getCurrentElementNode
(
)
;
}
else
if
(
property
.
equals
(
"dom/document-class-name"
)
)
{
return
getDocumentClassName
(
)
;
}
}
return
super
.
getProperty
(
propertyId
)
;
}
public
void
startDocument
(
int
versionIndex
,
int
encodingIndex
,
int
standAloneIndex
)
{
if
(
versionIndex
!=
-
1
)
{
fStringPool
.
orphanString
(
versionIndex
)
;
}
if
(
encodingIndex
!=
-
1
)
{
fStringPool
.
orphanString
(
encodingIndex
)
;
}
if
(
standAloneIndex
!=
-
1
)
{
fStringPool
.
orphanString
(
standAloneIndex
)
;
}
String
documentClassName
=
null
;
try
{
documentClassName
=
getDocumentClassName
(
)
;
}
catch
(
SAXException
e
)
{
throw
new
RuntimeException
(
"fatal error getting document factory"
)
;
}
boolean
deferNodeExpansion
=
true
;
try
{
deferNodeExpansion
=
getDeferNodeExpansion
(
)
;
}
catch
(
SAXException
e
)
{
throw
new
RuntimeException
(
"fatal error reading expansion mode"
)
;
}
if
(
documentClassName
.
equals
(
DEFAULT_DOCUMENT_CLASS_NAME
)
&&
deferNodeExpansion
)
{
boolean
nsEnabled
=
false
;
try
{
nsEnabled
=
getNamespaces
(
)
;
}
catch
(
SAXException
s
)
{
}
fDocument
=
fDeferredDocumentImpl
=
new
DeferredDocumentImpl
(
fStringPool
,
nsEnabled
,
fGrammarAccess
)
;
fDocumentIndex
=
fDeferredDocumentImpl
.
createDocument
(
)
;
fCurrentNodeIndex
=
fDocumentIndex
;
}
else
{
if
(
documentClassName
.
equals
(
DEFAULT_DOCUMENT_CLASS_NAME
)
)
{
fDocument
=
fDocumentImpl
=
new
DocumentImpl
(
fGrammarAccess
)
;
}
else
{
try
{
Class
documentClass
=
Class
.
forName
(
documentClassName
)
;
fDocument
=
(
Document
)
documentClass
.
newInstance
(
)
;
}
catch
(
Exception
e
)
{
}
}
fCurrentElementNode
=
fDocument
;
}
}
public
void
endDocument
(
)
throws
Exception
{
}
public
void
startNamespaceDeclScope
(
int
prefix
,
int
uri
)
throws
Exception
{
}
public
void
endNamespaceDeclScope
(
int
prefix
)
throws
Exception
{
}
public
void
startElement
(
int
elementTypeIndex
,
XMLAttrList
xmlAttrList
,
int
attrListIndex
)
throws
Exception
{
if
(
fDeferredDocumentImpl
!=
null
)
{
int
element
=
fDeferredDocumentImpl
.
createElement
(
elementTypeIndex
,
xmlAttrList
,
attrListIndex
)
;
fDeferredDocumentImpl
.
appendChild
(
fCurrentNodeIndex
,
element
)
;
fCurrentNodeIndex
=
element
;
fWithinElement
=
true
;
int
index
=
xmlAttrList
.
getFirstAttr
(
attrListIndex
)
;
while
(
index
!=
-
1
)
{
if
(
xmlAttrList
.
getAttType
(
index
)
==
fStringPool
.
addSymbol
(
"ID"
)
)
{
int
nameIndex
=
xmlAttrList
.
getAttValue
(
index
)
;
fDeferredDocumentImpl
.
putIdentifier
(
nameIndex
,
element
)
;
}
index
=
xmlAttrList
.
getNextAttr
(
index
)
;
}
if
(
!
fSeenRootElement
)
{
fSeenRootElement
=
true
;
if
(
fGrammarAccess
&&
fValidator
==
fSchemaValidator
)
{
Document
schemaDocument
=
fSchemaValidator
.
getSchemaDocument
(
)
;
if
(
schemaDocument
!=
null
)
{
if
(
fDocumentTypeIndex
==
-
1
)
{
fDocumentTypeIndex
=
fDeferredDocumentImpl
.
createDocumentType
(
elementTypeIndex
,
-
1
,
-
1
)
;
fDeferredDocumentImpl
.
appendChild
(
0
,
fDocumentTypeIndex
)
;
}
Element
schema
=
schemaDocument
.
getDocumentElement
(
)
;
copyInto
(
schema
,
fDocumentTypeIndex
)
;
}
}
}
}
else
{
boolean
nsEnabled
=
false
;
try
{
nsEnabled
=
getNamespaces
(
)
;
}
catch
(
SAXException
s
)
{
}
String
elementName
=
fStringPool
.
toString
(
elementTypeIndex
)
;
AttributeList
attrList
=
xmlAttrList
.
getAttributeList
(
attrListIndex
)
;
Element
e
;
if
(
nsEnabled
)
{
e
=
(
ElementImpl
)
(
(
DocumentImpl
)
fDocument
)
.
createElementNS
(
fStringPool
.
toString
(
fStringPool
.
getURIForQName
(
elementTypeIndex
)
)
,
fStringPool
.
toString
(
elementTypeIndex
)
)
;
}
else
{
e
=
fDocument
.
createElement
(
elementName
)
;
}
int
attrListLength
=
attrList
.
getLength
(
)
;
for
(
int
i
=
0
;
i
<
attrListLength
;
i
++
)
{
if
(
nsEnabled
)
{
int
attName
=
xmlAttrList
.
getAttrName
(
i
)
;
(
(
ElementImpl
)
e
)
.
setAttributeNS
(
fStringPool
.
toString
(
fStringPool
.
getURIForQName
(
attName
)
)
,
fStringPool
.
toString
(
attName
)
,
attrList
.
getValue
(
i
)
)
;
}
else
{
String
attrName
=
attrList
.
getName
(
i
)
;
String
attrValue
=
attrList
.
getValue
(
i
)
;
e
.
setAttribute
(
attrName
,
attrValue
)
;
if
(
fDocumentImpl
!=
null
&&
!
xmlAttrList
.
isSpecified
(
i
)
)
{
(
(
AttrImpl
)
e
.
getAttributeNode
(
attrName
)
)
.
setSpecified
(
false
)
;
}
}
}
fCurrentElementNode
.
appendChild
(
e
)
;
fCurrentElementNode
=
e
;
fWithinElement
=
true
;
if
(
fDocumentImpl
!=
null
)
{
int
index
=
xmlAttrList
.
getFirstAttr
(
attrListIndex
)
;
while
(
index
!=
-
1
)
{
if
(
xmlAttrList
.
getAttType
(
index
)
==
fStringPool
.
addSymbol
(
"ID"
)
)
{
String
name
=
fStringPool
.
toString
(
xmlAttrList
.
getAttValue
(
index
)
)
;
fDocumentImpl
.
putIdentifier
(
name
,
e
)
;
}
index
=
xmlAttrList
.
getNextAttr
(
index
)
;
}
}
xmlAttrList
.
releaseAttrList
(
attrListIndex
)
;
if
(
!
fSeenRootElement
)
{
fSeenRootElement
=
true
;
if
(
fDocumentImpl
!=
null
&&
fGrammarAccess
&&
fValidator
==
fSchemaValidator
)
{
Document
schemaDocument
=
fSchemaValidator
.
getSchemaDocument
(
)
;
if
(
schemaDocument
!=
null
)
{
if
(
fDocumentType
==
null
)
{
String
rootName
=
elementName
;
String
systemId
=
""
;
String
publicId
=
""
;
fDocumentType
=
fDocumentImpl
.
createDocumentType
(
rootName
,
publicId
,
systemId
)
;
fDocument
.
appendChild
(
fDocumentType
)
;
}
Element
schema
=
schemaDocument
.
getDocumentElement
(
)
;
XUtil
.
copyInto
(
schema
,
fDocumentType
)
;
}
}
}
}
}
public
void
endElement
(
int
elementTypeIndex
)
throws
Exception
{
if
(
fDeferredDocumentImpl
!=
null
)
{
fCurrentNodeIndex
=
fDeferredDocumentImpl
.
getParentNode
(
fCurrentNodeIndex
)
;
fWithinElement
=
false
;
}
else
{
fCurrentElementNode
=
fCurrentElementNode
.
getParentNode
(
)
;
fWithinElement
=
false
;
}
}
public
void
characters
(
int
dataIndex
)
throws
Exception
{
if
(
fDeferredDocumentImpl
!=
null
)
{
int
text
;
if
(
fInCDATA
)
{
text
=
fDeferredDocumentImpl
.
createCDATASection
(
dataIndex
,
false
)
;
}
else
{
text
=
fDeferredDocumentImpl
.
createTextNode
(
dataIndex
,
false
)
;
}
fDeferredDocumentImpl
.
appendChild
(
fCurrentNodeIndex
,
text
)
;
}
else
{
Text
text
;
if
(
fInCDATA
)
{
text
=
fDocument
.
createCDATASection
(
fStringPool
.
orphanString
(
dataIndex
)
)
;
}
else
{
if
(
fWithinElement
&&
fCurrentElementNode
.
getNodeType
(
)
==
Node
.
ELEMENT_NODE
)
{
Node
lastChild
=
fCurrentElementNode
.
getLastChild
(
)
;
if
(
lastChild
!=
null
&&
lastChild
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
(
(
Text
)
lastChild
)
.
appendData
(
fStringPool
.
orphanString
(
dataIndex
)
)
;
return
;
}
}
text
=
fDocument
.
createTextNode
(
fStringPool
.
orphanString
(
dataIndex
)
)
;
}
fCurrentElementNode
.
appendChild
(
text
)
;
}
}
public
void
ignorableWhitespace
(
int
dataIndex
)
throws
Exception
{
if
(
fDeferredDocumentImpl
!=
null
)
{
int
text
;
if
(
fInCDATA
)
{
text
=
fDeferredDocumentImpl
.
createCDATASection
(
dataIndex
,
true
)
;
}
else
{
text
=
fDeferredDocumentImpl
.
createTextNode
(
dataIndex
,
true
)
;
}
fDeferredDocumentImpl
.
appendChild
(
fCurrentNodeIndex
,
text
)
;
}
else
{
Text
text
;
if
(
fInCDATA
)
{
text
=
fDocument
.
createCDATASection
(
fStringPool
.
orphanString
(
dataIndex
)
)
;
}
else
{
if
(
fWithinElement
&&
fCurrentElementNode
.
getNodeType
(
)
==
Node
.
ELEMENT_NODE
)
{
Node
lastChild
=
fCurrentElementNode
.
getLastChild
(
)
;
if
(
lastChild
!=
null
&&
lastChild
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
(
(
Text
)
lastChild
)
.
appendData
(
fStringPool
.
orphanString
(
dataIndex
)
)
;
return
;
}
}
text
=
fDocument
.
createTextNode
(
fStringPool
.
orphanString
(
dataIndex
)
)
;
}
if
(
fDocumentImpl
!=
null
)
{
(
(
TextImpl
)
text
)
.
setIgnorableWhitespace
(
true
)
;
}
fCurrentElementNode
.
appendChild
(
text
)
;
}
}
public
void
processingInstruction
(
int
targetIndex
,
int
dataIndex
)
throws
Exception
{
if
(
fDeferredDocumentImpl
!=
null
)
{
int
pi
=
fDeferredDocumentImpl
.
createProcessingInstruction
(
targetIndex
,
dataIndex
)
;
fDeferredDocumentImpl
.
appendChild
(
fCurrentNodeIndex
,
pi
)
;
}
else
{
String
target
=
fStringPool
.
orphanString
(
targetIndex
)
;
String
data
=
fStringPool
.
orphanString
(
dataIndex
)
;
ProcessingInstruction
pi
=
fDocument
.
createProcessingInstruction
(
target
,
data
)
;
fCurrentElementNode
.
appendChild
(
pi
)
;
}
}
public
void
comment
(
int
dataIndex
)
throws
Exception
{
if
(
fDeferredDocumentImpl
!=
null
)
{
int
comment
=
fDeferredDocumentImpl
.
createComment
(
dataIndex
)
;
fDeferredDocumentImpl
.
appendChild
(
fCurrentNodeIndex
,
comment
)
;
}
else
{
Comment
comment
=
fDocument
.
createComment
(
fStringPool
.
orphanString
(
dataIndex
)
)
;
fCurrentElementNode
.
appendChild
(
comment
)
;
}
}
public
void
characters
(
char
ch
[
]
,
int
start
,
int
length
)
throws
Exception
{
}
public
void
ignorableWhitespace
(
char
ch
[
]
,
int
start
,
int
length
)
throws
Exception
{
}
public
void
startCDATA
(
)
throws
Exception
{
fInCDATA
=
true
;
}
public
void
endCDATA
(
)
throws
Exception
{
fInCDATA
=
false
;
}
public
void
startEntityReference
(
int
entityName
,
int
entityType
,
int
entityContext
)
throws
Exception
{
if
(
!
fCreateEntityReferenceNodes
)
{
return
;
}
if
(
entityName
==
fAmpIndex
||
entityName
==
fGtIndex
||
entityName
==
fLtIndex
||
entityName
==
fAposIndex
||
entityName
==
fQuotIndex
)
{
return
;
}
if
(
entityContext
!=
XMLEntityHandler
.
CONTEXT_IN_CONTENT
)
{
return
;
}
if
(
fDeferredDocumentImpl
!=
null
)
{
int
entityRefIndex
=
fDeferredDocumentImpl
.
createEntityReference
(
entityName
)
;
fDeferredDocumentImpl
.
appendChild
(
fCurrentNodeIndex
,
entityRefIndex
)
;
fCurrentNodeIndex
=
entityRefIndex
;
}
else
{
EntityReference
er
=
fDocument
.
createEntityReference
(
fStringPool
.
toString
(
entityName
)
)
;
fCurrentElementNode
.
appendChild
(
er
)
;
fCurrentElementNode
=
er
;
}
}
public
void
endEntityReference
(
int
entityName
,
int
entityType
,
int
entityContext
)
throws
Exception
{
if
(
!
fCreateEntityReferenceNodes
)
{
return
;
}
if
(
entityName
==
fAmpIndex
||
entityName
==
fGtIndex
||
entityName
==
fLtIndex
||
entityName
==
fAposIndex
||
entityName
==
fQuotIndex
)
{
return
;
}
if
(
entityContext
!=
XMLEntityHandler
.
CONTEXT_IN_CONTENT
)
{
return
;
}
if
(
fDeferredDocumentImpl
!=
null
)
{
String
name
=
fStringPool
.
toString
(
entityName
)
;
int
erChild
=
fCurrentNodeIndex
;
fCurrentNodeIndex
=
fDeferredDocumentImpl
.
getParentNode
(
erChild
)
;
if
(
fDeferredDocumentImpl
.
getNodeType
(
erChild
)
!=
Node
.
ENTITY_REFERENCE_NODE
)
return
;
erChild
=
fDeferredDocumentImpl
.
getFirstChild
(
erChild
)
;
if
(
fDocumentTypeIndex
!=
-
1
)
{
int
entityDecl
=
fDeferredDocumentImpl
.
getFirstChild
(
fDocumentTypeIndex
)
;
while
(
entityDecl
!=
-
1
)
{
if
(
fDeferredDocumentImpl
.
getNodeType
(
entityDecl
)
==
Node
.
ENTITY_NODE
&&
fDeferredDocumentImpl
.
getNodeNameString
(
entityDecl
)
.
equals
(
name
)
)
{
break
;
}
entityDecl
=
fDeferredDocumentImpl
.
getNextSibling
(
entityDecl
)
;
}
if
(
entityDecl
!=
-
1
&&
fDeferredDocumentImpl
.
getFirstChild
(
entityDecl
)
==
-
1
)
{
fDeferredDocumentImpl
.
setAsFirstChild
(
entityDecl
,
erChild
)
;
}
}
}
else
{
Node
erNode
=
fCurrentElementNode
;
fCurrentElementNode
=
erNode
.
getParentNode
(
)
;
if
(
fDocumentImpl
!=
null
)
{
NamedNodeMap
entities
=
fDocumentType
.
getEntities
(
)
;
String
name
=
fStringPool
.
toString
(
entityName
)
;
Node
entityNode
=
entities
.
getNamedItem
(
name
)
;
if
(
entityNode
==
null
||
entityNode
.
hasChildNodes
(
)
)
{
return
;
}
Entity
entity
=
(
Entity
)
entityNode
;
if
(
erNode
.
hasChildNodes
(
)
)
{
NodeList
list
=
erNode
.
getChildNodes
(
)
;
int
len
=
list
.
getLength
(
)
;
for
(
int
i
=
0
;
i
<
len
;
i
++
)
{
Node
childClone
=
list
.
item
(
i
)
.
cloneNode
(
true
)
;
entity
.
appendChild
(
childClone
)
;
}
}
}
}
}
public
void
startDTD
(
int
rootElementType
,
int
publicId
,
int
systemId
)
throws
Exception
{
if
(
fDocumentImpl
!=
null
)
{
String
rootElementName
=
fStringPool
.
toString
(
rootElementType
)
;
String
publicString
=
fStringPool
.
toString
(
publicId
)
;
String
systemString
=
fStringPool
.
toString
(
systemId
)
;
fDocumentType
=
fDocumentImpl
.
createDocumentType
(
rootElementName
,
publicString
,
systemString
)
;
fDocumentImpl
.
appendChild
(
fDocumentType
)
;
if
(
fGrammarAccess
)
{
Element
schema
=
fDocument
.
createElement
(
"schema"
)
;
schema
.
setAttribute
(
"xmlns"
,
"http://www.w3.org/XML/Group/1999/09/23-xmlschema/"
)
;
(
(
AttrImpl
)
schema
.
getAttributeNode
(
"xmlns"
)
)
.
setSpecified
(
false
)
;
schema
.
setAttribute
(
"model"
,
"closed"
)
;
(
(
AttrImpl
)
schema
.
getAttributeNode
(
"model"
)
)
.
setSpecified
(
false
)
;
fDocumentType
.
appendChild
(
schema
)
;
}
}
else
if
(
fDeferredDocumentImpl
!=
null
)
{
fDocumentTypeIndex
=
fDeferredDocumentImpl
.
createDocumentType
(
rootElementType
,
publicId
,
systemId
)
;
fDeferredDocumentImpl
.
appendChild
(
fDocumentIndex
,
fDocumentTypeIndex
)
;
if
(
fGrammarAccess
)
{
int
handle
=
fAttrList
.
startAttrList
(
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"xmlns"
)
,
fStringPool
.
addString
(
"http://www.w3.org/XML/Group/1999/09/23-xmlschema/"
)
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
false
,
false
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"model"
)
,
fStringPool
.
addString
(
"closed"
)
,
fStringPool
.
addSymbol
(
"ENUMERATION"
)
,
false
,
false
)
;
fAttrList
.
endAttrList
(
)
;
int
schemaIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"schema"
)
,
fAttrList
,
handle
)
;
fDeferredDocumentImpl
.
appendChild
(
fDocumentTypeIndex
,
schemaIndex
)
;
}
}
}
public
void
endDTD
(
)
throws
Exception
{
}
public
void
elementDecl
(
int
elementTypeIndex
,
XMLValidator
.
ContentSpec
contentSpec
)
throws
Exception
{
if
(
DEBUG_ATTLIST_DECL
)
{
String
contentModel
=
contentSpec
.
toString
(
)
;
System
.
out
.
println
(
"elementDecl("
+
fStringPool
.
toString
(
elementTypeIndex
)
+
", "
+
contentModel
+
")"
)
;
}
if
(
fGrammarAccess
)
{
if
(
fDeferredDocumentImpl
!=
null
)
{
int
schemaIndex
=
getFirstChildElement
(
fDocumentTypeIndex
,
"schema"
)
;
String
elementName
=
fStringPool
.
toString
(
elementTypeIndex
)
;
int
elementIndex
=
getFirstChildElement
(
schemaIndex
,
"element"
,
"name"
,
elementName
)
;
if
(
elementIndex
==
-
1
)
{
int
handle
=
fAttrList
.
startAttrList
(
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"name"
)
,
fStringPool
.
addString
(
elementName
)
,
fStringPool
.
addSymbol
(
"NMTOKEN"
)
,
true
,
false
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"export"
)
,
fStringPool
.
addString
(
"true"
)
,
fStringPool
.
addSymbol
(
"ENUMERATION"
)
,
false
,
false
)
;
fAttrList
.
endAttrList
(
)
;
elementIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"element"
)
,
fAttrList
,
handle
)
;
fDeferredDocumentImpl
.
appendChild
(
schemaIndex
,
elementIndex
)
;
}
int
archetypeIndex
=
getFirstChildElement
(
elementIndex
,
"archetype"
)
;
if
(
archetypeIndex
==
-
1
)
{
archetypeIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"archetype"
)
,
null
,
-
1
)
;
fDeferredDocumentImpl
.
insertBefore
(
elementIndex
,
archetypeIndex
,
getFirstChildElement
(
elementIndex
)
)
;
}
int
contentType
=
contentSpec
.
getType
(
)
;
String
contentTypeName
=
fStringPool
.
toString
(
contentType
)
;
if
(
contentTypeName
.
equals
(
"EMPTY"
)
)
{
int
attributeIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"content"
)
,
fStringPool
.
addString
(
"empty"
)
,
true
)
;
fDeferredDocumentImpl
.
setAttributeNode
(
archetypeIndex
,
attributeIndex
)
;
}
else
if
(
contentTypeName
.
equals
(
"ANY"
)
)
{
int
attributeIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"content"
)
,
fStringPool
.
addString
(
"any"
)
,
true
)
;
fDeferredDocumentImpl
.
setAttributeNode
(
archetypeIndex
,
attributeIndex
)
;
}
else
if
(
contentTypeName
.
equals
(
"CHILDREN"
)
)
{
int
attributeIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"content"
)
,
fStringPool
.
addString
(
"elemOnly"
)
,
false
)
;
fDeferredDocumentImpl
.
setAttributeNode
(
archetypeIndex
,
attributeIndex
)
;
attributeIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"order"
)
,
fStringPool
.
addString
(
"seq"
)
,
false
)
;
fDeferredDocumentImpl
.
setAttributeNode
(
archetypeIndex
,
attributeIndex
)
;
XMLContentSpecNode
node
=
new
XMLContentSpecNode
(
)
;
int
contentSpecIndex
=
contentSpec
.
getHandle
(
)
;
contentSpec
.
getNode
(
contentSpecIndex
,
node
)
;
Element
model
=
createContentModel
(
contentSpec
,
node
)
;
int
modelIndex
=
createDeferredContentModel
(
model
)
;
int
firstChildIndex
=
getFirstChildElement
(
archetypeIndex
)
;
fDeferredDocumentImpl
.
insertBefore
(
archetypeIndex
,
modelIndex
,
firstChildIndex
)
;
}
else
{
int
attributeIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"content"
)
,
fStringPool
.
addString
(
"mixed"
)
,
true
)
;
fDeferredDocumentImpl
.
setAttributeNode
(
archetypeIndex
,
attributeIndex
)
;
XMLContentSpecNode
node
=
new
XMLContentSpecNode
(
)
;
int
index
=
contentSpec
.
getHandle
(
)
;
contentSpec
.
getNode
(
index
,
node
)
;
if
(
node
.
type
!=
0
)
{
contentSpec
.
getNode
(
node
.
value
,
node
)
;
do
{
index
=
node
.
value
;
int
handle
=
fAttrList
.
startAttrList
(
)
;
contentSpec
.
getNode
(
node
.
otherValue
,
node
)
;
String
elementRefName
=
fStringPool
.
toString
(
node
.
value
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"ref"
)
,
fStringPool
.
addString
(
elementRefName
)
,
fStringPool
.
addSymbol
(
"NMTOKEN"
)
,
true
,
false
)
;
fAttrList
.
endAttrList
(
)
;
int
elementRefIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"element"
)
,
fAttrList
,
handle
)
;
fDeferredDocumentImpl
.
insertBefore
(
archetypeIndex
,
elementRefIndex
,
getFirstChildElement
(
archetypeIndex
,
"element"
)
)
;
contentSpec
.
getNode
(
index
,
node
)
;
}
while
(
node
.
type
!=
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
)
;
}
}
}
else
if
(
fDocumentImpl
!=
null
)
{
Element
schema
=
XUtil
.
getFirstChildElement
(
fDocumentType
,
"schema"
)
;
String
elementName
=
fStringPool
.
toString
(
elementTypeIndex
)
;
Element
element
=
XUtil
.
getFirstChildElement
(
schema
,
"element"
,
"name"
,
elementName
)
;
if
(
element
==
null
)
{
element
=
fDocument
.
createElement
(
"element"
)
;
element
.
setAttribute
(
"name"
,
elementName
)
;
element
.
setAttribute
(
"export"
,
"true"
)
;
(
(
AttrImpl
)
element
.
getAttributeNode
(
"export"
)
)
.
setSpecified
(
false
)
;
schema
.
appendChild
(
element
)
;
}
Element
archetype
=
XUtil
.
getFirstChildElement
(
element
,
"archetype"
)
;
if
(
archetype
==
null
)
{
archetype
=
fDocument
.
createElement
(
"archetype"
)
;
element
.
insertBefore
(
archetype
,
XUtil
.
getFirstChildElement
(
element
)
)
;
}
int
contentType
=
contentSpec
.
getType
(
)
;
String
contentTypeName
=
fStringPool
.
toString
(
contentType
)
;
if
(
contentTypeName
.
equals
(
"EMPTY"
)
)
{
archetype
.
setAttribute
(
"content"
,
"empty"
)
;
}
else
if
(
contentTypeName
.
equals
(
"ANY"
)
)
{
archetype
.
setAttribute
(
"content"
,
"any"
)
;
}
else
if
(
contentTypeName
.
equals
(
"CHILDREN"
)
)
{
archetype
.
setAttribute
(
"content"
,
"elemOnly"
)
;
(
(
AttrImpl
)
archetype
.
getAttributeNode
(
"content"
)
)
.
setSpecified
(
false
)
;
archetype
.
setAttribute
(
"order"
,
"seq"
)
;
(
(
AttrImpl
)
archetype
.
getAttributeNode
(
"order"
)
)
.
setSpecified
(
false
)
;
XMLContentSpecNode
node
=
new
XMLContentSpecNode
(
)
;
int
handle
=
contentSpec
.
getHandle
(
)
;
contentSpec
.
getNode
(
handle
,
node
)
;
Element
model
=
createContentModel
(
contentSpec
,
node
)
;
Element
firstChild
=
XUtil
.
getFirstChildElement
(
archetype
)
;
archetype
.
insertBefore
(
model
,
firstChild
)
;
}
else
{
archetype
.
setAttribute
(
"content"
,
"mixed"
)
;
XMLContentSpecNode
node
=
new
XMLContentSpecNode
(
)
;
int
handle
=
contentSpec
.
getHandle
(
)
;
contentSpec
.
getNode
(
handle
,
node
)
;
if
(
node
.
type
!=
0
)
{
contentSpec
.
getNode
(
node
.
value
,
node
)
;
do
{
handle
=
node
.
value
;
Element
elementRef
=
fDocument
.
createElement
(
"element"
)
;
contentSpec
.
getNode
(
node
.
otherValue
,
node
)
;
String
elementRefName
=
fStringPool
.
toString
(
node
.
value
)
;
elementRef
.
setAttribute
(
"ref"
,
elementRefName
)
;
archetype
.
insertBefore
(
elementRef
,
XUtil
.
getFirstChildElement
(
archetype
,
"element"
)
)
;
contentSpec
.
getNode
(
handle
,
node
)
;
}
while
(
node
.
type
!=
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
)
;
}
}
}
}
}
public
void
attlistDecl
(
int
elementTypeIndex
,
int
attrNameIndex
,
int
attType
,
String
enumString
,
int
attDefaultType
,
int
attDefaultValue
)
throws
Exception
{
if
(
DEBUG_ATTLIST_DECL
)
{
System
.
out
.
println
(
"attlistDecl("
+
fStringPool
.
toString
(
elementTypeIndex
)
+
", "
+
fStringPool
.
toString
(
attrNameIndex
)
+
", "
+
fStringPool
.
toString
(
attType
)
+
", "
+
enumString
+
", "
+
fStringPool
.
toString
(
attDefaultType
)
+
", "
+
fStringPool
.
toString
(
attDefaultValue
)
+
")"
)
;
}
if
(
fDeferredDocumentImpl
!=
null
)
{
if
(
attDefaultValue
!=
-
1
)
{
if
(
DEBUG_ATTLIST_DECL
)
{
System
.
out
.
println
(
"  adding default attribute value: "
+
fStringPool
.
toString
(
attDefaultValue
)
)
;
}
int
elementDefIndex
=
fDeferredDocumentImpl
.
lookupElementDefinition
(
elementTypeIndex
)
;
if
(
elementDefIndex
==
-
1
)
{
elementDefIndex
=
fDeferredDocumentImpl
.
createElementDefinition
(
elementTypeIndex
)
;
fDeferredDocumentImpl
.
appendChild
(
fDocumentTypeIndex
,
elementDefIndex
)
;
}
int
attrIndex
=
fDeferredDocumentImpl
.
createAttribute
(
attrNameIndex
,
attDefaultValue
,
false
)
;
fDeferredDocumentImpl
.
appendChild
(
elementDefIndex
,
attrIndex
)
;
}
if
(
fGrammarAccess
)
{
int
schemaIndex
=
getFirstChildElement
(
fDocumentTypeIndex
,
"schema"
)
;
String
elementName
=
fStringPool
.
toString
(
elementTypeIndex
)
;
int
elementIndex
=
getFirstChildElement
(
schemaIndex
,
"element"
,
"name"
,
elementName
)
;
if
(
elementIndex
==
-
1
)
{
int
handle
=
fAttrList
.
startAttrList
(
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"name"
)
,
fStringPool
.
addString
(
elementName
)
,
fStringPool
.
addSymbol
(
"NMTOKEN"
)
,
true
,
false
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"export"
)
,
fStringPool
.
addString
(
"true"
)
,
fStringPool
.
addSymbol
(
"ENUMERATION"
)
,
false
,
false
)
;
fAttrList
.
endAttrList
(
)
;
elementIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"element"
)
,
fAttrList
,
handle
)
;
fDeferredDocumentImpl
.
appendChild
(
schemaIndex
,
elementIndex
)
;
}
int
archetypeIndex
=
getFirstChildElement
(
elementIndex
,
"archetype"
)
;
if
(
archetypeIndex
==
-
1
)
{
archetypeIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"archetype"
)
,
null
,
-
1
)
;
fDeferredDocumentImpl
.
insertBefore
(
elementIndex
,
archetypeIndex
,
getFirstChildElement
(
elementIndex
)
)
;
}
String
attributeName
=
fStringPool
.
toString
(
attrNameIndex
)
;
int
attributeIndex
=
getFirstChildElement
(
elementIndex
,
"attribute"
,
"name"
,
attributeName
)
;
if
(
attributeIndex
==
-
1
)
{
int
handle
=
fAttrList
.
startAttrList
(
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"name"
)
,
fStringPool
.
addString
(
attributeName
)
,
fStringPool
.
addSymbol
(
"NMTOKEN"
)
,
true
,
false
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"minOccurs"
)
,
fStringPool
.
addString
(
"0"
)
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
false
,
false
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"maxOccurs"
)
,
fStringPool
.
addString
(
"1"
)
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
false
,
false
)
;
fAttrList
.
endAttrList
(
)
;
attributeIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"attribute"
)
,
fAttrList
,
handle
)
;
fDeferredDocumentImpl
.
appendChild
(
archetypeIndex
,
attributeIndex
)
;
String
attributeTypeName
=
fStringPool
.
toString
(
attType
)
;
if
(
attributeTypeName
.
equals
(
"CDATA"
)
)
{
int
typeAttrIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"type"
)
,
fStringPool
.
addString
(
"string"
)
,
false
)
;
fDeferredDocumentImpl
.
setAttributeNode
(
attributeIndex
,
typeAttrIndex
)
;
}
else
if
(
attributeTypeName
.
equals
(
"ENUMERATION"
)
)
{
int
typeAttrIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"type"
)
,
fStringPool
.
addString
(
"NMTOKEN"
)
,
true
)
;
fDeferredDocumentImpl
.
setAttributeNode
(
attributeIndex
,
typeAttrIndex
)
;
int
enumerationIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"enumeration"
)
,
null
,
-
1
)
;
fDeferredDocumentImpl
.
appendChild
(
attributeIndex
,
enumerationIndex
)
;
String
tokenizerString
=
enumString
.
substring
(
1
,
enumString
.
length
(
)
-
1
)
;
StringTokenizer
tokenizer
=
new
StringTokenizer
(
tokenizerString
,
"|"
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
int
literalIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"literal"
)
,
null
,
-
1
)
;
int
textIndex
=
fDeferredDocumentImpl
.
createTextNode
(
fStringPool
.
addString
(
tokenizer
.
nextToken
(
)
)
,
false
)
;
fDeferredDocumentImpl
.
appendChild
(
literalIndex
,
textIndex
)
;
fDeferredDocumentImpl
.
appendChild
(
enumerationIndex
,
literalIndex
)
;
}
}
else
{
int
typeAttrIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"type"
)
,
fStringPool
.
addString
(
attributeTypeName
)
,
true
)
;
fDeferredDocumentImpl
.
setAttributeNode
(
attributeIndex
,
typeAttrIndex
)
;
}
boolean
fixed
=
false
;
if
(
attDefaultType
!=
-
1
)
{
String
attributeDefaultTypeName
=
fStringPool
.
toString
(
attDefaultType
)
;
if
(
attributeDefaultTypeName
.
equals
(
"#REQUIRED"
)
)
{
int
minOccursAttrIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"minOccurs"
)
,
fStringPool
.
addString
(
"1"
)
,
true
)
;
int
oldMinOccursAttrIndex
=
fDeferredDocumentImpl
.
setAttributeNode
(
attributeIndex
,
minOccursAttrIndex
)
;
fStringPool
.
releaseString
(
fDeferredDocumentImpl
.
getNodeValue
(
oldMinOccursAttrIndex
)
)
;
}
else
if
(
attributeDefaultTypeName
.
equals
(
"#FIXED"
)
)
{
fixed
=
true
;
int
fixedAttrIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"fixed"
)
,
attDefaultValue
,
true
)
;
fDeferredDocumentImpl
.
setAttributeNode
(
attributeIndex
,
fixedAttrIndex
)
;
}
}
if
(
!
fixed
&&
attDefaultValue
!=
-
1
)
{
int
defaultAttrIndex
=
fDeferredDocumentImpl
.
createAttribute
(
fStringPool
.
addSymbol
(
"default"
)
,
attDefaultValue
,
true
)
;
fDeferredDocumentImpl
.
setAttributeNode
(
attributeIndex
,
defaultAttrIndex
)
;
}
}
}
}
else
if
(
fDocumentImpl
!=
null
)
{
if
(
attDefaultValue
!=
-
1
)
{
if
(
DEBUG_ATTLIST_DECL
)
{
System
.
out
.
println
(
"  adding default attribute value: "
+
fStringPool
.
toString
(
attDefaultValue
)
)
;
}
String
elementName
=
fStringPool
.
toString
(
elementTypeIndex
)
;
NamedNodeMap
elements
=
(
(
DocumentTypeImpl
)
fDocumentType
)
.
getElements
(
)
;
ElementDefinitionImpl
elementDef
=
(
ElementDefinitionImpl
)
elements
.
getNamedItem
(
elementName
)
;
if
(
elementDef
==
null
)
{
elementDef
=
fDocumentImpl
.
createElementDefinition
(
elementName
)
;
(
(
DocumentTypeImpl
)
fDocumentType
)
.
getElements
(
)
.
setNamedItem
(
elementDef
)
;
}
String
attrName
=
fStringPool
.
toString
(
attrNameIndex
)
;
String
attrValue
=
fStringPool
.
toString
(
attDefaultValue
)
;
AttrImpl
attr
=
(
AttrImpl
)
fDocumentImpl
.
createAttribute
(
attrName
)
;
attr
.
setValue
(
attrValue
)
;
attr
.
setSpecified
(
false
)
;
elementDef
.
getAttributes
(
)
.
setNamedItem
(
attr
)
;
}
if
(
fGrammarAccess
)
{
Element
schema
=
XUtil
.
getFirstChildElement
(
fDocumentType
,
"schema"
)
;
String
elementName
=
fStringPool
.
toString
(
elementTypeIndex
)
;
Element
element
=
XUtil
.
getFirstChildElement
(
schema
,
"element"
,
"name"
,
elementName
)
;
if
(
element
==
null
)
{
element
=
fDocument
.
createElement
(
"element"
)
;
element
.
setAttribute
(
"name"
,
elementName
)
;
element
.
setAttribute
(
"export"
,
"true"
)
;
(
(
AttrImpl
)
element
.
getAttributeNode
(
"export"
)
)
.
setSpecified
(
false
)
;
schema
.
appendChild
(
element
)
;
}
Element
archetype
=
XUtil
.
getFirstChildElement
(
element
,
"archetype"
)
;
if
(
archetype
==
null
)
{
archetype
=
fDocument
.
createElement
(
"archetype"
)
;
element
.
insertBefore
(
archetype
,
XUtil
.
getFirstChildElement
(
element
)
)
;
}
String
attributeName
=
fStringPool
.
toString
(
attrNameIndex
)
;
Element
attribute
=
XUtil
.
getFirstChildElement
(
element
,
"attribute"
,
"name"
,
attributeName
)
;
if
(
attribute
==
null
)
{
attribute
=
fDocument
.
createElement
(
"attribute"
)
;
attribute
.
setAttribute
(
"name"
,
attributeName
)
;
attribute
.
setAttribute
(
"minOccurs"
,
"0"
)
;
(
(
AttrImpl
)
attribute
.
getAttributeNode
(
"minOccurs"
)
)
.
setSpecified
(
false
)
;
attribute
.
setAttribute
(
"maxOccurs"
,
"1"
)
;
(
(
AttrImpl
)
attribute
.
getAttributeNode
(
"maxOccurs"
)
)
.
setSpecified
(
false
)
;
archetype
.
appendChild
(
attribute
)
;
String
attributeTypeName
=
fStringPool
.
toString
(
attType
)
;
if
(
attributeTypeName
.
equals
(
"CDATA"
)
)
{
attribute
.
setAttribute
(
"type"
,
"string"
)
;
(
(
AttrImpl
)
attribute
.
getAttributeNode
(
"type"
)
)
.
setSpecified
(
false
)
;
}
else
if
(
attributeTypeName
.
equals
(
"ENUMERATION"
)
)
{
attribute
.
setAttribute
(
"type"
,
"NMTOKEN"
)
;
Element
enumeration
=
fDocument
.
createElement
(
"enumeration"
)
;
attribute
.
appendChild
(
enumeration
)
;
String
tokenizerString
=
enumString
.
substring
(
1
,
enumString
.
length
(
)
-
1
)
;
StringTokenizer
tokenizer
=
new
StringTokenizer
(
tokenizerString
,
"|"
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
Element
literal
=
fDocument
.
createElement
(
"literal"
)
;
Text
text
=
fDocument
.
createTextNode
(
tokenizer
.
nextToken
(
)
)
;
literal
.
appendChild
(
text
)
;
enumeration
.
appendChild
(
literal
)
;
}
}
else
{
attribute
.
setAttribute
(
"type"
,
attributeTypeName
)
;
}
boolean
fixed
=
false
;
if
(
attDefaultType
!=
-
1
)
{
String
attributeDefaultTypeName
=
fStringPool
.
toString
(
attDefaultType
)
;
if
(
attributeDefaultTypeName
.
equals
(
"#REQUIRED"
)
)
{
attribute
.
setAttribute
(
"minOccurs"
,
"1"
)
;
(
(
AttrImpl
)
attribute
.
getAttributeNode
(
"minOccurs"
)
)
.
setSpecified
(
true
)
;
}
else
if
(
attributeDefaultTypeName
.
equals
(
"#FIXED"
)
)
{
fixed
=
true
;
String
fixedValue
=
fStringPool
.
toString
(
attDefaultValue
)
;
attribute
.
setAttribute
(
"fixed"
,
fixedValue
)
;
}
}
if
(
!
fixed
&&
attDefaultValue
!=
-
1
)
{
String
defaultValue
=
fStringPool
.
toString
(
attDefaultValue
)
;
attribute
.
setAttribute
(
"default"
,
defaultValue
)
;
}
}
}
}
}
public
void
internalPEDecl
(
int
entityName
,
int
entityValue
)
throws
Exception
{
}
public
void
externalPEDecl
(
int
entityName
,
int
publicId
,
int
systemId
)
throws
Exception
{
}
public
void
internalEntityDecl
(
int
entityNameIndex
,
int
entityValueIndex
)
throws
Exception
{
if
(
fDeferredDocumentImpl
!=
null
)
{
if
(
fDocumentTypeIndex
==
-
1
)
return
;
int
newEntityIndex
=
fDeferredDocumentImpl
.
createEntity
(
entityNameIndex
,
-
1
,
-
1
,
-
1
)
;
fDeferredDocumentImpl
.
appendChild
(
fDocumentTypeIndex
,
newEntityIndex
)
;
if
(
fGrammarAccess
)
{
int
schemaIndex
=
getFirstChildElement
(
fDocumentTypeIndex
,
"schema"
)
;
String
entityName
=
fStringPool
.
toString
(
entityNameIndex
)
;
int
textEntityIndex
=
getFirstChildElement
(
schemaIndex
,
"textEntity"
,
"name"
,
entityName
)
;
if
(
textEntityIndex
==
-
1
)
{
int
handle
=
fAttrList
.
startAttrList
(
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"name"
)
,
fStringPool
.
addString
(
entityName
)
,
fStringPool
.
addSymbol
(
"NMTOKEN"
)
,
true
,
false
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"export"
)
,
fStringPool
.
addString
(
"true"
)
,
fStringPool
.
addSymbol
(
"ENUMERATION"
)
,
false
,
false
)
;
fAttrList
.
endAttrList
(
)
;
textEntityIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"textEntity"
)
,
fAttrList
,
handle
)
;
fDeferredDocumentImpl
.
appendChild
(
schemaIndex
,
textEntityIndex
)
;
int
textIndex
=
fDeferredDocumentImpl
.
createTextNode
(
entityValueIndex
,
false
)
;
fDeferredDocumentImpl
.
appendChild
(
textEntityIndex
,
textIndex
)
;
}
}
}
else
if
(
fDocumentImpl
!=
null
)
{
if
(
fDocumentType
==
null
)
return
;
String
entityName
=
fStringPool
.
toString
(
entityNameIndex
)
;
Entity
entity
=
fDocumentImpl
.
createEntity
(
entityName
)
;
fDocumentType
.
getEntities
(
)
.
setNamedItem
(
entity
)
;
if
(
fGrammarAccess
)
{
Element
schema
=
XUtil
.
getFirstChildElement
(
fDocumentType
,
"schema"
)
;
Element
textEntity
=
XUtil
.
getFirstChildElement
(
schema
,
"textEntity"
,
"name"
,
entityName
)
;
if
(
textEntity
==
null
)
{
textEntity
=
fDocument
.
createElement
(
"textEntity"
)
;
textEntity
.
setAttribute
(
"name"
,
entityName
)
;
textEntity
.
setAttribute
(
"export"
,
"true"
)
;
(
(
AttrImpl
)
textEntity
.
getAttributeNode
(
"export"
)
)
.
setSpecified
(
false
)
;
String
entityValue
=
fStringPool
.
toString
(
entityValueIndex
)
;
Text
value
=
fDocument
.
createTextNode
(
entityValue
)
;
textEntity
.
appendChild
(
value
)
;
schema
.
appendChild
(
textEntity
)
;
}
}
}
}
public
void
externalEntityDecl
(
int
entityNameIndex
,
int
publicIdIndex
,
int
systemIdIndex
)
throws
Exception
{
if
(
fDeferredDocumentImpl
!=
null
)
{
int
newEntityIndex
=
fDeferredDocumentImpl
.
createEntity
(
entityNameIndex
,
publicIdIndex
,
systemIdIndex
,
-
1
)
;
fDeferredDocumentImpl
.
appendChild
(
fDocumentTypeIndex
,
newEntityIndex
)
;
if
(
fGrammarAccess
)
{
int
schemaIndex
=
getFirstChildElement
(
fDocumentTypeIndex
,
"schema"
)
;
String
entityName
=
fStringPool
.
toString
(
entityNameIndex
)
;
int
externalEntityIndex
=
getFirstChildElement
(
schemaIndex
,
"externalEntity"
,
"name"
,
entityName
)
;
if
(
externalEntityIndex
==
-
1
)
{
int
handle
=
fAttrList
.
startAttrList
(
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"name"
)
,
fStringPool
.
addString
(
entityName
)
,
fStringPool
.
addSymbol
(
"NMTOKEN"
)
,
true
,
false
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"export"
)
,
fStringPool
.
addString
(
"true"
)
,
fStringPool
.
addSymbol
(
"ENUMERATION"
)
,
false
,
false
)
;
if
(
publicIdIndex
!=
-
1
)
{
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"public"
)
,
publicIdIndex
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
true
,
false
)
;
}
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"system"
)
,
systemIdIndex
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
true
,
false
)
;
fAttrList
.
endAttrList
(
)
;
externalEntityIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"externalEntity"
)
,
fAttrList
,
handle
)
;
fDeferredDocumentImpl
.
appendChild
(
schemaIndex
,
externalEntityIndex
)
;
}
}
}
else
if
(
fDocumentImpl
!=
null
)
{
String
entityName
=
fStringPool
.
toString
(
entityNameIndex
)
;
String
publicId
=
fStringPool
.
toString
(
publicIdIndex
)
;
String
systemId
=
fStringPool
.
toString
(
systemIdIndex
)
;
EntityImpl
entity
=
(
EntityImpl
)
fDocumentImpl
.
createEntity
(
entityName
)
;
if
(
publicIdIndex
!=
-
1
)
{
entity
.
setPublicId
(
publicId
)
;
}
entity
.
setSystemId
(
systemId
)
;
fDocumentType
.
getEntities
(
)
.
setNamedItem
(
entity
)
;
if
(
fGrammarAccess
)
{
Element
schema
=
XUtil
.
getFirstChildElement
(
fDocumentType
,
"schema"
)
;
Element
externalEntity
=
XUtil
.
getFirstChildElement
(
schema
,
"externalEntity"
,
"name"
,
entityName
)
;
if
(
externalEntity
==
null
)
{
externalEntity
=
fDocument
.
createElement
(
"externalEntity"
)
;
externalEntity
.
setAttribute
(
"name"
,
entityName
)
;
externalEntity
.
setAttribute
(
"export"
,
"true"
)
;
(
(
AttrImpl
)
externalEntity
.
getAttributeNode
(
"export"
)
)
.
setSpecified
(
false
)
;
if
(
publicIdIndex
!=
-
1
)
{
externalEntity
.
setAttribute
(
"public"
,
publicId
)
;
}
externalEntity
.
setAttribute
(
"system"
,
systemId
)
;
schema
.
appendChild
(
externalEntity
)
;
}
}
}
}
public
void
unparsedEntityDecl
(
int
entityNameIndex
,
int
publicIdIndex
,
int
systemIdIndex
,
int
notationNameIndex
)
throws
Exception
{
if
(
fDeferredDocumentImpl
!=
null
)
{
int
newEntityIndex
=
fDeferredDocumentImpl
.
createEntity
(
entityNameIndex
,
publicIdIndex
,
systemIdIndex
,
notationNameIndex
)
;
fDeferredDocumentImpl
.
appendChild
(
fDocumentTypeIndex
,
newEntityIndex
)
;
if
(
fGrammarAccess
)
{
int
schemaIndex
=
getFirstChildElement
(
fDocumentTypeIndex
,
"schema"
)
;
String
entityName
=
fStringPool
.
toString
(
entityNameIndex
)
;
int
unparsedEntityIndex
=
getFirstChildElement
(
schemaIndex
,
"unparsedEntity"
,
"name"
,
entityName
)
;
if
(
unparsedEntityIndex
==
-
1
)
{
int
handle
=
fAttrList
.
startAttrList
(
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"name"
)
,
fStringPool
.
addString
(
entityName
)
,
fStringPool
.
addSymbol
(
"NMTOKEN"
)
,
true
,
false
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"export"
)
,
fStringPool
.
addString
(
"true"
)
,
fStringPool
.
addSymbol
(
"ENUMERATION"
)
,
false
,
false
)
;
if
(
publicIdIndex
!=
-
1
)
{
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"public"
)
,
publicIdIndex
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
true
,
false
)
;
}
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"system"
)
,
systemIdIndex
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
true
,
false
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"notation"
)
,
fStringPool
.
addString
(
fStringPool
.
toString
(
notationNameIndex
)
)
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
true
,
false
)
;
fAttrList
.
endAttrList
(
)
;
unparsedEntityIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"unparsedEntity"
)
,
fAttrList
,
handle
)
;
fDeferredDocumentImpl
.
appendChild
(
schemaIndex
,
unparsedEntityIndex
)
;
}
}
}
else
if
(
fDocumentImpl
!=
null
)
{
String
entityName
=
fStringPool
.
toString
(
entityNameIndex
)
;
String
publicId
=
fStringPool
.
toString
(
publicIdIndex
)
;
String
systemId
=
fStringPool
.
toString
(
systemIdIndex
)
;
String
notationName
=
fStringPool
.
toString
(
notationNameIndex
)
;
EntityImpl
entity
=
(
EntityImpl
)
fDocumentImpl
.
createEntity
(
entityName
)
;
if
(
publicIdIndex
!=
-
1
)
{
entity
.
setPublicId
(
publicId
)
;
}
entity
.
setSystemId
(
systemId
)
;
entity
.
setNotationName
(
notationName
)
;
fDocumentType
.
getEntities
(
)
.
setNamedItem
(
entity
)
;
if
(
fGrammarAccess
)
{
Element
schema
=
XUtil
.
getFirstChildElement
(
fDocumentType
,
"schema"
)
;
Element
unparsedEntity
=
XUtil
.
getFirstChildElement
(
schema
,
"unparsedEntity"
,
"name"
,
entityName
)
;
if
(
unparsedEntity
==
null
)
{
unparsedEntity
=
fDocument
.
createElement
(
"unparsedEntity"
)
;
unparsedEntity
.
setAttribute
(
"name"
,
entityName
)
;
unparsedEntity
.
setAttribute
(
"export"
,
"true"
)
;
(
(
AttrImpl
)
unparsedEntity
.
getAttributeNode
(
"export"
)
)
.
setSpecified
(
false
)
;
if
(
publicIdIndex
!=
-
1
)
{
unparsedEntity
.
setAttribute
(
"public"
,
publicId
)
;
}
unparsedEntity
.
setAttribute
(
"system"
,
systemId
)
;
unparsedEntity
.
setAttribute
(
"notation"
,
notationName
)
;
schema
.
appendChild
(
unparsedEntity
)
;
}
}
}
}
public
void
notationDecl
(
int
notationNameIndex
,
int
publicIdIndex
,
int
systemIdIndex
)
throws
Exception
{
if
(
fDeferredDocumentImpl
!=
null
)
{
int
newNotationIndex
=
fDeferredDocumentImpl
.
createNotation
(
notationNameIndex
,
publicIdIndex
,
systemIdIndex
)
;
fDeferredDocumentImpl
.
appendChild
(
fDocumentTypeIndex
,
newNotationIndex
)
;
if
(
fGrammarAccess
)
{
int
schemaIndex
=
getFirstChildElement
(
fDocumentTypeIndex
,
"schema"
)
;
String
notationName
=
fStringPool
.
toString
(
notationNameIndex
)
;
int
notationIndex
=
getFirstChildElement
(
schemaIndex
,
"notation"
,
"name"
,
notationName
)
;
if
(
notationIndex
==
-
1
)
{
int
handle
=
fAttrList
.
startAttrList
(
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"name"
)
,
fStringPool
.
addString
(
notationName
)
,
fStringPool
.
addSymbol
(
"NMTOKEN"
)
,
true
,
false
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"export"
)
,
fStringPool
.
addString
(
"true"
)
,
fStringPool
.
addSymbol
(
"ENUMERATION"
)
,
false
,
false
)
;
if
(
publicIdIndex
==
-
1
)
{
publicIdIndex
=
0
;
}
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"public"
)
,
publicIdIndex
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
true
,
false
)
;
if
(
systemIdIndex
!=
-
1
)
{
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
"system"
)
,
systemIdIndex
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
true
,
false
)
;
}
fAttrList
.
endAttrList
(
)
;
notationIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
"notation"
)
,
fAttrList
,
handle
)
;
fDeferredDocumentImpl
.
appendChild
(
schemaIndex
,
notationIndex
)
;
}
}
}
else
if
(
fDocumentImpl
!=
null
)
{
String
notationName
=
fStringPool
.
toString
(
notationNameIndex
)
;
String
publicId
=
fStringPool
.
toString
(
publicIdIndex
)
;
String
systemId
=
fStringPool
.
toString
(
systemIdIndex
)
;
NotationImpl
notationImpl
=
(
NotationImpl
)
fDocumentImpl
.
createNotation
(
notationName
)
;
notationImpl
.
setPublicId
(
publicId
)
;
if
(
systemIdIndex
!=
-
1
)
{
notationImpl
.
setSystemId
(
systemId
)
;
}
fDocumentType
.
getNotations
(
)
.
setNamedItem
(
notationImpl
)
;
if
(
fGrammarAccess
)
{
Element
schema
=
XUtil
.
getFirstChildElement
(
fDocumentType
,
"schema"
)
;
Element
notation
=
XUtil
.
getFirstChildElement
(
schema
,
"notation"
,
"name"
,
notationName
)
;
if
(
notation
==
null
)
{
notation
=
fDocument
.
createElement
(
"notation"
)
;
notation
.
setAttribute
(
"name"
,
notationName
)
;
notation
.
setAttribute
(
"export"
,
"true"
)
;
(
(
AttrImpl
)
notation
.
getAttributeNode
(
"export"
)
)
.
setSpecified
(
false
)
;
if
(
publicId
==
null
)
{
publicId
=
""
;
}
notation
.
setAttribute
(
"public"
,
publicId
)
;
if
(
systemIdIndex
!=
-
1
)
{
notation
.
setAttribute
(
"system"
,
systemId
)
;
}
schema
.
appendChild
(
notation
)
;
}
}
}
}
private
Element
createContentModel
(
XMLValidator
.
ContentSpec
contentSpec
,
XMLContentSpecNode
node
)
{
Element
model
=
createContentModel
(
contentSpec
,
node
,
null
)
;
return
model
;
}
private
Element
createContentModel
(
XMLValidator
.
ContentSpec
contentSpec
,
XMLContentSpecNode
node
,
Element
parent
)
{
int
minOccur
=
1
;
int
maxOccur
=
1
;
switch
(
node
.
type
)
{
case
XMLContentSpecNode
.
CONTENTSPECNODE_ONE_OR_MORE
:
{
minOccur
=
1
;
maxOccur
=
-
1
;
contentSpec
.
getNode
(
node
.
value
,
node
)
;
break
;
}
case
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_MORE
:
{
minOccur
=
0
;
maxOccur
=
-
1
;
contentSpec
.
getNode
(
node
.
value
,
node
)
;
break
;
}
case
XMLContentSpecNode
.
CONTENTSPECNODE_ZERO_OR_ONE
:
{
minOccur
=
0
;
maxOccur
=
1
;
contentSpec
.
getNode
(
node
.
value
,
node
)
;
break
;
}
}
int
nodeType
=
node
.
type
;
switch
(
nodeType
)
{
case
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
:
case
XMLContentSpecNode
.
CONTENTSPECNODE_SEQ
:
{
int
leftIndex
=
node
.
value
;
int
rightIndex
=
node
.
otherValue
;
contentSpec
.
getNode
(
leftIndex
,
node
)
;
Element
left
=
createContentModel
(
contentSpec
,
node
,
parent
)
;
contentSpec
.
getNode
(
rightIndex
,
node
)
;
Element
right
=
createContentModel
(
contentSpec
,
node
,
null
)
;
String
type
=
nodeType
==
XMLContentSpecNode
.
CONTENTSPECNODE_CHOICE
?
"choice"
:
"seq"
;
Element
model
=
left
;
if
(
!
left
.
getAttribute
(
"order"
)
.
equals
(
type
)
)
{
String
minOccurs
=
left
.
getAttribute
(
"minOccurs"
)
;
String
maxOccurs
=
left
.
getAttribute
(
"maxOccurs"
)
;
if
(
parent
==
null
||
(
(
minOccurs
.
equals
(
"1"
)
||
minOccurs
.
length
(
)
==
0
)
&&
(
maxOccurs
.
equals
(
"1"
)
||
maxOccurs
.
length
(
)
==
0
)
)
)
{
model
=
fDocument
.
createElement
(
"group"
)
;
model
.
setAttribute
(
"collection"
,
"no"
)
;
(
(
AttrImpl
)
model
.
getAttributeNode
(
"collection"
)
)
.
setSpecified
(
false
)
;
model
.
setAttribute
(
"order"
,
type
)
;
if
(
type
.
equals
(
"seq"
)
)
{
(
(
AttrImpl
)
model
.
getAttributeNode
(
"order"
)
)
.
setSpecified
(
false
)
;
}
model
.
appendChild
(
left
)
;
}
else
{
model
=
parent
;
}
}
setOccurrenceCount
(
model
,
minOccur
,
maxOccur
)
;
model
.
appendChild
(
right
)
;
return
model
;
}
case
XMLContentSpecNode
.
CONTENTSPECNODE_LEAF
:
{
String
name
=
fStringPool
.
toString
(
node
.
value
)
;
Element
leaf
=
fDocument
.
createElement
(
"element"
)
;
leaf
.
setAttribute
(
"ref"
,
name
)
;
setOccurrenceCount
(
leaf
,
minOccur
,
maxOccur
)
;
return
leaf
;
}
}
return
null
;
}
private
void
setOccurrenceCount
(
Element
model
,
int
minOccur
,
int
maxOccur
)
{
model
.
setAttribute
(
"minOccurs"
,
Integer
.
toString
(
minOccur
)
)
;
if
(
minOccur
==
1
)
{
(
(
AttrImpl
)
model
.
getAttributeNode
(
"minOccurs"
)
)
.
setSpecified
(
false
)
;
}
if
(
maxOccur
==
-
1
)
{
model
.
setAttribute
(
"maxOccurs"
,
"*"
)
;
}
else
if
(
maxOccur
!=
1
)
{
model
.
setAttribute
(
"maxOccurs"
,
Integer
.
toString
(
maxOccur
)
)
;
}
}
private
int
getFirstChildElement
(
int
nodeIndex
)
{
int
childIndex
=
fDeferredDocumentImpl
.
getFirstChild
(
nodeIndex
)
;
while
(
childIndex
!=
-
1
)
{
if
(
fDeferredDocumentImpl
.
getNodeType
(
childIndex
)
==
Node
.
ELEMENT_NODE
)
{
return
childIndex
;
}
childIndex
=
fDeferredDocumentImpl
.
getNextSibling
(
childIndex
)
;
}
return
-
1
;
}
private
int
getNextSiblingElement
(
int
nodeIndex
)
{
int
siblingIndex
=
fDeferredDocumentImpl
.
getNextSibling
(
nodeIndex
)
;
while
(
siblingIndex
!=
-
1
)
{
if
(
fDeferredDocumentImpl
.
getNodeType
(
siblingIndex
)
==
Node
.
ELEMENT_NODE
)
{
return
siblingIndex
;
}
siblingIndex
=
fDeferredDocumentImpl
.
getNextSibling
(
siblingIndex
)
;
}
return
-
1
;
}
private
int
getFirstChildElement
(
int
nodeIndex
,
String
elementName
)
{
int
childIndex
=
getFirstChildElement
(
nodeIndex
)
;
if
(
childIndex
!=
-
1
)
{
while
(
childIndex
!=
-
1
)
{
String
nodeName
=
fDeferredDocumentImpl
.
getNodeNameString
(
childIndex
)
;
if
(
fDeferredDocumentImpl
.
getNodeNameString
(
childIndex
)
.
equals
(
elementName
)
)
{
return
childIndex
;
}
childIndex
=
getNextSiblingElement
(
childIndex
)
;
}
}
return
-
1
;
}
private
int
getNextSiblingElement
(
int
nodeIndex
,
String
elementName
)
{
int
siblingIndex
=
getNextSiblingElement
(
nodeIndex
)
;
if
(
siblingIndex
!=
-
1
)
{
while
(
siblingIndex
!=
-
1
)
{
String
nodeName
=
fDeferredDocumentImpl
.
getNodeNameString
(
siblingIndex
)
;
if
(
nodeName
.
equals
(
elementName
)
)
{
return
siblingIndex
;
}
siblingIndex
=
getNextSiblingElement
(
siblingIndex
)
;
}
}
return
-
1
;
}
private
int
getFirstChildElement
(
int
nodeIndex
,
String
elemName
,
String
attrName
,
String
attrValue
)
{
int
childIndex
=
getFirstChildElement
(
nodeIndex
,
elemName
)
;
if
(
childIndex
!=
-
1
)
{
while
(
childIndex
!=
-
1
)
{
int
attrIndex
=
fDeferredDocumentImpl
.
getNodeValue
(
childIndex
)
;
while
(
attrIndex
!=
-
1
)
{
String
nodeName
=
fDeferredDocumentImpl
.
getNodeNameString
(
attrIndex
)
;
if
(
nodeName
.
equals
(
attrName
)
)
{
int
textIndex
=
fDeferredDocumentImpl
.
getFirstChild
(
attrIndex
)
;
String
nodeValue
=
fDeferredDocumentImpl
.
getNodeValueString
(
textIndex
)
;
if
(
nodeValue
.
equals
(
attrValue
)
)
{
return
childIndex
;
}
}
attrIndex
=
fDeferredDocumentImpl
.
getNextSibling
(
attrIndex
)
;
}
childIndex
=
getNextSiblingElement
(
childIndex
,
elemName
)
;
}
}
return
-
1
;
}
private
int
getNextSiblingElement
(
int
nodeIndex
,
String
elemName
,
String
attrName
,
String
attrValue
)
{
int
siblingIndex
=
getNextSiblingElement
(
nodeIndex
,
elemName
)
;
if
(
siblingIndex
!=
-
1
)
{
int
attributeNameIndex
=
fStringPool
.
addSymbol
(
attrName
)
;
while
(
siblingIndex
!=
-
1
)
{
int
attrIndex
=
fDeferredDocumentImpl
.
getNodeValue
(
siblingIndex
)
;
while
(
attrIndex
!=
-
1
)
{
int
attrValueIndex
=
fDeferredDocumentImpl
.
getNodeValue
(
attrIndex
)
;
if
(
attrValue
.
equals
(
fStringPool
.
toString
(
attrValueIndex
)
)
)
{
return
siblingIndex
;
}
attrIndex
=
fDeferredDocumentImpl
.
getNextSibling
(
attrIndex
)
;
}
siblingIndex
=
getNextSiblingElement
(
siblingIndex
,
elemName
)
;
}
}
return
-
1
;
}
private
void
copyInto
(
Node
src
,
int
destIndex
)
throws
Exception
{
boolean
domimpl
=
src
!=
null
&&
src
instanceof
DocumentImpl
;
Node
start
=
src
;
Node
parent
=
src
;
Node
place
=
src
;
while
(
place
!=
null
)
{
int
nodeIndex
=
-
1
;
short
type
=
place
.
getNodeType
(
)
;
switch
(
type
)
{
case
Node
.
CDATA_SECTION_NODE
:
{
boolean
ignorable
=
domimpl
&&
(
(
TextImpl
)
place
)
.
isIgnorableWhitespace
(
)
;
nodeIndex
=
fDeferredDocumentImpl
.
createCDATASection
(
fStringPool
.
addString
(
place
.
getNodeValue
(
)
)
,
ignorable
)
;
break
;
}
case
Node
.
COMMENT_NODE
:
{
nodeIndex
=
fDeferredDocumentImpl
.
createComment
(
fStringPool
.
addString
(
place
.
getNodeValue
(
)
)
)
;
break
;
}
case
Node
.
ELEMENT_NODE
:
{
XMLAttrList
attrList
=
null
;
int
handle
=
-
1
;
NamedNodeMap
attrs
=
place
.
getAttributes
(
)
;
if
(
attrs
!=
null
)
{
int
length
=
attrs
.
getLength
(
)
;
if
(
length
>
0
)
{
handle
=
fAttrList
.
startAttrList
(
)
;
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
Attr
attr
=
(
Attr
)
attrs
.
item
(
i
)
;
String
attrName
=
attr
.
getNodeName
(
)
;
String
attrValue
=
attr
.
getNodeValue
(
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
attrName
)
,
fStringPool
.
addString
(
attrValue
)
,
fStringPool
.
addSymbol
(
"CDATA"
)
,
attr
.
getSpecified
(
)
,
false
)
;
}
fAttrList
.
endAttrList
(
)
;
attrList
=
fAttrList
;
}
}
nodeIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
place
.
getNodeName
(
)
)
,
attrList
,
handle
)
;
break
;
}
case
Node
.
ENTITY_REFERENCE_NODE
:
{
nodeIndex
=
fDeferredDocumentImpl
.
createEntityReference
(
fStringPool
.
addSymbol
(
place
.
getNodeName
(
)
)
)
;
break
;
}
case
Node
.
PROCESSING_INSTRUCTION_NODE
:
{
nodeIndex
=
fDeferredDocumentImpl
.
createProcessingInstruction
(
fStringPool
.
addSymbol
(
place
.
getNodeName
(
)
)
,
fStringPool
.
addString
(
place
.
getNodeValue
(
)
)
)
;
break
;
}
case
Node
.
TEXT_NODE
:
{
boolean
ignorable
=
domimpl
&&
(
(
TextImpl
)
place
)
.
isIgnorableWhitespace
(
)
;
nodeIndex
=
fDeferredDocumentImpl
.
createTextNode
(
fStringPool
.
addString
(
place
.
getNodeValue
(
)
)
,
ignorable
)
;
break
;
}
default
:
{
throw
new
IllegalArgumentException
(
"can't copy node type, "
+
type
+
" ("
+
place
.
getNodeName
(
)
+
')'
)
;
}
}
fDeferredDocumentImpl
.
appendChild
(
destIndex
,
nodeIndex
)
;
if
(
place
.
hasChildNodes
(
)
)
{
parent
=
place
;
place
=
place
.
getFirstChild
(
)
;
destIndex
=
nodeIndex
;
}
else
{
place
=
place
.
getNextSibling
(
)
;
while
(
place
==
null
&&
parent
!=
start
)
{
place
=
parent
.
getNextSibling
(
)
;
parent
=
parent
.
getParentNode
(
)
;
destIndex
=
fDeferredDocumentImpl
.
getParentNode
(
destIndex
)
;
}
}
}
}
private
int
createDeferredContentModel
(
Node
model
)
throws
Exception
{
int
nodeType
=
model
.
getNodeType
(
)
;
switch
(
nodeType
)
{
case
Node
.
ELEMENT_NODE
:
{
NamedNodeMap
attrs
=
model
.
getAttributes
(
)
;
int
handle
=
fAttrList
.
startAttrList
(
)
;
int
length
=
attrs
.
getLength
(
)
;
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
Attr
attr
=
(
Attr
)
attrs
.
item
(
i
)
;
String
attrName
=
attr
.
getNodeName
(
)
;
String
attrValue
=
attr
.
getNodeValue
(
)
;
fAttrList
.
addAttr
(
fStringPool
.
addSymbol
(
attrName
)
,
fStringPool
.
addString
(
attrValue
)
,
fStringPool
.
addSymbol
(
(
String
)
TYPES
.
get
(
attrName
)
)
,
attr
.
getSpecified
(
)
,
false
)
;
}
fAttrList
.
endAttrList
(
)
;
int
modelIndex
=
fDeferredDocumentImpl
.
createElement
(
fStringPool
.
addSymbol
(
model
.
getNodeName
(
)
)
,
fAttrList
,
handle
)
;
Node
child
=
model
.
getFirstChild
(
)
;
while
(
child
!=
null
)
{
int
childIndex
=
createDeferredContentModel
(
child
)
;
fDeferredDocumentImpl
.
appendChild
(
modelIndex
,
childIndex
)
;
child
=
child
.
getNextSibling
(
)
;
}
return
modelIndex
;
}
case
Node
.
TEXT_NODE
:
{
return
fDeferredDocumentImpl
.
createTextNode
(
fStringPool
.
addString
(
model
.
getNodeValue
(
)
)
,
false
)
;
}
}
return
-
1
;
}
}
