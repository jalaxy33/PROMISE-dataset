package
org
.
apache
.
xerces
.
dom
;
import
java
.
io
.
*
;
import
org
.
w3c
.
dom
.
*
;
import
org
.
w3c
.
dom
.
events
.
MutationEvent
;
import
org
.
apache
.
xerces
.
dom
.
events
.
MutationEventImpl
;
public
class
AttrImpl
extends
NodeImpl
implements
Attr
{
static
final
long
serialVersionUID
=
7277707688218972102L
;
protected
Object
value
=
null
;
protected
String
name
;
protected
static
TextImpl
textNode
=
null
;
protected
AttrImpl
(
DocumentImpl
ownerDocument
,
String
name
)
{
super
(
ownerDocument
)
;
this
.
name
=
name
;
isSpecified
(
true
)
;
hasStringValue
(
true
)
;
}
protected
AttrImpl
(
)
{
}
protected
void
makeChildNode
(
)
{
if
(
hasStringValue
(
)
)
{
if
(
value
!=
null
)
{
TextImpl
text
=
(
TextImpl
)
ownerDocument
(
)
.
createTextNode
(
(
String
)
value
)
;
value
=
text
;
text
.
isFirstChild
(
true
)
;
text
.
previousSibling
=
text
;
text
.
ownerNode
=
this
;
text
.
isOwned
(
true
)
;
}
hasStringValue
(
false
)
;
}
}
public
Node
cloneNode
(
boolean
deep
)
{
AttrImpl
clone
=
(
AttrImpl
)
super
.
cloneNode
(
deep
)
;
if
(
!
clone
.
hasStringValue
(
)
)
{
clone
.
value
=
null
;
if
(
deep
)
{
for
(
Node
child
=
(
Node
)
value
;
child
!=
null
;
child
=
child
.
getNextSibling
(
)
)
{
clone
.
appendChild
(
child
.
cloneNode
(
true
)
)
;
}
}
}
clone
.
isSpecified
(
true
)
;
return
clone
;
}
public
short
getNodeType
(
)
{
return
Node
.
ATTRIBUTE_NODE
;
}
public
String
getNodeName
(
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
return
name
;
}
public
void
setNodeValue
(
String
value
)
throws
DOMException
{
setValue
(
value
)
;
}
public
String
getNodeValue
(
)
{
return
getValue
(
)
;
}
public
String
getName
(
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
return
name
;
}
public
void
setValue
(
String
newvalue
)
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMException
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
LCount
lc
=
null
;
String
oldvalue
=
""
;
DocumentImpl
ownerDocument
=
ownerDocument
(
)
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
&&
ownerNode
!=
null
)
{
oldvalue
=
getValue
(
)
;
}
}
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
if
(
value
!=
null
)
{
if
(
hasStringValue
(
)
)
{
if
(
textNode
==
null
)
{
textNode
=
(
TextImpl
)
ownerDocument
.
createTextNode
(
(
String
)
value
)
;
}
else
{
textNode
.
data
=
(
String
)
value
;
}
value
=
textNode
;
textNode
.
isFirstChild
(
true
)
;
textNode
.
previousSibling
=
textNode
;
textNode
.
ownerNode
=
this
;
textNode
.
isOwned
(
true
)
;
hasStringValue
(
false
)
;
internalRemoveChild
(
textNode
,
MUTATION_LOCAL
)
;
}
else
{
while
(
value
!=
null
)
{
internalRemoveChild
(
(
Node
)
value
,
MUTATION_LOCAL
)
;
}
}
}
}
else
{
if
(
!
hasStringValue
(
)
&&
value
!=
null
)
{
ChildNode
firstChild
=
(
ChildNode
)
value
;
firstChild
.
previousSibling
=
null
;
firstChild
.
isFirstChild
(
false
)
;
}
value
=
null
;
needsSyncChildren
(
false
)
;
}
isSpecified
(
true
)
;
if
(
newvalue
!=
null
)
{
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
internalInsertBefore
(
ownerDocument
.
createTextNode
(
newvalue
)
,
null
,
MUTATION_LOCAL
)
;
hasStringValue
(
false
)
;
}
else
{
value
=
newvalue
;
hasStringValue
(
true
)
;
}
}
changed
(
)
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
dispatchAggregateEvents
(
this
,
oldvalue
,
MutationEvent
.
MODIFICATION
)
;
}
}
public
String
getValue
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
if
(
value
==
null
)
{
return
""
;
}
if
(
hasStringValue
(
)
)
{
return
(
String
)
value
;
}
ChildNode
firstChild
=
(
(
ChildNode
)
value
)
;
ChildNode
node
=
firstChild
.
nextSibling
;
if
(
node
==
null
)
{
return
firstChild
.
getNodeValue
(
)
;
}
StringBuffer
value
=
new
StringBuffer
(
firstChild
.
getNodeValue
(
)
)
;
while
(
node
!=
null
)
{
value
.
append
(
node
.
getNodeValue
(
)
)
;
node
=
node
.
nextSibling
;
}
return
value
.
toString
(
)
;
}
public
boolean
getSpecified
(
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
return
isSpecified
(
)
;
}
public
Element
getElement
(
)
{
return
(
Element
)
(
isOwned
(
)
?
ownerNode
:
null
)
;
}
public
Element
getOwnerElement
(
)
{
return
(
Element
)
(
isOwned
(
)
?
ownerNode
:
null
)
;
}
public
void
normalize
(
)
{
if
(
isNormalized
(
)
||
hasStringValue
(
)
)
return
;
Node
kid
,
next
;
ChildNode
firstChild
=
(
ChildNode
)
value
;
for
(
kid
=
firstChild
;
kid
!=
null
;
kid
=
next
)
{
next
=
kid
.
getNextSibling
(
)
;
if
(
kid
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
if
(
next
!=
null
&&
next
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
(
(
Text
)
kid
)
.
appendData
(
next
.
getNodeValue
(
)
)
;
removeChild
(
next
)
;
next
=
kid
;
}
else
{
if
(
kid
.
getNodeValue
(
)
.
length
(
)
==
0
)
removeChild
(
kid
)
;
}
}
}
isNormalized
(
true
)
;
}
public
void
setSpecified
(
boolean
arg
)
{
if
(
needsSyncData
(
)
)
{
synchronizeData
(
)
;
}
isSpecified
(
arg
)
;
}
public
String
toString
(
)
{
return
getName
(
)
+
"="
+
"\""
+
getValue
(
)
+
"\""
;
}
public
boolean
hasChildNodes
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
value
!=
null
;
}
public
NodeList
getChildNodes
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
this
;
}
public
Node
getFirstChild
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
makeChildNode
(
)
;
return
(
Node
)
value
;
}
public
Node
getLastChild
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
lastChild
(
)
;
}
final
ChildNode
lastChild
(
)
{
makeChildNode
(
)
;
return
value
!=
null
?
(
(
ChildNode
)
value
)
.
previousSibling
:
null
;
}
final
void
lastChild
(
ChildNode
node
)
{
if
(
value
!=
null
)
{
(
(
ChildNode
)
value
)
.
previousSibling
=
node
;
}
}
public
Node
insertBefore
(
Node
newChild
,
Node
refChild
)
throws
DOMException
{
return
internalInsertBefore
(
newChild
,
refChild
,
MUTATION_ALL
)
;
}
Node
internalInsertBefore
(
Node
newChild
,
Node
refChild
,
int
mutationMask
)
throws
DOMException
{
DocumentImpl
ownerDocument
=
ownerDocument
(
)
;
boolean
errorChecking
=
ownerDocument
.
errorChecking
;
if
(
newChild
.
getNodeType
(
)
==
Node
.
DOCUMENT_FRAGMENT_NODE
)
{
if
(
errorChecking
)
{
for
(
Node
kid
=
newChild
.
getFirstChild
(
)
;
kid
!=
null
;
kid
=
kid
.
getNextSibling
(
)
)
{
if
(
!
ownerDocument
.
isKidOK
(
this
,
kid
)
)
{
throw
new
DOMException
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
}
}
while
(
newChild
.
hasChildNodes
(
)
)
{
insertBefore
(
newChild
.
getFirstChild
(
)
,
refChild
)
;
}
return
newChild
;
}
if
(
newChild
==
refChild
)
{
refChild
=
refChild
.
getNextSibling
(
)
;
removeChild
(
newChild
)
;
insertBefore
(
newChild
,
refChild
)
;
return
newChild
;
}
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
if
(
errorChecking
)
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMException
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
if
(
newChild
.
getOwnerDocument
(
)
!=
ownerDocument
)
{
throw
new
DOMException
(
DOMException
.
WRONG_DOCUMENT_ERR
,
"DOM005 Wrong document"
)
;
}
if
(
!
ownerDocument
.
isKidOK
(
this
,
newChild
)
)
{
throw
new
DOMException
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
if
(
refChild
!=
null
&&
refChild
.
getParentNode
(
)
!=
this
)
{
throw
new
DOMException
(
DOMException
.
NOT_FOUND_ERR
,
"DOM008 Not found"
)
;
}
boolean
treeSafe
=
true
;
for
(
NodeImpl
a
=
this
;
treeSafe
&&
a
!=
null
;
a
=
a
.
parentNode
(
)
)
{
treeSafe
=
newChild
!=
a
;
}
if
(
!
treeSafe
)
{
throw
new
DOMException
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
}
makeChildNode
(
)
;
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
&&
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
}
ChildNode
newInternal
=
(
ChildNode
)
newChild
;
Node
oldparent
=
newInternal
.
parentNode
(
)
;
if
(
oldparent
!=
null
)
{
oldparent
.
removeChild
(
newInternal
)
;
}
ChildNode
refInternal
=
(
ChildNode
)
refChild
;
newInternal
.
ownerNode
=
this
;
newInternal
.
isOwned
(
true
)
;
ChildNode
firstChild
=
(
ChildNode
)
value
;
if
(
firstChild
==
null
)
{
value
=
newInternal
;
newInternal
.
isFirstChild
(
true
)
;
newInternal
.
previousSibling
=
newInternal
;
}
else
{
if
(
refInternal
==
null
)
{
ChildNode
lastChild
=
firstChild
.
previousSibling
;
lastChild
.
nextSibling
=
newInternal
;
newInternal
.
previousSibling
=
lastChild
;
firstChild
.
previousSibling
=
newInternal
;
}
else
{
if
(
refChild
==
firstChild
)
{
firstChild
.
isFirstChild
(
false
)
;
newInternal
.
nextSibling
=
firstChild
;
newInternal
.
previousSibling
=
firstChild
.
previousSibling
;
firstChild
.
previousSibling
=
newInternal
;
value
=
newInternal
;
newInternal
.
isFirstChild
(
true
)
;
}
else
{
ChildNode
prev
=
refInternal
.
previousSibling
;
newInternal
.
nextSibling
=
refInternal
;
prev
.
nextSibling
=
newInternal
;
refInternal
.
previousSibling
=
newInternal
;
newInternal
.
previousSibling
=
prev
;
}
}
}
changed
(
)
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
if
(
(
mutationMask
&
MUTATION_LOCAL
)
!=
0
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_INSERTED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_INSERTED
,
true
,
false
,
this
,
null
,
null
,
null
,
(
short
)
0
)
;
newInternal
.
dispatchEvent
(
me
)
;
}
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_INSERTED_INTO_DOCUMENT
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
NodeImpl
eventAncestor
=
this
;
if
(
enclosingAttr
!=
null
)
eventAncestor
=
(
NodeImpl
)
(
enclosingAttr
.
node
.
getOwnerElement
(
)
)
;
if
(
eventAncestor
!=
null
)
{
NodeImpl
p
=
eventAncestor
;
while
(
p
!=
null
)
{
eventAncestor
=
p
;
if
(
p
.
getNodeType
(
)
==
ATTRIBUTE_NODE
)
{
p
=
(
ElementImpl
)
(
(
AttrImpl
)
p
)
.
getOwnerElement
(
)
;
}
else
{
p
=
p
.
parentNode
(
)
;
}
}
if
(
eventAncestor
.
getNodeType
(
)
==
Node
.
DOCUMENT_NODE
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_INSERTED_INTO_DOCUMENT
,
false
,
false
,
null
,
null
,
null
,
null
,
(
short
)
0
)
;
dispatchEventToSubtree
(
newInternal
,
me
)
;
}
}
}
}
if
(
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
{
dispatchAggregateEvents
(
enclosingAttr
)
;
}
}
checkNormalizationAfterInsert
(
newInternal
)
;
return
newChild
;
}
public
Node
removeChild
(
Node
oldChild
)
throws
DOMException
{
if
(
hasStringValue
(
)
)
{
throw
new
DOMException
(
DOMException
.
NOT_FOUND_ERR
,
"DOM008 Not found"
)
;
}
return
internalRemoveChild
(
oldChild
,
MUTATION_ALL
)
;
}
Node
internalRemoveChild
(
Node
oldChild
,
int
mutationMask
)
throws
DOMException
{
DocumentImpl
ownerDocument
=
ownerDocument
(
)
;
if
(
ownerDocument
.
errorChecking
)
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMException
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
if
(
oldChild
!=
null
&&
oldChild
.
getParentNode
(
)
!=
this
)
{
throw
new
DOMException
(
DOMException
.
NOT_FOUND_ERR
,
"DOM008 Not found"
)
;
}
}
ownerDocument
.
removedChildNode
(
oldChild
)
;
ChildNode
oldInternal
=
(
ChildNode
)
oldChild
;
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
if
(
(
mutationMask
&
MUTATION_LOCAL
)
!=
0
)
{
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_REMOVED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_REMOVED
,
true
,
false
,
this
,
null
,
null
,
null
,
(
short
)
0
)
;
oldInternal
.
dispatchEvent
(
me
)
;
}
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_REMOVED_FROM_DOCUMENT
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
NodeImpl
eventAncestor
=
this
;
if
(
enclosingAttr
!=
null
)
eventAncestor
=
(
NodeImpl
)
enclosingAttr
.
node
.
getOwnerElement
(
)
;
if
(
eventAncestor
!=
null
)
{
for
(
NodeImpl
p
=
eventAncestor
.
parentNode
(
)
;
p
!=
null
;
p
=
p
.
parentNode
(
)
)
{
eventAncestor
=
p
;
}
if
(
eventAncestor
.
getNodeType
(
)
==
Node
.
DOCUMENT_NODE
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_REMOVED_FROM_DOCUMENT
,
false
,
false
,
null
,
null
,
null
,
null
,
(
short
)
0
)
;
dispatchEventToSubtree
(
oldInternal
,
me
)
;
}
}
}
}
}
if
(
oldInternal
==
value
)
{
oldInternal
.
isFirstChild
(
false
)
;
value
=
oldInternal
.
nextSibling
;
ChildNode
firstChild
=
(
ChildNode
)
value
;
if
(
firstChild
!=
null
)
{
firstChild
.
isFirstChild
(
true
)
;
firstChild
.
previousSibling
=
oldInternal
.
previousSibling
;
}
}
else
{
ChildNode
prev
=
oldInternal
.
previousSibling
;
ChildNode
next
=
oldInternal
.
nextSibling
;
prev
.
nextSibling
=
next
;
if
(
next
==
null
)
{
ChildNode
firstChild
=
(
ChildNode
)
value
;
firstChild
.
previousSibling
=
prev
;
}
else
{
next
.
previousSibling
=
prev
;
}
}
ChildNode
oldPreviousSibling
=
oldInternal
.
previousSibling
(
)
;
oldInternal
.
ownerNode
=
ownerDocument
;
oldInternal
.
isOwned
(
false
)
;
oldInternal
.
nextSibling
=
null
;
oldInternal
.
previousSibling
=
null
;
changed
(
)
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
if
(
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
dispatchAggregateEvents
(
enclosingAttr
)
;
}
checkNormalizationAfterRemove
(
oldPreviousSibling
)
;
return
oldInternal
;
}
public
Node
replaceChild
(
Node
newChild
,
Node
oldChild
)
throws
DOMException
{
makeChildNode
(
)
;
EnclosingAttr
enclosingAttr
=
null
;
DocumentImpl
ownerDocument
=
ownerDocument
(
)
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
}
internalInsertBefore
(
newChild
,
oldChild
,
MUTATION_LOCAL
)
;
if
(
newChild
!=
oldChild
)
{
internalRemoveChild
(
oldChild
,
MUTATION_LOCAL
)
;
}
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
dispatchAggregateEvents
(
enclosingAttr
)
;
}
return
oldChild
;
}
public
int
getLength
(
)
{
if
(
hasStringValue
(
)
)
{
return
1
;
}
ChildNode
node
=
(
ChildNode
)
value
;
int
length
=
0
;
for
(
;
node
!=
null
;
node
=
node
.
nextSibling
)
{
length
++
;
}
return
length
;
}
public
Node
item
(
int
index
)
{
if
(
hasStringValue
(
)
)
{
if
(
index
!=
0
||
value
==
null
)
{
return
null
;
}
else
{
makeChildNode
(
)
;
return
(
Node
)
value
;
}
}
ChildNode
node
=
(
ChildNode
)
value
;
for
(
int
i
=
0
;
i
<
index
&&
node
!=
null
;
i
++
)
{
node
=
node
.
nextSibling
;
}
return
node
;
}
public
void
setReadOnly
(
boolean
readOnly
,
boolean
deep
)
{
super
.
setReadOnly
(
readOnly
,
deep
)
;
if
(
deep
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
if
(
hasStringValue
(
)
)
{
return
;
}
for
(
ChildNode
mykid
=
(
ChildNode
)
value
;
mykid
!=
null
;
mykid
=
mykid
.
nextSibling
)
{
if
(
mykid
.
getNodeType
(
)
!=
Node
.
ENTITY_REFERENCE_NODE
)
{
mykid
.
setReadOnly
(
readOnly
,
true
)
;
}
}
}
}
protected
void
synchronizeChildren
(
)
{
needsSyncChildren
(
false
)
;
}
protected
final
void
synchronizeChildren
(
int
nodeIndex
)
{
DeferredDocumentImpl
ownerDocument
=
(
DeferredDocumentImpl
)
ownerDocument
(
)
;
boolean
orig
=
ownerDocument
.
mutationEvents
;
ownerDocument
.
mutationEvents
=
false
;
needsSyncChildren
(
false
)
;
int
last
=
ownerDocument
.
getLastChild
(
nodeIndex
)
;
int
prev
=
ownerDocument
.
getPrevSibling
(
last
)
;
if
(
prev
==
-
1
)
{
value
=
ownerDocument
.
getNodeValueString
(
last
)
;
hasStringValue
(
true
)
;
}
else
{
ChildNode
firstNode
=
null
;
ChildNode
lastNode
=
null
;
for
(
int
index
=
last
;
index
!=
-
1
;
index
=
ownerDocument
.
getPrevSibling
(
index
)
)
{
ChildNode
node
=
(
ChildNode
)
ownerDocument
.
getNodeObject
(
index
)
;
if
(
lastNode
==
null
)
{
lastNode
=
node
;
}
else
{
firstNode
.
previousSibling
=
node
;
}
node
.
ownerNode
=
this
;
node
.
isOwned
(
true
)
;
node
.
nextSibling
=
firstNode
;
firstNode
=
node
;
}
if
(
lastNode
!=
null
)
{
value
=
firstNode
;
firstNode
.
isFirstChild
(
true
)
;
lastChild
(
lastNode
)
;
}
hasStringValue
(
false
)
;
}
ownerDocument
.
mutationEvents
=
orig
;
}
void
checkNormalizationAfterInsert
(
ChildNode
insertedChild
)
{
if
(
insertedChild
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
ChildNode
prev
=
insertedChild
.
previousSibling
(
)
;
ChildNode
next
=
insertedChild
.
nextSibling
;
if
(
(
prev
!=
null
&&
prev
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
||
(
next
!=
null
&&
next
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
)
{
isNormalized
(
false
)
;
}
}
else
{
if
(
!
insertedChild
.
isNormalized
(
)
)
{
isNormalized
(
false
)
;
}
}
}
void
checkNormalizationAfterRemove
(
ChildNode
previousSibling
)
{
if
(
previousSibling
!=
null
&&
previousSibling
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
ChildNode
next
=
previousSibling
.
nextSibling
;
if
(
next
!=
null
&&
next
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
isNormalized
(
false
)
;
}
}
}
private
void
writeObject
(
ObjectOutputStream
out
)
throws
IOException
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
out
.
defaultWriteObject
(
)
;
}
private
void
readObject
(
ObjectInputStream
ois
)
throws
ClassNotFoundException
,
IOException
{
ois
.
defaultReadObject
(
)
;
needsSyncChildren
(
false
)
;
}
}
