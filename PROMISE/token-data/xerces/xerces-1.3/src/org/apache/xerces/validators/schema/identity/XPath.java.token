package
org
.
apache
.
xerces
.
validators
.
schema
.
identity
;
import
org
.
apache
.
xerces
.
utils
.
NamespacesScope
;
import
org
.
apache
.
xerces
.
utils
.
QName
;
import
org
.
apache
.
xerces
.
utils
.
StringPool
;
public
class
XPath
{
private
static
final
boolean
DEBUG_ALL
=
false
;
private
static
final
boolean
DEBUG_XPATH_PARSE
=
DEBUG_ALL
||
false
;
private
static
final
boolean
DEBUG_ANY
=
DEBUG_XPATH_PARSE
;
protected
String
fExpression
;
protected
LocationPath
fLocationPath
;
protected
StringPool
fStringPool
;
public
XPath
(
String
xpath
,
StringPool
stringPool
,
NamespacesScope
context
)
throws
XPathException
{
fExpression
=
xpath
;
fStringPool
=
stringPool
;
parseExpression
(
context
)
;
}
public
LocationPath
getLocationPath
(
)
{
return
(
LocationPath
)
fLocationPath
.
clone
(
)
;
}
public
String
toString
(
)
{
return
fLocationPath
.
toString
(
)
;
}
private
void
parseExpression
(
final
NamespacesScope
context
)
throws
XPathException
{
final
XPath
.
Tokens
xtokens
=
new
XPath
.
Tokens
(
fStringPool
)
;
XPath
.
Scanner
scanner
=
new
XPath
.
Scanner
(
fStringPool
)
{
protected
void
addToken
(
XPath
.
Tokens
tokens
,
int
token
)
throws
XPathException
{
if
(
token
==
XPath
.
Tokens
.
EXPRTOKEN_ATSIGN
||
token
==
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_ATTRIBUTE
||
token
==
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_CHILD
||
token
==
XPath
.
Tokens
.
EXPRTOKEN_DOUBLE_COLON
||
token
==
XPath
.
Tokens
.
EXPRTOKEN_NAMETEST_QNAME
||
token
==
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_SLASH
||
token
==
XPath
.
Tokens
.
EXPRTOKEN_PERIOD
)
{
super
.
addToken
(
tokens
,
token
)
;
return
;
}
StringBuffer
str
=
new
StringBuffer
(
)
;
str
.
append
(
"token not supported: "
)
;
String
tokenName
=
tokens
.
getTokenName
(
token
)
;
if
(
tokenName
!=
null
)
{
str
.
append
(
'"'
)
;
str
.
append
(
tokenName
)
;
str
.
append
(
'"'
)
;
}
else
{
str
.
append
(
'('
)
;
str
.
append
(
token
)
;
str
.
append
(
')'
)
;
}
String
message
=
str
.
toString
(
)
;
throw
new
XPathException
(
message
)
;
}
}
;
int
length
=
fExpression
.
length
(
)
;
boolean
success
=
scanner
.
scanExpr
(
fStringPool
,
xtokens
,
fExpression
,
0
,
length
)
;
java
.
util
.
Vector
stepsVector
=
new
java
.
util
.
Vector
(
)
;
int
tokenCount
=
xtokens
.
getTokenCount
(
)
;
for
(
int
i
=
0
;
i
<
tokenCount
;
i
++
)
{
int
token
=
xtokens
.
getToken
(
i
)
;
switch
(
token
)
{
case
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_ATTRIBUTE
:
{
i
++
;
}
case
XPath
.
Tokens
.
EXPRTOKEN_ATSIGN
:
{
if
(
i
==
tokenCount
-
1
)
{
throw
new
XPathException
(
"missing attribute name"
)
;
}
token
=
xtokens
.
getToken
(
++
i
)
;
if
(
token
!=
XPath
.
Tokens
.
EXPRTOKEN_NAMETEST_QNAME
)
{
throw
new
XPathException
(
"expected "
+
xtokens
.
getTokenName
(
XPath
.
Tokens
.
EXPRTOKEN_NAMETEST_QNAME
)
+
", found "
+
xtokens
.
getTokenName
(
token
)
)
;
}
token
=
xtokens
.
getToken
(
++
i
)
;
int
prefix
=
xtokens
.
getTokenString
(
token
)
;
int
uri
=
context
!=
null
?
context
.
getNamespaceForPrefix
(
prefix
)
:
-
1
;
if
(
prefix
!=
-
1
&&
context
!=
null
&&
uri
==
-
1
)
{
throw
new
XPathException
(
"prefix "
+
fStringPool
.
toString
(
prefix
)
+
" not bound to namespace URI"
)
;
}
token
=
xtokens
.
getToken
(
++
i
)
;
int
localpart
=
xtokens
.
getTokenString
(
token
)
;
int
rawname
=
prefix
!=
-
1
?
fStringPool
.
addSymbol
(
fStringPool
.
toString
(
prefix
)
+
':'
+
fStringPool
.
toString
(
localpart
)
)
:
localpart
;
Axis
axis
=
new
Axis
(
Axis
.
ATTRIBUTE
)
;
NodeTest
nodeTest
=
new
NodeTest
(
fStringPool
,
new
QName
(
prefix
,
localpart
,
rawname
,
uri
)
)
;
Step
step
=
new
Step
(
axis
,
nodeTest
)
;
stepsVector
.
addElement
(
step
)
;
break
;
}
case
XPath
.
Tokens
.
EXPRTOKEN_DOUBLE_COLON
:
{
throw
new
XPathException
(
"Not allowed to have double colon here"
)
;
}
case
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_CHILD
:
{
i
++
;
}
case
XPath
.
Tokens
.
EXPRTOKEN_NAMETEST_QNAME
:
{
token
=
xtokens
.
getToken
(
++
i
)
;
int
prefix
=
xtokens
.
getTokenString
(
token
)
;
int
uri
=
context
!=
null
?
context
.
getNamespaceForPrefix
(
prefix
)
:
-
1
;
if
(
prefix
!=
-
1
&&
context
!=
null
&&
uri
==
-
1
)
{
throw
new
XPathException
(
"prefix "
+
fStringPool
.
toString
(
prefix
)
+
" not bound to namespace URI"
)
;
}
token
=
xtokens
.
getToken
(
++
i
)
;
int
localpart
=
xtokens
.
getTokenString
(
token
)
;
int
rawname
=
prefix
!=
-
1
?
fStringPool
.
addSymbol
(
fStringPool
.
toString
(
prefix
)
+
':'
+
fStringPool
.
toString
(
localpart
)
)
:
localpart
;
Axis
axis
=
new
Axis
(
Axis
.
CHILD
)
;
NodeTest
nodeTest
=
new
NodeTest
(
fStringPool
,
new
QName
(
prefix
,
localpart
,
rawname
,
uri
)
)
;
Step
step
=
new
Step
(
axis
,
nodeTest
)
;
stepsVector
.
addElement
(
step
)
;
break
;
}
case
XPath
.
Tokens
.
EXPRTOKEN_PERIOD
:
{
Axis
axis
=
new
Axis
(
Axis
.
SELF
)
;
NodeTest
nodeTest
=
new
NodeTest
(
NodeTest
.
NODE
)
;
Step
step
=
new
Step
(
axis
,
nodeTest
)
;
stepsVector
.
addElement
(
step
)
;
break
;
}
case
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_SLASH
:
{
if
(
i
==
0
)
{
throw
new
XPathException
(
"not allowed to select the root"
)
;
}
if
(
i
==
tokenCount
-
1
)
{
throw
new
XPathException
(
"expected step following '/'"
)
;
}
break
;
}
}
}
int
size
=
stepsVector
.
size
(
)
;
if
(
size
==
0
)
{
throw
new
XPathException
(
"empty xpath expression"
)
;
}
Step
[
]
steps
=
new
Step
[
size
]
;
stepsVector
.
copyInto
(
steps
)
;
fLocationPath
=
new
LocationPath
(
steps
)
;
if
(
DEBUG_XPATH_PARSE
)
{
System
.
out
.
println
(
">>> "
+
fLocationPath
)
;
}
}
public
static
class
LocationPath
implements
Cloneable
{
public
Step
[
]
steps
;
public
LocationPath
(
Step
[
]
steps
)
{
this
.
steps
=
steps
;
}
protected
LocationPath
(
LocationPath
path
)
{
steps
=
new
Step
[
path
.
steps
.
length
]
;
for
(
int
i
=
0
;
i
<
steps
.
length
;
i
++
)
{
steps
[
i
]
=
(
Step
)
path
.
steps
[
i
]
.
clone
(
)
;
}
}
public
String
toString
(
)
{
StringBuffer
str
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
steps
.
length
;
i
++
)
{
if
(
i
>
0
)
{
str
.
append
(
'/'
)
;
}
str
.
append
(
steps
[
i
]
.
toString
(
)
)
;
}
if
(
false
)
{
str
.
append
(
'['
)
;
String
s
=
super
.
toString
(
)
;
str
.
append
(
s
.
substring
(
s
.
indexOf
(
'@'
)
)
)
;
str
.
append
(
']'
)
;
}
return
str
.
toString
(
)
;
}
public
Object
clone
(
)
{
return
new
LocationPath
(
this
)
;
}
}
public
static
class
Step
implements
Cloneable
{
public
Axis
axis
;
public
NodeTest
nodeTest
;
public
Step
(
Axis
axis
,
NodeTest
nodeTest
)
{
this
.
axis
=
axis
;
this
.
nodeTest
=
nodeTest
;
}
protected
Step
(
Step
step
)
{
axis
=
(
Axis
)
step
.
axis
.
clone
(
)
;
nodeTest
=
(
NodeTest
)
step
.
nodeTest
.
clone
(
)
;
}
public
String
toString
(
)
{
if
(
axis
.
type
==
Axis
.
SELF
)
{
return
"."
;
}
if
(
axis
.
type
==
Axis
.
ATTRIBUTE
)
{
return
"@"
+
nodeTest
.
toString
(
)
;
}
if
(
axis
.
type
==
Axis
.
CHILD
)
{
return
nodeTest
.
toString
(
)
;
}
return
"??? ("
+
axis
.
type
+
')'
;
}
public
Object
clone
(
)
{
return
new
Step
(
this
)
;
}
}
public
static
class
Axis
implements
Cloneable
{
public
static
final
short
CHILD
=
1
;
public
static
final
short
ATTRIBUTE
=
2
;
public
static
final
short
SELF
=
3
;
public
short
type
;
public
Axis
(
short
type
)
{
this
.
type
=
type
;
}
protected
Axis
(
Axis
axis
)
{
type
=
axis
.
type
;
}
public
String
toString
(
)
{
switch
(
type
)
{
case
CHILD
:
return
"child"
;
case
ATTRIBUTE
:
return
"attribute"
;
case
SELF
:
return
"self"
;
}
return
"???"
;
}
public
Object
clone
(
)
{
return
new
Axis
(
this
)
;
}
}
public
static
class
NodeTest
implements
Cloneable
{
public
static
final
short
QNAME
=
1
;
public
static
final
short
WILDCARD
=
2
;
public
static
final
short
NODE
=
3
;
protected
StringPool
fStringPool
;
public
short
type
;
public
final
QName
name
=
new
QName
(
)
;
public
NodeTest
(
short
type
)
{
this
.
type
=
type
;
}
public
NodeTest
(
StringPool
stringPool
,
QName
name
)
{
fStringPool
=
stringPool
;
this
.
type
=
QNAME
;
this
.
name
.
setValues
(
name
)
;
}
public
NodeTest
(
NodeTest
nodeTest
)
{
fStringPool
=
nodeTest
.
fStringPool
;
type
=
nodeTest
.
type
;
name
.
setValues
(
nodeTest
.
name
)
;
}
public
String
toString
(
)
{
switch
(
type
)
{
case
QNAME
:
{
if
(
name
.
prefix
!=
-
1
)
{
if
(
name
.
uri
==
-
1
)
{
return
fStringPool
.
toString
(
name
.
prefix
)
+
':'
+
fStringPool
.
toString
(
name
.
localpart
)
;
}
return
"{"
+
fStringPool
.
toString
(
name
.
uri
)
+
'}'
+
fStringPool
.
toString
(
name
.
prefix
)
+
':'
+
fStringPool
.
toString
(
name
.
localpart
)
;
}
return
fStringPool
.
toString
(
name
.
localpart
)
;
}
case
WILDCARD
:
{
return
"*"
;
}
case
NODE
:
{
return
"node()"
;
}
}
return
"???"
;
}
public
Object
clone
(
)
{
return
new
NodeTest
(
this
)
;
}
}
private
static
final
class
Tokens
{
static
final
boolean
DUMP_TOKENS
=
false
;
public
static
final
int
EXPRTOKEN_OPEN_PAREN
=
-
1000
,
EXPRTOKEN_CLOSE_PAREN
=
-
1001
,
EXPRTOKEN_OPEN_BRACKET
=
-
1002
,
EXPRTOKEN_CLOSE_BRACKET
=
-
1003
,
EXPRTOKEN_PERIOD
=
-
1004
,
EXPRTOKEN_DOUBLE_PERIOD
=
-
1005
,
EXPRTOKEN_ATSIGN
=
-
1006
,
EXPRTOKEN_COMMA
=
-
1007
,
EXPRTOKEN_DOUBLE_COLON
=
-
1008
,
EXPRTOKEN_NAMETEST_ANY
=
-
1009
,
EXPRTOKEN_NAMETEST_NAMESPACE
=
-
1010
,
EXPRTOKEN_NAMETEST_QNAME
=
-
1011
,
EXPRTOKEN_NODETYPE_COMMENT
=
-
1012
,
EXPRTOKEN_NODETYPE_TEXT
=
-
1013
,
EXPRTOKEN_NODETYPE_PI
=
-
1014
,
EXPRTOKEN_NODETYPE_NODE
=
-
1015
,
EXPRTOKEN_OPERATOR_AND
=
-
1016
,
EXPRTOKEN_OPERATOR_OR
=
-
1017
,
EXPRTOKEN_OPERATOR_MOD
=
-
1018
,
EXPRTOKEN_OPERATOR_DIV
=
-
1019
,
EXPRTOKEN_OPERATOR_MULT
=
-
1020
,
EXPRTOKEN_OPERATOR_SLASH
=
-
1021
,
EXPRTOKEN_OPERATOR_DOUBLE_SLASH
=
-
1022
,
EXPRTOKEN_OPERATOR_UNION
=
-
1023
,
EXPRTOKEN_OPERATOR_PLUS
=
-
1024
,
EXPRTOKEN_OPERATOR_MINUS
=
-
1025
,
EXPRTOKEN_OPERATOR_EQUAL
=
-
1026
,
EXPRTOKEN_OPERATOR_NOT_EQUAL
=
-
1027
,
EXPRTOKEN_OPERATOR_LESS
=
-
1028
,
EXPRTOKEN_OPERATOR_LESS_EQUAL
=
-
1029
,
EXPRTOKEN_OPERATOR_GREATER
=
-
1030
,
EXPRTOKEN_OPERATOR_GREATER_EQUAL
=
-
1031
,
EXPRTOKEN_FIRST_OPERATOR
=
EXPRTOKEN_OPERATOR_AND
,
EXPRTOKEN_LAST_OPERATOR
=
EXPRTOKEN_OPERATOR_GREATER_EQUAL
,
EXPRTOKEN_FUNCTION_NAME
=
-
1032
,
EXPRTOKEN_AXISNAME_ANCESTOR
=
-
1033
,
EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF
=
-
1034
,
EXPRTOKEN_AXISNAME_ATTRIBUTE
=
-
1035
,
EXPRTOKEN_AXISNAME_CHILD
=
-
1036
,
EXPRTOKEN_AXISNAME_DESCENDANT
=
-
1037
,
EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF
=
-
1038
,
EXPRTOKEN_AXISNAME_FOLLOWING
=
-
1039
,
EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING
=
-
1040
,
EXPRTOKEN_AXISNAME_NAMESPACE
=
-
1041
,
EXPRTOKEN_AXISNAME_PARENT
=
-
1042
,
EXPRTOKEN_AXISNAME_PRECEDING
=
-
1043
,
EXPRTOKEN_AXISNAME_PRECEDING_SIBLING
=
-
1044
,
EXPRTOKEN_AXISNAME_SELF
=
-
1045
,
EXPRTOKEN_LITERAL
=
-
1046
,
EXPRTOKEN_NUMBER
=
-
1047
,
EXPRTOKEN_VARIABLE_REFERENCE
=
-
1048
;
private
static
final
int
INITIAL_TOKEN_COUNT
=
1
<<
8
;
private
int
[
]
fTokens
=
new
int
[
INITIAL_TOKEN_COUNT
]
;
private
int
fTokenCount
=
0
;
private
StringPool
fStringPool
;
private
java
.
util
.
Hashtable
fSymbolMapping
=
new
java
.
util
.
Hashtable
(
)
;
private
java
.
util
.
Hashtable
fTokenNames
=
new
java
.
util
.
Hashtable
(
)
;
public
Tokens
(
StringPool
stringPool
)
{
fStringPool
=
stringPool
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPEN_PAREN
)
,
"EXPRTOKEN_OPEN_PAREN"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_CLOSE_PAREN
)
,
"EXPRTOKEN_CLOSE_PAREN"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPEN_BRACKET
)
,
"EXPRTOKEN_OPEN_BRACKET"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_CLOSE_BRACKET
)
,
"EXPRTOKEN_CLOSE_BRACKET"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_PERIOD
)
,
"EXPRTOKEN_PERIOD"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_DOUBLE_PERIOD
)
,
"EXPRTOKEN_DOUBLE_PERIOD"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_ATSIGN
)
,
"EXPRTOKEN_ATSIGN"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_COMMA
)
,
"EXPRTOKEN_COMMA"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_DOUBLE_COLON
)
,
"EXPRTOKEN_DOUBLE_COLON"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_NAMETEST_ANY
)
,
"EXPRTOKEN_NAMETEST_ANY"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_NAMETEST_NAMESPACE
)
,
"EXPRTOKEN_NAMETEST_NAMESPACE"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_NAMETEST_QNAME
)
,
"EXPRTOKEN_NAMETEST_QNAME"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_NODETYPE_COMMENT
)
,
"EXPRTOKEN_NODETYPE_COMMENT"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_NODETYPE_TEXT
)
,
"EXPRTOKEN_NODETYPE_TEXT"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_NODETYPE_PI
)
,
"EXPRTOKEN_NODETYPE_PI"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_NODETYPE_NODE
)
,
"EXPRTOKEN_NODETYPE_NODE"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_AND
)
,
"EXPRTOKEN_OPERATOR_AND"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_OR
)
,
"EXPRTOKEN_OPERATOR_OR"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_MOD
)
,
"EXPRTOKEN_OPERATOR_MOD"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_DIV
)
,
"EXPRTOKEN_OPERATOR_DIV"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_MULT
)
,
"EXPRTOKEN_OPERATOR_MULT"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_SLASH
)
,
"EXPRTOKEN_OPERATOR_SLASH"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_DOUBLE_SLASH
)
,
"EXPRTOKEN_OPERATOR_DOUBLE_SLASH"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_UNION
)
,
"EXPRTOKEN_OPERATOR_UNION"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_PLUS
)
,
"EXPRTOKEN_OPERATOR_PLUS"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_MINUS
)
,
"EXPRTOKEN_OPERATOR_MINUS"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_EQUAL
)
,
"EXPRTOKEN_OPERATOR_EQUAL"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_NOT_EQUAL
)
,
"EXPRTOKEN_OPERATOR_NOT_EQUAL"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_LESS
)
,
"EXPRTOKEN_OPERATOR_LESS"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_LESS_EQUAL
)
,
"EXPRTOKEN_OPERATOR_LESS_EQUAL"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_GREATER
)
,
"EXPRTOKEN_OPERATOR_GREATER"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_OPERATOR_GREATER_EQUAL
)
,
"EXPRTOKEN_OPERATOR_GREATER_EQUAL"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_FUNCTION_NAME
)
,
"EXPRTOKEN_FUNCTION_NAME"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_ANCESTOR
)
,
"EXPRTOKEN_AXISNAME_ANCESTOR"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF
)
,
"EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_ATTRIBUTE
)
,
"EXPRTOKEN_AXISNAME_ATTRIBUTE"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_CHILD
)
,
"EXPRTOKEN_AXISNAME_CHILD"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_DESCENDANT
)
,
"EXPRTOKEN_AXISNAME_DESCENDANT"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF
)
,
"EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_FOLLOWING
)
,
"EXPRTOKEN_AXISNAME_FOLLOWING"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING
)
,
"EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_NAMESPACE
)
,
"EXPRTOKEN_AXISNAME_NAMESPACE"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_PARENT
)
,
"EXPRTOKEN_AXISNAME_PARENT"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_PRECEDING
)
,
"EXPRTOKEN_AXISNAME_PRECEDING"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_PRECEDING_SIBLING
)
,
"EXPRTOKEN_AXISNAME_PRECEDING_SIBLING"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_AXISNAME_SELF
)
,
"EXPRTOKEN_AXISNAME_SELF"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_LITERAL
)
,
"EXPRTOKEN_LITERAL"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_NUMBER
)
,
"EXPRTOKEN_NUMBER"
)
;
fTokenNames
.
put
(
new
Integer
(
EXPRTOKEN_VARIABLE_REFERENCE
)
,
"EXPRTOKEN_VARIABLE_REFERENCE"
)
;
}
public
String
getTokenName
(
int
token
)
{
return
(
String
)
fTokenNames
.
get
(
new
Integer
(
token
)
)
;
}
public
int
getTokenString
(
int
token
)
{
return
token
;
}
public
void
addToken
(
int
token
)
{
try
{
fTokens
[
fTokenCount
]
=
token
;
}
catch
(
ArrayIndexOutOfBoundsException
ex
)
{
int
[
]
oldList
=
fTokens
;
fTokens
=
new
int
[
fTokenCount
<<
1
]
;
System
.
arraycopy
(
oldList
,
0
,
fTokens
,
0
,
fTokenCount
)
;
fTokens
[
fTokenCount
]
=
token
;
}
fTokenCount
++
;
}
public
int
getTokenCount
(
)
{
return
fTokenCount
;
}
public
int
getToken
(
int
tokenIndex
)
{
return
fTokens
[
tokenIndex
]
;
}
public
void
dumpTokens
(
)
{
for
(
int
i
=
0
;
i
<
fTokenCount
;
i
++
)
{
switch
(
fTokens
[
i
]
)
{
case
EXPRTOKEN_OPEN_PAREN
:
System
.
out
.
print
(
"<OPEN_PAREN/>"
)
;
break
;
case
EXPRTOKEN_CLOSE_PAREN
:
System
.
out
.
print
(
"<CLOSE_PAREN/>"
)
;
break
;
case
EXPRTOKEN_OPEN_BRACKET
:
System
.
out
.
print
(
"<OPEN_BRACKET/>"
)
;
break
;
case
EXPRTOKEN_CLOSE_BRACKET
:
System
.
out
.
print
(
"<CLOSE_BRACKET/>"
)
;
break
;
case
EXPRTOKEN_PERIOD
:
System
.
out
.
print
(
"<PERIOD/>"
)
;
break
;
case
EXPRTOKEN_DOUBLE_PERIOD
:
System
.
out
.
print
(
"<DOUBLE_PERIOD/>"
)
;
break
;
case
EXPRTOKEN_ATSIGN
:
System
.
out
.
print
(
"<ATSIGN/>"
)
;
break
;
case
EXPRTOKEN_COMMA
:
System
.
out
.
print
(
"<COMMA/>"
)
;
break
;
case
EXPRTOKEN_DOUBLE_COLON
:
System
.
out
.
print
(
"<DOUBLE_COLON/>"
)
;
break
;
case
EXPRTOKEN_NAMETEST_ANY
:
System
.
out
.
print
(
"<NAMETEST_ANY/>"
)
;
break
;
case
EXPRTOKEN_NAMETEST_NAMESPACE
:
System
.
out
.
print
(
"<NAMETEST_NAMESPACE"
)
;
System
.
out
.
print
(
" prefix=\""
+
getTokenString
(
fTokens
[
++
i
]
)
+
"\""
)
;
System
.
out
.
print
(
"/>"
)
;
break
;
case
EXPRTOKEN_NAMETEST_QNAME
:
System
.
out
.
print
(
"<NAMETEST_QNAME"
)
;
if
(
fTokens
[
++
i
]
!=
-
1
)
System
.
out
.
print
(
" prefix=\""
+
getTokenString
(
fTokens
[
i
]
)
+
"\""
)
;
System
.
out
.
print
(
" localpart=\""
+
getTokenString
(
fTokens
[
++
i
]
)
+
"\""
)
;
System
.
out
.
print
(
"/>"
)
;
break
;
case
EXPRTOKEN_NODETYPE_COMMENT
:
System
.
out
.
print
(
"<NODETYPE_COMMENT/>"
)
;
break
;
case
EXPRTOKEN_NODETYPE_TEXT
:
System
.
out
.
print
(
"<NODETYPE_TEXT/>"
)
;
break
;
case
EXPRTOKEN_NODETYPE_PI
:
System
.
out
.
print
(
"<NODETYPE_PI/>"
)
;
break
;
case
EXPRTOKEN_NODETYPE_NODE
:
System
.
out
.
print
(
"<NODETYPE_NODE/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_AND
:
System
.
out
.
print
(
"<OPERATOR_AND/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_OR
:
System
.
out
.
print
(
"<OPERATOR_OR/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_MOD
:
System
.
out
.
print
(
"<OPERATOR_MOD/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_DIV
:
System
.
out
.
print
(
"<OPERATOR_DIV/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_MULT
:
System
.
out
.
print
(
"<OPERATOR_MULT/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_SLASH
:
System
.
out
.
print
(
"<OPERATOR_SLASH/>"
)
;
if
(
i
+
1
<
fTokenCount
)
{
System
.
out
.
println
(
)
;
System
.
out
.
print
(
"  "
)
;
}
break
;
case
EXPRTOKEN_OPERATOR_DOUBLE_SLASH
:
System
.
out
.
print
(
"<OPERATOR_DOUBLE_SLASH/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_UNION
:
System
.
out
.
print
(
"<OPERATOR_UNION/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_PLUS
:
System
.
out
.
print
(
"<OPERATOR_PLUS/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_MINUS
:
System
.
out
.
print
(
"<OPERATOR_MINUS/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_EQUAL
:
System
.
out
.
print
(
"<OPERATOR_EQUAL/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_NOT_EQUAL
:
System
.
out
.
print
(
"<OPERATOR_NOT_EQUAL/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_LESS
:
System
.
out
.
print
(
"<OPERATOR_LESS/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_LESS_EQUAL
:
System
.
out
.
print
(
"<OPERATOR_LESS_EQUAL/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_GREATER
:
System
.
out
.
print
(
"<OPERATOR_GREATER/>"
)
;
break
;
case
EXPRTOKEN_OPERATOR_GREATER_EQUAL
:
System
.
out
.
print
(
"<OPERATOR_GREATER_EQUAL/>"
)
;
break
;
case
EXPRTOKEN_FUNCTION_NAME
:
System
.
out
.
print
(
"<FUNCTION_NAME"
)
;
if
(
fTokens
[
++
i
]
!=
-
1
)
System
.
out
.
print
(
" prefix=\""
+
getTokenString
(
fTokens
[
i
]
)
+
"\""
)
;
System
.
out
.
print
(
" localpart=\""
+
getTokenString
(
fTokens
[
++
i
]
)
+
"\""
)
;
System
.
out
.
print
(
"/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_ANCESTOR
:
System
.
out
.
print
(
"<AXISNAME_ANCESTOR/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF
:
System
.
out
.
print
(
"<AXISNAME_ANCESTOR_OR_SELF/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_ATTRIBUTE
:
System
.
out
.
print
(
"<AXISNAME_ATTRIBUTE/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_CHILD
:
System
.
out
.
print
(
"<AXISNAME_CHILD/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_DESCENDANT
:
System
.
out
.
print
(
"<AXISNAME_DESCENDANT/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF
:
System
.
out
.
print
(
"<AXISNAME_DESCENDANT_OR_SELF/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_FOLLOWING
:
System
.
out
.
print
(
"<AXISNAME_FOLLOWING/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING
:
System
.
out
.
print
(
"<AXISNAME_FOLLOWING_SIBLING/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_NAMESPACE
:
System
.
out
.
print
(
"<AXISNAME_NAMESPACE/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_PARENT
:
System
.
out
.
print
(
"<AXISNAME_PARENT/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_PRECEDING
:
System
.
out
.
print
(
"<AXISNAME_PRECEDING/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_PRECEDING_SIBLING
:
System
.
out
.
print
(
"<AXISNAME_PRECEDING_SIBLING/>"
)
;
break
;
case
EXPRTOKEN_AXISNAME_SELF
:
System
.
out
.
print
(
"<AXISNAME_SELF/>"
)
;
break
;
case
EXPRTOKEN_LITERAL
:
System
.
out
.
print
(
"<LITERAL"
)
;
System
.
out
.
print
(
" value=\""
+
getTokenString
(
fTokens
[
++
i
]
)
+
"\""
)
;
System
.
out
.
print
(
"/>"
)
;
break
;
case
EXPRTOKEN_NUMBER
:
System
.
out
.
print
(
"<NUMBER"
)
;
System
.
out
.
print
(
" whole=\""
+
getTokenString
(
fTokens
[
++
i
]
)
+
"\""
)
;
System
.
out
.
print
(
" part=\""
+
getTokenString
(
fTokens
[
++
i
]
)
+
"\""
)
;
System
.
out
.
print
(
"/>"
)
;
break
;
case
EXPRTOKEN_VARIABLE_REFERENCE
:
System
.
out
.
print
(
"<VARIABLE_REFERENCE"
)
;
if
(
fTokens
[
++
i
]
!=
-
1
)
System
.
out
.
print
(
" prefix=\""
+
getTokenString
(
fTokens
[
i
]
)
+
"\""
)
;
System
.
out
.
print
(
" localpart=\""
+
getTokenString
(
fTokens
[
++
i
]
)
+
"\""
)
;
System
.
out
.
print
(
"/>"
)
;
break
;
default
:
System
.
out
.
println
(
"<???/>"
)
;
}
}
System
.
out
.
println
(
)
;
}
}
private
static
class
Scanner
{
private
static
final
byte
CHARTYPE_INVALID
=
0
,
CHARTYPE_OTHER
=
1
,
CHARTYPE_WHITESPACE
=
2
,
CHARTYPE_EXCLAMATION
=
3
,
CHARTYPE_QUOTE
=
4
,
CHARTYPE_DOLLAR
=
5
,
CHARTYPE_OPEN_PAREN
=
6
,
CHARTYPE_CLOSE_PAREN
=
7
,
CHARTYPE_STAR
=
8
,
CHARTYPE_PLUS
=
9
,
CHARTYPE_COMMA
=
10
,
CHARTYPE_MINUS
=
11
,
CHARTYPE_PERIOD
=
12
,
CHARTYPE_SLASH
=
13
,
CHARTYPE_DIGIT
=
14
,
CHARTYPE_COLON
=
15
,
CHARTYPE_LESS
=
16
,
CHARTYPE_EQUAL
=
17
,
CHARTYPE_GREATER
=
18
,
CHARTYPE_ATSIGN
=
19
,
CHARTYPE_LETTER
=
20
,
CHARTYPE_OPEN_BRACKET
=
21
,
CHARTYPE_CLOSE_BRACKET
=
22
,
CHARTYPE_UNDERSCORE
=
23
,
CHARTYPE_UNION
=
24
,
CHARTYPE_NONASCII
=
25
;
private
static
byte
[
]
fASCIICharMap
=
{
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
2
,
2
,
0
,
0
,
2
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
0
,
2
,
3
,
4
,
1
,
5
,
1
,
1
,
4
,
6
,
7
,
8
,
9
,
10
,
11
,
12
,
13
,
14
,
14
,
14
,
14
,
14
,
14
,
14
,
14
,
14
,
14
,
15
,
1
,
16
,
17
,
18
,
1
,
19
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
21
,
1
,
22
,
1
,
23
,
1
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
20
,
1
,
24
,
1
,
1
,
1
}
;
private
StringPool
fStringPool
;
private
int
fAndSymbol
;
private
int
fOrSymbol
;
private
int
fModSymbol
;
private
int
fDivSymbol
;
private
int
fCommentSymbol
;
private
int
fTextSymbol
;
private
int
fPISymbol
;
private
int
fNodeSymbol
;
private
int
fAncestorSymbol
;
private
int
fAncestorOrSelfSymbol
;
private
int
fAttributeSymbol
;
private
int
fChildSymbol
;
private
int
fDescendantSymbol
;
private
int
fDescendantOrSelfSymbol
;
private
int
fFollowingSymbol
;
private
int
fFollowingSiblingSymbol
;
private
int
fNamespaceSymbol
;
private
int
fParentSymbol
;
private
int
fPrecedingSymbol
;
private
int
fPrecedingSiblingSymbol
;
private
int
fSelfSymbol
;
public
Scanner
(
StringPool
stringPool
)
{
fStringPool
=
stringPool
;
fAndSymbol
=
fStringPool
.
addSymbol
(
"and"
)
;
fOrSymbol
=
fStringPool
.
addSymbol
(
"or"
)
;
fModSymbol
=
fStringPool
.
addSymbol
(
"mod"
)
;
fDivSymbol
=
fStringPool
.
addSymbol
(
"div"
)
;
fCommentSymbol
=
fStringPool
.
addSymbol
(
"comment"
)
;
fTextSymbol
=
fStringPool
.
addSymbol
(
"text"
)
;
fPISymbol
=
fStringPool
.
addSymbol
(
"processing-instruction"
)
;
fNodeSymbol
=
fStringPool
.
addSymbol
(
"node"
)
;
fAncestorSymbol
=
fStringPool
.
addSymbol
(
"ancestor"
)
;
fAncestorOrSelfSymbol
=
fStringPool
.
addSymbol
(
"ancestor-or-self"
)
;
fAttributeSymbol
=
fStringPool
.
addSymbol
(
"attribute"
)
;
fChildSymbol
=
fStringPool
.
addSymbol
(
"child"
)
;
fDescendantSymbol
=
fStringPool
.
addSymbol
(
"descendant"
)
;
fDescendantOrSelfSymbol
=
fStringPool
.
addSymbol
(
"descendant-or-self"
)
;
fFollowingSymbol
=
fStringPool
.
addSymbol
(
"following"
)
;
fFollowingSiblingSymbol
=
fStringPool
.
addSymbol
(
"following-sibling"
)
;
fNamespaceSymbol
=
fStringPool
.
addSymbol
(
"namespace"
)
;
fParentSymbol
=
fStringPool
.
addSymbol
(
"parent"
)
;
fPrecedingSymbol
=
fStringPool
.
addSymbol
(
"preceding"
)
;
fPrecedingSiblingSymbol
=
fStringPool
.
addSymbol
(
"preceding-sibling"
)
;
fSelfSymbol
=
fStringPool
.
addSymbol
(
"self"
)
;
}
public
boolean
scanExpr
(
StringPool
stringPool
,
XPath
.
Tokens
tokens
,
String
data
,
int
currentOffset
,
int
endOffset
)
throws
XPathException
{
int
nameOffset
;
int
nameHandle
,
prefixHandle
;
boolean
starIsMultiplyOperator
=
false
;
int
ch
;
while
(
true
)
{
if
(
currentOffset
==
endOffset
)
{
break
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
while
(
ch
==
' '
||
ch
==
0x0A
||
ch
==
0x09
||
ch
==
0x0D
)
{
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
}
if
(
currentOffset
==
endOffset
)
{
break
;
}
byte
chartype
=
(
ch
>=
0x80
)
?
CHARTYPE_NONASCII
:
fASCIICharMap
[
ch
]
;
switch
(
chartype
)
{
case
CHARTYPE_OPEN_PAREN
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPEN_PAREN
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_CLOSE_PAREN
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_CLOSE_PAREN
)
;
starIsMultiplyOperator
=
true
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_OPEN_BRACKET
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPEN_BRACKET
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_CLOSE_BRACKET
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_CLOSE_BRACKET
)
;
starIsMultiplyOperator
=
true
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_PERIOD
:
if
(
currentOffset
+
1
==
endOffset
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_PERIOD
)
;
starIsMultiplyOperator
=
true
;
currentOffset
++
;
break
;
}
ch
=
data
.
charAt
(
currentOffset
+
1
)
;
if
(
ch
==
'.'
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_DOUBLE_PERIOD
)
;
starIsMultiplyOperator
=
true
;
currentOffset
+=
2
;
}
else
if
(
ch
>=
'0'
&&
ch
<=
'9'
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_NUMBER
)
;
starIsMultiplyOperator
=
true
;
currentOffset
=
scanNumber
(
tokens
,
data
,
endOffset
,
currentOffset
)
;
}
else
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_PERIOD
)
;
starIsMultiplyOperator
=
true
;
currentOffset
++
;
}
if
(
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_ATSIGN
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_ATSIGN
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_COMMA
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_COMMA
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_COLON
:
if
(
++
currentOffset
==
endOffset
)
{
System
.
out
.
println
(
"abort 1a"
)
;
return
false
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
if
(
ch
!=
':'
)
{
System
.
out
.
println
(
"abort 1b"
)
;
return
false
;
}
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_DOUBLE_COLON
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_SLASH
:
if
(
++
currentOffset
==
endOffset
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_SLASH
)
;
starIsMultiplyOperator
=
false
;
break
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
if
(
ch
==
'/'
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_DOUBLE_SLASH
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
}
else
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_SLASH
)
;
starIsMultiplyOperator
=
false
;
}
break
;
case
CHARTYPE_UNION
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_UNION
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_PLUS
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_PLUS
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_MINUS
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_MINUS
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_EQUAL
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_EQUAL
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_EXCLAMATION
:
if
(
++
currentOffset
==
endOffset
)
{
System
.
out
.
println
(
"abort 2a"
)
;
return
false
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
if
(
ch
!=
'='
)
{
System
.
out
.
println
(
"abort 2b"
)
;
return
false
;
}
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_NOT_EQUAL
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_LESS
:
if
(
++
currentOffset
==
endOffset
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_LESS
)
;
starIsMultiplyOperator
=
false
;
break
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
if
(
ch
==
'='
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_LESS_EQUAL
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
}
else
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_LESS
)
;
starIsMultiplyOperator
=
false
;
}
break
;
case
CHARTYPE_GREATER
:
if
(
++
currentOffset
==
endOffset
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_GREATER
)
;
starIsMultiplyOperator
=
false
;
break
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
if
(
ch
==
'='
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_GREATER_EQUAL
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
}
else
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_GREATER
)
;
starIsMultiplyOperator
=
false
;
}
break
;
case
CHARTYPE_QUOTE
:
int
qchar
=
ch
;
if
(
++
currentOffset
==
endOffset
)
{
System
.
out
.
println
(
"abort 2c"
)
;
return
false
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
int
litOffset
=
currentOffset
;
while
(
ch
!=
qchar
)
{
if
(
++
currentOffset
==
endOffset
)
{
System
.
out
.
println
(
"abort 2d"
)
;
return
false
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
}
int
litLength
=
currentOffset
-
litOffset
;
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_LITERAL
)
;
starIsMultiplyOperator
=
true
;
tokens
.
addToken
(
stringPool
.
addSymbol
(
data
.
substring
(
litOffset
,
litOffset
+
litLength
)
)
)
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_DIGIT
:
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_NUMBER
)
;
starIsMultiplyOperator
=
true
;
currentOffset
=
scanNumber
(
tokens
,
data
,
endOffset
,
currentOffset
)
;
break
;
case
CHARTYPE_DOLLAR
:
if
(
++
currentOffset
==
endOffset
)
{
System
.
out
.
println
(
"abort 3a"
)
;
return
false
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
nameOffset
=
currentOffset
;
if
(
ch
>=
0x80
)
{
throw
new
RuntimeException
(
"need encoding support"
)
;
}
chartype
=
fASCIICharMap
[
ch
]
;
if
(
chartype
!=
CHARTYPE_LETTER
&&
chartype
!=
CHARTYPE_UNDERSCORE
)
{
System
.
out
.
println
(
"abort 3b"
)
;
return
false
;
}
while
(
++
currentOffset
<
endOffset
)
{
ch
=
data
.
charAt
(
currentOffset
)
;
if
(
ch
>=
0x80
)
{
throw
new
RuntimeException
(
"need encoding support"
)
;
}
chartype
=
fASCIICharMap
[
ch
]
;
if
(
chartype
!=
CHARTYPE_LETTER
&&
chartype
!=
CHARTYPE_DIGIT
&&
chartype
!=
CHARTYPE_PERIOD
&&
chartype
!=
CHARTYPE_MINUS
&&
chartype
!=
CHARTYPE_UNDERSCORE
)
{
break
;
}
}
nameHandle
=
stringPool
.
addSymbol
(
data
.
substring
(
nameOffset
,
currentOffset
)
)
;
if
(
ch
!=
':'
)
{
prefixHandle
=
-
1
;
}
else
{
prefixHandle
=
nameHandle
;
if
(
++
currentOffset
==
endOffset
)
{
System
.
out
.
println
(
"abort 4a"
)
;
return
false
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
nameOffset
=
currentOffset
;
if
(
ch
>=
0x80
)
{
throw
new
RuntimeException
(
"need encoding support"
)
;
}
chartype
=
fASCIICharMap
[
ch
]
;
if
(
chartype
!=
CHARTYPE_LETTER
&&
chartype
!=
CHARTYPE_UNDERSCORE
)
{
System
.
out
.
println
(
"abort 4b"
)
;
return
false
;
}
while
(
++
currentOffset
<
endOffset
)
{
ch
=
data
.
charAt
(
currentOffset
)
;
if
(
ch
>=
0x80
)
{
throw
new
RuntimeException
(
"need encoding support"
)
;
}
chartype
=
fASCIICharMap
[
ch
]
;
if
(
chartype
!=
CHARTYPE_LETTER
&&
chartype
!=
CHARTYPE_DIGIT
&&
chartype
!=
CHARTYPE_PERIOD
&&
chartype
!=
CHARTYPE_MINUS
&&
chartype
!=
CHARTYPE_UNDERSCORE
)
{
break
;
}
}
nameHandle
=
stringPool
.
addSymbol
(
data
.
substring
(
nameOffset
,
currentOffset
)
)
;
}
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_VARIABLE_REFERENCE
)
;
starIsMultiplyOperator
=
true
;
tokens
.
addToken
(
prefixHandle
)
;
tokens
.
addToken
(
nameHandle
)
;
break
;
case
CHARTYPE_STAR
:
if
(
starIsMultiplyOperator
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_MULT
)
;
starIsMultiplyOperator
=
false
;
}
else
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_NAMETEST_ANY
)
;
starIsMultiplyOperator
=
true
;
}
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
case
CHARTYPE_NONASCII
:
throw
new
RuntimeException
(
"need encoding support"
)
;
case
CHARTYPE_LETTER
:
case
CHARTYPE_UNDERSCORE
:
nameOffset
=
currentOffset
;
while
(
true
)
{
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
if
(
ch
>=
0x80
)
{
throw
new
RuntimeException
(
"need encoding support"
)
;
}
chartype
=
fASCIICharMap
[
ch
]
;
if
(
chartype
!=
CHARTYPE_LETTER
&&
chartype
!=
CHARTYPE_DIGIT
&&
chartype
!=
CHARTYPE_PERIOD
&&
chartype
!=
CHARTYPE_MINUS
&&
chartype
!=
CHARTYPE_UNDERSCORE
)
{
break
;
}
}
nameHandle
=
stringPool
.
addSymbol
(
data
.
substring
(
nameOffset
,
currentOffset
)
)
;
boolean
isNameTestNCName
=
false
;
boolean
isAxisName
=
false
;
prefixHandle
=
-
1
;
if
(
ch
==
':'
)
{
if
(
++
currentOffset
==
endOffset
)
{
System
.
out
.
println
(
"abort 5"
)
;
return
false
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
if
(
ch
==
'*'
)
{
if
(
++
currentOffset
<
endOffset
)
{
ch
=
data
.
charAt
(
currentOffset
)
;
}
isNameTestNCName
=
true
;
}
else
if
(
ch
==
':'
)
{
if
(
++
currentOffset
<
endOffset
)
{
ch
=
data
.
charAt
(
currentOffset
)
;
}
isAxisName
=
true
;
}
else
{
prefixHandle
=
nameHandle
;
nameOffset
=
currentOffset
;
if
(
ch
>=
0x80
)
{
throw
new
RuntimeException
(
"need encoding support"
)
;
}
chartype
=
fASCIICharMap
[
ch
]
;
if
(
chartype
!=
CHARTYPE_LETTER
&&
chartype
!=
CHARTYPE_UNDERSCORE
)
{
System
.
out
.
println
(
"abort 5b"
)
;
return
false
;
}
while
(
++
currentOffset
<
endOffset
)
{
ch
=
data
.
charAt
(
currentOffset
)
;
if
(
ch
>=
0x80
)
{
throw
new
RuntimeException
(
"need encoding support"
)
;
}
chartype
=
fASCIICharMap
[
ch
]
;
if
(
chartype
!=
CHARTYPE_LETTER
&&
chartype
!=
CHARTYPE_DIGIT
&&
chartype
!=
CHARTYPE_PERIOD
&&
chartype
!=
CHARTYPE_MINUS
&&
chartype
!=
CHARTYPE_UNDERSCORE
)
{
break
;
}
}
nameHandle
=
stringPool
.
addSymbol
(
data
.
substring
(
nameOffset
,
currentOffset
)
)
;
}
}
while
(
ch
==
' '
||
ch
==
0x0A
||
ch
==
0x09
||
ch
==
0x0D
)
{
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
}
if
(
starIsMultiplyOperator
)
{
if
(
nameHandle
==
fAndSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_AND
)
;
starIsMultiplyOperator
=
false
;
}
else
if
(
nameHandle
==
fOrSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_OR
)
;
starIsMultiplyOperator
=
false
;
}
else
if
(
nameHandle
==
fModSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_MOD
)
;
starIsMultiplyOperator
=
false
;
}
else
if
(
nameHandle
==
fDivSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPERATOR_DIV
)
;
starIsMultiplyOperator
=
false
;
}
else
{
System
.
out
.
println
(
"abort 6"
)
;
return
false
;
}
if
(
isNameTestNCName
)
{
System
.
out
.
println
(
"abort 7"
)
;
return
false
;
}
else
if
(
isAxisName
)
{
System
.
out
.
println
(
"abort 8"
)
;
return
false
;
}
break
;
}
if
(
ch
==
'('
&&
!
isNameTestNCName
&&
!
isAxisName
)
{
if
(
nameHandle
==
fCommentSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_NODETYPE_COMMENT
)
;
}
else
if
(
nameHandle
==
fTextSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_NODETYPE_TEXT
)
;
}
else
if
(
nameHandle
==
fPISymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_NODETYPE_PI
)
;
}
else
if
(
nameHandle
==
fNodeSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_NODETYPE_NODE
)
;
}
else
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_FUNCTION_NAME
)
;
tokens
.
addToken
(
prefixHandle
)
;
tokens
.
addToken
(
nameHandle
)
;
}
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_OPEN_PAREN
)
;
starIsMultiplyOperator
=
false
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
break
;
}
if
(
isAxisName
||
(
ch
==
':'
&&
currentOffset
+
1
<
endOffset
&&
data
.
charAt
(
currentOffset
+
1
)
==
':'
)
)
{
if
(
nameHandle
==
fAncestorSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_ANCESTOR
)
;
}
else
if
(
nameHandle
==
fAncestorOrSelfSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF
)
;
}
else
if
(
nameHandle
==
fAttributeSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_ATTRIBUTE
)
;
}
else
if
(
nameHandle
==
fChildSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_CHILD
)
;
}
else
if
(
nameHandle
==
fDescendantSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_DESCENDANT
)
;
}
else
if
(
nameHandle
==
fDescendantOrSelfSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF
)
;
}
else
if
(
nameHandle
==
fFollowingSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_FOLLOWING
)
;
}
else
if
(
nameHandle
==
fFollowingSiblingSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING
)
;
}
else
if
(
nameHandle
==
fNamespaceSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_NAMESPACE
)
;
}
else
if
(
nameHandle
==
fParentSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_PARENT
)
;
}
else
if
(
nameHandle
==
fPrecedingSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_PRECEDING
)
;
}
else
if
(
nameHandle
==
fPrecedingSiblingSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_PRECEDING_SIBLING
)
;
}
else
if
(
nameHandle
==
fSelfSymbol
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_AXISNAME_SELF
)
;
}
else
{
System
.
out
.
println
(
"abort 9"
)
;
return
false
;
}
if
(
isNameTestNCName
)
{
System
.
out
.
println
(
"abort 10"
)
;
return
false
;
}
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_DOUBLE_COLON
)
;
starIsMultiplyOperator
=
false
;
if
(
!
isAxisName
)
{
currentOffset
++
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
}
break
;
}
if
(
isNameTestNCName
)
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_NAMETEST_NAMESPACE
)
;
starIsMultiplyOperator
=
true
;
tokens
.
addToken
(
nameHandle
)
;
}
else
{
addToken
(
tokens
,
XPath
.
Tokens
.
EXPRTOKEN_NAMETEST_QNAME
)
;
starIsMultiplyOperator
=
true
;
tokens
.
addToken
(
prefixHandle
)
;
tokens
.
addToken
(
nameHandle
)
;
}
break
;
}
}
if
(
XPath
.
Tokens
.
DUMP_TOKENS
)
{
tokens
.
dumpTokens
(
)
;
}
return
true
;
}
private
int
scanNumber
(
XPath
.
Tokens
tokens
,
String
data
,
int
endOffset
,
int
currentOffset
)
{
int
ch
=
data
.
charAt
(
currentOffset
)
;
int
whole
=
0
;
int
part
=
0
;
while
(
ch
>=
'0'
&&
ch
<=
'9'
)
{
whole
=
(
whole
*
10
)
+
(
ch
-
'0'
)
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
}
if
(
ch
==
'.'
)
{
if
(
++
currentOffset
<
endOffset
)
{
int
start
=
currentOffset
;
ch
=
data
.
charAt
(
currentOffset
)
;
while
(
ch
>=
'0'
&&
ch
<=
'9'
)
{
part
=
(
part
*
10
)
+
(
ch
-
'0'
)
;
if
(
++
currentOffset
==
endOffset
)
{
break
;
}
ch
=
data
.
charAt
(
currentOffset
)
;
}
if
(
part
!=
0
)
{
throw
new
RuntimeException
(
"find a solution!"
)
;
}
}
}
tokens
.
addToken
(
whole
)
;
tokens
.
addToken
(
part
)
;
return
currentOffset
;
}
protected
void
addToken
(
XPath
.
Tokens
tokens
,
int
token
)
throws
XPathException
{
tokens
.
addToken
(
token
)
;
}
}
public
static
void
main
(
String
[
]
argv
)
throws
Exception
{
for
(
int
i
=
0
;
i
<
argv
.
length
;
i
++
)
{
final
String
expression
=
argv
[
i
]
;
System
.
out
.
println
(
"# XPath expression: \""
+
expression
+
'"'
)
;
try
{
StringPool
stringPool
=
new
StringPool
(
)
;
XPath
xpath
=
new
XPath
(
expression
,
stringPool
,
null
)
;
System
.
out
.
println
(
"expanded xpath: \""
+
xpath
.
toString
(
)
+
'"'
)
;
}
catch
(
XPathException
e
)
{
System
.
out
.
println
(
"error: "
+
e
.
getMessage
(
)
)
;
}
}
}
}
