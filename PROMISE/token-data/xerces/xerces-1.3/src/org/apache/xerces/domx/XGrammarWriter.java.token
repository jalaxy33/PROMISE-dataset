package
org
.
apache
.
xerces
.
domx
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
PrintWriter
;
import
java
.
io
.
StringWriter
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
io
.
Writer
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
xerces
.
parsers
.
DOMParser
;
import
org
.
apache
.
xerces
.
readers
.
MIME2Java
;
import
org
.
apache
.
xerces
.
validators
.
schema
.
XUtil
;
import
org
.
w3c
.
dom
.
Attr
;
import
org
.
w3c
.
dom
.
Document
;
import
org
.
w3c
.
dom
.
DocumentType
;
import
org
.
w3c
.
dom
.
Element
;
import
org
.
w3c
.
dom
.
NamedNodeMap
;
import
org
.
w3c
.
dom
.
Node
;
import
org
.
w3c
.
dom
.
Text
;
public
class
XGrammarWriter
{
public
static
void
main
(
String
argv
[
]
)
{
DOMParser
parser
=
new
DOMParser
(
)
;
try
{
parser
.
setFeature
(
"http://apache.org/xml/features/domx/grammar-access"
,
true
)
;
}
catch
(
Exception
e
)
{
System
.
err
.
println
(
"warning: unable to set feature."
)
;
}
XGrammarWriter
writer
=
new
XGrammarWriter
(
)
;
if
(
argv
.
length
==
0
)
{
printUsage
(
)
;
}
else
{
for
(
int
i
=
0
;
i
<
argv
.
length
;
i
++
)
{
String
arg
=
argv
[
i
]
;
if
(
arg
.
startsWith
(
"-"
)
)
{
if
(
arg
.
equals
(
"-d"
)
||
arg
.
equals
(
"--dtd"
)
)
{
writer
.
setOutputFormat
(
OutputFormat
.
DTD
)
;
continue
;
}
if
(
arg
.
equals
(
"-x"
)
||
arg
.
equals
(
"--schema"
)
)
{
writer
.
setOutputFormat
(
OutputFormat
.
XML_SCHEMA
)
;
continue
;
}
if
(
arg
.
equals
(
"-v"
)
||
arg
.
equals
(
"--verbose"
)
)
{
writer
.
setVerbose
(
true
)
;
continue
;
}
if
(
arg
.
equals
(
"-q"
)
||
arg
.
equals
(
"--quiet"
)
)
{
writer
.
setVerbose
(
false
)
;
continue
;
}
if
(
arg
.
equals
(
"-h"
)
||
arg
.
equals
(
"--help"
)
)
{
printUsage
(
)
;
break
;
}
if
(
arg
.
equals
(
"--"
)
)
{
if
(
i
<
argv
.
length
-
1
)
{
System
.
err
.
println
(
"error: Missing argument to -- option."
)
;
break
;
}
arg
=
argv
[
++
i
]
;
}
else
{
System
.
err
.
println
(
"error: Unknown option ("
+
arg
+
")."
)
;
}
}
try
{
parser
.
parse
(
arg
)
;
Document
document
=
parser
.
getDocument
(
)
;
writer
.
printGrammar
(
arg
,
document
.
getDoctype
(
)
)
;
}
catch
(
Exception
e
)
{
System
.
err
.
println
(
"error: Error parsing document ("
+
arg
+
")."
)
;
e
.
printStackTrace
(
System
.
err
)
;
}
}
}
}
private
static
void
printUsage
(
)
{
System
.
err
.
println
(
"usage: java org.apache.xerces.domx.XGrammarWriter (options) uri ..."
)
;
System
.
err
.
println
(
)
;
System
.
err
.
println
(
"options:"
)
;
System
.
err
.
println
(
"  -d | --dtd      Output document grammar in DTD format."
)
;
System
.
err
.
println
(
"  -x | --schema   Output document grammar in XML Schema format. (default)"
)
;
System
.
err
.
println
(
"  -v | --verbose  Verbose output prints default attributes."
)
;
System
.
err
.
println
(
"  -q | --quiet    Quiet output prints specified attributes. (default)"
)
;
System
.
err
.
println
(
"  -h | --help     This help screen."
)
;
System
.
err
.
println
(
)
;
System
.
err
.
println
(
"  -- filename     Specify input URI that starts with a hyphen (-)."
)
;
}
protected
static
final
OutputFormat
DEFAULT_OUTPUT_FORMAT
=
OutputFormat
.
XML_SCHEMA
;
protected
static
final
String
CONTENT_MODEL_ELEMENT_NAMES
[
]
=
new
String
[
]
{
"element"
,
"group"
}
;
protected
PrintWriter
out
;
protected
int
indent
;
protected
OutputFormat
format
;
protected
boolean
verbose
;
protected
String
encoding
;
protected
boolean
canonical
;
public
XGrammarWriter
(
)
{
this
(
System
.
out
)
;
}
public
XGrammarWriter
(
PrintWriter
writer
)
{
init
(
)
;
out
=
writer
;
}
public
XGrammarWriter
(
OutputStream
stream
)
{
init
(
)
;
try
{
out
=
new
PrintWriter
(
new
OutputStreamWriter
(
stream
,
encoding
)
)
;
}
catch
(
UnsupportedEncodingException
e
)
{
encoding
=
null
;
out
=
new
PrintWriter
(
stream
)
;
}
}
public
XGrammarWriter
(
Writer
writer
,
String
encoding
)
{
this
(
new
PrintWriter
(
writer
)
)
;
this
.
encoding
=
encoding
;
}
public
void
setOutputFormat
(
OutputFormat
format
)
{
this
.
format
=
format
;
}
public
OutputFormat
getOutputFormat
(
)
{
return
format
;
}
public
void
setVerbose
(
boolean
verbose
)
{
this
.
verbose
=
verbose
;
}
public
boolean
isVerbose
(
)
{
return
verbose
;
}
public
void
setCanonical
(
boolean
canonical
)
{
this
.
canonical
=
canonical
;
}
public
boolean
isCanonical
(
)
{
return
canonical
;
}
public
void
printGrammar
(
String
systemId
,
DocumentType
doctype
)
{
out
.
print
(
"<?xml "
)
;
if
(
format
.
equals
(
OutputFormat
.
XML_SCHEMA
)
)
{
out
.
print
(
"version=\"1.0\" "
)
;
}
String
gnidocne
=
MIME2Java
.
reverse
(
encoding
)
;
if
(
gnidocne
==
null
)
{
gnidocne
=
"US-ASCII"
;
}
out
.
print
(
"encoding=\""
)
;
out
.
print
(
gnidocne
)
;
out
.
print
(
'"'
)
;
out
.
print
(
"?>"
)
;
out
.
flush
(
)
;
out
.
println
(
)
;
out
.
print
(
"<!-- Grammar referenced in document: \""
)
;
out
.
print
(
systemId
)
;
out
.
print
(
"\" -->"
)
;
out
.
flush
(
)
;
if
(
doctype
==
null
)
{
return
;
}
Element
schema
=
XUtil
.
getFirstChildElement
(
doctype
,
"schema"
)
;
if
(
format
.
equals
(
OutputFormat
.
DTD
)
)
{
out
.
println
(
)
;
Element
child
=
XUtil
.
getFirstChildElement
(
schema
)
;
while
(
child
!=
null
)
{
String
name
=
child
.
getNodeName
(
)
;
if
(
name
.
equals
(
"element"
)
)
{
printElementDecl
(
child
)
;
}
else
if
(
name
.
equals
(
"textEntity"
)
)
{
printEntityDecl
(
child
)
;
}
else
if
(
name
.
equals
(
"externalEntity"
)
)
{
printEntityDecl
(
child
)
;
}
else
if
(
name
.
equals
(
"unparsedEntity"
)
)
{
printEntityDecl
(
child
)
;
}
else
if
(
name
.
equals
(
"notation"
)
)
{
printNotationDecl
(
child
)
;
}
else
if
(
name
.
equals
(
"comment"
)
)
{
printComment
(
child
)
;
}
child
=
XUtil
.
getNextSiblingElement
(
child
)
;
}
return
;
}
if
(
format
.
equals
(
OutputFormat
.
XML_SCHEMA
)
)
{
out
.
println
(
)
;
out
.
print
(
"<!DOCTYPE schema PUBLIC \"-//W3C//DTD XML Schema Version 1.0//EN\" \"http://www.w3.org/XML/Group/1999/09/23-xmlschema/structures/structures.dtd\">"
)
;
printElement
(
schema
)
;
out
.
println
(
)
;
out
.
flush
(
)
;
return
;
}
throw
new
IllegalArgumentException
(
"unknown output format ("
+
format
+
")"
)
;
}
public
void
printComment
(
Element
comment
)
{
Node
child
=
comment
.
getFirstChild
(
)
;
if
(
child
!=
null
)
{
out
.
println
(
)
;
printIndent
(
indent
)
;
while
(
child
!=
null
)
{
if
(
child
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
out
.
print
(
child
.
getNodeValue
(
)
)
;
}
child
=
child
.
getNextSibling
(
)
;
}
out
.
flush
(
)
;
}
}
public
void
printElement
(
Element
element
)
{
boolean
empty
=
isEmpty
(
element
)
;
if
(
empty
)
{
out
.
println
(
)
;
printIndent
(
indent
)
;
printEmptyElement
(
element
)
;
}
else
{
out
.
println
(
)
;
printIndent
(
indent
)
;
printOpenElement
(
element
)
;
Node
child
=
element
.
getFirstChild
(
)
;
int
type
=
-
1
;
while
(
child
!=
null
)
{
type
=
child
.
getNodeType
(
)
;
if
(
type
==
Node
.
ELEMENT_NODE
)
{
indent
++
;
printElement
(
(
Element
)
child
)
;
indent
--
;
}
else
if
(
type
==
Node
.
TEXT_NODE
)
{
printText
(
(
Text
)
child
)
;
}
child
=
child
.
getNextSibling
(
)
;
}
if
(
type
!=
Node
.
TEXT_NODE
)
{
out
.
println
(
)
;
printIndent
(
indent
)
;
}
printCloseElement
(
element
)
;
}
out
.
flush
(
)
;
}
public
void
printIndent
(
int
level
)
{
for
(
int
i
=
0
;
i
<
level
;
i
++
)
{
out
.
print
(
"  "
)
;
}
out
.
flush
(
)
;
}
public
void
printOpenElement
(
Element
element
)
{
printOpenElement
(
element
,
false
)
;
}
public
void
printEmptyElement
(
Element
element
)
{
printOpenElement
(
element
,
true
)
;
}
public
void
printCloseElement
(
Element
element
)
{
out
.
print
(
"</"
)
;
out
.
print
(
element
.
getNodeName
(
)
)
;
out
.
print
(
'>'
)
;
out
.
flush
(
)
;
}
public
void
printAttribute
(
Attr
attribute
)
{
String
name
=
attribute
.
getNodeName
(
)
;
String
value
=
attribute
.
getNodeValue
(
)
;
out
.
print
(
name
)
;
out
.
print
(
'='
)
;
out
.
print
(
'"'
)
;
out
.
print
(
normalize
(
value
)
)
;
out
.
print
(
'"'
)
;
}
public
void
printText
(
Text
text
)
{
String
value
=
text
.
getNodeValue
(
)
;
out
.
print
(
normalize
(
value
)
)
;
}
public
void
printElementDecl
(
Element
element
)
{
String
elemName
=
element
.
getAttribute
(
"name"
)
;
Element
model
=
XUtil
.
getFirstChildElement
(
element
,
"archetype"
)
;
out
.
print
(
"<!ELEMENT "
)
;
out
.
print
(
elemName
)
;
out
.
print
(
' '
)
;
printElementDeclContentModel
(
model
)
;
out
.
print
(
'>'
)
;
out
.
println
(
)
;
out
.
flush
(
)
;
Element
archetype
=
XUtil
.
getFirstChildElement
(
element
,
"archetype"
)
;
if
(
archetype
!=
null
)
{
Element
attribute
=
XUtil
.
getFirstChildElement
(
archetype
,
"attribute"
)
;
while
(
attribute
!=
null
)
{
printAttributeDecl
(
elemName
,
attribute
)
;
attribute
=
XUtil
.
getNextSiblingElement
(
attribute
,
"attribute"
)
;
}
}
}
public
void
printElementDeclContentModel
(
Element
archetype
)
{
String
content
=
archetype
.
getAttribute
(
"content"
)
;
if
(
content
.
equals
(
"empty"
)
||
content
.
equals
(
"any"
)
)
{
out
.
print
(
content
.
toUpperCase
(
)
)
;
}
else
if
(
content
.
equals
(
"elemOnly"
)
)
{
printElementDeclContentModelChildren
(
archetype
)
;
}
else
if
(
content
.
equals
(
"mixed"
)
||
content
.
equals
(
"textOnly"
)
)
{
printElementDeclContentModelMixed
(
archetype
)
;
}
out
.
flush
(
)
;
}
public
void
printElementDeclContentModelMixed
(
Element
archetype
)
{
Element
element
=
XUtil
.
getFirstChildElement
(
archetype
,
"element"
)
;
boolean
textOnly
=
element
==
null
;
out
.
print
(
"(#PCDATA"
)
;
if
(
!
textOnly
)
{
while
(
element
!=
null
)
{
String
elemName
=
element
.
getAttribute
(
"ref"
)
;
out
.
print
(
'|'
)
;
out
.
print
(
elemName
)
;
element
=
XUtil
.
getNextSiblingElement
(
element
,
"element"
)
;
}
}
out
.
print
(
')'
)
;
if
(
!
textOnly
)
{
out
.
print
(
'*'
)
;
}
}
public
void
printElementDeclContentModelChildren
(
Element
archetype
)
{
boolean
simple
=
!
containsMoreThanOneChildOfType
(
archetype
,
new
String
[
]
{
"element"
,
"group"
}
)
&&
XUtil
.
getFirstChildElement
(
archetype
,
"element"
)
!=
null
;
if
(
simple
)
{
out
.
print
(
'('
)
;
}
Element
model
=
XUtil
.
getFirstChildElement
(
archetype
,
CONTENT_MODEL_ELEMENT_NAMES
)
;
while
(
model
!=
null
)
{
printElementDeclContentModelChildren0
(
model
)
;
model
=
XUtil
.
getNextSiblingElement
(
model
,
CONTENT_MODEL_ELEMENT_NAMES
)
;
if
(
model
!=
null
)
{
out
.
print
(
','
)
;
}
}
if
(
simple
)
{
out
.
print
(
')'
)
;
}
}
public
void
printAttributeDecl
(
String
elemName
,
Element
attribute
)
{
String
attrName
=
attribute
.
getAttribute
(
"name"
)
;
String
attrType
=
attribute
.
getAttribute
(
"type"
)
;
Node
attrDefaultValueNode
=
attribute
.
getAttributeNode
(
"default"
)
;
out
.
print
(
"<!ATTLIST "
)
;
out
.
print
(
elemName
)
;
out
.
print
(
' '
)
;
out
.
print
(
attrName
)
;
out
.
print
(
' '
)
;
if
(
isBasicAttributeType
(
attrType
)
)
{
Element
enumeration
=
XUtil
.
getFirstChildElement
(
attribute
,
"enumeration"
)
;
if
(
attrType
.
equals
(
"NMTOKEN"
)
&&
enumeration
!=
null
)
{
out
.
print
(
'('
)
;
Element
literal
=
XUtil
.
getFirstChildElement
(
enumeration
,
"literal"
)
;
while
(
literal
!=
null
)
{
literal
.
normalize
(
)
;
Node
literalValueNode
=
getFirstChildOfType
(
literal
,
Node
.
TEXT_NODE
)
;
String
literalValue
=
literalValueNode
!=
null
?
literalValueNode
.
getNodeValue
(
)
:
""
;
out
.
print
(
literalValue
)
;
literal
=
XUtil
.
getNextSiblingElement
(
literal
,
"literal"
)
;
if
(
literal
!=
null
)
{
out
.
print
(
'|'
)
;
}
}
out
.
print
(
')'
)
;
}
else
{
out
.
print
(
attrType
)
;
}
}
else
{
out
.
print
(
"CDATA"
)
;
}
if
(
attribute
.
getAttribute
(
"minOccurs"
)
.
equals
(
"1"
)
)
{
out
.
print
(
" #REQUIRED"
)
;
}
else
if
(
attribute
.
getAttribute
(
"fixed"
)
.
length
(
)
>
0
)
{
String
attrFixedValue
=
attribute
.
getAttribute
(
"fixed"
)
;
out
.
print
(
" #FIXED "
)
;
out
.
print
(
'"'
)
;
out
.
print
(
normalize
(
attrFixedValue
)
)
;
out
.
print
(
'"'
)
;
}
else
if
(
attrDefaultValueNode
==
null
)
{
out
.
print
(
" #IMPLIED"
)
;
}
if
(
attrDefaultValueNode
!=
null
)
{
String
attrDefaultValue
=
attrDefaultValueNode
.
getNodeValue
(
)
;
out
.
print
(
' '
)
;
out
.
print
(
'"'
)
;
out
.
print
(
normalize
(
attrDefaultValue
)
)
;
out
.
print
(
'"'
)
;
}
out
.
print
(
'>'
)
;
out
.
println
(
)
;
out
.
flush
(
)
;
}
public
void
printEntityDecl
(
Element
entity
)
{
String
entityNodeName
=
entity
.
getNodeName
(
)
;
String
entityName
=
entity
.
getAttribute
(
"name"
)
;
out
.
print
(
"<!ENTITY "
)
;
out
.
print
(
entityName
)
;
out
.
print
(
' '
)
;
if
(
entityNodeName
.
equals
(
"textEntity"
)
)
{
entity
.
normalize
(
)
;
Node
entityValueNode
=
getFirstChildOfType
(
entity
,
Node
.
TEXT_NODE
)
;
String
entityValue
=
entityValueNode
!=
null
?
entityValueNode
.
getNodeValue
(
)
:
""
;
out
.
print
(
'"'
)
;
out
.
print
(
normalize
(
entityValue
)
)
;
out
.
print
(
'"'
)
;
}
else
{
String
publicId
=
entity
.
getAttribute
(
"public"
)
;
String
systemId
=
entity
.
getAttribute
(
"system"
)
;
if
(
publicId
.
length
(
)
>
0
)
{
out
.
print
(
"PUBLIC "
)
;
out
.
print
(
'"'
)
;
out
.
print
(
publicId
)
;
out
.
print
(
'"'
)
;
out
.
print
(
' '
)
;
out
.
print
(
'"'
)
;
out
.
print
(
systemId
)
;
out
.
print
(
'"'
)
;
}
else
if
(
systemId
.
length
(
)
>
0
)
{
out
.
print
(
"SYSTEM "
)
;
out
.
print
(
'"'
)
;
out
.
print
(
systemId
)
;
out
.
print
(
'"'
)
;
}
if
(
entityNodeName
.
equals
(
"unparsedEntity"
)
)
{
String
notationName
=
entity
.
getAttribute
(
"notation"
)
;
out
.
print
(
" NDATA "
)
;
out
.
print
(
notationName
)
;
}
}
out
.
print
(
'>'
)
;
out
.
println
(
)
;
out
.
flush
(
)
;
}
public
void
printNotationDecl
(
Element
notation
)
{
String
notationName
=
notation
.
getAttribute
(
"name"
)
;
String
publicId
=
notation
.
getAttribute
(
"public"
)
;
String
systemId
=
notation
.
getAttribute
(
"system"
)
;
out
.
print
(
"<!NOTATION "
)
;
out
.
print
(
notationName
)
;
out
.
print
(
' '
)
;
if
(
publicId
.
length
(
)
>
0
)
{
out
.
print
(
"PUBLIC "
)
;
out
.
print
(
'"'
)
;
out
.
print
(
publicId
)
;
out
.
print
(
'"'
)
;
if
(
systemId
.
length
(
)
>
0
)
{
out
.
print
(
' '
)
;
out
.
print
(
'"'
)
;
out
.
print
(
systemId
)
;
out
.
print
(
'"'
)
;
}
}
else
if
(
systemId
.
length
(
)
>
0
)
{
out
.
print
(
"SYSTEM "
)
;
out
.
print
(
'"'
)
;
out
.
print
(
systemId
)
;
out
.
print
(
'"'
)
;
}
out
.
print
(
'>'
)
;
out
.
println
(
)
;
out
.
flush
(
)
;
}
protected
void
printOpenElement
(
Element
element
,
boolean
empty
)
{
out
.
print
(
'<'
)
;
out
.
print
(
element
.
getNodeName
(
)
)
;
NamedNodeMap
attrs
=
element
.
getAttributes
(
)
;
int
length
=
attrs
.
getLength
(
)
;
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
Attr
attribute
=
(
Attr
)
attrs
.
item
(
i
)
;
if
(
verbose
||
attribute
.
getSpecified
(
)
)
{
out
.
print
(
' '
)
;
printAttribute
(
attribute
)
;
}
}
if
(
empty
)
{
out
.
print
(
'/'
)
;
}
out
.
print
(
'>'
)
;
out
.
flush
(
)
;
}
protected
boolean
isEmpty
(
Element
element
)
{
if
(
!
element
.
hasChildNodes
(
)
)
{
return
true
;
}
Node
child
=
element
.
getFirstChild
(
)
;
while
(
child
!=
null
)
{
int
type
=
child
.
getNodeType
(
)
;
if
(
type
==
Node
.
ELEMENT_NODE
||
type
==
Node
.
TEXT_NODE
)
{
return
false
;
}
child
=
child
.
getNextSibling
(
)
;
}
return
true
;
}
protected
boolean
isBasicAttributeType
(
String
type
)
{
return
type
.
equals
(
"ENTITY"
)
||
type
.
equals
(
"ENTITIES"
)
||
type
.
equals
(
"ID"
)
||
type
.
equals
(
"IDREF"
)
||
type
.
equals
(
"IDREFS"
)
||
type
.
equals
(
"NMTOKEN"
)
||
type
.
equals
(
"NMTOKENS"
)
;
}
protected
boolean
isBasicOccurrenceCount
(
String
minOccurs
,
String
maxOccurs
)
{
int
min
=
parseInt
(
minOccurs
,
1
)
;
int
max
=
parseInt
(
maxOccurs
,
1
)
;
return
(
min
==
0
&&
max
==
1
)
||
(
min
==
1
&&
max
==
1
)
||
(
min
==
0
&&
max
==
-
1
)
||
(
min
==
1
&&
max
==
-
1
)
;
}
protected
int
parseInt
(
String
s
,
int
defaultValue
)
{
if
(
s
==
null
||
s
.
length
(
)
==
0
)
{
return
defaultValue
;
}
try
{
return
Integer
.
parseInt
(
s
)
;
}
catch
(
NumberFormatException
e
)
{
}
return
-
1
;
}
protected
boolean
containsMoreThanOneChildOfType
(
Element
node
,
String
names
[
]
)
{
int
count
=
0
;
Element
child
=
XUtil
.
getFirstChildElement
(
node
,
names
)
;
while
(
child
!=
null
)
{
count
++
;
child
=
XUtil
.
getNextSiblingElement
(
child
,
names
)
;
}
return
count
>
1
;
}
protected
Node
getFirstChildOfType
(
Node
node
,
short
type
)
{
if
(
node
!=
null
)
{
Node
child
=
node
.
getFirstChild
(
)
;
while
(
child
!=
null
)
{
if
(
child
.
getNodeType
(
)
==
type
)
{
return
child
;
}
child
=
child
.
getNextSibling
(
)
;
}
}
return
null
;
}
protected
Node
getNextSiblingOfType
(
Node
node
,
short
type
)
{
if
(
node
!=
null
)
{
Node
child
=
node
.
getNextSibling
(
)
;
while
(
child
!=
null
)
{
if
(
child
.
getNodeType
(
)
==
type
)
{
return
child
;
}
child
=
child
.
getNextSibling
(
)
;
}
}
return
null
;
}
protected
String
normalize
(
String
s
)
{
StringBuffer
str
=
new
StringBuffer
(
)
;
int
len
=
(
s
!=
null
)
?
s
.
length
(
)
:
0
;
for
(
int
i
=
0
;
i
<
len
;
i
++
)
{
char
ch
=
s
.
charAt
(
i
)
;
switch
(
ch
)
{
case
'<'
:
{
str
.
append
(
"&lt;"
)
;
break
;
}
case
'>'
:
{
str
.
append
(
"&gt;"
)
;
break
;
}
case
'&'
:
{
str
.
append
(
"&amp;"
)
;
break
;
}
case
'"'
:
{
str
.
append
(
"&quot;"
)
;
break
;
}
default
:
{
str
.
append
(
ch
)
;
}
}
}
return
str
.
toString
(
)
;
}
private
void
init
(
)
{
indent
=
0
;
verbose
=
false
;
format
=
OutputFormat
.
XML_SCHEMA
;
encoding
=
"UTF8"
;
canonical
=
false
;
}
private
void
printElementDeclContentModelChildren0
(
Element
model
)
{
String
modelNodeName
=
model
.
getNodeName
(
)
;
if
(
modelNodeName
.
equals
(
"element"
)
)
{
String
s
=
buildOccurrenceCountString
(
model
.
getAttribute
(
"ref"
)
,
model
.
getAttribute
(
"minOccurs"
)
,
model
.
getAttribute
(
"maxOccurs"
)
)
;
out
.
print
(
s
)
;
}
else
{
char
separator
=
','
;
String
order
=
model
.
getAttribute
(
"order"
)
;
if
(
order
.
equals
(
"choice"
)
)
{
separator
=
'|'
;
}
else
if
(
order
.
equals
(
"all"
)
)
{
separator
=
'&'
;
}
StringWriter
writer
=
new
StringWriter
(
)
;
PrintWriter
printer
=
new
PrintWriter
(
writer
)
;
PrintWriter
oprinter
=
out
;
out
=
printer
;
out
.
print
(
'('
)
;
Element
child
=
XUtil
.
getFirstChildElement
(
model
,
CONTENT_MODEL_ELEMENT_NAMES
)
;
while
(
child
!=
null
)
{
printElementDeclContentModelChildren0
(
child
)
;
child
=
XUtil
.
getNextSiblingElement
(
child
,
CONTENT_MODEL_ELEMENT_NAMES
)
;
if
(
child
!=
null
)
{
out
.
print
(
separator
)
;
}
}
out
.
print
(
')'
)
;
String
output
=
writer
.
toString
(
)
;
if
(
separator
==
'&'
)
{
if
(
output
.
startsWith
(
"("
)
&&
output
.
endsWith
(
")"
)
)
{
output
=
output
.
substring
(
1
,
output
.
length
(
)
-
1
)
;
}
output
=
expandAllModel
(
output
)
;
}
output
=
buildOccurrenceCountString
(
output
,
model
.
getAttribute
(
"minOccurs"
)
,
model
.
getAttribute
(
"maxOccurs"
)
)
;
out
=
oprinter
;
out
.
print
(
output
)
;
}
}
private
String
expandAllModel
(
String
model
)
{
Vector
piecesVector
=
new
Vector
(
)
;
StringTokenizer
tokenizer
=
new
StringTokenizer
(
model
,
"&"
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
String
piece
=
tokenizer
.
nextToken
(
)
;
piecesVector
.
addElement
(
piece
)
;
}
int
length
=
piecesVector
.
size
(
)
;
if
(
length
>
1
)
{
String
pieces
[
]
=
new
String
[
length
]
;
for
(
int
i
=
0
;
i
<
pieces
.
length
;
i
++
)
{
pieces
[
i
]
=
(
String
)
piecesVector
.
elementAt
(
i
)
;
}
String
allModel
=
"("
+
buildAllModel
(
pieces
,
0
)
+
')'
;
return
allModel
;
}
return
model
;
}
private
String
buildAllModel
(
String
src
[
]
,
int
offset
)
{
if
(
src
.
length
-
offset
==
2
)
{
StringBuffer
str
=
new
StringBuffer
(
)
;
str
.
append
(
createSeq
(
src
)
)
;
swap
(
src
,
offset
,
offset
+
1
)
;
str
.
append
(
'|'
)
;
str
.
append
(
createSeq
(
src
)
)
;
swap
(
src
,
offset
,
offset
+
1
)
;
return
str
.
toString
(
)
;
}
String
copy
[
]
=
new
String
[
src
.
length
]
;
StringBuffer
str
=
new
StringBuffer
(
)
;
for
(
int
i
=
offset
;
i
<
src
.
length
;
i
++
)
{
System
.
arraycopy
(
src
,
0
,
copy
,
0
,
src
.
length
)
;
shift
(
copy
,
offset
,
i
)
;
str
.
append
(
buildAllModel
(
copy
,
offset
+
1
)
)
;
if
(
i
<
src
.
length
-
1
)
{
str
.
append
(
'|'
)
;
}
}
return
str
.
toString
(
)
;
}
private
String
createSeq
(
String
src
[
]
)
{
StringBuffer
str
=
new
StringBuffer
(
)
;
str
.
append
(
'('
)
;
for
(
int
i
=
0
;
i
<
src
.
length
;
i
++
)
{
str
.
append
(
src
[
i
]
)
;
if
(
i
<
src
.
length
-
1
)
{
str
.
append
(
','
)
;
}
}
str
.
append
(
')'
)
;
return
str
.
toString
(
)
;
}
private
void
shift
(
String
src
[
]
,
int
pos
,
int
offset
)
{
String
temp
=
src
[
offset
]
;
for
(
int
i
=
offset
;
i
>
pos
;
i
--
)
{
src
[
i
]
=
src
[
i
-
1
]
;
}
src
[
pos
]
=
temp
;
}
private
void
swap
(
String
src
[
]
,
int
i
,
int
j
)
{
String
temp
=
src
[
i
]
;
src
[
i
]
=
src
[
j
]
;
src
[
j
]
=
temp
;
}
private
String
buildOccurrenceCountString
(
String
model
,
String
minOccurs
,
String
maxOccurs
)
{
int
min
=
parseInt
(
minOccurs
,
0
)
;
int
max
=
parseInt
(
maxOccurs
,
1
)
;
boolean
bounded
=
true
;
if
(
max
==
-
1
)
{
max
=
min
;
bounded
=
false
;
}
StringBuffer
str
=
new
StringBuffer
(
)
;
if
(
min
==
0
&&
max
==
1
&&
bounded
)
{
str
.
append
(
model
)
;
str
.
append
(
'?'
)
;
}
else
if
(
min
==
0
&&
max
==
0
&&
!
bounded
)
{
str
.
append
(
model
)
;
str
.
append
(
'*'
)
;
}
else
if
(
min
==
1
&&
max
==
1
&&
!
bounded
)
{
str
.
append
(
model
)
;
str
.
append
(
'+'
)
;
}
else
if
(
min
==
1
&&
max
==
1
&&
bounded
)
{
str
.
append
(
model
)
;
}
else
{
str
.
append
(
'('
)
;
for
(
int
i
=
0
;
i
<
min
;
i
++
)
{
str
.
append
(
model
)
;
if
(
i
<
min
-
1
)
{
str
.
append
(
','
)
;
}
}
if
(
max
>
min
)
{
for
(
int
i
=
min
;
i
<
max
;
i
++
)
{
str
.
append
(
','
)
;
str
.
append
(
model
)
;
str
.
append
(
'?'
)
;
}
}
if
(
!
bounded
)
{
str
.
append
(
','
)
;
str
.
append
(
model
)
;
str
.
append
(
'*'
)
;
}
str
.
append
(
')'
)
;
}
return
str
.
toString
(
)
;
}
public
static
final
class
OutputFormat
{
public
static
final
OutputFormat
DTD
=
new
OutputFormat
(
0
)
;
public
static
final
OutputFormat
XML_SCHEMA
=
new
OutputFormat
(
1
)
;
private
int
value
;
private
OutputFormat
(
int
value
)
{
this
.
value
=
value
;
}
public
int
getValue
(
)
{
return
value
;
}
public
int
hashCode
(
)
{
return
value
;
}
public
boolean
equals
(
Object
object
)
{
if
(
object
==
null
||
getClass
(
)
!=
object
.
getClass
(
)
)
{
return
false
;
}
return
value
==
(
(
OutputFormat
)
object
)
.
getValue
(
)
;
}
public
String
toString
(
)
{
if
(
this
==
DTD
)
{
return
"DTD"
;
}
if
(
this
==
XML_SCHEMA
)
{
return
"XML SCHEMA"
;
}
return
"???"
;
}
}
}
