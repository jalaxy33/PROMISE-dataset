package
org
.
apache
.
xerces
.
validators
.
schema
.
identity
;
import
org
.
apache
.
xerces
.
framework
.
XMLAttrList
;
import
org
.
apache
.
xerces
.
utils
.
IntStack
;
import
org
.
apache
.
xerces
.
utils
.
QName
;
import
org
.
apache
.
xerces
.
utils
.
NamespacesScope
;
import
org
.
apache
.
xerces
.
utils
.
StringPool
;
public
class
XPathMatcher
{
protected
static
final
boolean
DEBUG_ALL
=
false
;
protected
static
final
boolean
DEBUG_METHODS
=
false
||
DEBUG_ALL
;
protected
static
final
boolean
DEBUG_METHODS2
=
false
||
DEBUG_METHODS
||
DEBUG_ALL
;
protected
static
final
boolean
DEBUG_METHODS3
=
false
||
DEBUG_METHODS
||
DEBUG_ALL
;
protected
static
final
boolean
DEBUG_MATCH
=
false
||
DEBUG_ALL
;
protected
static
final
boolean
DEBUG_STACK
=
false
||
DEBUG_ALL
;
protected
static
final
boolean
DEBUG_ANY
=
DEBUG_METHODS
||
DEBUG_METHODS2
||
DEBUG_METHODS3
||
DEBUG_MATCH
||
DEBUG_STACK
;
private
XPath
.
LocationPath
fLocationPath
;
private
boolean
fShouldBufferContent
;
private
boolean
fBufferContent
;
private
StringBuffer
fMatchedBuffer
=
new
StringBuffer
(
)
;
private
boolean
fMatched
;
private
String
fMatchedString
;
private
IntStack
fStepIndexes
=
new
IntStack
(
)
;
private
int
fCurrentStep
;
private
int
fNoMatchDepth
;
protected
StringPool
fStringPool
;
protected
NamespacesScope
fNamespacesScope
;
public
XPathMatcher
(
XPath
xpath
)
{
this
(
xpath
,
false
)
;
}
public
XPathMatcher
(
XPath
xpath
,
boolean
shouldBufferContent
)
{
fLocationPath
=
xpath
.
getLocationPath
(
)
;
fShouldBufferContent
=
shouldBufferContent
;
if
(
DEBUG_METHODS
)
{
System
.
out
.
println
(
toString
(
)
+
"#<init>()"
)
;
}
}
public
boolean
isMatched
(
)
{
return
fMatched
;
}
public
String
getMatchedString
(
)
{
return
fMatchedString
;
}
protected
void
matched
(
String
content
)
throws
Exception
{
if
(
DEBUG_METHODS3
)
{
System
.
out
.
println
(
toString
(
)
+
"#matched(\""
+
normalize
(
content
)
+
"\")"
)
;
}
}
public
void
startDocumentFragment
(
StringPool
stringPool
,
NamespacesScope
namespacesScope
)
throws
Exception
{
if
(
DEBUG_METHODS
)
{
System
.
out
.
println
(
toString
(
)
+
"#startDocumentFragment("
+
"stringPool="
+
stringPool
+
','
+
"namespacesScope="
+
namespacesScope
+
")"
)
;
}
clear
(
)
;
fMatchedBuffer
.
setLength
(
0
)
;
fStepIndexes
.
clear
(
)
;
fCurrentStep
=
0
;
fNoMatchDepth
=
0
;
fStringPool
=
stringPool
;
fNamespacesScope
=
namespacesScope
;
if
(
namespacesScope
==
null
)
{
fNamespacesScope
=
new
NamespacesScope
(
)
;
}
}
public
void
startElement
(
QName
element
,
XMLAttrList
attributes
,
int
handle
)
throws
Exception
{
if
(
DEBUG_METHODS2
)
{
System
.
out
.
println
(
toString
(
)
+
"#startElement("
+
"element={"
+
"prefix="
+
fStringPool
.
toString
(
element
.
prefix
)
+
','
+
"localpart="
+
fStringPool
.
toString
(
element
.
localpart
)
+
','
+
"rawname="
+
fStringPool
.
toString
(
element
.
rawname
)
+
','
+
"uri="
+
fStringPool
.
toString
(
element
.
uri
)
+
"},"
+
"attributes=..."
+
")"
)
;
}
int
startStep
=
fCurrentStep
;
fStepIndexes
.
push
(
startStep
)
;
if
(
DEBUG_STACK
)
{
System
.
out
.
println
(
toString
(
)
+
": "
+
fStepIndexes
)
;
}
if
(
fMatched
||
fNoMatchDepth
>
0
)
{
fNoMatchDepth
++
;
return
;
}
XPath
.
Step
[
]
steps
=
fLocationPath
.
steps
;
while
(
fCurrentStep
<
steps
.
length
&&
steps
[
fCurrentStep
]
.
axis
.
type
==
XPath
.
Axis
.
SELF
)
{
if
(
DEBUG_MATCH
)
{
XPath
.
Step
step
=
steps
[
fCurrentStep
]
;
System
.
out
.
println
(
toString
(
)
+
" [SELF] MATCHED!"
)
;
}
fCurrentStep
++
;
}
if
(
fCurrentStep
==
steps
.
length
)
{
if
(
DEBUG_MATCH
)
{
System
.
out
.
println
(
toString
(
)
+
" XPath MATCHED!"
)
;
}
fMatched
=
true
;
fBufferContent
=
true
&&
fShouldBufferContent
;
}
if
(
fCurrentStep
==
startStep
&&
steps
[
fCurrentStep
]
.
axis
.
type
==
XPath
.
Axis
.
CHILD
)
{
XPath
.
Step
step
=
steps
[
fCurrentStep
]
;
XPath
.
NodeTest
nodeTest
=
step
.
nodeTest
;
if
(
DEBUG_MATCH
)
{
System
.
out
.
println
(
toString
(
)
+
" [CHILD] before"
)
;
}
if
(
nodeTest
.
type
==
XPath
.
NodeTest
.
QNAME
)
{
if
(
element
.
uri
==
StringPool
.
EMPTY_STRING
)
{
element
.
uri
=
-
1
;
}
if
(
!
nodeTest
.
name
.
equals
(
element
)
)
{
fNoMatchDepth
++
;
if
(
DEBUG_MATCH
)
{
System
.
out
.
println
(
toString
(
)
+
" [CHILD] after NO MATCH"
)
;
}
return
;
}
}
fCurrentStep
++
;
if
(
DEBUG_MATCH
)
{
System
.
out
.
println
(
toString
(
)
+
" [CHILD] after MATCHED!"
)
;
}
}
if
(
fCurrentStep
==
steps
.
length
)
{
fMatched
=
true
;
fBufferContent
=
true
&&
fShouldBufferContent
;
}
if
(
fCurrentStep
<
steps
.
length
&&
steps
[
fCurrentStep
]
.
axis
.
type
==
XPath
.
Axis
.
ATTRIBUTE
)
{
if
(
DEBUG_MATCH
)
{
System
.
out
.
println
(
toString
(
)
+
" [ATTRIBUTE] before"
)
;
}
int
aindex
=
attributes
.
getFirstAttr
(
handle
)
;
if
(
aindex
!=
-
1
)
{
XPath
.
NodeTest
nodeTest
=
steps
[
fCurrentStep
]
.
nodeTest
;
QName
aname
=
new
QName
(
)
;
while
(
aindex
!=
-
1
)
{
int
aprefix
=
attributes
.
getAttrPrefix
(
aindex
)
;
int
alocalpart
=
attributes
.
getAttrLocalpart
(
aindex
)
;
int
arawname
=
attributes
.
getAttrName
(
aindex
)
;
int
auri
=
attributes
.
getAttrURI
(
aindex
)
;
if
(
auri
==
StringPool
.
EMPTY_STRING
)
{
auri
=
-
1
;
}
aname
.
setValues
(
aprefix
,
alocalpart
,
arawname
,
auri
)
;
if
(
nodeTest
.
type
!=
XPath
.
NodeTest
.
QNAME
||
nodeTest
.
name
.
equals
(
aname
)
)
{
fCurrentStep
++
;
if
(
fCurrentStep
==
steps
.
length
)
{
fMatched
=
true
;
int
avalue
=
attributes
.
getAttValue
(
aindex
)
;
fMatchedString
=
fStringPool
.
toString
(
avalue
)
;
matched
(
fMatchedString
)
;
}
break
;
}
aindex
=
attributes
.
getNextAttr
(
aindex
)
;
}
}
if
(
!
fMatched
)
{
fNoMatchDepth
++
;
if
(
DEBUG_MATCH
)
{
System
.
out
.
println
(
toString
(
)
+
" [ATTRIBUTE] after"
)
;
}
return
;
}
if
(
DEBUG_MATCH
)
{
System
.
out
.
println
(
toString
(
)
+
" [ATTRIBUTE] after MATCHED!"
)
;
}
}
}
public
void
characters
(
char
[
]
ch
,
int
offset
,
int
length
)
throws
Exception
{
if
(
DEBUG_METHODS
)
{
System
.
out
.
println
(
toString
(
)
+
"#characters("
+
"text="
+
normalize
(
new
String
(
ch
,
offset
,
length
)
)
+
")"
)
;
}
if
(
fBufferContent
&&
fNoMatchDepth
==
0
)
{
if
(
!
DEBUG_METHODS
&&
DEBUG_METHODS2
)
{
System
.
out
.
println
(
toString
(
)
+
"#characters("
+
"text="
+
normalize
(
new
String
(
ch
,
offset
,
length
)
)
+
")"
)
;
}
fMatchedBuffer
.
append
(
ch
,
offset
,
length
)
;
}
}
public
void
endElement
(
QName
element
)
throws
Exception
{
if
(
DEBUG_METHODS2
)
{
System
.
out
.
println
(
toString
(
)
+
"#endElement("
+
"element={"
+
"prefix="
+
fStringPool
.
toString
(
element
.
prefix
)
+
','
+
"localpart="
+
fStringPool
.
toString
(
element
.
localpart
)
+
','
+
"rawname="
+
fStringPool
.
toString
(
element
.
rawname
)
+
','
+
"uri="
+
fStringPool
.
toString
(
element
.
uri
)
+
"})"
)
;
}
fCurrentStep
=
fStepIndexes
.
pop
(
)
;
if
(
fNoMatchDepth
>
0
)
{
fNoMatchDepth
--
;
return
;
}
if
(
fBufferContent
)
{
fBufferContent
=
false
;
fMatchedString
=
fMatchedBuffer
.
toString
(
)
;
matched
(
fMatchedString
)
;
}
clear
(
)
;
if
(
DEBUG_STACK
)
{
System
.
out
.
println
(
toString
(
)
+
": "
+
fStepIndexes
)
;
}
}
public
void
endDocumentFragment
(
)
throws
Exception
{
if
(
DEBUG_METHODS
)
{
System
.
out
.
println
(
toString
(
)
+
"#endDocumentFragment()"
)
;
}
clear
(
)
;
}
public
String
toString
(
)
{
StringBuffer
str
=
new
StringBuffer
(
)
;
String
s
=
super
.
toString
(
)
;
int
index2
=
s
.
lastIndexOf
(
'.'
)
;
if
(
index2
!=
-
1
)
{
s
=
s
.
substring
(
index2
+
1
)
;
}
str
.
append
(
s
)
;
str
.
append
(
'['
)
;
XPath
.
Step
[
]
steps
=
fLocationPath
.
steps
;
for
(
int
i
=
0
;
i
<
steps
.
length
;
i
++
)
{
if
(
i
==
fCurrentStep
)
{
str
.
append
(
'^'
)
;
}
str
.
append
(
steps
[
i
]
.
toString
(
)
)
;
if
(
i
<
steps
.
length
-
1
)
{
str
.
append
(
'/'
)
;
}
}
if
(
fCurrentStep
==
steps
.
length
)
{
str
.
append
(
'^'
)
;
}
str
.
append
(
']'
)
;
return
str
.
toString
(
)
;
}
private
void
clear
(
)
{
fBufferContent
=
false
;
fMatchedBuffer
.
setLength
(
0
)
;
fMatched
=
false
;
fMatchedString
=
null
;
}
private
String
normalize
(
String
s
)
{
StringBuffer
str
=
new
StringBuffer
(
)
;
int
length
=
s
.
length
(
)
;
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
char
c
=
s
.
charAt
(
i
)
;
switch
(
c
)
{
case
'\n'
:
{
str
.
append
(
"\\n"
)
;
break
;
}
default
:
{
str
.
append
(
c
)
;
}
}
}
return
str
.
toString
(
)
;
}
}
