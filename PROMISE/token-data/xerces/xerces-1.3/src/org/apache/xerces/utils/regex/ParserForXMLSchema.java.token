package
org
.
apache
.
xerces
.
utils
.
regex
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Locale
;
class
ParserForXMLSchema
extends
RegexParser
{
public
ParserForXMLSchema
(
)
{
}
public
ParserForXMLSchema
(
Locale
locale
)
{
}
Token
processCaret
(
)
throws
ParseException
{
this
.
next
(
)
;
return
Token
.
createChar
(
'^'
)
;
}
Token
processDollar
(
)
throws
ParseException
{
this
.
next
(
)
;
return
Token
.
createChar
(
'$'
)
;
}
Token
processLookahead
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processNegativelookahead
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processLookbehind
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processNegativelookbehind
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processBacksolidus_A
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processBacksolidus_Z
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processBacksolidus_z
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processBacksolidus_b
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processBacksolidus_B
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processBacksolidus_lt
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processBacksolidus_gt
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processStar
(
Token
tok
)
throws
ParseException
{
this
.
next
(
)
;
return
Token
.
createClosure
(
tok
)
;
}
Token
processPlus
(
Token
tok
)
throws
ParseException
{
this
.
next
(
)
;
return
Token
.
createConcat
(
tok
,
Token
.
createClosure
(
tok
)
)
;
}
Token
processQuestion
(
Token
tok
)
throws
ParseException
{
this
.
next
(
)
;
Token
par
=
Token
.
createUnion
(
)
;
par
.
addChild
(
tok
)
;
par
.
addChild
(
Token
.
createEmpty
(
)
)
;
return
par
;
}
boolean
checkQuestion
(
int
off
)
{
return
false
;
}
Token
processParen
(
)
throws
ParseException
{
this
.
next
(
)
;
Token
tok
=
Token
.
createParen
(
this
.
parseRegex
(
)
,
0
)
;
if
(
this
.
read
(
)
!=
super
.
T_RPAREN
)
throw
ex
(
"parser.factor.1"
,
this
.
offset
-
1
)
;
this
.
next
(
)
;
return
tok
;
}
Token
processParen2
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processCondition
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processModifiers
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processIndependent
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
processBacksolidus_c
(
)
throws
ParseException
{
this
.
next
(
)
;
return
this
.
getTokenForShorthand
(
'c'
)
;
}
Token
processBacksolidus_C
(
)
throws
ParseException
{
this
.
next
(
)
;
return
this
.
getTokenForShorthand
(
'C'
)
;
}
Token
processBacksolidus_i
(
)
throws
ParseException
{
this
.
next
(
)
;
return
this
.
getTokenForShorthand
(
'i'
)
;
}
Token
processBacksolidus_I
(
)
throws
ParseException
{
this
.
next
(
)
;
return
this
.
getTokenForShorthand
(
'I'
)
;
}
Token
processBacksolidus_g
(
)
throws
ParseException
{
throw
this
.
ex
(
"parser.process.1"
,
this
.
offset
-
2
)
;
}
Token
processBacksolidus_X
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
-
2
)
;
}
Token
processBackreference
(
)
throws
ParseException
{
throw
ex
(
"parser.process.1"
,
this
.
offset
-
4
)
;
}
int
processCIinCharacterClass
(
RangeToken
tok
,
int
c
)
{
tok
.
mergeRanges
(
this
.
getTokenForShorthand
(
c
)
)
;
return
-
1
;
}
protected
RangeToken
parseCharacterClass
(
boolean
useNrange
)
throws
ParseException
{
this
.
setContext
(
S_INBRACKETS
)
;
this
.
next
(
)
;
boolean
nrange
=
false
;
RangeToken
base
=
null
;
RangeToken
tok
;
if
(
this
.
read
(
)
==
T_CHAR
&&
this
.
chardata
==
'^'
)
{
nrange
=
true
;
this
.
next
(
)
;
base
=
Token
.
createRange
(
)
;
base
.
addRange
(
0
,
Token
.
UTF16_MAX
)
;
tok
=
Token
.
createRange
(
)
;
}
else
{
tok
=
Token
.
createRange
(
)
;
}
int
type
;
boolean
firstloop
=
true
;
while
(
(
type
=
this
.
read
(
)
)
!=
T_EOF
)
{
if
(
type
==
T_CHAR
&&
this
.
chardata
==
']'
&&
!
firstloop
)
{
if
(
nrange
)
{
base
.
subtractRanges
(
tok
)
;
tok
=
base
;
}
break
;
}
int
c
=
this
.
chardata
;
boolean
end
=
false
;
if
(
type
==
T_BACKSOLIDUS
)
{
switch
(
c
)
{
case
'd'
:
case
'D'
:
case
'w'
:
case
'W'
:
case
's'
:
case
'S'
:
tok
.
mergeRanges
(
this
.
getTokenForShorthand
(
c
)
)
;
end
=
true
;
break
;
case
'i'
:
case
'I'
:
case
'c'
:
case
'C'
:
c
=
this
.
processCIinCharacterClass
(
tok
,
c
)
;
if
(
c
<
0
)
end
=
true
;
break
;
case
'p'
:
case
'P'
:
int
pstart
=
this
.
offset
;
RangeToken
tok2
=
this
.
processBacksolidus_pP
(
c
)
;
if
(
tok2
==
null
)
throw
this
.
ex
(
"parser.atom.5"
,
pstart
)
;
tok
.
mergeRanges
(
tok2
)
;
end
=
true
;
break
;
default
:
c
=
this
.
decodeEscaped
(
)
;
}
}
else
if
(
type
==
T_XMLSCHEMA_CC_SUBTRACTION
&&
!
firstloop
)
{
if
(
nrange
)
{
base
.
subtractRanges
(
tok
)
;
tok
=
base
;
}
RangeToken
range2
=
this
.
parseCharacterClass
(
false
)
;
tok
.
subtractRanges
(
range2
)
;
if
(
this
.
read
(
)
!=
T_CHAR
||
this
.
chardata
!=
']'
)
throw
this
.
ex
(
"parser.cc.5"
,
this
.
offset
)
;
break
;
}
this
.
next
(
)
;
if
(
!
end
)
{
if
(
type
==
T_CHAR
)
{
if
(
c
==
'['
)
throw
this
.
ex
(
"parser.cc.6"
,
this
.
offset
-
2
)
;
if
(
c
==
']'
)
throw
this
.
ex
(
"parser.cc.7"
,
this
.
offset
-
2
)
;
}
if
(
this
.
read
(
)
!=
T_CHAR
||
this
.
chardata
!=
'-'
)
{
tok
.
addRange
(
c
,
c
)
;
}
else
{
this
.
next
(
)
;
if
(
(
type
=
this
.
read
(
)
)
==
T_EOF
)
throw
this
.
ex
(
"parser.cc.2"
,
this
.
offset
)
;
if
(
type
==
T_CHAR
&&
this
.
chardata
==
']'
)
{
tok
.
addRange
(
c
,
c
)
;
tok
.
addRange
(
'-'
,
'-'
)
;
}
else
if
(
type
==
T_XMLSCHEMA_CC_SUBTRACTION
)
{
tok
.
addRange
(
c
,
c
)
;
tok
.
addRange
(
'-'
,
'-'
)
;
}
else
{
int
rangeend
=
this
.
chardata
;
if
(
type
==
T_CHAR
)
{
if
(
rangeend
==
'['
)
throw
this
.
ex
(
"parser.cc.6"
,
this
.
offset
-
1
)
;
if
(
rangeend
==
']'
)
throw
this
.
ex
(
"parser.cc.7"
,
this
.
offset
-
1
)
;
}
if
(
type
==
T_BACKSOLIDUS
)
rangeend
=
this
.
decodeEscaped
(
)
;
this
.
next
(
)
;
tok
.
addRange
(
c
,
rangeend
)
;
}
}
}
firstloop
=
false
;
}
if
(
this
.
read
(
)
==
T_EOF
)
throw
this
.
ex
(
"parser.cc.2"
,
this
.
offset
)
;
tok
.
sortRanges
(
)
;
tok
.
compactRanges
(
)
;
this
.
setContext
(
S_NORMAL
)
;
this
.
next
(
)
;
return
tok
;
}
protected
RangeToken
parseSetOperations
(
)
throws
ParseException
{
throw
this
.
ex
(
"parser.process.1"
,
this
.
offset
)
;
}
Token
getTokenForShorthand
(
int
ch
)
{
switch
(
ch
)
{
case
'd'
:
return
ParserForXMLSchema
.
getRange
(
"xml:isDigit"
,
true
)
;
case
'D'
:
return
ParserForXMLSchema
.
getRange
(
"xml:isDigit"
,
false
)
;
case
'w'
:
return
ParserForXMLSchema
.
getRange
(
"xml:isWord"
,
true
)
;
case
'W'
:
return
ParserForXMLSchema
.
getRange
(
"xml:isWord"
,
false
)
;
case
's'
:
return
ParserForXMLSchema
.
getRange
(
"xml:isSpace"
,
true
)
;
case
'S'
:
return
ParserForXMLSchema
.
getRange
(
"xml:isSpace"
,
false
)
;
case
'c'
:
return
ParserForXMLSchema
.
getRange
(
"xml:isNameChar"
,
true
)
;
case
'C'
:
return
ParserForXMLSchema
.
getRange
(
"xml:isNameChar"
,
false
)
;
case
'i'
:
return
ParserForXMLSchema
.
getRange
(
"xml:isInitialNameChar"
,
true
)
;
case
'I'
:
return
ParserForXMLSchema
.
getRange
(
"xml:isInitialNameChar"
,
false
)
;
default
:
throw
new
RuntimeException
(
"Internal Error: shorthands: \\u"
+
Integer
.
toString
(
ch
,
16
)
)
;
}
}
int
decodeEscaped
(
)
throws
ParseException
{
if
(
this
.
read
(
)
!=
T_BACKSOLIDUS
)
throw
ex
(
"parser.next.1"
,
this
.
offset
-
1
)
;
int
c
=
this
.
chardata
;
switch
(
c
)
{
case
'n'
:
c
=
'\n'
;
break
;
case
'r'
:
c
=
'\r'
;
break
;
case
't'
:
c
=
'\t'
;
break
;
case
'e'
:
case
'f'
:
case
'x'
:
case
'u'
:
case
'v'
:
throw
ex
(
"parser.process.1"
,
this
.
offset
-
2
)
;
case
'A'
:
case
'Z'
:
case
'z'
:
throw
ex
(
"parser.descape.5"
,
this
.
offset
-
2
)
;
default
:
}
return
c
;
}
static
protected
Hashtable
ranges
=
null
;
static
protected
Hashtable
ranges2
=
null
;
static
synchronized
protected
RangeToken
getRange
(
String
name
,
boolean
positive
)
{
if
(
ranges
==
null
)
{
ranges
=
new
Hashtable
(
)
;
ranges2
=
new
Hashtable
(
)
;
Token
tok
=
Token
.
createRange
(
)
;
setupRange
(
tok
,
SPACES
)
;
ranges
.
put
(
"xml:isSpace"
,
tok
)
;
ranges2
.
put
(
"xml:isSpace"
,
Token
.
complementRanges
(
tok
)
)
;
tok
=
Token
.
createRange
(
)
;
setupRange
(
tok
,
DIGITS
)
;
ranges
.
put
(
"xml:isDigit"
,
tok
)
;
ranges2
.
put
(
"xml:isDigit"
,
Token
.
complementRanges
(
tok
)
)
;
tok
=
Token
.
createRange
(
)
;
setupRange
(
tok
,
DIGITS
)
;
ranges
.
put
(
"xml:isDigit"
,
tok
)
;
ranges2
.
put
(
"xml:isDigit"
,
Token
.
complementRanges
(
tok
)
)
;
tok
=
Token
.
createRange
(
)
;
setupRange
(
tok
,
LETTERS
)
;
tok
.
mergeRanges
(
(
Token
)
ranges
.
get
(
"xml:isDigit"
)
)
;
ranges
.
put
(
"xml:isWord"
,
tok
)
;
ranges2
.
put
(
"xml:isWord"
,
Token
.
complementRanges
(
tok
)
)
;
tok
=
Token
.
createRange
(
)
;
setupRange
(
tok
,
NAMECHARS
)
;
ranges
.
put
(
"xml:isNameChar"
,
tok
)
;
ranges2
.
put
(
"xml:isNameChar"
,
Token
.
complementRanges
(
tok
)
)
;
tok
=
Token
.
createRange
(
)
;
setupRange
(
tok
,
LETTERS
)
;
tok
.
addRange
(
'_'
,
'_'
)
;
tok
.
addRange
(
':'
,
':'
)
;
ranges
.
put
(
"xml:isInitialNameChar"
,
tok
)
;
ranges2
.
put
(
"xml:isInitialNameChar"
,
Token
.
complementRanges
(
tok
)
)
;
}
RangeToken
tok
=
positive
?
(
RangeToken
)
ranges
.
get
(
name
)
:
(
RangeToken
)
ranges2
.
get
(
name
)
;
return
tok
;
}
static
void
setupRange
(
Token
range
,
String
src
)
{
int
len
=
src
.
length
(
)
;
for
(
int
i
=
0
;
i
<
len
;
i
+=
2
)
range
.
addRange
(
src
.
charAt
(
i
)
,
src
.
charAt
(
i
+
1
)
)
;
}
private
static
final
String
SPACES
=
"\t\n\r\r  "
;
private
static
final
String
NAMECHARS
=
"-.0:AZ__az··ÀÖ"
+
"ØöøıĴľŁňŊžƀǃǍǰ"
+
"ǴǵǺȗɐʨʻˁːˑ̀͠͡ͅ"
+
"ΆΊΌΌΎΡΣώϐϖϚϚϜϜ"
+
"ϞϞϠϠϢϳЁЌЎяёќўҁ"
+
"҃҆ҐӄӇӈӋӌӐӫӮӵӸӹ"
+
"ԱՖՙՙաֆֹֻֽֿֿ֑֣֡"
+
"ׁׂׄׄאתװײءغـْ٠٩"
+
"ٰڷںھۀێېۓە۪ۭۨ۰۹"
+
"ँःअह़्॑॔क़ॣ०९ঁঃ"
+
"অঌএঐওনপরললশহ়়"
+
"াৄেৈো্ৗৗড়ঢ়য়ৣ০ৱ"
+
"ਂਂਅਊਏਐਓਨਪਰਲਲ਼ਵਸ਼"
+
"ਸਹ਼਼ਾੂੇੈੋ੍ਖ਼ੜਫ਼ਫ਼"
+
"੦ੴઁઃઅઋઍઍએઑઓનપર"
+
"લળવહ઼ૅેૉો્ૠૠ૦૯"
+
"ଁଃଅଌଏଐଓନପରଲଳଶହ"
+
"଼ୃେୈୋ୍ୖୗଡ଼ଢ଼ୟୡ୦୯"
+
"ஂஃஅஊஎஐஒகஙசஜஜஞட"
+
"ணதநபமவஷஹாூெைொ்"
+
"ௗௗ௧௯ఁఃఅఌఎఐఒనపళ"
+
"వహాౄెైొ్ౕౖౠౡ౦౯"
+
"ಂಃಅಌಎಐಒನಪಳವಹಾೄ"
+
"ೆೈೊ್ೕೖೞೞೠೡ೦೯ംഃ"
+
"അഌഎഐഒനപഹാൃെൈൊ്"
+
"ൗൗൠൡ൦൯กฮะฺเ๎๐๙"
+
"ກຂຄຄງຈຊຊຍຍດທນຟ"
+
"ມຣລລວວສຫອຮະູົຽ"
+
"ເໄໆໆ່ໍ໐໙༘༙༠༩༵༵"
+
"༹༹༷༷༾ཇཉཀྵ྄ཱ྆ྋྐྕ"
+
"ྗྗྙྭྱྷྐྵྐྵႠჅაჶᄀᄀ"
+
"ᄂᄃᄅᄇᄉᄉᄋᄌᄎᄒᄼᄼᄾᄾ"
+
"ᅀᅀᅌᅌᅎᅎᅐᅐᅔᅕᅙᅙᅟᅡ"
+
"ᅣᅣᅥᅥᅧᅧᅩᅩᅭᅮᅲᅳᅵᅵ"
+
"ᆞᆞᆨᆨᆫᆫᆮᆯᆷᆸᆺᆺᆼᇂ"
+
"ᇫᇫᇰᇰᇹᇹḀẛẠỹἀἕἘἝ"
+
"ἠὅὈὍὐὗὙὙὛὛὝὝὟώ"
+
"ᾀᾴᾶᾼιιῂῄῆῌῐΐῖΊ"
+
"ῠῬῲῴῶῼ⃐⃜⃡⃡ΩΩKÅ"
+
"℮℮ↀↂ々々〇〇〡〯〱〵ぁゔ"
+
"゙゚ゝゞァヺーヾㄅㄬ一龥가힣"
+
""
;
private
static
final
String
LETTERS
=
"AZazÀÖØöøıĴľŁň"
+
"ŊžƀǃǍǰǴǵǺȗɐʨʻˁ"
+
"ΆΆΈΊΌΌΎΡΣώϐϖϚϚ"
+
"ϜϜϞϞϠϠϢϳЁЌЎяёќ"
+
"ўҁҐӄӇӈӋӌӐӫӮӵӸӹ"
+
"ԱՖՙՙաֆאתװײءغفي"
+
"ٱڷںھۀێېۓەەۥۦअह"
+
"ऽऽक़ॡঅঌএঐওনপরলল"
+
"শহড়ঢ়য়ৡৰৱਅਊਏਐਓਨ"
+
"ਪਰਲਲ਼ਵਸ਼ਸਹਖ਼ੜਫ਼ਫ਼ੲੴ"
+
"અઋઍઍએઑઓનપરલળવહ"
+
"ઽઽૠૠଅଌଏଐଓନପରଲଳ"
+
"ଶହଽଽଡ଼ଢ଼ୟୡஅஊஎஐஒக"
+
"ஙசஜஜஞடணதநபமவஷஹ"
+
"అఌఎఐఒనపళవహౠౡಅಌ"
+
"ಎಐಒನಪಳವಹೞೞೠೡഅഌ"
+
"എഐഒനപഹൠൡกฮะะาำ"
+
"เๅກຂຄຄງຈຊຊຍຍດທ"
+
"ນຟມຣລລວວສຫອຮະະ"
+
"າຳຽຽເໄཀཇཉཀྵႠჅაჶ"
+
"ᄀᄀᄂᄃᄅᄇᄉᄉᄋᄌᄎᄒᄼᄼ"
+
"ᄾᄾᅀᅀᅌᅌᅎᅎᅐᅐᅔᅕᅙᅙ"
+
"ᅟᅡᅣᅣᅥᅥᅧᅧᅩᅩᅭᅮᅲᅳ"
+
"ᅵᅵᆞᆞᆨᆨᆫᆫᆮᆯᆷᆸᆺᆺ"
+
"ᆼᇂᇫᇫᇰᇰᇹᇹḀẛẠỹἀἕ"
+
"ἘἝἠὅὈὍὐὗὙὙὛὛὝὝ"
+
"Ὗώᾀᾴᾶᾼιιῂῄῆῌῐΐ"
+
"ῖΊῠῬῲῴῶῼΩΩKÅ℮℮"
+
"ↀↂ〇〇〡〩ぁゔァヺㄅㄬ一龥"
+
"가힣"
;
private
static
final
String
DIGITS
=
"09٠٩۰۹०९০৯੦੯૦૯"
+
"୦୯௧௯౦౯೦೯൦൯๐๙໐໙"
+
"༠༩"
;
}
