package
org
.
apache
.
xerces
.
dom
;
import
java
.
io
.
*
;
import
org
.
w3c
.
dom
.
*
;
import
org
.
w3c
.
dom
.
events
.
*
;
import
org
.
apache
.
xerces
.
dom
.
*
;
import
org
.
apache
.
xerces
.
dom
.
events
.
*
;
public
abstract
class
ParentNode
extends
ChildNode
{
static
final
long
serialVersionUID
=
2815829867152120872L
;
protected
DocumentImpl
ownerDocument
;
protected
ChildNode
firstChild
=
null
;
protected
transient
int
fCachedLength
=
-
1
;
protected
transient
ChildNode
fCachedChild
;
protected
transient
int
fCachedChildIndex
=
-
1
;
protected
ParentNode
(
DocumentImpl
ownerDocument
)
{
super
(
ownerDocument
)
;
this
.
ownerDocument
=
ownerDocument
;
}
public
ParentNode
(
)
{
}
public
Node
cloneNode
(
boolean
deep
)
{
ParentNode
newnode
=
(
ParentNode
)
super
.
cloneNode
(
deep
)
;
newnode
.
ownerDocument
=
ownerDocument
;
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
newnode
.
firstChild
=
null
;
newnode
.
fCachedChildIndex
=
-
1
;
newnode
.
fCachedLength
=
-
1
;
if
(
deep
)
{
for
(
ChildNode
child
=
firstChild
;
child
!=
null
;
child
=
child
.
nextSibling
)
{
newnode
.
appendChild
(
child
.
cloneNode
(
true
)
)
;
}
}
return
newnode
;
}
public
Document
getOwnerDocument
(
)
{
return
ownerDocument
;
}
DocumentImpl
ownerDocument
(
)
{
return
ownerDocument
;
}
void
setOwnerDocument
(
DocumentImpl
doc
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
for
(
ChildNode
child
=
firstChild
;
child
!=
null
;
child
=
child
.
nextSibling
)
{
child
.
setOwnerDocument
(
doc
)
;
}
ownerDocument
=
doc
;
}
public
boolean
hasChildNodes
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
firstChild
!=
null
;
}
public
NodeList
getChildNodes
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
this
;
}
public
Node
getFirstChild
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
firstChild
;
}
public
Node
getLastChild
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
lastChild
(
)
;
}
final
ChildNode
lastChild
(
)
{
return
firstChild
!=
null
?
firstChild
.
previousSibling
:
null
;
}
final
void
lastChild
(
ChildNode
node
)
{
if
(
firstChild
!=
null
)
{
firstChild
.
previousSibling
=
node
;
}
}
public
Node
insertBefore
(
Node
newChild
,
Node
refChild
)
throws
DOMException
{
return
internalInsertBefore
(
newChild
,
refChild
,
MUTATION_ALL
)
;
}
Node
internalInsertBefore
(
Node
newChild
,
Node
refChild
,
int
mutationMask
)
throws
DOMException
{
boolean
errorChecking
=
ownerDocument
.
errorChecking
;
if
(
newChild
.
getNodeType
(
)
==
Node
.
DOCUMENT_FRAGMENT_NODE
)
{
if
(
errorChecking
)
{
for
(
Node
kid
=
newChild
.
getFirstChild
(
)
;
kid
!=
null
;
kid
=
kid
.
getNextSibling
(
)
)
{
if
(
!
ownerDocument
.
isKidOK
(
this
,
kid
)
)
{
throw
new
DOMException
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
}
}
while
(
newChild
.
hasChildNodes
(
)
)
{
insertBefore
(
newChild
.
getFirstChild
(
)
,
refChild
)
;
}
return
newChild
;
}
if
(
newChild
==
refChild
)
{
refChild
=
refChild
.
getNextSibling
(
)
;
removeChild
(
newChild
)
;
insertBefore
(
newChild
,
refChild
)
;
return
newChild
;
}
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
if
(
errorChecking
)
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMException
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
if
(
newChild
.
getOwnerDocument
(
)
!=
ownerDocument
)
{
throw
new
DOMException
(
DOMException
.
WRONG_DOCUMENT_ERR
,
"DOM005 Wrong document"
)
;
}
if
(
!
ownerDocument
.
isKidOK
(
this
,
newChild
)
)
{
throw
new
DOMException
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
if
(
refChild
!=
null
&&
refChild
.
getParentNode
(
)
!=
this
)
{
throw
new
DOMException
(
DOMException
.
NOT_FOUND_ERR
,
"DOM008 Not found"
)
;
}
boolean
treeSafe
=
true
;
for
(
NodeImpl
a
=
this
;
treeSafe
&&
a
!=
null
;
a
=
a
.
parentNode
(
)
)
{
treeSafe
=
newChild
!=
a
;
}
if
(
!
treeSafe
)
{
throw
new
DOMException
(
DOMException
.
HIERARCHY_REQUEST_ERR
,
"DOM006 Hierarchy request error"
)
;
}
}
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
&&
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
}
ChildNode
newInternal
=
(
ChildNode
)
newChild
;
Node
oldparent
=
newInternal
.
parentNode
(
)
;
if
(
oldparent
!=
null
)
{
oldparent
.
removeChild
(
newInternal
)
;
}
ChildNode
refInternal
=
(
ChildNode
)
refChild
;
newInternal
.
ownerNode
=
this
;
newInternal
.
isOwned
(
true
)
;
if
(
firstChild
==
null
)
{
firstChild
=
newInternal
;
newInternal
.
isFirstChild
(
true
)
;
newInternal
.
previousSibling
=
newInternal
;
}
else
{
if
(
refInternal
==
null
)
{
ChildNode
lastChild
=
firstChild
.
previousSibling
;
lastChild
.
nextSibling
=
newInternal
;
newInternal
.
previousSibling
=
lastChild
;
firstChild
.
previousSibling
=
newInternal
;
}
else
{
if
(
refChild
==
firstChild
)
{
firstChild
.
isFirstChild
(
false
)
;
newInternal
.
nextSibling
=
firstChild
;
newInternal
.
previousSibling
=
firstChild
.
previousSibling
;
firstChild
.
previousSibling
=
newInternal
;
firstChild
=
newInternal
;
newInternal
.
isFirstChild
(
true
)
;
}
else
{
ChildNode
prev
=
refInternal
.
previousSibling
;
newInternal
.
nextSibling
=
refInternal
;
prev
.
nextSibling
=
newInternal
;
refInternal
.
previousSibling
=
newInternal
;
newInternal
.
previousSibling
=
prev
;
}
}
}
changed
(
)
;
if
(
fCachedLength
!=
-
1
)
{
fCachedLength
++
;
}
if
(
fCachedChildIndex
!=
-
1
)
{
if
(
fCachedChild
==
refInternal
)
{
fCachedChild
=
newInternal
;
}
else
{
fCachedChildIndex
=
-
1
;
}
}
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
if
(
(
mutationMask
&
MUTATION_LOCAL
)
!=
0
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_INSERTED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_INSERTED
,
true
,
false
,
this
,
null
,
null
,
null
,
(
short
)
0
)
;
newInternal
.
dispatchEvent
(
me
)
;
}
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_INSERTED_INTO_DOCUMENT
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
NodeImpl
eventAncestor
=
this
;
if
(
enclosingAttr
!=
null
)
eventAncestor
=
(
NodeImpl
)
(
enclosingAttr
.
node
.
getOwnerElement
(
)
)
;
if
(
eventAncestor
!=
null
)
{
NodeImpl
p
=
eventAncestor
;
while
(
p
!=
null
)
{
eventAncestor
=
p
;
if
(
p
.
getNodeType
(
)
==
ATTRIBUTE_NODE
)
{
p
=
(
ElementImpl
)
(
(
AttrImpl
)
p
)
.
getOwnerElement
(
)
;
}
else
{
p
=
p
.
parentNode
(
)
;
}
}
if
(
eventAncestor
.
getNodeType
(
)
==
Node
.
DOCUMENT_NODE
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_INSERTED_INTO_DOCUMENT
,
false
,
false
,
null
,
null
,
null
,
null
,
(
short
)
0
)
;
dispatchEventToSubtree
(
newInternal
,
me
)
;
}
}
}
}
if
(
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
{
dispatchAggregateEvents
(
enclosingAttr
)
;
}
}
checkNormalizationAfterInsert
(
newInternal
)
;
return
newChild
;
}
public
Node
removeChild
(
Node
oldChild
)
throws
DOMException
{
return
internalRemoveChild
(
oldChild
,
MUTATION_ALL
)
;
}
Node
internalRemoveChild
(
Node
oldChild
,
int
mutationMask
)
throws
DOMException
{
DocumentImpl
ownerDocument
=
ownerDocument
(
)
;
if
(
ownerDocument
.
errorChecking
)
{
if
(
isReadOnly
(
)
)
{
throw
new
DOMException
(
DOMException
.
NO_MODIFICATION_ALLOWED_ERR
,
"DOM001 Modification not allowed"
)
;
}
if
(
oldChild
!=
null
&&
oldChild
.
getParentNode
(
)
!=
this
)
{
throw
new
DOMException
(
DOMException
.
NOT_FOUND_ERR
,
"DOM008 Not found"
)
;
}
}
ownerDocument
.
removedChildNode
(
oldChild
)
;
ChildNode
oldInternal
=
(
ChildNode
)
oldChild
;
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
if
(
(
mutationMask
&
MUTATION_LOCAL
)
!=
0
)
{
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_REMOVED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_REMOVED
,
true
,
false
,
this
,
null
,
null
,
null
,
(
short
)
0
)
;
oldInternal
.
dispatchEvent
(
me
)
;
}
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_NODE_REMOVED_FROM_DOCUMENT
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
NodeImpl
eventAncestor
=
this
;
if
(
enclosingAttr
!=
null
)
eventAncestor
=
(
NodeImpl
)
enclosingAttr
.
node
.
getOwnerElement
(
)
;
if
(
eventAncestor
!=
null
)
{
for
(
NodeImpl
p
=
eventAncestor
.
parentNode
(
)
;
p
!=
null
;
p
=
p
.
parentNode
(
)
)
{
eventAncestor
=
p
;
}
if
(
eventAncestor
.
getNodeType
(
)
==
Node
.
DOCUMENT_NODE
)
{
MutationEvent
me
=
new
MutationEventImpl
(
)
;
me
.
initMutationEvent
(
MutationEventImpl
.
DOM_NODE_REMOVED_FROM_DOCUMENT
,
false
,
false
,
null
,
null
,
null
,
null
,
(
short
)
0
)
;
dispatchEventToSubtree
(
oldInternal
,
me
)
;
}
}
}
}
}
if
(
fCachedLength
!=
-
1
)
{
fCachedLength
--
;
}
if
(
fCachedChildIndex
!=
-
1
)
{
if
(
fCachedChild
==
oldInternal
)
{
fCachedChildIndex
--
;
fCachedChild
=
oldInternal
.
previousSibling
(
)
;
}
else
{
fCachedChildIndex
=
-
1
;
}
}
if
(
oldInternal
==
firstChild
)
{
oldInternal
.
isFirstChild
(
false
)
;
firstChild
=
oldInternal
.
nextSibling
;
if
(
firstChild
!=
null
)
{
firstChild
.
isFirstChild
(
true
)
;
firstChild
.
previousSibling
=
oldInternal
.
previousSibling
;
}
}
else
{
ChildNode
prev
=
oldInternal
.
previousSibling
;
ChildNode
next
=
oldInternal
.
nextSibling
;
prev
.
nextSibling
=
next
;
if
(
next
==
null
)
{
firstChild
.
previousSibling
=
prev
;
}
else
{
next
.
previousSibling
=
prev
;
}
}
ChildNode
oldPreviousSibling
=
oldInternal
.
previousSibling
(
)
;
oldInternal
.
ownerNode
=
ownerDocument
;
oldInternal
.
isOwned
(
false
)
;
oldInternal
.
nextSibling
=
null
;
oldInternal
.
previousSibling
=
null
;
changed
(
)
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
if
(
(
mutationMask
&
MUTATION_AGGREGATE
)
!=
0
)
dispatchAggregateEvents
(
enclosingAttr
)
;
}
checkNormalizationAfterRemove
(
oldPreviousSibling
)
;
return
oldInternal
;
}
public
Node
replaceChild
(
Node
newChild
,
Node
oldChild
)
throws
DOMException
{
EnclosingAttr
enclosingAttr
=
null
;
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
LCount
lc
=
LCount
.
lookup
(
MutationEventImpl
.
DOM_ATTR_MODIFIED
)
;
if
(
lc
.
captures
+
lc
.
bubbles
+
lc
.
defaults
>
0
)
{
enclosingAttr
=
getEnclosingAttr
(
)
;
}
}
internalInsertBefore
(
newChild
,
oldChild
,
MUTATION_LOCAL
)
;
if
(
newChild
!=
oldChild
)
{
internalRemoveChild
(
oldChild
,
MUTATION_LOCAL
)
;
}
if
(
MUTATIONEVENTS
&&
ownerDocument
.
mutationEvents
)
{
dispatchAggregateEvents
(
enclosingAttr
)
;
}
return
oldChild
;
}
private
int
nodeListGetLength
(
)
{
if
(
fCachedLength
==
-
1
)
{
ChildNode
node
;
if
(
fCachedChildIndex
!=
-
1
&&
fCachedChild
!=
null
)
{
fCachedLength
=
fCachedChildIndex
;
node
=
fCachedChild
;
}
else
{
node
=
firstChild
;
fCachedLength
=
0
;
}
for
(
;
node
!=
null
;
node
=
node
.
nextSibling
)
{
fCachedLength
++
;
}
}
return
fCachedLength
;
}
public
int
getLength
(
)
{
return
nodeListGetLength
(
)
;
}
private
Node
nodeListItem
(
int
index
)
{
if
(
fCachedChildIndex
!=
-
1
&&
fCachedChild
!=
null
)
{
if
(
fCachedChildIndex
<
index
)
{
while
(
fCachedChildIndex
<
index
&&
fCachedChild
!=
null
)
{
fCachedChildIndex
++
;
fCachedChild
=
fCachedChild
.
nextSibling
;
}
}
else
if
(
fCachedChildIndex
>
index
)
{
while
(
fCachedChildIndex
>
index
&&
fCachedChild
!=
null
)
{
fCachedChildIndex
--
;
fCachedChild
=
fCachedChild
.
previousSibling
(
)
;
}
}
return
fCachedChild
;
}
fCachedChild
=
firstChild
;
for
(
fCachedChildIndex
=
0
;
fCachedChildIndex
<
index
&&
fCachedChild
!=
null
;
fCachedChildIndex
++
)
{
fCachedChild
=
fCachedChild
.
nextSibling
;
}
return
fCachedChild
;
}
public
Node
item
(
int
index
)
{
return
nodeListItem
(
index
)
;
}
protected
final
NodeList
getChildNodesUnoptimized
(
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
return
new
NodeList
(
)
{
public
int
getLength
(
)
{
return
nodeListGetLength
(
)
;
}
public
Node
item
(
int
index
)
{
return
nodeListItem
(
index
)
;
}
}
;
}
public
void
normalize
(
)
{
if
(
isNormalized
(
)
)
{
return
;
}
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
ChildNode
kid
;
for
(
kid
=
firstChild
;
kid
!=
null
;
kid
=
kid
.
nextSibling
)
{
kid
.
normalize
(
)
;
}
isNormalized
(
true
)
;
}
public
void
setReadOnly
(
boolean
readOnly
,
boolean
deep
)
{
super
.
setReadOnly
(
readOnly
,
deep
)
;
if
(
deep
)
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
for
(
ChildNode
mykid
=
firstChild
;
mykid
!=
null
;
mykid
=
mykid
.
nextSibling
)
{
if
(
mykid
.
getNodeType
(
)
!=
Node
.
ENTITY_REFERENCE_NODE
)
{
mykid
.
setReadOnly
(
readOnly
,
true
)
;
}
}
}
}
protected
void
synchronizeChildren
(
)
{
needsSyncChildren
(
false
)
;
}
protected
final
void
synchronizeChildren
(
int
nodeIndex
)
{
boolean
orig
=
ownerDocument
.
mutationEvents
;
ownerDocument
.
mutationEvents
=
false
;
needsSyncChildren
(
false
)
;
DeferredDocumentImpl
ownerDocument
=
(
DeferredDocumentImpl
)
this
.
ownerDocument
;
ChildNode
first
=
null
;
ChildNode
last
=
null
;
for
(
int
index
=
ownerDocument
.
getLastChild
(
nodeIndex
)
;
index
!=
-
1
;
index
=
ownerDocument
.
getPrevSibling
(
index
)
)
{
ChildNode
node
=
(
ChildNode
)
ownerDocument
.
getNodeObject
(
index
)
;
if
(
last
==
null
)
{
last
=
node
;
}
else
{
first
.
previousSibling
=
node
;
}
node
.
ownerNode
=
this
;
node
.
isOwned
(
true
)
;
node
.
nextSibling
=
first
;
first
=
node
;
}
if
(
last
!=
null
)
{
firstChild
=
first
;
first
.
isFirstChild
(
true
)
;
lastChild
(
last
)
;
}
ownerDocument
.
mutationEvents
=
orig
;
}
void
checkNormalizationAfterInsert
(
ChildNode
insertedChild
)
{
if
(
insertedChild
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
ChildNode
prev
=
insertedChild
.
previousSibling
(
)
;
ChildNode
next
=
insertedChild
.
nextSibling
;
if
(
(
prev
!=
null
&&
prev
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
||
(
next
!=
null
&&
next
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
)
{
isNormalized
(
false
)
;
}
}
else
{
if
(
!
insertedChild
.
isNormalized
(
)
)
{
isNormalized
(
false
)
;
}
}
}
void
checkNormalizationAfterRemove
(
ChildNode
previousSibling
)
{
if
(
previousSibling
!=
null
&&
previousSibling
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
ChildNode
next
=
previousSibling
.
nextSibling
;
if
(
next
!=
null
&&
next
.
getNodeType
(
)
==
Node
.
TEXT_NODE
)
{
isNormalized
(
false
)
;
}
}
}
private
void
writeObject
(
ObjectOutputStream
out
)
throws
IOException
{
if
(
needsSyncChildren
(
)
)
{
synchronizeChildren
(
)
;
}
out
.
defaultWriteObject
(
)
;
}
private
void
readObject
(
ObjectInputStream
ois
)
throws
ClassNotFoundException
,
IOException
{
ois
.
defaultReadObject
(
)
;
needsSyncChildren
(
false
)
;
fCachedLength
=
-
1
;
fCachedChildIndex
=
-
1
;
}
}
