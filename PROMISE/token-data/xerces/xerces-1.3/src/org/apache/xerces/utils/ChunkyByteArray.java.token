package
org
.
apache
.
xerces
.
utils
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
public
final
class
ChunkyByteArray
extends
InputStream
{
public
ChunkyByteArray
(
InputStream
is
)
throws
IOException
{
fInputStream
=
is
;
fill
(
)
;
}
public
int
read
(
)
throws
IOException
{
if
(
fData
==
null
)
return
fInputStream
==
null
?
-
1
:
fInputStream
.
read
(
)
;
int
b
=
(
int
)
(
fData
[
0
]
[
fOffset
]
)
;
if
(
++
fOffset
==
fLength
)
{
fData
=
null
;
if
(
fLength
<
CHUNK_SIZE
)
fInputStream
=
null
;
}
return
b
;
}
public
int
read
(
byte
buffer
[
]
,
int
offset
,
int
length
)
throws
IOException
{
int
bytesLeft
=
fLength
-
fOffset
;
if
(
bytesLeft
==
0
)
return
fInputStream
==
null
?
-
1
:
fInputStream
.
read
(
buffer
,
offset
,
length
)
;
if
(
length
<=
0
)
return
0
;
byte
[
]
chunk
=
fData
[
0
]
;
if
(
length
>=
bytesLeft
)
{
length
=
bytesLeft
;
if
(
fLength
<
CHUNK_SIZE
)
fInputStream
=
null
;
}
if
(
buffer
==
null
)
{
fOffset
+=
length
;
return
length
;
}
int
stop
=
offset
+
length
;
do
{
buffer
[
offset
++
]
=
chunk
[
fOffset
++
]
;
}
while
(
offset
<
stop
)
;
return
length
;
}
public
void
rewind
(
)
{
fOffset
=
0
;
}
public
byte
byteAt
(
int
offset
)
throws
IOException
{
int
chunk
=
offset
>
>
CHUNK_SHIFT
;
int
index
=
offset
&
CHUNK_MASK
;
try
{
return
fData
[
chunk
]
[
index
]
;
}
catch
(
NullPointerException
ex
)
{
}
catch
(
ArrayIndexOutOfBoundsException
e
)
{
byte
newdata
[
]
[
]
=
new
byte
[
fData
.
length
*
2
]
[
]
;
System
.
arraycopy
(
fData
,
0
,
newdata
,
0
,
fData
.
length
)
;
fData
=
newdata
;
}
if
(
index
==
0
)
{
fill
(
)
;
return
fData
[
chunk
]
[
index
]
;
}
return
0
;
}
public
boolean
atEOF
(
int
offset
)
{
return
(
offset
>
fLength
)
;
}
public
void
close
(
)
throws
IOException
{
if
(
fInputStream
!=
null
)
{
fInputStream
.
close
(
)
;
fInputStream
=
null
;
}
}
private
void
fill
(
)
throws
IOException
{
int
bufnum
=
fLength
>
>
CHUNK_SHIFT
;
byte
[
]
data
=
new
byte
[
CHUNK_SIZE
]
;
fData
[
bufnum
]
=
data
;
int
offset
=
0
;
int
capacity
=
CHUNK_SIZE
;
int
result
=
0
;
do
{
result
=
fInputStream
.
read
(
data
,
offset
,
capacity
)
;
if
(
result
==
-
1
)
{
data
[
offset
]
=
(
byte
)
0xff
;
fInputStream
.
close
(
)
;
fInputStream
=
null
;
break
;
}
if
(
result
>
0
)
{
fLength
+=
result
;
offset
+=
result
;
capacity
-=
result
;
}
}
while
(
capacity
>
0
)
;
}
private
static
final
int
CHUNK_SHIFT
=
14
;
private
static
final
int
CHUNK_SIZE
=
(
1
<<
CHUNK_SHIFT
)
;
private
static
final
int
CHUNK_MASK
=
CHUNK_SIZE
-
1
;
private
static
final
int
INITIAL_CHUNK_COUNT
=
(
1
<<
(
20
-
CHUNK_SHIFT
)
)
;
private
InputStream
fInputStream
=
null
;
private
byte
[
]
[
]
fData
=
new
byte
[
INITIAL_CHUNK_COUNT
]
[
]
;
private
int
fLength
=
0
;
private
int
fOffset
=
0
;
}
