package
org
.
apache
.
tools
.
ant
.
taskdefs
.
optional
.
dotnet
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
java
.
io
.
File
;
import
java
.
util
.
ArrayList
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
java
.
util
.
Iterator
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
public
class
DotnetResource
{
private
File
file
;
private
boolean
embed
=
true
;
private
Boolean
isPublic
=
null
;
private
String
name
=
null
;
private
ArrayList
fileSets
=
new
ArrayList
(
)
;
private
String
namespace
=
null
;
public
boolean
isEmbed
(
)
{
return
embed
;
}
public
void
setEmbed
(
boolean
embed
)
{
this
.
embed
=
embed
;
}
public
File
getFile
(
)
{
return
file
;
}
public
void
setFile
(
File
file
)
{
this
.
file
=
file
;
}
public
Boolean
getPublic
(
)
{
return
isPublic
;
}
public
void
setPublic
(
Boolean
aPublic
)
{
isPublic
=
aPublic
;
}
public
String
getName
(
)
{
return
name
;
}
public
void
setName
(
String
name
)
{
this
.
name
=
name
;
}
public
String
getNamespace
(
)
{
return
namespace
;
}
public
void
setNamespace
(
String
namespace
)
{
if
(
namespace
==
null
)
{
this
.
namespace
=
null
;
}
else
{
this
.
namespace
=
(
namespace
.
length
(
)
==
0
||
namespace
.
endsWith
(
"."
)
?
namespace
:
namespace
+
'.'
)
;
}
}
private
void
checkParameters
(
)
{
if
(
hasFilesets
(
)
)
{
if
(
getName
(
)
!=
null
)
{
throw
new
BuildException
(
"Cannot use <resource name=\"...\"> attribute with filesets"
)
;
}
if
(
getFile
(
)
!=
null
)
{
throw
new
BuildException
(
"Cannot use <resource file=\"...\"> attribute with filesets"
)
;
}
}
else
{
if
(
getNamespace
(
)
!=
null
)
{
throw
new
BuildException
(
"Cannot use <resource namespace=\"...\"> attribute without filesets"
)
;
}
}
}
public
void
getParameters
(
Project
p
,
NetCommand
command
,
boolean
csharpStyle
)
{
checkParameters
(
)
;
if
(
hasFilesets
(
)
)
{
for
(
Iterator
listIter
=
fileSets
.
iterator
(
)
;
listIter
.
hasNext
(
)
;
)
{
FileSet
fs
=
(
FileSet
)
listIter
.
next
(
)
;
String
baseDirectory
=
fs
.
getDir
(
p
)
.
toString
(
)
;
String
namespace
=
getNamespace
(
)
;
DirectoryScanner
ds
=
fs
.
getDirectoryScanner
(
p
)
;
String
[
]
files
=
ds
.
getIncludedFiles
(
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
String
file
=
files
[
i
]
;
command
.
addArgument
(
getParameter
(
baseDirectory
+
File
.
separatorChar
+
file
,
(
namespace
==
null
?
null
:
namespace
+
file
.
replace
(
File
.
separatorChar
,
'.'
)
)
,
csharpStyle
)
)
;
}
}
}
else
{
command
.
addArgument
(
getParameter
(
getFile
(
)
.
toString
(
)
,
getName
(
)
,
csharpStyle
)
)
;
}
}
private
String
getParameter
(
String
fileName
,
String
name
,
boolean
csharpStyle
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
buffer
.
append
(
isEmbed
(
)
?
"/resource"
:
"/linkresource"
)
;
buffer
.
append
(
':'
)
;
buffer
.
append
(
fileName
)
;
if
(
name
!=
null
)
{
buffer
.
append
(
','
)
;
buffer
.
append
(
name
)
;
if
(
csharpStyle
)
{
if
(
getPublic
(
)
!=
null
)
{
throw
new
BuildException
(
"This compiler does not support the "
+
"public/private option."
)
;
}
else
{
if
(
getPublic
(
)
!=
null
)
{
buffer
.
append
(
','
)
;
buffer
.
append
(
getPublic
(
)
.
booleanValue
(
)
?
"public"
:
"private"
)
;
}
}
}
else
if
(
getPublic
(
)
!=
null
)
{
throw
new
BuildException
(
"You cannot have a public or private "
+
"option without naming the resource"
)
;
}
}
return
buffer
.
toString
(
)
;
}
public
void
addFileset
(
FileSet
fileset
)
{
fileSets
.
add
(
fileset
)
;
}
public
boolean
hasFilesets
(
)
{
return
fileSets
.
size
(
)
>
0
;
}
}
