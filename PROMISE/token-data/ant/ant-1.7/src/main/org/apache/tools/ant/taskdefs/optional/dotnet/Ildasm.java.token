package
org
.
apache
.
tools
.
ant
.
taskdefs
.
optional
.
dotnet
;
import
org
.
apache
.
tools
.
ant
.
types
.
EnumeratedAttribute
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
import
java
.
io
.
File
;
public
class
Ildasm
extends
Task
{
private
static
final
FileUtils
FILE_UTILS
=
FileUtils
.
getFileUtils
(
)
;
private
File
sourceFile
;
private
File
destFile
;
private
boolean
progressBar
=
false
;
private
String
encoding
;
private
boolean
bytes
=
false
;
private
boolean
linenumbers
=
false
;
private
boolean
rawExceptionHandling
=
false
;
private
boolean
showSource
=
false
;
private
boolean
quoteallnames
=
false
;
private
boolean
header
=
false
;
private
boolean
assembler
=
true
;
private
boolean
metadata
=
false
;
private
String
visibility
;
private
String
item
;
private
String
executable
=
"ildasm"
;
private
File
resourceDir
;
public
void
setResourceDir
(
File
resourceDir
)
{
this
.
resourceDir
=
resourceDir
;
}
public
void
setExecutable
(
String
executable
)
{
this
.
executable
=
executable
;
}
public
void
setEncoding
(
EncodingTypes
encoding
)
{
this
.
encoding
=
encoding
.
getValue
(
)
;
}
public
void
setAssembler
(
boolean
assembler
)
{
this
.
assembler
=
assembler
;
}
public
void
setBytes
(
boolean
bytes
)
{
this
.
bytes
=
bytes
;
}
public
void
setDestFile
(
File
destFile
)
{
this
.
destFile
=
destFile
;
}
public
void
setHeader
(
boolean
header
)
{
this
.
header
=
header
;
}
public
void
setItem
(
String
item
)
{
this
.
item
=
item
;
}
public
void
setLinenumbers
(
boolean
linenumbers
)
{
this
.
linenumbers
=
linenumbers
;
}
public
void
setMetadata
(
boolean
metadata
)
{
this
.
metadata
=
metadata
;
}
public
void
setProgressBar
(
boolean
progressBar
)
{
this
.
progressBar
=
progressBar
;
}
public
void
setQuoteallnames
(
boolean
quoteallnames
)
{
this
.
quoteallnames
=
quoteallnames
;
}
public
void
setRawExceptionHandling
(
boolean
rawExceptionHandling
)
{
this
.
rawExceptionHandling
=
rawExceptionHandling
;
}
public
void
setShowSource
(
boolean
showSource
)
{
this
.
showSource
=
showSource
;
}
public
void
setSourceFile
(
File
sourceFile
)
{
this
.
sourceFile
=
sourceFile
;
}
public
void
setSrcFile
(
File
sourceFile
)
{
setSourceFile
(
sourceFile
)
;
}
public
void
setVisibility
(
String
visibility
)
{
this
.
visibility
=
visibility
;
}
private
void
validate
(
)
{
if
(
sourceFile
==
null
||
!
sourceFile
.
exists
(
)
||
!
sourceFile
.
isFile
(
)
)
{
throw
new
BuildException
(
"invalid source"
)
;
}
if
(
destFile
==
null
||
destFile
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"invalid dest"
)
;
}
if
(
resourceDir
!=
null
&&
(
!
resourceDir
.
exists
(
)
||
!
resourceDir
.
isDirectory
(
)
)
)
{
throw
new
BuildException
(
"invalid resource directory"
)
;
}
}
private
boolean
isDisassemblyNeeded
(
)
{
if
(
!
destFile
.
exists
(
)
)
{
log
(
"Destination file does not exist: a build is required"
,
Project
.
MSG_VERBOSE
)
;
return
true
;
}
long
sourceTime
=
sourceFile
.
lastModified
(
)
;
long
destTime
=
destFile
.
lastModified
(
)
;
if
(
sourceTime
>
(
destTime
+
FILE_UTILS
.
getFileTimestampGranularity
(
)
)
)
{
log
(
"Source file is newer than the dest file: a rebuild is required"
,
Project
.
MSG_VERBOSE
)
;
return
true
;
}
else
{
log
(
"The .il file is up to date"
,
Project
.
MSG_VERBOSE
)
;
return
false
;
}
}
public
void
execute
(
)
throws
BuildException
{
log
(
"This task is deprecated and will be removed in a future version\n"
+
"of Ant.  It is now part of the .NET Antlib:\n"
+
"http://ant.apache.org/antlibs/dotnet/index.html"
,
Project
.
MSG_WARN
)
;
validate
(
)
;
if
(
!
isDisassemblyNeeded
(
)
)
{
return
;
}
NetCommand
command
=
new
NetCommand
(
this
,
"ildasm"
,
executable
)
;
command
.
setFailOnError
(
true
)
;
command
.
addArgument
(
"/text"
)
;
command
.
addArgument
(
"/out="
+
destFile
.
toString
(
)
)
;
if
(
!
progressBar
)
{
command
.
addArgument
(
"/nobar"
)
;
}
if
(
linenumbers
)
{
command
.
addArgument
(
"/linenum"
)
;
}
if
(
showSource
)
{
command
.
addArgument
(
"/source"
)
;
}
if
(
quoteallnames
)
{
command
.
addArgument
(
"/quoteallnames"
)
;
}
if
(
header
)
{
command
.
addArgument
(
"/header"
)
;
}
if
(
!
assembler
)
{
command
.
addArgument
(
"/noil"
)
;
}
if
(
metadata
)
{
command
.
addArgument
(
"/tokens"
)
;
}
command
.
addArgument
(
"/item:"
,
item
)
;
if
(
rawExceptionHandling
)
{
command
.
addArgument
(
"/raweh"
)
;
}
command
.
addArgument
(
EncodingTypes
.
getEncodingOption
(
encoding
)
)
;
if
(
bytes
)
{
command
.
addArgument
(
"/bytes"
)
;
}
command
.
addArgument
(
"/vis:"
,
visibility
)
;
command
.
addArgument
(
sourceFile
.
getAbsolutePath
(
)
)
;
File
execDir
=
resourceDir
;
if
(
execDir
==
null
)
{
execDir
=
destFile
.
getParentFile
(
)
;
}
command
.
setDirectory
(
execDir
)
;
try
{
command
.
runCommand
(
)
;
}
catch
(
BuildException
e
)
{
if
(
destFile
.
exists
(
)
)
{
log
(
"Deleting destination file as it may be corrupt"
)
;
destFile
.
delete
(
)
;
}
throw
e
;
}
}
public
static
class
EncodingTypes
extends
EnumeratedAttribute
{
public
static
final
String
UNICODE
=
"unicode"
;
public
static
final
String
UTF8
=
"utf8"
;
public
static
final
String
ASCII
=
"ascii"
;
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
ASCII
,
UTF8
,
UNICODE
,
}
;
}
public
static
String
getEncodingOption
(
String
enumValue
)
{
if
(
UNICODE
.
equals
(
enumValue
)
)
{
return
"/unicode"
;
}
if
(
UTF8
.
equals
(
enumValue
)
)
{
return
"/utf8"
;
}
return
null
;
}
}
public
static
class
VisibilityOptions
extends
EnumeratedAttribute
{
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
"pub"
,
"pri"
,
"fam"
,
"asm"
,
"faa"
,
"foa"
,
"psc"
,
}
;
}
}
}
