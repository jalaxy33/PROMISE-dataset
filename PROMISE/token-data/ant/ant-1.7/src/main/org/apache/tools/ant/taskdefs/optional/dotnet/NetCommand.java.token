package
org
.
apache
.
tools
.
ant
.
taskdefs
.
optional
.
dotnet
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
PrintWriter
;
import
java
.
io
.
BufferedOutputStream
;
import
java
.
util
.
Hashtable
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
Execute
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
ExecuteStreamHandler
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
LogStreamHandler
;
import
org
.
apache
.
tools
.
ant
.
types
.
Commandline
;
public
class
NetCommand
{
private
static
final
FileUtils
FILE_UTILS
=
FileUtils
.
getFileUtils
(
)
;
protected
Task
owner
;
protected
Execute
executable
;
protected
Commandline
commandLine
;
protected
String
title
;
protected
String
program
;
protected
boolean
traceCommandLine
=
false
;
protected
boolean
failOnError
;
private
File
directory
;
private
boolean
useResponseFile
=
false
;
private
File
temporaryCommandFile
;
private
int
automaticResponseFileThreshold
=
64
;
public
NetCommand
(
Task
owner
,
String
title
,
String
program
)
{
this
.
owner
=
owner
;
this
.
title
=
title
;
this
.
program
=
program
;
commandLine
=
new
Commandline
(
)
;
commandLine
.
setExecutable
(
program
)
;
}
public
void
setTraceCommandLine
(
boolean
b
)
{
traceCommandLine
=
b
;
}
public
void
setFailOnError
(
boolean
b
)
{
failOnError
=
b
;
}
public
boolean
getFailFailOnError
(
)
{
return
failOnError
;
}
public
void
setDirectory
(
File
directory
)
{
this
.
directory
=
directory
;
}
protected
void
logVerbose
(
String
msg
)
{
owner
.
getProject
(
)
.
log
(
msg
,
Project
.
MSG_VERBOSE
)
;
}
protected
void
logError
(
String
msg
)
{
owner
.
getProject
(
)
.
log
(
msg
,
Project
.
MSG_ERR
)
;
}
public
void
addArgument
(
String
argument
)
{
if
(
argument
!=
null
&&
argument
.
length
(
)
!=
0
)
{
commandLine
.
createArgument
(
)
.
setValue
(
argument
)
;
}
}
public
void
addArguments
(
String
[
]
arguments
)
{
if
(
arguments
!=
null
&&
arguments
.
length
!=
0
)
{
for
(
int
i
=
0
;
i
<
arguments
.
length
;
i
++
)
{
addArgument
(
arguments
[
i
]
)
;
}
}
}
public
void
addArgument
(
String
argument1
,
String
argument2
)
{
if
(
argument2
!=
null
&&
argument2
.
length
(
)
!=
0
)
{
commandLine
.
createArgument
(
)
.
setValue
(
argument1
+
argument2
)
;
}
}
public
boolean
isUseResponseFile
(
)
{
return
useResponseFile
;
}
public
void
setUseResponseFile
(
boolean
useResponseFile
)
{
this
.
useResponseFile
=
useResponseFile
;
}
public
int
getAutomaticResponseFileThreshold
(
)
{
return
automaticResponseFileThreshold
;
}
public
void
setAutomaticResponseFileThreshold
(
int
automaticResponseFileThreshold
)
{
this
.
automaticResponseFileThreshold
=
automaticResponseFileThreshold
;
}
protected
void
prepareExecutor
(
)
{
if
(
owner
==
null
)
{
throw
new
RuntimeException
(
"no owner"
)
;
}
if
(
owner
.
getProject
(
)
==
null
)
{
throw
new
RuntimeException
(
"Owner has no project"
)
;
}
File
dir
=
owner
.
getProject
(
)
.
getBaseDir
(
)
;
if
(
directory
!=
null
)
{
dir
=
directory
;
}
ExecuteStreamHandler
handler
=
new
LogStreamHandler
(
owner
,
Project
.
MSG_INFO
,
Project
.
MSG_WARN
)
;
executable
=
new
Execute
(
handler
,
null
)
;
executable
.
setAntRun
(
owner
.
getProject
(
)
)
;
executable
.
setWorkingDirectory
(
dir
)
;
}
public
void
runCommand
(
)
throws
BuildException
{
prepareExecutor
(
)
;
int
err
=
-
1
;
try
{
if
(
traceCommandLine
)
{
owner
.
log
(
"In directory "
+
executable
.
getWorkingDirectory
(
)
)
;
owner
.
log
(
commandLine
.
describeCommand
(
)
)
;
}
else
{
logVerbose
(
"In directory "
+
executable
.
getWorkingDirectory
(
)
)
;
logVerbose
(
commandLine
.
describeCommand
(
)
)
;
}
setExecutableCommandLine
(
)
;
err
=
executable
.
execute
(
)
;
if
(
Execute
.
isFailure
(
err
)
)
{
if
(
failOnError
)
{
throw
new
BuildException
(
title
+
" returned: "
+
err
,
owner
.
getLocation
(
)
)
;
}
else
{
owner
.
log
(
title
+
"  Result: "
+
err
,
Project
.
MSG_ERR
)
;
}
}
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
title
+
" failed: "
+
e
,
e
,
owner
.
getLocation
(
)
)
;
}
finally
{
if
(
temporaryCommandFile
!=
null
)
{
temporaryCommandFile
.
delete
(
)
;
}
}
}
private
void
setExecutableCommandLine
(
)
{
String
[
]
commands
=
commandLine
.
getCommandline
(
)
;
if
(
automaticResponseFileThreshold
>
0
&&
commands
.
length
>
automaticResponseFileThreshold
)
{
useResponseFile
=
true
;
}
if
(
!
useResponseFile
||
commands
.
length
<=
1
)
{
executable
.
setCommandline
(
commands
)
;
}
else
{
FileOutputStream
fos
=
null
;
temporaryCommandFile
=
FILE_UTILS
.
createTempFile
(
"cmd"
,
".txt"
,
null
)
;
owner
.
log
(
"Using response file "
+
temporaryCommandFile
,
Project
.
MSG_VERBOSE
)
;
try
{
fos
=
new
FileOutputStream
(
temporaryCommandFile
)
;
PrintWriter
out
=
new
PrintWriter
(
new
BufferedOutputStream
(
fos
)
)
;
for
(
int
i
=
1
;
i
<
commands
.
length
;
++
i
)
{
out
.
println
(
commands
[
i
]
)
;
}
out
.
flush
(
)
;
out
.
close
(
)
;
}
catch
(
IOException
ex
)
{
throw
new
BuildException
(
"saving command stream to "
+
temporaryCommandFile
,
ex
)
;
}
String
[
]
newCommandLine
=
new
String
[
2
]
;
newCommandLine
[
0
]
=
commands
[
0
]
;
newCommandLine
[
1
]
=
"@"
+
temporaryCommandFile
.
getAbsolutePath
(
)
;
logVerbose
(
Commandline
.
describeCommand
(
newCommandLine
)
)
;
executable
.
setCommandline
(
newCommandLine
)
;
}
}
public
int
scanOneFileset
(
DirectoryScanner
scanner
,
Hashtable
filesToBuild
,
long
outputTimestamp
)
{
int
filesOutOfDate
=
0
;
String
[
]
dependencies
=
scanner
.
getIncludedFiles
(
)
;
File
base
=
scanner
.
getBasedir
(
)
;
for
(
int
i
=
0
;
i
<
dependencies
.
length
;
i
++
)
{
File
targetFile
=
new
File
(
base
,
dependencies
[
i
]
)
;
if
(
filesToBuild
.
get
(
targetFile
)
==
null
)
{
filesToBuild
.
put
(
targetFile
,
targetFile
)
;
if
(
targetFile
.
lastModified
(
)
>
outputTimestamp
)
{
filesOutOfDate
++
;
owner
.
log
(
targetFile
.
toString
(
)
+
" is out of date"
,
Project
.
MSG_VERBOSE
)
;
}
else
{
owner
.
log
(
targetFile
.
toString
(
)
,
Project
.
MSG_VERBOSE
)
;
}
}
}
return
filesOutOfDate
;
}
}
