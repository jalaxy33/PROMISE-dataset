package
org
.
apache
.
tools
.
ant
.
taskdefs
.
optional
.
dotnet
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
import
java
.
io
.
File
;
public
class
ImportTypelib
extends
Task
{
private
static
final
FileUtils
FILE_UTILS
=
FileUtils
.
getFileUtils
(
)
;
private
File
srcFile
;
private
File
destFile
;
private
String
namespace
;
private
boolean
useSysArray
=
false
;
private
boolean
unsafe
=
false
;
private
String
extraOptions
=
null
;
public
void
setDestFile
(
File
destFile
)
{
this
.
destFile
=
destFile
;
}
public
void
setNamespace
(
String
namespace
)
{
this
.
namespace
=
namespace
;
}
public
void
setSrcFile
(
File
srcFile
)
{
this
.
srcFile
=
srcFile
;
}
public
void
setUnsafe
(
boolean
unsafe
)
{
this
.
unsafe
=
unsafe
;
}
public
void
setUseSysArray
(
boolean
useSysArray
)
{
this
.
useSysArray
=
useSysArray
;
}
public
void
setExtraOptions
(
String
extraOptions
)
{
this
.
extraOptions
=
extraOptions
;
}
protected
void
validate
(
)
throws
BuildException
{
if
(
destFile
==
null
)
{
throw
new
BuildException
(
"destination file must be specified"
)
;
}
if
(
destFile
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"destination file is a directory"
)
;
}
if
(
srcFile
==
null
||
!
srcFile
.
exists
(
)
)
{
throw
new
BuildException
(
"source file does not exist"
)
;
}
if
(
srcFile
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"source file is a directory"
)
;
}
if
(
namespace
==
null
)
{
throw
new
BuildException
(
"No namespace"
)
;
}
}
private
boolean
isExecuteNeeded
(
)
{
if
(
!
destFile
.
exists
(
)
)
{
log
(
"Destination file does not exist: a build is required"
,
Project
.
MSG_VERBOSE
)
;
return
true
;
}
long
sourceTime
=
srcFile
.
lastModified
(
)
;
long
destTime
=
destFile
.
lastModified
(
)
;
if
(
sourceTime
>
(
destTime
+
FILE_UTILS
.
getFileTimestampGranularity
(
)
)
)
{
log
(
"Source file is newer than the dest file: a rebuild is required"
,
Project
.
MSG_VERBOSE
)
;
return
true
;
}
else
{
log
(
"The output file is up to date"
,
Project
.
MSG_VERBOSE
)
;
return
false
;
}
}
public
void
execute
(
)
throws
BuildException
{
log
(
"This task is deprecated and will be removed in a future version\n"
+
"of Ant.  It is now part of the .NET Antlib:\n"
+
"http://ant.apache.org/antlibs/dotnet/index.html"
,
Project
.
MSG_WARN
)
;
validate
(
)
;
log
(
"Importing typelib "
+
srcFile
+
" to assembly "
+
destFile
+
" in namespace "
+
namespace
,
Project
.
MSG_VERBOSE
)
;
if
(
!
isExecuteNeeded
(
)
)
{
return
;
}
NetCommand
command
=
new
NetCommand
(
this
,
"ImportTypelib"
,
"tlbimp"
)
;
command
.
setFailOnError
(
true
)
;
command
.
addArgument
(
srcFile
.
toString
(
)
)
;
command
.
addArgument
(
"/nologo"
)
;
command
.
addArgument
(
"/out:"
+
destFile
)
;
command
.
addArgument
(
"/namespace:"
,
namespace
)
;
if
(
useSysArray
)
{
command
.
addArgument
(
"/sysarray"
)
;
}
if
(
unsafe
)
{
command
.
addArgument
(
"/unsafe"
)
;
}
command
.
addArgument
(
extraOptions
)
;
command
.
runCommand
(
)
;
}
}
