package
org
.
apache
.
tools
.
ant
.
taskdefs
.
optional
.
ssh
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
util
.
TeeOutputStream
;
import
org
.
apache
.
tools
.
ant
.
util
.
KeepAliveOutputStream
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileWriter
;
import
java
.
io
.
IOException
;
import
java
.
io
.
StringReader
;
import
com
.
jcraft
.
jsch
.
ChannelExec
;
import
com
.
jcraft
.
jsch
.
JSchException
;
import
com
.
jcraft
.
jsch
.
Session
;
public
class
SSHExec
extends
SSHBase
{
private
String
command
=
null
;
private
long
maxwait
=
0
;
private
Thread
thread
=
null
;
private
String
outputProperty
=
null
;
private
File
outputFile
=
null
;
private
boolean
append
=
false
;
private
static
final
String
TIMEOUT_MESSAGE
=
"Timeout period exceeded, connection dropped."
;
public
SSHExec
(
)
{
super
(
)
;
}
public
void
setCommand
(
String
command
)
{
this
.
command
=
command
;
}
public
void
setTimeout
(
long
timeout
)
{
maxwait
=
timeout
;
}
public
void
setOutput
(
File
output
)
{
outputFile
=
output
;
}
public
void
setAppend
(
boolean
append
)
{
this
.
append
=
append
;
}
public
void
setOutputproperty
(
String
property
)
{
outputProperty
=
property
;
}
public
void
execute
(
)
throws
BuildException
{
if
(
getHost
(
)
==
null
)
{
throw
new
BuildException
(
"Host is required."
)
;
}
if
(
getUserInfo
(
)
.
getName
(
)
==
null
)
{
throw
new
BuildException
(
"Username is required."
)
;
}
if
(
getUserInfo
(
)
.
getKeyfile
(
)
==
null
&&
getUserInfo
(
)
.
getPassword
(
)
==
null
)
{
throw
new
BuildException
(
"Password or Keyfile is required."
)
;
}
if
(
command
==
null
)
{
throw
new
BuildException
(
"Command is required."
)
;
}
ByteArrayOutputStream
out
=
new
ByteArrayOutputStream
(
)
;
TeeOutputStream
tee
=
new
TeeOutputStream
(
out
,
new
KeepAliveOutputStream
(
System
.
out
)
)
;
Session
session
=
null
;
try
{
session
=
openSession
(
)
;
session
.
setTimeout
(
(
int
)
maxwait
)
;
final
ChannelExec
channel
=
(
ChannelExec
)
session
.
openChannel
(
"exec"
)
;
channel
.
setCommand
(
command
)
;
channel
.
setOutputStream
(
tee
)
;
channel
.
setExtOutputStream
(
tee
)
;
channel
.
connect
(
)
;
thread
=
new
Thread
(
)
{
public
void
run
(
)
{
while
(
!
channel
.
isEOF
(
)
)
{
if
(
thread
==
null
)
{
return
;
}
try
{
sleep
(
500
)
;
}
catch
(
Exception
e
)
{
}
}
}
}
;
thread
.
start
(
)
;
thread
.
join
(
maxwait
)
;
if
(
thread
.
isAlive
(
)
)
{
thread
=
null
;
if
(
getFailonerror
(
)
)
{
throw
new
BuildException
(
TIMEOUT_MESSAGE
)
;
}
else
{
log
(
TIMEOUT_MESSAGE
,
Project
.
MSG_ERR
)
;
}
}
else
{
if
(
outputProperty
!=
null
)
{
getProject
(
)
.
setProperty
(
outputProperty
,
out
.
toString
(
)
)
;
}
if
(
outputFile
!=
null
)
{
writeToFile
(
out
.
toString
(
)
,
append
,
outputFile
)
;
}
int
ec
=
channel
.
getExitStatus
(
)
;
if
(
ec
!=
0
)
{
String
msg
=
"Remote command failed with exit status "
+
ec
;
if
(
getFailonerror
(
)
)
{
throw
new
BuildException
(
msg
)
;
}
else
{
log
(
msg
,
Project
.
MSG_ERR
)
;
}
}
}
}
catch
(
BuildException
e
)
{
throw
e
;
}
catch
(
JSchException
e
)
{
if
(
e
.
getMessage
(
)
.
indexOf
(
"session is down"
)
>=
0
)
{
if
(
getFailonerror
(
)
)
{
throw
new
BuildException
(
TIMEOUT_MESSAGE
,
e
)
;
}
else
{
log
(
TIMEOUT_MESSAGE
,
Project
.
MSG_ERR
)
;
}
}
else
{
if
(
getFailonerror
(
)
)
{
throw
new
BuildException
(
e
)
;
}
else
{
log
(
"Caught exception: "
+
e
.
getMessage
(
)
,
Project
.
MSG_ERR
)
;
}
}
}
catch
(
Exception
e
)
{
if
(
getFailonerror
(
)
)
{
throw
new
BuildException
(
e
)
;
}
else
{
log
(
"Caught exception: "
+
e
.
getMessage
(
)
,
Project
.
MSG_ERR
)
;
}
}
finally
{
if
(
session
!=
null
&&
session
.
isConnected
(
)
)
{
session
.
disconnect
(
)
;
}
}
}
private
void
writeToFile
(
String
from
,
boolean
append
,
File
to
)
throws
IOException
{
FileWriter
out
=
null
;
try
{
out
=
new
FileWriter
(
to
.
getAbsolutePath
(
)
,
append
)
;
StringReader
in
=
new
StringReader
(
from
)
;
char
[
]
buffer
=
new
char
[
8192
]
;
int
bytesRead
;
while
(
true
)
{
bytesRead
=
in
.
read
(
buffer
)
;
if
(
bytesRead
==
-
1
)
{
break
;
}
out
.
write
(
buffer
,
0
,
bytesRead
)
;
}
out
.
flush
(
)
;
}
finally
{
if
(
out
!=
null
)
{
out
.
close
(
)
;
}
}
}
}
