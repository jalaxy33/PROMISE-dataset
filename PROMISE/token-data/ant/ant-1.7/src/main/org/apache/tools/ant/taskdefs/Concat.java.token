package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
File
;
import
java
.
io
.
Reader
;
import
java
.
io
.
Writer
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
PrintWriter
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
StringReader
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Iterator
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
ProjectComponent
;
import
org
.
apache
.
tools
.
ant
.
filters
.
util
.
ChainReaderHelper
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileList
;
import
org
.
apache
.
tools
.
ant
.
types
.
FilterChain
;
import
org
.
apache
.
tools
.
ant
.
types
.
Resource
;
import
org
.
apache
.
tools
.
ant
.
types
.
ResourceCollection
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
Restrict
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
Resources
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
FileResource
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
StringResource
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Not
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Exists
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
ResourceSelector
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
import
org
.
apache
.
tools
.
ant
.
util
.
ConcatResourceInputStream
;
public
class
Concat
extends
Task
{
private
static
final
int
BUFFER_SIZE
=
8192
;
private
static
final
FileUtils
FILE_UTILS
=
FileUtils
.
getFileUtils
(
)
;
private
static
final
ResourceSelector
EXISTS
=
new
Exists
(
)
;
private
static
final
ResourceSelector
NOT_EXISTS
=
new
Not
(
EXISTS
)
;
private
File
destinationFile
;
private
boolean
append
;
private
String
encoding
;
private
String
outputEncoding
;
private
boolean
binary
;
private
StringBuffer
textBuffer
;
private
Resources
rc
;
private
Vector
filterChains
;
private
boolean
forceOverwrite
=
true
;
private
TextElement
footer
;
private
TextElement
header
;
private
boolean
fixLastLine
=
false
;
private
String
eolString
;
private
Writer
outputWriter
=
null
;
public
Concat
(
)
{
reset
(
)
;
}
public
void
reset
(
)
{
append
=
false
;
forceOverwrite
=
true
;
destinationFile
=
null
;
encoding
=
null
;
outputEncoding
=
null
;
fixLastLine
=
false
;
filterChains
=
null
;
footer
=
null
;
header
=
null
;
binary
=
false
;
outputWriter
=
null
;
textBuffer
=
null
;
eolString
=
System
.
getProperty
(
"line.separator"
)
;
rc
=
null
;
}
public
void
setDestfile
(
File
destinationFile
)
{
this
.
destinationFile
=
destinationFile
;
}
public
void
setAppend
(
boolean
append
)
{
this
.
append
=
append
;
}
public
void
setEncoding
(
String
encoding
)
{
this
.
encoding
=
encoding
;
if
(
outputEncoding
==
null
)
{
outputEncoding
=
encoding
;
}
}
public
void
setOutputEncoding
(
String
outputEncoding
)
{
this
.
outputEncoding
=
outputEncoding
;
}
public
void
setForce
(
boolean
force
)
{
this
.
forceOverwrite
=
force
;
}
public
Path
createPath
(
)
{
Path
path
=
new
Path
(
getProject
(
)
)
;
add
(
path
)
;
return
path
;
}
public
void
addFileset
(
FileSet
set
)
{
add
(
set
)
;
}
public
void
addFilelist
(
FileList
list
)
{
add
(
list
)
;
}
public
void
add
(
ResourceCollection
c
)
{
rc
=
rc
==
null
?
new
Resources
(
)
:
rc
;
rc
.
add
(
c
)
;
}
public
void
addFilterChain
(
FilterChain
filterChain
)
{
if
(
filterChains
==
null
)
{
filterChains
=
new
Vector
(
)
;
}
filterChains
.
addElement
(
filterChain
)
;
}
public
void
addText
(
String
text
)
{
if
(
textBuffer
==
null
)
{
textBuffer
=
new
StringBuffer
(
text
.
length
(
)
)
;
}
textBuffer
.
append
(
text
)
;
}
public
void
addHeader
(
TextElement
headerToAdd
)
{
this
.
header
=
headerToAdd
;
}
public
void
addFooter
(
TextElement
footerToAdd
)
{
this
.
footer
=
footerToAdd
;
}
public
void
setFixLastLine
(
boolean
fixLastLine
)
{
this
.
fixLastLine
=
fixLastLine
;
}
public
void
setEol
(
FixCRLF
.
CrLf
crlf
)
{
String
s
=
crlf
.
getValue
(
)
;
if
(
s
.
equals
(
"cr"
)
||
s
.
equals
(
"mac"
)
)
{
eolString
=
"\r"
;
}
else
if
(
s
.
equals
(
"lf"
)
||
s
.
equals
(
"unix"
)
)
{
eolString
=
"\n"
;
}
else
if
(
s
.
equals
(
"crlf"
)
||
s
.
equals
(
"dos"
)
)
{
eolString
=
"\r\n"
;
}
}
public
void
setWriter
(
Writer
outputWriter
)
{
this
.
outputWriter
=
outputWriter
;
}
public
void
setBinary
(
boolean
binary
)
{
this
.
binary
=
binary
;
}
private
ResourceCollection
validate
(
)
{
sanitizeText
(
)
;
if
(
binary
)
{
if
(
destinationFile
==
null
)
{
throw
new
BuildException
(
"destfile attribute is required for binary concatenation"
)
;
}
if
(
textBuffer
!=
null
)
{
throw
new
BuildException
(
"Nested text is incompatible with binary concatenation"
)
;
}
if
(
encoding
!=
null
||
outputEncoding
!=
null
)
{
throw
new
BuildException
(
"Seting input or output encoding is incompatible with binary"
+
" concatenation"
)
;
}
if
(
filterChains
!=
null
)
{
throw
new
BuildException
(
"Setting filters is incompatible with binary concatenation"
)
;
}
if
(
fixLastLine
)
{
throw
new
BuildException
(
"Setting fixlastline is incompatible with binary concatenation"
)
;
}
if
(
header
!=
null
||
footer
!=
null
)
{
throw
new
BuildException
(
"Nested header or footer is incompatible with binary concatenation"
)
;
}
}
if
(
destinationFile
!=
null
&&
outputWriter
!=
null
)
{
throw
new
BuildException
(
"Cannot specify both a destination file and an output writer"
)
;
}
if
(
rc
==
null
&&
textBuffer
==
null
)
{
throw
new
BuildException
(
"At least one resource must be provided, or some text."
)
;
}
if
(
rc
!=
null
)
{
if
(
textBuffer
!=
null
)
{
throw
new
BuildException
(
"Cannot include inline text when using resources."
)
;
}
Restrict
noexistRc
=
new
Restrict
(
)
;
noexistRc
.
add
(
NOT_EXISTS
)
;
noexistRc
.
add
(
rc
)
;
for
(
Iterator
i
=
noexistRc
.
iterator
(
)
;
i
.
hasNext
(
)
;
)
{
log
(
i
.
next
(
)
+
" does not exist."
,
Project
.
MSG_ERR
)
;
}
if
(
destinationFile
!=
null
)
{
for
(
Iterator
i
=
rc
.
iterator
(
)
;
i
.
hasNext
(
)
;
)
{
Object
o
=
i
.
next
(
)
;
if
(
o
instanceof
FileResource
)
{
File
f
=
(
(
FileResource
)
o
)
.
getFile
(
)
;
if
(
FILE_UTILS
.
fileNameEquals
(
f
,
destinationFile
)
)
{
throw
new
BuildException
(
"Input file \""
+
f
+
"\" is the same as the output file."
)
;
}
}
}
}
Restrict
existRc
=
new
Restrict
(
)
;
existRc
.
add
(
EXISTS
)
;
existRc
.
add
(
rc
)
;
boolean
outofdate
=
destinationFile
==
null
||
forceOverwrite
;
if
(
!
outofdate
)
{
for
(
Iterator
i
=
existRc
.
iterator
(
)
;
!
outofdate
&&
i
.
hasNext
(
)
;
)
{
Resource
r
=
(
Resource
)
i
.
next
(
)
;
outofdate
=
(
r
.
getLastModified
(
)
==
0L
||
r
.
getLastModified
(
)
>
destinationFile
.
lastModified
(
)
)
;
}
}
if
(
!
outofdate
)
{
log
(
destinationFile
+
" is up-to-date."
,
Project
.
MSG_VERBOSE
)
;
return
null
;
}
return
existRc
;
}
else
{
StringResource
s
=
new
StringResource
(
)
;
s
.
setProject
(
getProject
(
)
)
;
s
.
setValue
(
textBuffer
.
toString
(
)
)
;
return
s
;
}
}
public
void
execute
(
)
{
ResourceCollection
c
=
validate
(
)
;
if
(
c
==
null
)
{
return
;
}
if
(
c
.
size
(
)
<
1
&&
header
==
null
&&
footer
==
null
)
{
log
(
"No existing resources and no nested text, doing nothing"
,
Project
.
MSG_INFO
)
;
return
;
}
if
(
binary
)
{
binaryCat
(
c
)
;
}
else
{
cat
(
c
)
;
}
}
private
void
binaryCat
(
ResourceCollection
c
)
{
log
(
"Binary concatenation of "
+
c
.
size
(
)
+
" resources to "
+
destinationFile
)
;
FileOutputStream
out
=
null
;
InputStream
in
=
null
;
try
{
try
{
out
=
new
FileOutputStream
(
destinationFile
)
;
}
catch
(
Exception
t
)
{
throw
new
BuildException
(
"Unable to open "
+
destinationFile
+
" for writing"
,
t
)
;
}
in
=
new
ConcatResourceInputStream
(
c
)
;
(
(
ConcatResourceInputStream
)
in
)
.
setManagingComponent
(
this
)
;
Thread
t
=
new
Thread
(
new
StreamPumper
(
in
,
out
)
)
;
t
.
start
(
)
;
try
{
t
.
join
(
)
;
}
catch
(
InterruptedException
e
)
{
try
{
t
.
join
(
)
;
}
catch
(
InterruptedException
ee
)
{
}
}
}
finally
{
FileUtils
.
close
(
in
)
;
if
(
out
!=
null
)
{
try
{
out
.
close
(
)
;
}
catch
(
Exception
ex
)
{
throw
new
BuildException
(
"Unable to close "
+
destinationFile
,
ex
)
;
}
}
}
}
private
void
cat
(
ResourceCollection
c
)
{
OutputStream
os
=
null
;
char
[
]
buffer
=
new
char
[
BUFFER_SIZE
]
;
try
{
PrintWriter
writer
=
null
;
if
(
outputWriter
!=
null
)
{
writer
=
new
PrintWriter
(
outputWriter
)
;
}
else
{
if
(
destinationFile
==
null
)
{
os
=
new
LogOutputStream
(
this
,
Project
.
MSG_WARN
)
;
}
else
{
File
parent
=
destinationFile
.
getParentFile
(
)
;
if
(
!
parent
.
exists
(
)
)
{
parent
.
mkdirs
(
)
;
}
os
=
new
FileOutputStream
(
destinationFile
.
getAbsolutePath
(
)
,
append
)
;
}
if
(
outputEncoding
==
null
)
{
writer
=
new
PrintWriter
(
new
BufferedWriter
(
new
OutputStreamWriter
(
os
)
)
)
;
}
else
{
writer
=
new
PrintWriter
(
new
BufferedWriter
(
new
OutputStreamWriter
(
os
,
outputEncoding
)
)
)
;
}
}
if
(
header
!=
null
)
{
if
(
header
.
getFiltering
(
)
)
{
concatenate
(
buffer
,
writer
,
new
StringReader
(
header
.
getValue
(
)
)
)
;
}
else
{
writer
.
print
(
header
.
getValue
(
)
)
;
}
}
if
(
c
.
size
(
)
>
0
)
{
concatenate
(
buffer
,
writer
,
new
MultiReader
(
c
)
)
;
}
if
(
footer
!=
null
)
{
if
(
footer
.
getFiltering
(
)
)
{
concatenate
(
buffer
,
writer
,
new
StringReader
(
footer
.
getValue
(
)
)
)
;
}
else
{
writer
.
print
(
footer
.
getValue
(
)
)
;
}
}
writer
.
flush
(
)
;
if
(
os
!=
null
)
{
os
.
flush
(
)
;
}
}
catch
(
IOException
ioex
)
{
throw
new
BuildException
(
"Error while concatenating: "
+
ioex
.
getMessage
(
)
,
ioex
)
;
}
finally
{
FileUtils
.
close
(
os
)
;
}
}
private
void
concatenate
(
char
[
]
buffer
,
Writer
writer
,
Reader
in
)
throws
IOException
{
if
(
filterChains
!=
null
)
{
ChainReaderHelper
helper
=
new
ChainReaderHelper
(
)
;
helper
.
setBufferSize
(
BUFFER_SIZE
)
;
helper
.
setPrimaryReader
(
in
)
;
helper
.
setFilterChains
(
filterChains
)
;
helper
.
setProject
(
getProject
(
)
)
;
in
=
new
BufferedReader
(
helper
.
getAssembledReader
(
)
)
;
}
while
(
true
)
{
int
nRead
=
in
.
read
(
buffer
,
0
,
buffer
.
length
)
;
if
(
nRead
==
-
1
)
{
break
;
}
writer
.
write
(
buffer
,
0
,
nRead
)
;
}
writer
.
flush
(
)
;
}
private
void
sanitizeText
(
)
{
if
(
textBuffer
!=
null
)
{
if
(
textBuffer
.
substring
(
0
)
.
trim
(
)
.
length
(
)
==
0
)
{
textBuffer
=
null
;
}
}
}
public
static
class
TextElement
extends
ProjectComponent
{
private
String
value
=
""
;
private
boolean
trimLeading
=
false
;
private
boolean
trim
=
false
;
private
boolean
filtering
=
true
;
private
String
encoding
=
null
;
public
void
setFiltering
(
boolean
filtering
)
{
this
.
filtering
=
filtering
;
}
private
boolean
getFiltering
(
)
{
return
filtering
;
}
public
void
setEncoding
(
String
encoding
)
{
this
.
encoding
=
encoding
;
}
public
void
setFile
(
File
file
)
throws
BuildException
{
if
(
!
file
.
exists
(
)
)
{
throw
new
BuildException
(
"File "
+
file
+
" does not exist."
)
;
}
BufferedReader
reader
=
null
;
try
{
if
(
this
.
encoding
==
null
)
{
reader
=
new
BufferedReader
(
new
FileReader
(
file
)
)
;
}
else
{
reader
=
new
BufferedReader
(
new
InputStreamReader
(
new
FileInputStream
(
file
)
,
this
.
encoding
)
)
;
}
value
=
FileUtils
.
readFully
(
reader
)
;
}
catch
(
IOException
ex
)
{
throw
new
BuildException
(
ex
)
;
}
finally
{
FileUtils
.
close
(
reader
)
;
}
}
public
void
addText
(
String
value
)
{
this
.
value
+=
getProject
(
)
.
replaceProperties
(
value
)
;
}
public
void
setTrimLeading
(
boolean
strip
)
{
this
.
trimLeading
=
strip
;
}
public
void
setTrim
(
boolean
trim
)
{
this
.
trim
=
trim
;
}
public
String
getValue
(
)
{
if
(
value
==
null
)
{
value
=
""
;
}
if
(
value
.
trim
(
)
.
length
(
)
==
0
)
{
value
=
""
;
}
if
(
trimLeading
)
{
char
[
]
current
=
value
.
toCharArray
(
)
;
StringBuffer
b
=
new
StringBuffer
(
current
.
length
)
;
boolean
startOfLine
=
true
;
int
pos
=
0
;
while
(
pos
<
current
.
length
)
{
char
ch
=
current
[
pos
++
]
;
if
(
startOfLine
)
{
if
(
ch
==
' '
||
ch
==
'\t'
)
{
continue
;
}
startOfLine
=
false
;
}
b
.
append
(
ch
)
;
if
(
ch
==
'\n'
||
ch
==
'\r'
)
{
startOfLine
=
true
;
}
}
value
=
b
.
toString
(
)
;
}
if
(
trim
)
{
value
=
value
.
trim
(
)
;
}
return
value
;
}
}
private
class
MultiReader
extends
Reader
{
private
Reader
reader
=
null
;
private
int
lastPos
=
0
;
private
char
[
]
lastChars
=
new
char
[
eolString
.
length
(
)
]
;
private
boolean
needAddSeparator
=
false
;
private
Iterator
i
;
private
MultiReader
(
ResourceCollection
c
)
{
i
=
c
.
iterator
(
)
;
}
private
Reader
getReader
(
)
throws
IOException
{
if
(
reader
==
null
&&
i
.
hasNext
(
)
)
{
Resource
r
=
(
Resource
)
i
.
next
(
)
;
log
(
"Concating "
+
r
.
toLongString
(
)
,
Project
.
MSG_VERBOSE
)
;
InputStream
is
=
r
.
getInputStream
(
)
;
reader
=
new
BufferedReader
(
encoding
==
null
?
new
InputStreamReader
(
is
)
:
new
InputStreamReader
(
is
,
encoding
)
)
;
Arrays
.
fill
(
lastChars
,
(
char
)
0
)
;
}
return
reader
;
}
private
void
nextReader
(
)
throws
IOException
{
close
(
)
;
reader
=
null
;
}
public
int
read
(
)
throws
IOException
{
if
(
needAddSeparator
)
{
int
ret
=
eolString
.
charAt
(
lastPos
++
)
;
if
(
lastPos
>=
eolString
.
length
(
)
)
{
lastPos
=
0
;
needAddSeparator
=
false
;
}
return
ret
;
}
while
(
getReader
(
)
!=
null
)
{
int
ch
=
getReader
(
)
.
read
(
)
;
if
(
ch
==
-
1
)
{
nextReader
(
)
;
if
(
fixLastLine
&&
isMissingEndOfLine
(
)
)
{
needAddSeparator
=
true
;
lastPos
=
0
;
}
}
else
{
addLastChar
(
(
char
)
ch
)
;
return
ch
;
}
}
return
-
1
;
}
public
int
read
(
char
[
]
cbuf
,
int
off
,
int
len
)
throws
IOException
{
int
amountRead
=
0
;
while
(
getReader
(
)
!=
null
||
needAddSeparator
)
{
if
(
needAddSeparator
)
{
cbuf
[
off
]
=
eolString
.
charAt
(
lastPos
++
)
;
if
(
lastPos
>=
eolString
.
length
(
)
)
{
lastPos
=
0
;
needAddSeparator
=
false
;
}
len
--
;
off
++
;
amountRead
++
;
if
(
len
==
0
)
{
return
amountRead
;
}
continue
;
}
int
nRead
=
getReader
(
)
.
read
(
cbuf
,
off
,
len
)
;
if
(
nRead
==
-
1
||
nRead
==
0
)
{
nextReader
(
)
;
if
(
fixLastLine
&&
isMissingEndOfLine
(
)
)
{
needAddSeparator
=
true
;
lastPos
=
0
;
}
}
else
{
if
(
fixLastLine
)
{
for
(
int
i
=
nRead
;
i
>
(
nRead
-
lastChars
.
length
)
;
--
i
)
{
if
(
i
<=
0
)
{
break
;
}
addLastChar
(
cbuf
[
off
+
i
-
1
]
)
;
}
}
len
-=
nRead
;
off
+=
nRead
;
amountRead
+=
nRead
;
if
(
len
==
0
)
{
return
amountRead
;
}
}
}
if
(
amountRead
==
0
)
{
return
-
1
;
}
else
{
return
amountRead
;
}
}
public
void
close
(
)
throws
IOException
{
if
(
reader
!=
null
)
{
reader
.
close
(
)
;
}
}
private
void
addLastChar
(
char
ch
)
{
for
(
int
i
=
lastChars
.
length
-
2
;
i
>=
0
;
--
i
)
{
lastChars
[
i
]
=
lastChars
[
i
+
1
]
;
}
lastChars
[
lastChars
.
length
-
1
]
=
ch
;
}
private
boolean
isMissingEndOfLine
(
)
{
for
(
int
i
=
0
;
i
<
lastChars
.
length
;
++
i
)
{
if
(
lastChars
[
i
]
!=
eolString
.
charAt
(
i
)
)
{
return
true
;
}
}
return
false
;
}
}
}
