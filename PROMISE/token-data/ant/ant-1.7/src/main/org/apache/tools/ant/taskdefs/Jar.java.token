package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
ByteArrayInputStream
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
PrintWriter
;
import
java
.
io
.
Reader
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Comparator
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
TreeMap
;
import
java
.
util
.
Vector
;
import
java
.
util
.
zip
.
ZipEntry
;
import
java
.
util
.
zip
.
ZipFile
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
types
.
EnumeratedAttribute
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
types
.
ResourceCollection
;
import
org
.
apache
.
tools
.
ant
.
types
.
ZipFileSet
;
import
org
.
apache
.
tools
.
ant
.
types
.
spi
.
Service
;
import
org
.
apache
.
tools
.
zip
.
JarMarker
;
import
org
.
apache
.
tools
.
zip
.
ZipExtraField
;
import
org
.
apache
.
tools
.
zip
.
ZipOutputStream
;
public
class
Jar
extends
Zip
{
private
static
final
String
INDEX_NAME
=
"META-INF/INDEX.LIST"
;
private
static
final
String
MANIFEST_NAME
=
"META-INF/MANIFEST.MF"
;
private
List
serviceList
=
new
ArrayList
(
)
;
private
Manifest
configuredManifest
;
private
Manifest
savedConfiguredManifest
;
private
Manifest
filesetManifest
;
private
Manifest
originalManifest
;
private
FilesetManifestConfig
filesetManifestConfig
;
private
boolean
mergeManifestsMain
=
true
;
private
Manifest
manifest
;
private
String
manifestEncoding
;
private
File
manifestFile
;
private
boolean
index
=
false
;
private
boolean
createEmpty
=
false
;
private
Vector
rootEntries
;
private
Path
indexJars
;
private
static
final
ZipExtraField
[
]
JAR_MARKER
=
new
ZipExtraField
[
]
{
JarMarker
.
getInstance
(
)
}
;
protected
String
emptyBehavior
=
"create"
;
public
Jar
(
)
{
super
(
)
;
archiveType
=
"jar"
;
emptyBehavior
=
"create"
;
setEncoding
(
"UTF8"
)
;
rootEntries
=
new
Vector
(
)
;
}
public
void
setWhenempty
(
WhenEmpty
we
)
{
log
(
"JARs are never empty, they contain at least a manifest file"
,
Project
.
MSG_WARN
)
;
}
public
void
setWhenmanifestonly
(
WhenEmpty
we
)
{
emptyBehavior
=
we
.
getValue
(
)
;
}
public
void
setJarfile
(
File
jarFile
)
{
setDestFile
(
jarFile
)
;
}
public
void
setIndex
(
boolean
flag
)
{
index
=
flag
;
}
public
void
setManifestEncoding
(
String
manifestEncoding
)
{
this
.
manifestEncoding
=
manifestEncoding
;
}
public
void
addConfiguredManifest
(
Manifest
newManifest
)
throws
ManifestException
{
if
(
configuredManifest
==
null
)
{
configuredManifest
=
newManifest
;
}
else
{
configuredManifest
.
merge
(
newManifest
)
;
}
savedConfiguredManifest
=
configuredManifest
;
}
public
void
setManifest
(
File
manifestFile
)
{
if
(
!
manifestFile
.
exists
(
)
)
{
throw
new
BuildException
(
"Manifest file: "
+
manifestFile
+
" does not exist."
,
getLocation
(
)
)
;
}
this
.
manifestFile
=
manifestFile
;
}
private
Manifest
getManifest
(
File
manifestFile
)
{
Manifest
newManifest
=
null
;
FileInputStream
fis
=
null
;
InputStreamReader
isr
=
null
;
try
{
fis
=
new
FileInputStream
(
manifestFile
)
;
if
(
manifestEncoding
==
null
)
{
isr
=
new
InputStreamReader
(
fis
)
;
}
else
{
isr
=
new
InputStreamReader
(
fis
,
manifestEncoding
)
;
}
newManifest
=
getManifest
(
isr
)
;
}
catch
(
UnsupportedEncodingException
e
)
{
throw
new
BuildException
(
"Unsupported encoding while reading manifest: "
+
e
.
getMessage
(
)
,
e
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
"Unable to read manifest file: "
+
manifestFile
+
" ("
+
e
.
getMessage
(
)
+
")"
,
e
)
;
}
finally
{
if
(
isr
!=
null
)
{
try
{
isr
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
}
return
newManifest
;
}
private
Manifest
getManifestFromJar
(
File
jarFile
)
throws
IOException
{
ZipFile
zf
=
null
;
try
{
zf
=
new
ZipFile
(
jarFile
)
;
Enumeration
e
=
zf
.
entries
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
ZipEntry
ze
=
(
ZipEntry
)
e
.
nextElement
(
)
;
if
(
ze
.
getName
(
)
.
equalsIgnoreCase
(
MANIFEST_NAME
)
)
{
InputStreamReader
isr
=
new
InputStreamReader
(
zf
.
getInputStream
(
ze
)
,
"UTF-8"
)
;
return
getManifest
(
isr
)
;
}
}
return
null
;
}
finally
{
if
(
zf
!=
null
)
{
try
{
zf
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
}
}
private
Manifest
getManifest
(
Reader
r
)
{
Manifest
newManifest
=
null
;
try
{
newManifest
=
new
Manifest
(
r
)
;
}
catch
(
ManifestException
e
)
{
log
(
"Manifest is invalid: "
+
e
.
getMessage
(
)
,
Project
.
MSG_ERR
)
;
throw
new
BuildException
(
"Invalid Manifest: "
+
manifestFile
,
e
,
getLocation
(
)
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
"Unable to read manifest file"
+
" ("
+
e
.
getMessage
(
)
+
")"
,
e
)
;
}
return
newManifest
;
}
public
void
setFilesetmanifest
(
FilesetManifestConfig
config
)
{
filesetManifestConfig
=
config
;
mergeManifestsMain
=
"merge"
.
equals
(
config
.
getValue
(
)
)
;
if
(
filesetManifestConfig
!=
null
&&
!
filesetManifestConfig
.
getValue
(
)
.
equals
(
"skip"
)
)
{
doubleFilePass
=
true
;
}
}
public
void
addMetainf
(
ZipFileSet
fs
)
{
fs
.
setPrefix
(
"META-INF/"
)
;
super
.
addFileset
(
fs
)
;
}
public
void
addConfiguredIndexJars
(
Path
p
)
{
if
(
indexJars
==
null
)
{
indexJars
=
new
Path
(
getProject
(
)
)
;
}
indexJars
.
append
(
p
)
;
}
public
void
addConfiguredService
(
Service
service
)
{
service
.
check
(
)
;
serviceList
.
add
(
service
)
;
}
private
void
writeServices
(
ZipOutputStream
zOut
)
throws
IOException
{
Iterator
serviceIterator
;
Service
service
;
serviceIterator
=
serviceList
.
iterator
(
)
;
while
(
serviceIterator
.
hasNext
(
)
)
{
service
=
(
Service
)
serviceIterator
.
next
(
)
;
super
.
zipFile
(
service
.
getAsStream
(
)
,
zOut
,
"META-INF/service/"
+
service
.
getType
(
)
,
System
.
currentTimeMillis
(
)
,
null
,
ZipFileSet
.
DEFAULT_FILE_MODE
)
;
}
}
protected
void
initZipOutputStream
(
ZipOutputStream
zOut
)
throws
IOException
,
BuildException
{
if
(
!
skipWriting
)
{
Manifest
jarManifest
=
createManifest
(
)
;
writeManifest
(
zOut
,
jarManifest
)
;
writeServices
(
zOut
)
;
}
}
private
Manifest
createManifest
(
)
throws
BuildException
{
try
{
Manifest
finalManifest
=
Manifest
.
getDefaultManifest
(
)
;
if
(
manifest
==
null
)
{
if
(
manifestFile
!=
null
)
{
manifest
=
getManifest
(
manifestFile
)
;
}
}
if
(
isInUpdateMode
(
)
)
{
finalManifest
.
merge
(
originalManifest
)
;
}
finalManifest
.
merge
(
filesetManifest
)
;
finalManifest
.
merge
(
configuredManifest
)
;
finalManifest
.
merge
(
manifest
,
!
mergeManifestsMain
)
;
return
finalManifest
;
}
catch
(
ManifestException
e
)
{
log
(
"Manifest is invalid: "
+
e
.
getMessage
(
)
,
Project
.
MSG_ERR
)
;
throw
new
BuildException
(
"Invalid Manifest"
,
e
,
getLocation
(
)
)
;
}
}
private
void
writeManifest
(
ZipOutputStream
zOut
,
Manifest
manifest
)
throws
IOException
{
for
(
Enumeration
e
=
manifest
.
getWarnings
(
)
;
e
.
hasMoreElements
(
)
;
)
{
log
(
"Manifest warning: "
+
(
String
)
e
.
nextElement
(
)
,
Project
.
MSG_WARN
)
;
}
zipDir
(
null
,
zOut
,
"META-INF/"
,
ZipFileSet
.
DEFAULT_DIR_MODE
,
JAR_MARKER
)
;
ByteArrayOutputStream
baos
=
new
ByteArrayOutputStream
(
)
;
OutputStreamWriter
osw
=
new
OutputStreamWriter
(
baos
,
Manifest
.
JAR_ENCODING
)
;
PrintWriter
writer
=
new
PrintWriter
(
osw
)
;
manifest
.
write
(
writer
)
;
writer
.
flush
(
)
;
ByteArrayInputStream
bais
=
new
ByteArrayInputStream
(
baos
.
toByteArray
(
)
)
;
super
.
zipFile
(
bais
,
zOut
,
MANIFEST_NAME
,
System
.
currentTimeMillis
(
)
,
null
,
ZipFileSet
.
DEFAULT_FILE_MODE
)
;
super
.
initZipOutputStream
(
zOut
)
;
}
protected
void
finalizeZipOutputStream
(
ZipOutputStream
zOut
)
throws
IOException
,
BuildException
{
if
(
index
)
{
createIndexList
(
zOut
)
;
}
}
private
void
createIndexList
(
ZipOutputStream
zOut
)
throws
IOException
{
ByteArrayOutputStream
baos
=
new
ByteArrayOutputStream
(
)
;
PrintWriter
writer
=
new
PrintWriter
(
new
OutputStreamWriter
(
baos
,
"UTF8"
)
)
;
writer
.
println
(
"JarIndex-Version: 1.0"
)
;
writer
.
println
(
)
;
writer
.
println
(
zipFile
.
getName
(
)
)
;
writeIndexLikeList
(
new
ArrayList
(
addedDirs
.
keySet
(
)
)
,
rootEntries
,
writer
)
;
writer
.
println
(
)
;
if
(
indexJars
!=
null
)
{
Manifest
mf
=
createManifest
(
)
;
Manifest
.
Attribute
classpath
=
mf
.
getMainSection
(
)
.
getAttribute
(
Manifest
.
ATTRIBUTE_CLASSPATH
)
;
String
[
]
cpEntries
=
null
;
if
(
classpath
!=
null
&&
classpath
.
getValue
(
)
!=
null
)
{
StringTokenizer
tok
=
new
StringTokenizer
(
classpath
.
getValue
(
)
,
" "
)
;
cpEntries
=
new
String
[
tok
.
countTokens
(
)
]
;
int
c
=
0
;
while
(
tok
.
hasMoreTokens
(
)
)
{
cpEntries
[
c
++
]
=
tok
.
nextToken
(
)
;
}
}
String
[
]
indexJarEntries
=
indexJars
.
list
(
)
;
for
(
int
i
=
0
;
i
<
indexJarEntries
.
length
;
i
++
)
{
String
name
=
findJarName
(
indexJarEntries
[
i
]
,
cpEntries
)
;
if
(
name
!=
null
)
{
ArrayList
dirs
=
new
ArrayList
(
)
;
ArrayList
files
=
new
ArrayList
(
)
;
grabFilesAndDirs
(
indexJarEntries
[
i
]
,
dirs
,
files
)
;
if
(
dirs
.
size
(
)
+
files
.
size
(
)
>
0
)
{
writer
.
println
(
name
)
;
writeIndexLikeList
(
dirs
,
files
,
writer
)
;
writer
.
println
(
)
;
}
}
}
}
writer
.
flush
(
)
;
ByteArrayInputStream
bais
=
new
ByteArrayInputStream
(
baos
.
toByteArray
(
)
)
;
super
.
zipFile
(
bais
,
zOut
,
INDEX_NAME
,
System
.
currentTimeMillis
(
)
,
null
,
ZipFileSet
.
DEFAULT_FILE_MODE
)
;
}
protected
void
zipFile
(
InputStream
is
,
ZipOutputStream
zOut
,
String
vPath
,
long
lastModified
,
File
fromArchive
,
int
mode
)
throws
IOException
{
if
(
MANIFEST_NAME
.
equalsIgnoreCase
(
vPath
)
)
{
if
(
!
doubleFilePass
||
(
doubleFilePass
&&
skipWriting
)
)
{
filesetManifest
(
fromArchive
,
is
)
;
}
}
else
if
(
INDEX_NAME
.
equalsIgnoreCase
(
vPath
)
&&
index
)
{
log
(
"Warning: selected "
+
archiveType
+
" files include a META-INF/INDEX.LIST which will"
+
" be replaced by a newly generated one."
,
Project
.
MSG_WARN
)
;
}
else
{
if
(
index
&&
vPath
.
indexOf
(
"/"
)
==
-
1
)
{
rootEntries
.
addElement
(
vPath
)
;
}
super
.
zipFile
(
is
,
zOut
,
vPath
,
lastModified
,
fromArchive
,
mode
)
;
}
}
private
void
filesetManifest
(
File
file
,
InputStream
is
)
throws
IOException
{
if
(
manifestFile
!=
null
&&
manifestFile
.
equals
(
file
)
)
{
log
(
"Found manifest "
+
file
,
Project
.
MSG_VERBOSE
)
;
try
{
if
(
is
!=
null
)
{
InputStreamReader
isr
;
if
(
manifestEncoding
==
null
)
{
isr
=
new
InputStreamReader
(
is
)
;
}
else
{
isr
=
new
InputStreamReader
(
is
,
manifestEncoding
)
;
}
manifest
=
getManifest
(
isr
)
;
}
else
{
manifest
=
getManifest
(
file
)
;
}
}
catch
(
UnsupportedEncodingException
e
)
{
throw
new
BuildException
(
"Unsupported encoding while reading "
+
"manifest: "
+
e
.
getMessage
(
)
,
e
)
;
}
}
else
if
(
filesetManifestConfig
!=
null
&&
!
filesetManifestConfig
.
getValue
(
)
.
equals
(
"skip"
)
)
{
log
(
"Found manifest to merge in file "
+
file
,
Project
.
MSG_VERBOSE
)
;
try
{
Manifest
newManifest
=
null
;
if
(
is
!=
null
)
{
InputStreamReader
isr
;
if
(
manifestEncoding
==
null
)
{
isr
=
new
InputStreamReader
(
is
)
;
}
else
{
isr
=
new
InputStreamReader
(
is
,
manifestEncoding
)
;
}
newManifest
=
getManifest
(
isr
)
;
}
else
{
newManifest
=
getManifest
(
file
)
;
}
if
(
filesetManifest
==
null
)
{
filesetManifest
=
newManifest
;
}
else
{
filesetManifest
.
merge
(
newManifest
)
;
}
}
catch
(
UnsupportedEncodingException
e
)
{
throw
new
BuildException
(
"Unsupported encoding while reading "
+
"manifest: "
+
e
.
getMessage
(
)
,
e
)
;
}
catch
(
ManifestException
e
)
{
log
(
"Manifest in file "
+
file
+
" is invalid: "
+
e
.
getMessage
(
)
,
Project
.
MSG_ERR
)
;
throw
new
BuildException
(
"Invalid Manifest"
,
e
,
getLocation
(
)
)
;
}
}
else
{
}
}
protected
ArchiveState
getResourcesToAdd
(
ResourceCollection
[
]
rcs
,
File
zipFile
,
boolean
needsUpdate
)
throws
BuildException
{
if
(
zipFile
.
exists
(
)
)
{
try
{
originalManifest
=
getManifestFromJar
(
zipFile
)
;
if
(
originalManifest
==
null
)
{
log
(
"Updating jar since the current jar has no manifest"
,
Project
.
MSG_VERBOSE
)
;
needsUpdate
=
true
;
}
else
{
Manifest
mf
=
createManifest
(
)
;
if
(
!
mf
.
equals
(
originalManifest
)
)
{
log
(
"Updating jar since jar manifest has changed"
,
Project
.
MSG_VERBOSE
)
;
needsUpdate
=
true
;
}
}
}
catch
(
Throwable
t
)
{
log
(
"error while reading original manifest in file: "
+
zipFile
.
toString
(
)
+
t
.
getMessage
(
)
,
Project
.
MSG_WARN
)
;
needsUpdate
=
true
;
}
}
else
{
needsUpdate
=
true
;
}
createEmpty
=
needsUpdate
;
return
super
.
getResourcesToAdd
(
rcs
,
zipFile
,
needsUpdate
)
;
}
protected
boolean
createEmptyZip
(
File
zipFile
)
throws
BuildException
{
if
(
!
createEmpty
)
{
return
true
;
}
if
(
emptyBehavior
.
equals
(
"skip"
)
)
{
log
(
"Warning: skipping "
+
archiveType
+
" archive "
+
zipFile
+
" because no files were included."
,
Project
.
MSG_WARN
)
;
return
true
;
}
else
if
(
emptyBehavior
.
equals
(
"fail"
)
)
{
throw
new
BuildException
(
"Cannot create "
+
archiveType
+
" archive "
+
zipFile
+
": no files were included."
,
getLocation
(
)
)
;
}
ZipOutputStream
zOut
=
null
;
try
{
log
(
"Building MANIFEST-only jar: "
+
getDestFile
(
)
.
getAbsolutePath
(
)
)
;
zOut
=
new
ZipOutputStream
(
new
FileOutputStream
(
getDestFile
(
)
)
)
;
zOut
.
setEncoding
(
getEncoding
(
)
)
;
if
(
isCompress
(
)
)
{
zOut
.
setMethod
(
ZipOutputStream
.
DEFLATED
)
;
}
else
{
zOut
.
setMethod
(
ZipOutputStream
.
STORED
)
;
}
initZipOutputStream
(
zOut
)
;
finalizeZipOutputStream
(
zOut
)
;
}
catch
(
IOException
ioe
)
{
throw
new
BuildException
(
"Could not create almost empty JAR archive"
+
" ("
+
ioe
.
getMessage
(
)
+
")"
,
ioe
,
getLocation
(
)
)
;
}
finally
{
try
{
if
(
zOut
!=
null
)
{
zOut
.
close
(
)
;
}
}
catch
(
IOException
ex
)
{
}
createEmpty
=
false
;
}
return
true
;
}
protected
void
cleanUp
(
)
{
super
.
cleanUp
(
)
;
if
(
!
doubleFilePass
||
(
doubleFilePass
&&
!
skipWriting
)
)
{
manifest
=
null
;
configuredManifest
=
savedConfiguredManifest
;
filesetManifest
=
null
;
originalManifest
=
null
;
}
rootEntries
.
removeAllElements
(
)
;
}
public
void
reset
(
)
{
super
.
reset
(
)
;
emptyBehavior
=
"create"
;
configuredManifest
=
null
;
filesetManifestConfig
=
null
;
mergeManifestsMain
=
false
;
manifestFile
=
null
;
index
=
false
;
}
public
static
class
FilesetManifestConfig
extends
EnumeratedAttribute
{
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
"skip"
,
"merge"
,
"mergewithoutmain"
}
;
}
}
protected
final
void
writeIndexLikeList
(
List
dirs
,
List
files
,
PrintWriter
writer
)
throws
IOException
{
Collections
.
sort
(
dirs
)
;
Collections
.
sort
(
files
)
;
Iterator
iter
=
dirs
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
String
dir
=
(
String
)
iter
.
next
(
)
;
dir
=
dir
.
replace
(
'\\'
,
'/'
)
;
if
(
dir
.
startsWith
(
"./"
)
)
{
dir
=
dir
.
substring
(
2
)
;
}
while
(
dir
.
startsWith
(
"/"
)
)
{
dir
=
dir
.
substring
(
1
)
;
}
int
pos
=
dir
.
lastIndexOf
(
'/'
)
;
if
(
pos
!=
-
1
)
{
dir
=
dir
.
substring
(
0
,
pos
)
;
}
if
(
dir
.
startsWith
(
"META-INF"
)
)
{
continue
;
}
writer
.
println
(
dir
)
;
}
iter
=
files
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
writer
.
println
(
iter
.
next
(
)
)
;
}
}
protected
static
final
String
findJarName
(
String
fileName
,
String
[
]
classpath
)
{
if
(
classpath
==
null
)
{
return
(
new
File
(
fileName
)
)
.
getName
(
)
;
}
fileName
=
fileName
.
replace
(
File
.
separatorChar
,
'/'
)
;
TreeMap
matches
=
new
TreeMap
(
new
Comparator
(
)
{
public
int
compare
(
Object
o1
,
Object
o2
)
{
if
(
o1
instanceof
String
&&
o2
instanceof
String
)
{
return
(
(
String
)
o2
)
.
length
(
)
-
(
(
String
)
o1
)
.
length
(
)
;
}
return
0
;
}
}
)
;
for
(
int
i
=
0
;
i
<
classpath
.
length
;
i
++
)
{
if
(
fileName
.
endsWith
(
classpath
[
i
]
)
)
{
matches
.
put
(
classpath
[
i
]
,
classpath
[
i
]
)
;
}
else
{
int
slash
=
classpath
[
i
]
.
indexOf
(
"/"
)
;
String
candidate
=
classpath
[
i
]
;
while
(
slash
>
-
1
)
{
candidate
=
candidate
.
substring
(
slash
+
1
)
;
if
(
fileName
.
endsWith
(
candidate
)
)
{
matches
.
put
(
candidate
,
classpath
[
i
]
)
;
break
;
}
slash
=
candidate
.
indexOf
(
"/"
)
;
}
}
}
return
matches
.
size
(
)
==
0
?
null
:
(
String
)
matches
.
get
(
matches
.
firstKey
(
)
)
;
}
protected
static
final
void
grabFilesAndDirs
(
String
file
,
List
dirs
,
List
files
)
throws
IOException
{
org
.
apache
.
tools
.
zip
.
ZipFile
zf
=
null
;
try
{
zf
=
new
org
.
apache
.
tools
.
zip
.
ZipFile
(
file
,
"utf-8"
)
;
Enumeration
entries
=
zf
.
getEntries
(
)
;
HashSet
dirSet
=
new
HashSet
(
)
;
while
(
entries
.
hasMoreElements
(
)
)
{
org
.
apache
.
tools
.
zip
.
ZipEntry
ze
=
(
org
.
apache
.
tools
.
zip
.
ZipEntry
)
entries
.
nextElement
(
)
;
String
name
=
ze
.
getName
(
)
;
if
(
!
name
.
startsWith
(
"META-INF/"
)
)
{
if
(
ze
.
isDirectory
(
)
)
{
dirSet
.
add
(
name
)
;
}
else
if
(
name
.
indexOf
(
"/"
)
==
-
1
)
{
files
.
add
(
name
)
;
}
else
{
dirSet
.
add
(
name
.
substring
(
0
,
name
.
lastIndexOf
(
"/"
)
+
1
)
)
;
}
}
}
dirs
.
addAll
(
dirSet
)
;
}
finally
{
if
(
zf
!=
null
)
{
zf
.
close
(
)
;
}
}
}
}
