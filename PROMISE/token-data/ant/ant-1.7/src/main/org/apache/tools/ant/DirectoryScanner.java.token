package
org
.
apache
.
tools
.
ant
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
condition
.
Os
;
import
org
.
apache
.
tools
.
ant
.
types
.
Resource
;
import
org
.
apache
.
tools
.
ant
.
types
.
ResourceFactory
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
FileResource
;
import
org
.
apache
.
tools
.
ant
.
types
.
selectors
.
FileSelector
;
import
org
.
apache
.
tools
.
ant
.
types
.
selectors
.
SelectorScanner
;
import
org
.
apache
.
tools
.
ant
.
types
.
selectors
.
SelectorUtils
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
public
class
DirectoryScanner
implements
FileScanner
,
SelectorScanner
,
ResourceFactory
{
private
static
final
boolean
ON_VMS
=
Os
.
isFamily
(
"openvms"
)
;
protected
static
final
String
[
]
DEFAULTEXCLUDES
=
{
"**/*~"
,
"**/#*#"
,
"**/.#*"
,
"**/%*%"
,
"**/._*"
,
"**/CVS"
,
"**/CVS/**"
,
"**/.cvsignore"
,
"**/SCCS"
,
"**/SCCS/**"
,
"**/vssver.scc"
,
"**/.svn"
,
"**/.svn/**"
,
"**/.DS_Store"
}
;
private
static
final
FileUtils
FILE_UTILS
=
FileUtils
.
getFileUtils
(
)
;
private
static
final
boolean
[
]
CS_SCAN_ONLY
=
new
boolean
[
]
{
true
}
;
private
static
final
boolean
[
]
CS_THEN_NON_CS
=
new
boolean
[
]
{
true
,
false
}
;
private
static
Vector
defaultExcludes
=
new
Vector
(
)
;
static
{
resetDefaultExcludes
(
)
;
}
protected
File
basedir
;
protected
String
[
]
includes
;
protected
String
[
]
excludes
;
protected
FileSelector
[
]
selectors
=
null
;
protected
Vector
filesIncluded
;
protected
Vector
filesNotIncluded
;
protected
Vector
filesExcluded
;
protected
Vector
dirsIncluded
;
protected
Vector
dirsNotIncluded
;
protected
Vector
dirsExcluded
;
protected
Vector
filesDeselected
;
protected
Vector
dirsDeselected
;
protected
boolean
haveSlowResults
=
false
;
protected
boolean
isCaseSensitive
=
true
;
private
boolean
followSymlinks
=
true
;
protected
boolean
everythingIncluded
=
true
;
private
Map
fileListMap
=
new
HashMap
(
)
;
private
Set
scannedDirs
=
new
HashSet
(
)
;
private
Set
includeNonPatterns
=
new
HashSet
(
)
;
private
Set
excludeNonPatterns
=
new
HashSet
(
)
;
private
String
[
]
includePatterns
;
private
String
[
]
excludePatterns
;
private
boolean
areNonPatternSetsReady
=
false
;
private
boolean
scanning
=
false
;
private
Object
scanLock
=
new
Object
(
)
;
private
boolean
slowScanning
=
false
;
private
Object
slowScanLock
=
new
Object
(
)
;
private
IllegalStateException
illegal
=
null
;
public
DirectoryScanner
(
)
{
}
protected
static
boolean
matchPatternStart
(
String
pattern
,
String
str
)
{
return
SelectorUtils
.
matchPatternStart
(
pattern
,
str
)
;
}
protected
static
boolean
matchPatternStart
(
String
pattern
,
String
str
,
boolean
isCaseSensitive
)
{
return
SelectorUtils
.
matchPatternStart
(
pattern
,
str
,
isCaseSensitive
)
;
}
protected
static
boolean
matchPath
(
String
pattern
,
String
str
)
{
return
SelectorUtils
.
matchPath
(
pattern
,
str
)
;
}
protected
static
boolean
matchPath
(
String
pattern
,
String
str
,
boolean
isCaseSensitive
)
{
return
SelectorUtils
.
matchPath
(
pattern
,
str
,
isCaseSensitive
)
;
}
public
static
boolean
match
(
String
pattern
,
String
str
)
{
return
SelectorUtils
.
match
(
pattern
,
str
)
;
}
protected
static
boolean
match
(
String
pattern
,
String
str
,
boolean
isCaseSensitive
)
{
return
SelectorUtils
.
match
(
pattern
,
str
,
isCaseSensitive
)
;
}
public
static
String
[
]
getDefaultExcludes
(
)
{
return
(
String
[
]
)
defaultExcludes
.
toArray
(
new
String
[
defaultExcludes
.
size
(
)
]
)
;
}
public
static
boolean
addDefaultExclude
(
String
s
)
{
if
(
defaultExcludes
.
indexOf
(
s
)
==
-
1
)
{
defaultExcludes
.
add
(
s
)
;
return
true
;
}
return
false
;
}
public
static
boolean
removeDefaultExclude
(
String
s
)
{
return
defaultExcludes
.
remove
(
s
)
;
}
public
static
void
resetDefaultExcludes
(
)
{
defaultExcludes
=
new
Vector
(
)
;
for
(
int
i
=
0
;
i
<
DEFAULTEXCLUDES
.
length
;
i
++
)
{
defaultExcludes
.
add
(
DEFAULTEXCLUDES
[
i
]
)
;
}
}
public
void
setBasedir
(
String
basedir
)
{
setBasedir
(
basedir
==
null
?
(
File
)
null
:
new
File
(
basedir
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
)
)
;
}
public
synchronized
void
setBasedir
(
File
basedir
)
{
this
.
basedir
=
basedir
;
}
public
synchronized
File
getBasedir
(
)
{
return
basedir
;
}
public
synchronized
boolean
isCaseSensitive
(
)
{
return
isCaseSensitive
;
}
public
synchronized
void
setCaseSensitive
(
boolean
isCaseSensitive
)
{
this
.
isCaseSensitive
=
isCaseSensitive
;
}
public
synchronized
boolean
isFollowSymlinks
(
)
{
return
followSymlinks
;
}
public
synchronized
void
setFollowSymlinks
(
boolean
followSymlinks
)
{
this
.
followSymlinks
=
followSymlinks
;
}
public
synchronized
void
setIncludes
(
String
[
]
includes
)
{
if
(
includes
==
null
)
{
this
.
includes
=
null
;
}
else
{
this
.
includes
=
new
String
[
includes
.
length
]
;
for
(
int
i
=
0
;
i
<
includes
.
length
;
i
++
)
{
this
.
includes
[
i
]
=
normalizePattern
(
includes
[
i
]
)
;
}
}
}
public
synchronized
void
setExcludes
(
String
[
]
excludes
)
{
if
(
excludes
==
null
)
{
this
.
excludes
=
null
;
}
else
{
this
.
excludes
=
new
String
[
excludes
.
length
]
;
for
(
int
i
=
0
;
i
<
excludes
.
length
;
i
++
)
{
this
.
excludes
[
i
]
=
normalizePattern
(
excludes
[
i
]
)
;
}
}
}
public
synchronized
void
addExcludes
(
String
[
]
excludes
)
{
if
(
excludes
!=
null
&&
excludes
.
length
>
0
)
{
if
(
this
.
excludes
!=
null
&&
this
.
excludes
.
length
>
0
)
{
String
[
]
tmp
=
new
String
[
excludes
.
length
+
this
.
excludes
.
length
]
;
System
.
arraycopy
(
this
.
excludes
,
0
,
tmp
,
0
,
this
.
excludes
.
length
)
;
for
(
int
i
=
0
;
i
<
excludes
.
length
;
i
++
)
{
tmp
[
this
.
excludes
.
length
+
i
]
=
normalizePattern
(
excludes
[
i
]
)
;
}
this
.
excludes
=
tmp
;
}
else
{
setExcludes
(
excludes
)
;
}
}
}
private
static
String
normalizePattern
(
String
p
)
{
String
pattern
=
p
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
if
(
pattern
.
endsWith
(
File
.
separator
)
)
{
pattern
+=
"**"
;
}
return
pattern
;
}
public
synchronized
void
setSelectors
(
FileSelector
[
]
selectors
)
{
this
.
selectors
=
selectors
;
}
public
synchronized
boolean
isEverythingIncluded
(
)
{
return
everythingIncluded
;
}
public
void
scan
(
)
throws
IllegalStateException
{
synchronized
(
scanLock
)
{
if
(
scanning
)
{
while
(
scanning
)
{
try
{
scanLock
.
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
continue
;
}
}
if
(
illegal
!=
null
)
{
throw
illegal
;
}
return
;
}
scanning
=
true
;
}
try
{
synchronized
(
this
)
{
illegal
=
null
;
clearResults
(
)
;
boolean
nullIncludes
=
(
includes
==
null
)
;
includes
=
nullIncludes
?
new
String
[
]
{
"**"
}
:
includes
;
boolean
nullExcludes
=
(
excludes
==
null
)
;
excludes
=
nullExcludes
?
new
String
[
0
]
:
excludes
;
if
(
basedir
==
null
)
{
if
(
nullIncludes
)
{
return
;
}
}
else
{
if
(
!
basedir
.
exists
(
)
)
{
illegal
=
new
IllegalStateException
(
"basedir "
+
basedir
+
" does not exist"
)
;
}
if
(
!
basedir
.
isDirectory
(
)
)
{
illegal
=
new
IllegalStateException
(
"basedir "
+
basedir
+
" is not a directory"
)
;
}
if
(
illegal
!=
null
)
{
throw
illegal
;
}
}
if
(
isIncluded
(
""
)
)
{
if
(
!
isExcluded
(
""
)
)
{
if
(
isSelected
(
""
,
basedir
)
)
{
dirsIncluded
.
addElement
(
""
)
;
}
else
{
dirsDeselected
.
addElement
(
""
)
;
}
}
else
{
dirsExcluded
.
addElement
(
""
)
;
}
}
else
{
dirsNotIncluded
.
addElement
(
""
)
;
}
checkIncludePatterns
(
)
;
clearCaches
(
)
;
includes
=
nullIncludes
?
null
:
includes
;
excludes
=
nullExcludes
?
null
:
excludes
;
}
}
finally
{
synchronized
(
scanLock
)
{
scanning
=
false
;
scanLock
.
notifyAll
(
)
;
}
}
}
private
void
checkIncludePatterns
(
)
{
Map
newroots
=
new
HashMap
(
)
;
for
(
int
i
=
0
;
i
<
includes
.
length
;
i
++
)
{
if
(
FileUtils
.
isAbsolutePath
(
includes
[
i
]
)
)
{
if
(
basedir
!=
null
&&
!
SelectorUtils
.
matchPatternStart
(
includes
[
i
]
,
basedir
.
getAbsolutePath
(
)
,
isCaseSensitive
(
)
)
)
{
continue
;
}
}
else
if
(
basedir
==
null
)
{
continue
;
}
newroots
.
put
(
SelectorUtils
.
rtrimWildcardTokens
(
includes
[
i
]
)
,
includes
[
i
]
)
;
}
if
(
newroots
.
containsKey
(
""
)
&&
basedir
!=
null
)
{
scandir
(
basedir
,
""
,
true
)
;
}
else
{
Iterator
it
=
newroots
.
entrySet
(
)
.
iterator
(
)
;
File
canonBase
=
null
;
if
(
basedir
!=
null
)
{
try
{
canonBase
=
basedir
.
getCanonicalFile
(
)
;
}
catch
(
IOException
ex
)
{
throw
new
BuildException
(
ex
)
;
}
}
while
(
it
.
hasNext
(
)
)
{
Map
.
Entry
entry
=
(
Map
.
Entry
)
it
.
next
(
)
;
String
currentelement
=
(
String
)
entry
.
getKey
(
)
;
if
(
basedir
==
null
&&
!
FileUtils
.
isAbsolutePath
(
currentelement
)
)
{
continue
;
}
String
originalpattern
=
(
String
)
entry
.
getValue
(
)
;
File
myfile
=
new
File
(
basedir
,
currentelement
)
;
if
(
myfile
.
exists
(
)
)
{
try
{
String
path
=
(
basedir
==
null
)
?
myfile
.
getCanonicalPath
(
)
:
FILE_UTILS
.
removeLeadingPath
(
canonBase
,
myfile
.
getCanonicalFile
(
)
)
;
if
(
!
path
.
equals
(
currentelement
)
||
ON_VMS
)
{
myfile
=
findFile
(
basedir
,
currentelement
,
true
)
;
if
(
myfile
!=
null
&&
basedir
!=
null
)
{
currentelement
=
FILE_UTILS
.
removeLeadingPath
(
basedir
,
myfile
)
;
}
}
}
catch
(
IOException
ex
)
{
throw
new
BuildException
(
ex
)
;
}
}
if
(
(
myfile
==
null
||
!
myfile
.
exists
(
)
)
&&
!
isCaseSensitive
(
)
)
{
File
f
=
findFile
(
basedir
,
currentelement
,
false
)
;
if
(
f
!=
null
&&
f
.
exists
(
)
)
{
currentelement
=
(
basedir
==
null
)
?
f
.
getAbsolutePath
(
)
:
FILE_UTILS
.
removeLeadingPath
(
basedir
,
f
)
;
myfile
=
f
;
}
}
if
(
myfile
!=
null
&&
myfile
.
exists
(
)
)
{
if
(
!
followSymlinks
&&
isSymlink
(
basedir
,
currentelement
)
)
{
continue
;
}
if
(
myfile
.
isDirectory
(
)
)
{
if
(
isIncluded
(
currentelement
)
&&
currentelement
.
length
(
)
>
0
)
{
accountForIncludedDir
(
currentelement
,
myfile
,
true
)
;
}
else
{
if
(
currentelement
.
length
(
)
>
0
)
{
if
(
currentelement
.
charAt
(
currentelement
.
length
(
)
-
1
)
!=
File
.
separatorChar
)
{
currentelement
=
currentelement
+
File
.
separatorChar
;
}
}
scandir
(
myfile
,
currentelement
,
true
)
;
}
}
else
{
boolean
included
=
isCaseSensitive
(
)
?
originalpattern
.
equals
(
currentelement
)
:
originalpattern
.
equalsIgnoreCase
(
currentelement
)
;
if
(
included
)
{
accountForIncludedFile
(
currentelement
,
myfile
)
;
}
}
}
}
}
}
protected
synchronized
void
clearResults
(
)
{
filesIncluded
=
new
Vector
(
)
;
filesNotIncluded
=
new
Vector
(
)
;
filesExcluded
=
new
Vector
(
)
;
filesDeselected
=
new
Vector
(
)
;
dirsIncluded
=
new
Vector
(
)
;
dirsNotIncluded
=
new
Vector
(
)
;
dirsExcluded
=
new
Vector
(
)
;
dirsDeselected
=
new
Vector
(
)
;
everythingIncluded
=
(
basedir
!=
null
)
;
scannedDirs
.
clear
(
)
;
}
protected
void
slowScan
(
)
{
synchronized
(
slowScanLock
)
{
if
(
haveSlowResults
)
{
return
;
}
if
(
slowScanning
)
{
while
(
slowScanning
)
{
try
{
slowScanLock
.
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
}
}
return
;
}
slowScanning
=
true
;
}
try
{
synchronized
(
this
)
{
boolean
nullIncludes
=
(
includes
==
null
)
;
includes
=
nullIncludes
?
new
String
[
]
{
"**"
}
:
includes
;
boolean
nullExcludes
=
(
excludes
==
null
)
;
excludes
=
nullExcludes
?
new
String
[
0
]
:
excludes
;
String
[
]
excl
=
new
String
[
dirsExcluded
.
size
(
)
]
;
dirsExcluded
.
copyInto
(
excl
)
;
String
[
]
notIncl
=
new
String
[
dirsNotIncluded
.
size
(
)
]
;
dirsNotIncluded
.
copyInto
(
notIncl
)
;
processSlowScan
(
excl
)
;
processSlowScan
(
notIncl
)
;
clearCaches
(
)
;
includes
=
nullIncludes
?
null
:
includes
;
excludes
=
nullExcludes
?
null
:
excludes
;
}
}
finally
{
synchronized
(
slowScanLock
)
{
haveSlowResults
=
true
;
slowScanning
=
false
;
slowScanLock
.
notifyAll
(
)
;
}
}
}
private
void
processSlowScan
(
String
[
]
arr
)
{
for
(
int
i
=
0
;
i
<
arr
.
length
;
i
++
)
{
if
(
!
couldHoldIncluded
(
arr
[
i
]
)
)
{
scandir
(
new
File
(
basedir
,
arr
[
i
]
)
,
arr
[
i
]
+
File
.
separator
,
false
)
;
}
}
}
protected
void
scandir
(
File
dir
,
String
vpath
,
boolean
fast
)
{
if
(
dir
==
null
)
{
throw
new
BuildException
(
"dir must not be null."
)
;
}
else
if
(
!
dir
.
exists
(
)
)
{
throw
new
BuildException
(
dir
+
" doesn't exist."
)
;
}
else
if
(
!
dir
.
isDirectory
(
)
)
{
throw
new
BuildException
(
dir
+
" is not a directory."
)
;
}
if
(
fast
&&
hasBeenScanned
(
vpath
)
)
{
return
;
}
String
[
]
newfiles
=
dir
.
list
(
)
;
if
(
newfiles
==
null
)
{
throw
new
BuildException
(
"IO error scanning directory '"
+
dir
.
getAbsolutePath
(
)
+
"'"
)
;
}
if
(
!
followSymlinks
)
{
Vector
noLinks
=
new
Vector
(
)
;
for
(
int
i
=
0
;
i
<
newfiles
.
length
;
i
++
)
{
try
{
if
(
FILE_UTILS
.
isSymbolicLink
(
dir
,
newfiles
[
i
]
)
)
{
String
name
=
vpath
+
newfiles
[
i
]
;
File
file
=
new
File
(
dir
,
newfiles
[
i
]
)
;
(
file
.
isDirectory
(
)
?
dirsExcluded
:
filesExcluded
)
.
addElement
(
name
)
;
}
else
{
noLinks
.
addElement
(
newfiles
[
i
]
)
;
}
}
catch
(
IOException
ioe
)
{
String
msg
=
"IOException caught while checking "
+
"for links, couldn't get canonical path!"
;
System
.
err
.
println
(
msg
)
;
noLinks
.
addElement
(
newfiles
[
i
]
)
;
}
}
newfiles
=
(
String
[
]
)
(
noLinks
.
toArray
(
new
String
[
noLinks
.
size
(
)
]
)
)
;
}
for
(
int
i
=
0
;
i
<
newfiles
.
length
;
i
++
)
{
String
name
=
vpath
+
newfiles
[
i
]
;
File
file
=
new
File
(
dir
,
newfiles
[
i
]
)
;
if
(
file
.
isDirectory
(
)
)
{
if
(
isIncluded
(
name
)
)
{
accountForIncludedDir
(
name
,
file
,
fast
)
;
}
else
{
everythingIncluded
=
false
;
dirsNotIncluded
.
addElement
(
name
)
;
if
(
fast
&&
couldHoldIncluded
(
name
)
)
{
scandir
(
file
,
name
+
File
.
separator
,
fast
)
;
}
}
if
(
!
fast
)
{
scandir
(
file
,
name
+
File
.
separator
,
fast
)
;
}
}
else
if
(
file
.
isFile
(
)
)
{
if
(
isIncluded
(
name
)
)
{
accountForIncludedFile
(
name
,
file
)
;
}
else
{
everythingIncluded
=
false
;
filesNotIncluded
.
addElement
(
name
)
;
}
}
}
}
private
void
accountForIncludedFile
(
String
name
,
File
file
)
{
processIncluded
(
name
,
file
,
filesIncluded
,
filesExcluded
,
filesDeselected
)
;
}
private
void
accountForIncludedDir
(
String
name
,
File
file
,
boolean
fast
)
{
processIncluded
(
name
,
file
,
dirsIncluded
,
dirsExcluded
,
dirsDeselected
)
;
if
(
fast
&&
couldHoldIncluded
(
name
)
&&
!
contentsExcluded
(
name
)
)
{
scandir
(
file
,
name
+
File
.
separator
,
fast
)
;
}
}
private
void
processIncluded
(
String
name
,
File
file
,
Vector
inc
,
Vector
exc
,
Vector
des
)
{
if
(
inc
.
contains
(
name
)
||
exc
.
contains
(
name
)
||
des
.
contains
(
name
)
)
{
return
;
}
boolean
included
=
false
;
if
(
isExcluded
(
name
)
)
{
exc
.
add
(
name
)
;
}
else
if
(
isSelected
(
name
,
file
)
)
{
included
=
true
;
inc
.
add
(
name
)
;
}
else
{
des
.
add
(
name
)
;
}
everythingIncluded
&=
included
;
}
protected
boolean
isIncluded
(
String
name
)
{
ensureNonPatternSetsReady
(
)
;
if
(
isCaseSensitive
(
)
?
includeNonPatterns
.
contains
(
name
)
:
includeNonPatterns
.
contains
(
name
.
toUpperCase
(
)
)
)
{
return
true
;
}
for
(
int
i
=
0
;
i
<
includePatterns
.
length
;
i
++
)
{
if
(
matchPath
(
includePatterns
[
i
]
,
name
,
isCaseSensitive
(
)
)
)
{
return
true
;
}
}
return
false
;
}
protected
boolean
couldHoldIncluded
(
String
name
)
{
for
(
int
i
=
0
;
i
<
includes
.
length
;
i
++
)
{
if
(
matchPatternStart
(
includes
[
i
]
,
name
,
isCaseSensitive
(
)
)
&&
isMorePowerfulThanExcludes
(
name
,
includes
[
i
]
)
&&
isDeeper
(
includes
[
i
]
,
name
)
)
{
return
true
;
}
}
return
false
;
}
private
boolean
isDeeper
(
String
pattern
,
String
name
)
{
Vector
p
=
SelectorUtils
.
tokenizePath
(
pattern
)
;
Vector
n
=
SelectorUtils
.
tokenizePath
(
name
)
;
return
p
.
contains
(
"**"
)
||
p
.
size
(
)
>
n
.
size
(
)
;
}
private
boolean
isMorePowerfulThanExcludes
(
String
name
,
String
includepattern
)
{
String
soughtexclude
=
name
+
File
.
separator
+
"**"
;
for
(
int
counter
=
0
;
counter
<
excludes
.
length
;
counter
++
)
{
if
(
excludes
[
counter
]
.
equals
(
soughtexclude
)
)
{
return
false
;
}
}
return
true
;
}
private
boolean
contentsExcluded
(
String
name
)
{
name
=
(
name
.
endsWith
(
File
.
separator
)
)
?
name
:
name
+
File
.
separator
;
for
(
int
i
=
0
;
i
<
excludes
.
length
;
i
++
)
{
String
e
=
excludes
[
i
]
;
if
(
e
.
endsWith
(
"**"
)
&&
SelectorUtils
.
matchPath
(
e
.
substring
(
0
,
e
.
length
(
)
-
2
)
,
name
,
isCaseSensitive
(
)
)
)
{
return
true
;
}
}
return
false
;
}
protected
boolean
isExcluded
(
String
name
)
{
ensureNonPatternSetsReady
(
)
;
if
(
isCaseSensitive
(
)
?
excludeNonPatterns
.
contains
(
name
)
:
excludeNonPatterns
.
contains
(
name
.
toUpperCase
(
)
)
)
{
return
true
;
}
for
(
int
i
=
0
;
i
<
excludePatterns
.
length
;
i
++
)
{
if
(
matchPath
(
excludePatterns
[
i
]
,
name
,
isCaseSensitive
(
)
)
)
{
return
true
;
}
}
return
false
;
}
protected
boolean
isSelected
(
String
name
,
File
file
)
{
if
(
selectors
!=
null
)
{
for
(
int
i
=
0
;
i
<
selectors
.
length
;
i
++
)
{
if
(
!
selectors
[
i
]
.
isSelected
(
basedir
,
name
,
file
)
)
{
return
false
;
}
}
}
return
true
;
}
public
synchronized
String
[
]
getIncludedFiles
(
)
{
if
(
filesIncluded
==
null
)
{
throw
new
IllegalStateException
(
"Must call scan() first"
)
;
}
String
[
]
files
=
new
String
[
filesIncluded
.
size
(
)
]
;
filesIncluded
.
copyInto
(
files
)
;
Arrays
.
sort
(
files
)
;
return
files
;
}
public
synchronized
int
getIncludedFilesCount
(
)
{
if
(
filesIncluded
==
null
)
{
throw
new
IllegalStateException
(
"Must call scan() first"
)
;
}
return
filesIncluded
.
size
(
)
;
}
public
synchronized
String
[
]
getNotIncludedFiles
(
)
{
slowScan
(
)
;
String
[
]
files
=
new
String
[
filesNotIncluded
.
size
(
)
]
;
filesNotIncluded
.
copyInto
(
files
)
;
return
files
;
}
public
synchronized
String
[
]
getExcludedFiles
(
)
{
slowScan
(
)
;
String
[
]
files
=
new
String
[
filesExcluded
.
size
(
)
]
;
filesExcluded
.
copyInto
(
files
)
;
return
files
;
}
public
synchronized
String
[
]
getDeselectedFiles
(
)
{
slowScan
(
)
;
String
[
]
files
=
new
String
[
filesDeselected
.
size
(
)
]
;
filesDeselected
.
copyInto
(
files
)
;
return
files
;
}
public
synchronized
String
[
]
getIncludedDirectories
(
)
{
if
(
dirsIncluded
==
null
)
{
throw
new
IllegalStateException
(
"Must call scan() first"
)
;
}
String
[
]
directories
=
new
String
[
dirsIncluded
.
size
(
)
]
;
dirsIncluded
.
copyInto
(
directories
)
;
Arrays
.
sort
(
directories
)
;
return
directories
;
}
public
synchronized
int
getIncludedDirsCount
(
)
{
if
(
dirsIncluded
==
null
)
{
throw
new
IllegalStateException
(
"Must call scan() first"
)
;
}
return
dirsIncluded
.
size
(
)
;
}
public
synchronized
String
[
]
getNotIncludedDirectories
(
)
{
slowScan
(
)
;
String
[
]
directories
=
new
String
[
dirsNotIncluded
.
size
(
)
]
;
dirsNotIncluded
.
copyInto
(
directories
)
;
return
directories
;
}
public
synchronized
String
[
]
getExcludedDirectories
(
)
{
slowScan
(
)
;
String
[
]
directories
=
new
String
[
dirsExcluded
.
size
(
)
]
;
dirsExcluded
.
copyInto
(
directories
)
;
return
directories
;
}
public
synchronized
String
[
]
getDeselectedDirectories
(
)
{
slowScan
(
)
;
String
[
]
directories
=
new
String
[
dirsDeselected
.
size
(
)
]
;
dirsDeselected
.
copyInto
(
directories
)
;
return
directories
;
}
public
synchronized
void
addDefaultExcludes
(
)
{
int
excludesLength
=
excludes
==
null
?
0
:
excludes
.
length
;
String
[
]
newExcludes
;
newExcludes
=
new
String
[
excludesLength
+
defaultExcludes
.
size
(
)
]
;
if
(
excludesLength
>
0
)
{
System
.
arraycopy
(
excludes
,
0
,
newExcludes
,
0
,
excludesLength
)
;
}
String
[
]
defaultExcludesTemp
=
getDefaultExcludes
(
)
;
for
(
int
i
=
0
;
i
<
defaultExcludesTemp
.
length
;
i
++
)
{
newExcludes
[
i
+
excludesLength
]
=
defaultExcludesTemp
[
i
]
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
}
excludes
=
newExcludes
;
}
public
synchronized
Resource
getResource
(
String
name
)
{
return
new
FileResource
(
basedir
,
name
)
;
}
private
String
[
]
list
(
File
file
)
{
String
[
]
files
=
(
String
[
]
)
fileListMap
.
get
(
file
)
;
if
(
files
==
null
)
{
files
=
file
.
list
(
)
;
if
(
files
!=
null
)
{
fileListMap
.
put
(
file
,
files
)
;
}
}
return
files
;
}
private
File
findFile
(
File
base
,
String
path
,
boolean
cs
)
{
if
(
FileUtils
.
isAbsolutePath
(
path
)
)
{
if
(
base
==
null
)
{
String
[
]
s
=
FILE_UTILS
.
dissect
(
path
)
;
base
=
new
File
(
s
[
0
]
)
;
path
=
s
[
1
]
;
}
else
{
File
f
=
FILE_UTILS
.
normalize
(
path
)
;
String
s
=
FILE_UTILS
.
removeLeadingPath
(
base
,
f
)
;
if
(
s
.
equals
(
f
.
getAbsolutePath
(
)
)
)
{
return
null
;
}
path
=
s
;
}
}
return
findFile
(
base
,
SelectorUtils
.
tokenizePath
(
path
)
,
cs
)
;
}
private
File
findFile
(
File
base
,
Vector
pathElements
,
boolean
cs
)
{
if
(
pathElements
.
size
(
)
==
0
)
{
return
base
;
}
String
current
=
(
String
)
pathElements
.
remove
(
0
)
;
if
(
base
==
null
)
{
return
findFile
(
new
File
(
current
)
,
pathElements
,
cs
)
;
}
if
(
!
base
.
isDirectory
(
)
)
{
return
null
;
}
String
[
]
files
=
list
(
base
)
;
if
(
files
==
null
)
{
throw
new
BuildException
(
"IO error scanning directory "
+
base
.
getAbsolutePath
(
)
)
;
}
boolean
[
]
matchCase
=
cs
?
CS_SCAN_ONLY
:
CS_THEN_NON_CS
;
for
(
int
i
=
0
;
i
<
matchCase
.
length
;
i
++
)
{
for
(
int
j
=
0
;
j
<
files
.
length
;
j
++
)
{
if
(
matchCase
[
i
]
?
files
[
j
]
.
equals
(
current
)
:
files
[
j
]
.
equalsIgnoreCase
(
current
)
)
{
return
findFile
(
new
File
(
base
,
files
[
j
]
)
,
pathElements
,
cs
)
;
}
}
}
return
null
;
}
private
boolean
isSymlink
(
File
base
,
String
path
)
{
return
isSymlink
(
base
,
SelectorUtils
.
tokenizePath
(
path
)
)
;
}
private
boolean
isSymlink
(
File
base
,
Vector
pathElements
)
{
if
(
pathElements
.
size
(
)
>
0
)
{
String
current
=
(
String
)
pathElements
.
remove
(
0
)
;
try
{
return
FILE_UTILS
.
isSymbolicLink
(
base
,
current
)
||
isSymlink
(
new
File
(
base
,
current
)
,
pathElements
)
;
}
catch
(
IOException
ioe
)
{
String
msg
=
"IOException caught while checking "
+
"for links, couldn't get canonical path!"
;
System
.
err
.
println
(
msg
)
;
}
}
return
false
;
}
private
boolean
hasBeenScanned
(
String
vpath
)
{
return
!
scannedDirs
.
add
(
vpath
)
;
}
Set
getScannedDirs
(
)
{
return
scannedDirs
;
}
private
synchronized
void
clearCaches
(
)
{
fileListMap
.
clear
(
)
;
includeNonPatterns
.
clear
(
)
;
excludeNonPatterns
.
clear
(
)
;
includePatterns
=
null
;
excludePatterns
=
null
;
areNonPatternSetsReady
=
false
;
}
private
synchronized
void
ensureNonPatternSetsReady
(
)
{
if
(
!
areNonPatternSetsReady
)
{
includePatterns
=
fillNonPatternSet
(
includeNonPatterns
,
includes
)
;
excludePatterns
=
fillNonPatternSet
(
excludeNonPatterns
,
excludes
)
;
areNonPatternSetsReady
=
true
;
}
}
private
String
[
]
fillNonPatternSet
(
Set
set
,
String
[
]
patterns
)
{
ArrayList
al
=
new
ArrayList
(
patterns
.
length
)
;
for
(
int
i
=
0
;
i
<
patterns
.
length
;
i
++
)
{
if
(
!
SelectorUtils
.
hasWildcards
(
patterns
[
i
]
)
)
{
set
.
add
(
isCaseSensitive
(
)
?
patterns
[
i
]
:
patterns
[
i
]
.
toUpperCase
(
)
)
;
}
else
{
al
.
add
(
patterns
[
i
]
)
;
}
}
return
set
.
size
(
)
==
0
?
patterns
:
(
String
[
]
)
al
.
toArray
(
new
String
[
al
.
size
(
)
]
)
;
}
}
