package
org
.
apache
.
tools
.
zip
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FilterOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
RandomAccessFile
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
util
.
Date
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Vector
;
import
java
.
util
.
zip
.
CRC32
;
import
java
.
util
.
zip
.
Deflater
;
import
java
.
util
.
zip
.
ZipException
;
public
class
ZipOutputStream
extends
FilterOutputStream
{
public
static
final
int
DEFLATED
=
java
.
util
.
zip
.
ZipEntry
.
DEFLATED
;
public
static
final
int
DEFAULT_COMPRESSION
=
Deflater
.
DEFAULT_COMPRESSION
;
public
static
final
int
STORED
=
java
.
util
.
zip
.
ZipEntry
.
STORED
;
private
ZipEntry
entry
;
private
String
comment
=
""
;
private
int
level
=
DEFAULT_COMPRESSION
;
private
boolean
hasCompressionLevelChanged
=
false
;
private
int
method
=
java
.
util
.
zip
.
ZipEntry
.
DEFLATED
;
private
Vector
entries
=
new
Vector
(
)
;
private
CRC32
crc
=
new
CRC32
(
)
;
private
long
written
=
0
;
private
long
dataStart
=
0
;
private
long
localDataStart
=
0
;
private
long
cdOffset
=
0
;
private
long
cdLength
=
0
;
private
static
final
byte
[
]
ZERO
=
{
0
,
0
}
;
private
static
final
byte
[
]
LZERO
=
{
0
,
0
,
0
,
0
}
;
private
Hashtable
offsets
=
new
Hashtable
(
)
;
private
String
encoding
=
null
;
protected
Deflater
def
=
new
Deflater
(
level
,
true
)
;
protected
byte
[
]
buf
=
new
byte
[
512
]
;
private
RandomAccessFile
raf
=
null
;
public
ZipOutputStream
(
OutputStream
out
)
{
super
(
out
)
;
}
public
ZipOutputStream
(
File
file
)
throws
IOException
{
super
(
null
)
;
try
{
raf
=
new
RandomAccessFile
(
file
,
"rw"
)
;
raf
.
setLength
(
0
)
;
}
catch
(
IOException
e
)
{
if
(
raf
!=
null
)
{
try
{
raf
.
close
(
)
;
}
catch
(
IOException
inner
)
{
}
raf
=
null
;
}
out
=
new
FileOutputStream
(
file
)
;
}
}
public
boolean
isSeekable
(
)
{
return
raf
!=
null
;
}
public
void
setEncoding
(
String
encoding
)
{
this
.
encoding
=
encoding
;
}
public
String
getEncoding
(
)
{
return
encoding
;
}
public
void
finish
(
)
throws
IOException
{
closeEntry
(
)
;
cdOffset
=
written
;
for
(
int
i
=
0
,
entriesSize
=
entries
.
size
(
)
;
i
<
entriesSize
;
i
++
)
{
writeCentralFileHeader
(
(
ZipEntry
)
entries
.
elementAt
(
i
)
)
;
}
cdLength
=
written
-
cdOffset
;
writeCentralDirectoryEnd
(
)
;
offsets
.
clear
(
)
;
entries
.
removeAllElements
(
)
;
}
public
void
closeEntry
(
)
throws
IOException
{
if
(
entry
==
null
)
{
return
;
}
long
realCrc
=
crc
.
getValue
(
)
;
crc
.
reset
(
)
;
if
(
entry
.
getMethod
(
)
==
DEFLATED
)
{
def
.
finish
(
)
;
while
(
!
def
.
finished
(
)
)
{
deflate
(
)
;
}
entry
.
setSize
(
adjustToLong
(
def
.
getTotalIn
(
)
)
)
;
entry
.
setCompressedSize
(
adjustToLong
(
def
.
getTotalOut
(
)
)
)
;
entry
.
setCrc
(
realCrc
)
;
def
.
reset
(
)
;
written
+=
entry
.
getCompressedSize
(
)
;
}
else
if
(
raf
==
null
)
{
if
(
entry
.
getCrc
(
)
!=
realCrc
)
{
throw
new
ZipException
(
"bad CRC checksum for entry "
+
entry
.
getName
(
)
+
": "
+
Long
.
toHexString
(
entry
.
getCrc
(
)
)
+
" instead of "
+
Long
.
toHexString
(
realCrc
)
)
;
}
if
(
entry
.
getSize
(
)
!=
written
-
dataStart
)
{
throw
new
ZipException
(
"bad size for entry "
+
entry
.
getName
(
)
+
": "
+
entry
.
getSize
(
)
+
" instead of "
+
(
written
-
dataStart
)
)
;
}
}
else
{
long
size
=
written
-
dataStart
;
entry
.
setSize
(
size
)
;
entry
.
setCompressedSize
(
size
)
;
entry
.
setCrc
(
realCrc
)
;
}
if
(
raf
!=
null
)
{
long
save
=
raf
.
getFilePointer
(
)
;
raf
.
seek
(
localDataStart
)
;
writeOut
(
ZipLong
.
getBytes
(
entry
.
getCrc
(
)
)
)
;
writeOut
(
ZipLong
.
getBytes
(
entry
.
getCompressedSize
(
)
)
)
;
writeOut
(
ZipLong
.
getBytes
(
entry
.
getSize
(
)
)
)
;
raf
.
seek
(
save
)
;
}
writeDataDescriptor
(
entry
)
;
entry
=
null
;
}
public
void
putNextEntry
(
ZipEntry
ze
)
throws
IOException
{
closeEntry
(
)
;
entry
=
ze
;
entries
.
addElement
(
entry
)
;
if
(
entry
.
getMethod
(
)
==
-
1
)
{
entry
.
setMethod
(
method
)
;
}
if
(
entry
.
getTime
(
)
==
-
1
)
{
entry
.
setTime
(
System
.
currentTimeMillis
(
)
)
;
}
if
(
entry
.
getMethod
(
)
==
STORED
&&
raf
==
null
)
{
if
(
entry
.
getSize
(
)
==
-
1
)
{
throw
new
ZipException
(
"uncompressed size is required for"
+
" STORED method when not writing to a"
+
" file"
)
;
}
if
(
entry
.
getCrc
(
)
==
-
1
)
{
throw
new
ZipException
(
"crc checksum is required for STORED"
+
" method when not writing to a file"
)
;
}
entry
.
setCompressedSize
(
entry
.
getSize
(
)
)
;
}
if
(
entry
.
getMethod
(
)
==
DEFLATED
&&
hasCompressionLevelChanged
)
{
def
.
setLevel
(
level
)
;
hasCompressionLevelChanged
=
false
;
}
writeLocalFileHeader
(
entry
)
;
}
public
void
setComment
(
String
comment
)
{
this
.
comment
=
comment
;
}
public
void
setLevel
(
int
level
)
{
if
(
level
<
Deflater
.
DEFAULT_COMPRESSION
||
level
>
Deflater
.
BEST_COMPRESSION
)
{
throw
new
IllegalArgumentException
(
"Invalid compression level: "
+
level
)
;
}
hasCompressionLevelChanged
=
(
this
.
level
!=
level
)
;
this
.
level
=
level
;
}
public
void
setMethod
(
int
method
)
{
this
.
method
=
method
;
}
public
void
write
(
byte
[
]
b
,
int
offset
,
int
length
)
throws
IOException
{
if
(
entry
.
getMethod
(
)
==
DEFLATED
)
{
if
(
length
>
0
)
{
if
(
!
def
.
finished
(
)
)
{
def
.
setInput
(
b
,
offset
,
length
)
;
while
(
!
def
.
needsInput
(
)
)
{
deflate
(
)
;
}
}
}
}
else
{
writeOut
(
b
,
offset
,
length
)
;
written
+=
length
;
}
crc
.
update
(
b
,
offset
,
length
)
;
}
public
void
write
(
int
b
)
throws
IOException
{
byte
[
]
buff
=
new
byte
[
1
]
;
buff
[
0
]
=
(
byte
)
(
b
&
0xff
)
;
write
(
buff
,
0
,
1
)
;
}
public
void
close
(
)
throws
IOException
{
finish
(
)
;
if
(
raf
!=
null
)
{
raf
.
close
(
)
;
}
if
(
out
!=
null
)
{
out
.
close
(
)
;
}
}
public
void
flush
(
)
throws
IOException
{
if
(
out
!=
null
)
{
out
.
flush
(
)
;
}
}
protected
static
final
byte
[
]
LFH_SIG
=
ZipLong
.
getBytes
(
0X04034B50L
)
;
protected
static
final
byte
[
]
DD_SIG
=
ZipLong
.
getBytes
(
0X08074B50L
)
;
protected
static
final
byte
[
]
CFH_SIG
=
ZipLong
.
getBytes
(
0X02014B50L
)
;
protected
static
final
byte
[
]
EOCD_SIG
=
ZipLong
.
getBytes
(
0X06054B50L
)
;
protected
final
void
deflate
(
)
throws
IOException
{
int
len
=
def
.
deflate
(
buf
,
0
,
buf
.
length
)
;
if
(
len
>
0
)
{
writeOut
(
buf
,
0
,
len
)
;
}
}
protected
void
writeLocalFileHeader
(
ZipEntry
ze
)
throws
IOException
{
offsets
.
put
(
ze
,
ZipLong
.
getBytes
(
written
)
)
;
writeOut
(
LFH_SIG
)
;
written
+=
4
;
final
int
zipMethod
=
ze
.
getMethod
(
)
;
if
(
zipMethod
==
DEFLATED
&&
raf
==
null
)
{
writeOut
(
ZipShort
.
getBytes
(
20
)
)
;
writeOut
(
ZipShort
.
getBytes
(
8
)
)
;
}
else
{
writeOut
(
ZipShort
.
getBytes
(
10
)
)
;
writeOut
(
ZERO
)
;
}
written
+=
4
;
writeOut
(
ZipShort
.
getBytes
(
zipMethod
)
)
;
written
+=
2
;
writeOut
(
toDosTime
(
ze
.
getTime
(
)
)
)
;
written
+=
4
;
localDataStart
=
written
;
if
(
zipMethod
==
DEFLATED
||
raf
!=
null
)
{
writeOut
(
LZERO
)
;
writeOut
(
LZERO
)
;
writeOut
(
LZERO
)
;
}
else
{
writeOut
(
ZipLong
.
getBytes
(
ze
.
getCrc
(
)
)
)
;
writeOut
(
ZipLong
.
getBytes
(
ze
.
getSize
(
)
)
)
;
writeOut
(
ZipLong
.
getBytes
(
ze
.
getSize
(
)
)
)
;
}
written
+=
12
;
byte
[
]
name
=
getBytes
(
ze
.
getName
(
)
)
;
writeOut
(
ZipShort
.
getBytes
(
name
.
length
)
)
;
written
+=
2
;
byte
[
]
extra
=
ze
.
getLocalFileDataExtra
(
)
;
writeOut
(
ZipShort
.
getBytes
(
extra
.
length
)
)
;
written
+=
2
;
writeOut
(
name
)
;
written
+=
name
.
length
;
writeOut
(
extra
)
;
written
+=
extra
.
length
;
dataStart
=
written
;
}
protected
void
writeDataDescriptor
(
ZipEntry
ze
)
throws
IOException
{
if
(
ze
.
getMethod
(
)
!=
DEFLATED
||
raf
!=
null
)
{
return
;
}
writeOut
(
DD_SIG
)
;
writeOut
(
ZipLong
.
getBytes
(
entry
.
getCrc
(
)
)
)
;
writeOut
(
ZipLong
.
getBytes
(
entry
.
getCompressedSize
(
)
)
)
;
writeOut
(
ZipLong
.
getBytes
(
entry
.
getSize
(
)
)
)
;
written
+=
16
;
}
protected
void
writeCentralFileHeader
(
ZipEntry
ze
)
throws
IOException
{
writeOut
(
CFH_SIG
)
;
written
+=
4
;
writeOut
(
ZipShort
.
getBytes
(
(
ze
.
getPlatform
(
)
<<
8
)
|
20
)
)
;
written
+=
2
;
if
(
ze
.
getMethod
(
)
==
DEFLATED
&&
raf
==
null
)
{
writeOut
(
ZipShort
.
getBytes
(
20
)
)
;
writeOut
(
ZipShort
.
getBytes
(
8
)
)
;
}
else
{
writeOut
(
ZipShort
.
getBytes
(
10
)
)
;
writeOut
(
ZERO
)
;
}
written
+=
4
;
writeOut
(
ZipShort
.
getBytes
(
ze
.
getMethod
(
)
)
)
;
written
+=
2
;
writeOut
(
toDosTime
(
ze
.
getTime
(
)
)
)
;
written
+=
4
;
writeOut
(
ZipLong
.
getBytes
(
ze
.
getCrc
(
)
)
)
;
writeOut
(
ZipLong
.
getBytes
(
ze
.
getCompressedSize
(
)
)
)
;
writeOut
(
ZipLong
.
getBytes
(
ze
.
getSize
(
)
)
)
;
written
+=
12
;
byte
[
]
name
=
getBytes
(
ze
.
getName
(
)
)
;
writeOut
(
ZipShort
.
getBytes
(
name
.
length
)
)
;
written
+=
2
;
byte
[
]
extra
=
ze
.
getCentralDirectoryExtra
(
)
;
writeOut
(
ZipShort
.
getBytes
(
extra
.
length
)
)
;
written
+=
2
;
String
comm
=
ze
.
getComment
(
)
;
if
(
comm
==
null
)
{
comm
=
""
;
}
byte
[
]
commentB
=
getBytes
(
comm
)
;
writeOut
(
ZipShort
.
getBytes
(
commentB
.
length
)
)
;
written
+=
2
;
writeOut
(
ZERO
)
;
written
+=
2
;
writeOut
(
ZipShort
.
getBytes
(
ze
.
getInternalAttributes
(
)
)
)
;
written
+=
2
;
writeOut
(
ZipLong
.
getBytes
(
ze
.
getExternalAttributes
(
)
)
)
;
written
+=
4
;
writeOut
(
(
byte
[
]
)
offsets
.
get
(
ze
)
)
;
written
+=
4
;
writeOut
(
name
)
;
written
+=
name
.
length
;
writeOut
(
extra
)
;
written
+=
extra
.
length
;
writeOut
(
commentB
)
;
written
+=
commentB
.
length
;
}
protected
void
writeCentralDirectoryEnd
(
)
throws
IOException
{
writeOut
(
EOCD_SIG
)
;
writeOut
(
ZERO
)
;
writeOut
(
ZERO
)
;
byte
[
]
num
=
ZipShort
.
getBytes
(
entries
.
size
(
)
)
;
writeOut
(
num
)
;
writeOut
(
num
)
;
writeOut
(
ZipLong
.
getBytes
(
cdLength
)
)
;
writeOut
(
ZipLong
.
getBytes
(
cdOffset
)
)
;
byte
[
]
data
=
getBytes
(
comment
)
;
writeOut
(
ZipShort
.
getBytes
(
data
.
length
)
)
;
writeOut
(
data
)
;
}
private
static
final
byte
[
]
DOS_TIME_MIN
=
ZipLong
.
getBytes
(
0x00002100L
)
;
protected
static
ZipLong
toDosTime
(
Date
time
)
{
return
new
ZipLong
(
toDosTime
(
time
.
getTime
(
)
)
)
;
}
protected
static
byte
[
]
toDosTime
(
long
t
)
{
Date
time
=
new
Date
(
t
)
;
int
year
=
time
.
getYear
(
)
+
1900
;
if
(
year
<
1980
)
{
return
DOS_TIME_MIN
;
}
int
month
=
time
.
getMonth
(
)
+
1
;
long
value
=
(
(
year
-
1980
)
<<
25
)
|
(
month
<<
21
)
|
(
time
.
getDate
(
)
<<
16
)
|
(
time
.
getHours
(
)
<<
11
)
|
(
time
.
getMinutes
(
)
<<
5
)
|
(
time
.
getSeconds
(
)
>
>
1
)
;
return
ZipLong
.
getBytes
(
value
)
;
}
protected
byte
[
]
getBytes
(
String
name
)
throws
ZipException
{
if
(
encoding
==
null
)
{
return
name
.
getBytes
(
)
;
}
else
{
try
{
return
name
.
getBytes
(
encoding
)
;
}
catch
(
UnsupportedEncodingException
uee
)
{
throw
new
ZipException
(
uee
.
getMessage
(
)
)
;
}
}
}
protected
final
void
writeOut
(
byte
[
]
data
)
throws
IOException
{
writeOut
(
data
,
0
,
data
.
length
)
;
}
protected
final
void
writeOut
(
byte
[
]
data
,
int
offset
,
int
length
)
throws
IOException
{
if
(
raf
!=
null
)
{
raf
.
write
(
data
,
offset
,
length
)
;
}
else
{
out
.
write
(
data
,
offset
,
length
)
;
}
}
protected
static
long
adjustToLong
(
int
i
)
{
if
(
i
<
0
)
{
return
2
*
(
(
long
)
Integer
.
MAX_VALUE
)
+
2
+
i
;
}
else
{
return
i
;
}
}
}
