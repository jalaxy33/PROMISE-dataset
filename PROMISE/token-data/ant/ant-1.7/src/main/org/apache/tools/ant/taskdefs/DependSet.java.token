package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
File
;
import
java
.
util
.
Iterator
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileList
;
import
org
.
apache
.
tools
.
ant
.
types
.
Resource
;
import
org
.
apache
.
tools
.
ant
.
types
.
TimeComparison
;
import
org
.
apache
.
tools
.
ant
.
types
.
ResourceCollection
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
Sort
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
Union
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
Restrict
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
Resources
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
FileResource
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Not
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Exists
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
ResourceSelector
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
comparators
.
Reverse
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
comparators
.
ResourceComparator
;
public
class
DependSet
extends
MatchingTask
{
private
static
final
ResourceSelector
NOT_EXISTS
=
new
Not
(
new
Exists
(
)
)
;
private
static
final
ResourceComparator
DATE_ASC
=
new
org
.
apache
.
tools
.
ant
.
types
.
resources
.
comparators
.
Date
(
)
;
private
static
final
ResourceComparator
DATE_DESC
=
new
Reverse
(
DATE_ASC
)
;
private
static
class
NonExistent
extends
Restrict
{
private
NonExistent
(
ResourceCollection
rc
)
{
super
.
add
(
rc
)
;
super
.
add
(
NOT_EXISTS
)
;
}
}
private
static
class
Xest
extends
Sort
{
private
Xest
(
ResourceCollection
rc
,
ResourceComparator
c
)
{
super
.
add
(
c
)
;
super
.
add
(
rc
)
;
}
}
private
static
class
Oldest
extends
Xest
{
private
Oldest
(
ResourceCollection
rc
)
{
super
(
rc
,
DATE_ASC
)
;
}
}
private
static
class
Newest
extends
Xest
{
private
Newest
(
ResourceCollection
rc
)
{
super
(
rc
,
DATE_DESC
)
;
}
}
private
static
class
HideMissingBasedir
implements
ResourceCollection
{
private
FileSet
fs
;
private
HideMissingBasedir
(
FileSet
fs
)
{
this
.
fs
=
fs
;
}
public
Iterator
iterator
(
)
{
return
basedirExists
(
)
?
fs
.
iterator
(
)
:
Resources
.
EMPTY_ITERATOR
;
}
public
int
size
(
)
{
return
basedirExists
(
)
?
fs
.
size
(
)
:
0
;
}
public
boolean
isFilesystemOnly
(
)
{
return
true
;
}
private
boolean
basedirExists
(
)
{
File
basedir
=
fs
.
getDir
(
)
;
return
basedir
==
null
||
basedir
.
exists
(
)
;
}
}
private
Union
sources
=
null
;
private
Path
targets
=
null
;
public
synchronized
Union
createSources
(
)
{
sources
=
(
sources
==
null
)
?
new
Union
(
)
:
sources
;
return
sources
;
}
public
void
addSrcfileset
(
FileSet
fs
)
{
createSources
(
)
.
add
(
fs
)
;
}
public
void
addSrcfilelist
(
FileList
fl
)
{
createSources
(
)
.
add
(
fl
)
;
}
public
synchronized
Path
createTargets
(
)
{
targets
=
(
targets
==
null
)
?
new
Path
(
getProject
(
)
)
:
targets
;
return
targets
;
}
public
void
addTargetfileset
(
FileSet
fs
)
{
createTargets
(
)
.
add
(
new
HideMissingBasedir
(
fs
)
)
;
}
public
void
addTargetfilelist
(
FileList
fl
)
{
createTargets
(
)
.
add
(
fl
)
;
}
public
void
execute
(
)
throws
BuildException
{
if
(
sources
==
null
)
{
throw
new
BuildException
(
"At least one set of source resources must be specified"
)
;
}
if
(
targets
==
null
)
{
throw
new
BuildException
(
"At least one set of target files must be specified"
)
;
}
if
(
sources
.
size
(
)
>
0
&&
targets
.
size
(
)
>
0
&&
!
uptodate
(
sources
,
targets
)
)
{
log
(
"Deleting all target files."
,
Project
.
MSG_VERBOSE
)
;
Delete
delete
=
new
Delete
(
)
;
delete
.
bindToOwner
(
this
)
;
delete
.
add
(
targets
)
;
delete
.
perform
(
)
;
}
}
private
boolean
uptodate
(
ResourceCollection
src
,
ResourceCollection
target
)
{
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Date
datesel
=
new
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Date
(
)
;
datesel
.
setMillis
(
System
.
currentTimeMillis
(
)
)
;
datesel
.
setWhen
(
TimeComparison
.
AFTER
)
;
logFuture
(
targets
,
datesel
)
;
int
neTargets
=
new
NonExistent
(
targets
)
.
size
(
)
;
if
(
neTargets
>
0
)
{
log
(
neTargets
+
" nonexistent targets"
,
Project
.
MSG_VERBOSE
)
;
return
false
;
}
FileResource
oldestTarget
=
(
FileResource
)
(
new
Oldest
(
targets
)
.
iterator
(
)
.
next
(
)
)
;
log
(
oldestTarget
+
" is oldest target file"
,
Project
.
MSG_VERBOSE
)
;
logFuture
(
sources
,
datesel
)
;
int
neSources
=
new
NonExistent
(
sources
)
.
size
(
)
;
if
(
neSources
>
0
)
{
log
(
neSources
+
" nonexistent sources"
,
Project
.
MSG_VERBOSE
)
;
return
false
;
}
Resource
newestSource
=
(
Resource
)
(
new
Newest
(
sources
)
.
iterator
(
)
.
next
(
)
)
;
log
(
newestSource
.
toLongString
(
)
+
" is newest source"
,
Project
.
MSG_VERBOSE
)
;
return
oldestTarget
.
getLastModified
(
)
>=
newestSource
.
getLastModified
(
)
;
}
private
void
logFuture
(
ResourceCollection
rc
,
ResourceSelector
rsel
)
{
Restrict
r
=
new
Restrict
(
)
;
r
.
add
(
rsel
)
;
r
.
add
(
rc
)
;
for
(
Iterator
i
=
r
.
iterator
(
)
;
i
.
hasNext
(
)
;
)
{
log
(
"Warning: "
+
i
.
next
(
)
+
" modified in the future."
,
Project
.
MSG_WARN
)
;
}
}
}
