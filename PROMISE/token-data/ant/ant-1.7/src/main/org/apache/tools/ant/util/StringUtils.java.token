package
org
.
apache
.
tools
.
ant
.
util
;
import
java
.
io
.
PrintWriter
;
import
java
.
io
.
StringWriter
;
import
java
.
util
.
Vector
;
public
final
class
StringUtils
{
private
StringUtils
(
)
{
}
public
static
final
String
LINE_SEP
=
System
.
getProperty
(
"line.separator"
)
;
public
static
Vector
lineSplit
(
String
data
)
{
return
split
(
data
,
'\n'
)
;
}
public
static
Vector
split
(
String
data
,
int
ch
)
{
Vector
elems
=
new
Vector
(
)
;
int
pos
=
-
1
;
int
i
=
0
;
while
(
(
pos
=
data
.
indexOf
(
ch
,
i
)
)
!=
-
1
)
{
String
elem
=
data
.
substring
(
i
,
pos
)
;
elems
.
addElement
(
elem
)
;
i
=
pos
+
1
;
}
elems
.
addElement
(
data
.
substring
(
i
)
)
;
return
elems
;
}
public
static
String
replace
(
String
data
,
String
from
,
String
to
)
{
StringBuffer
buf
=
new
StringBuffer
(
data
.
length
(
)
)
;
int
pos
=
-
1
;
int
i
=
0
;
while
(
(
pos
=
data
.
indexOf
(
from
,
i
)
)
!=
-
1
)
{
buf
.
append
(
data
.
substring
(
i
,
pos
)
)
.
append
(
to
)
;
i
=
pos
+
from
.
length
(
)
;
}
buf
.
append
(
data
.
substring
(
i
)
)
;
return
buf
.
toString
(
)
;
}
public
static
String
getStackTrace
(
Throwable
t
)
{
StringWriter
sw
=
new
StringWriter
(
)
;
PrintWriter
pw
=
new
PrintWriter
(
sw
,
true
)
;
t
.
printStackTrace
(
pw
)
;
pw
.
flush
(
)
;
pw
.
close
(
)
;
return
sw
.
toString
(
)
;
}
public
static
boolean
endsWith
(
StringBuffer
buffer
,
String
suffix
)
{
if
(
suffix
.
length
(
)
>
buffer
.
length
(
)
)
{
return
false
;
}
int
endIndex
=
suffix
.
length
(
)
-
1
;
int
bufferIndex
=
buffer
.
length
(
)
-
1
;
while
(
endIndex
>=
0
)
{
if
(
buffer
.
charAt
(
bufferIndex
)
!=
suffix
.
charAt
(
endIndex
)
)
{
return
false
;
}
bufferIndex
--
;
endIndex
--
;
}
return
true
;
}
public
static
String
resolveBackSlash
(
String
input
)
{
StringBuffer
b
=
new
StringBuffer
(
)
;
boolean
backSlashSeen
=
false
;
for
(
int
i
=
0
;
i
<
input
.
length
(
)
;
++
i
)
{
char
c
=
input
.
charAt
(
i
)
;
if
(
!
backSlashSeen
)
{
if
(
c
==
'\\'
)
{
backSlashSeen
=
true
;
}
else
{
b
.
append
(
c
)
;
}
}
else
{
switch
(
c
)
{
case
'\\'
:
b
.
append
(
(
char
)
'\\'
)
;
break
;
case
'n'
:
b
.
append
(
(
char
)
'\n'
)
;
break
;
case
'r'
:
b
.
append
(
(
char
)
'\r'
)
;
break
;
case
't'
:
b
.
append
(
(
char
)
'\t'
)
;
break
;
case
'f'
:
b
.
append
(
(
char
)
'\f'
)
;
break
;
case
's'
:
b
.
append
(
" \t\n\r\f"
)
;
break
;
default
:
b
.
append
(
c
)
;
}
backSlashSeen
=
false
;
}
}
return
b
.
toString
(
)
;
}
public
static
long
parseHumanSizes
(
String
humanSize
)
throws
Exception
{
final
long
KILOBYTE
=
1024
;
final
long
MEGABYTE
=
KILOBYTE
*
1024
;
final
long
GIGABYTE
=
MEGABYTE
*
1024
;
final
long
TERABYTE
=
GIGABYTE
*
1024
;
final
long
PETABYTE
=
TERABYTE
*
1024
;
if
(
!
Character
.
isDigit
(
humanSize
.
charAt
(
humanSize
.
length
(
)
-
1
)
)
)
{
char
c
=
humanSize
.
charAt
(
humanSize
.
length
(
)
-
1
)
;
long
value
=
Long
.
valueOf
(
humanSize
.
substring
(
0
,
humanSize
.
length
(
)
-
1
)
)
.
longValue
(
)
;
switch
(
c
)
{
case
'K'
:
return
value
*
KILOBYTE
;
case
'M'
:
return
value
*
MEGABYTE
;
case
'G'
:
return
value
*
GIGABYTE
;
case
'T'
:
return
value
*
TERABYTE
;
case
'P'
:
return
value
*
PETABYTE
;
default
:
return
value
;
}
}
else
{
return
Long
.
parseLong
(
humanSize
)
;
}
}
}
