package
org
.
apache
.
tools
.
ant
.
taskdefs
.
optional
.
dotnet
;
import
java
.
io
.
File
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
condition
.
Os
;
import
org
.
apache
.
tools
.
ant
.
types
.
EnumeratedAttribute
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
public
class
Ilasm
extends
DotnetBaseMatchingTask
{
protected
static
final
String
exe_name
=
"ilasm"
;
protected
static
final
String
file_ext
=
"il"
;
protected
static
final
String
file_pattern
=
"**/*."
+
file_ext
;
protected
static
final
String
exe_title
=
"ilasm"
;
protected
String
targetType
;
protected
boolean
verbose
;
protected
boolean
listing
;
protected
File
resourceFile
;
protected
boolean
failOnError
;
protected
boolean
debug
;
private
File
keyfile
;
protected
String
extraOptions
;
protected
Vector
referenceFilesets
=
new
Vector
(
)
;
private
boolean
isMono
=
!
Os
.
isFamily
(
"windows"
)
;
public
Ilasm
(
)
{
Clear
(
)
;
setIncludes
(
file_pattern
)
;
}
public
void
Clear
(
)
{
targetType
=
null
;
srcDir
=
null
;
listing
=
false
;
verbose
=
false
;
debug
=
true
;
outputFile
=
null
;
failOnError
=
true
;
resourceFile
=
null
;
extraOptions
=
null
;
}
public
void
setTargetType
(
String
targetType
)
throws
BuildException
{
this
.
targetType
=
targetType
.
toLowerCase
(
)
;
if
(
!
targetType
.
equals
(
"exe"
)
&&
!
targetType
.
equals
(
"library"
)
)
{
throw
new
BuildException
(
"targetType "
+
targetType
+
" is not a valid type"
)
;
}
}
public
String
getTargetType
(
)
{
return
targetType
;
}
protected
String
getTargetTypeParameter
(
)
{
if
(
!
notEmpty
(
targetType
)
)
{
return
null
;
}
if
(
targetType
.
equals
(
"exe"
)
)
{
return
"/exe"
;
}
else
if
(
targetType
.
equals
(
"library"
)
)
{
return
"/dll"
;
}
else
{
return
null
;
}
}
public
void
setOwner
(
String
s
)
{
log
(
"This option is not supported by ILASM as of Beta-2, "
+
"and will be ignored"
,
Project
.
MSG_WARN
)
;
}
protected
boolean
notEmpty
(
String
s
)
{
return
s
!=
null
&&
s
.
length
(
)
!=
0
;
}
public
void
setVerbose
(
boolean
b
)
{
verbose
=
b
;
}
protected
String
getVerboseParameter
(
)
{
return
verbose
?
null
:
"/quiet"
;
}
public
void
setListing
(
boolean
b
)
{
listing
=
b
;
}
protected
String
getListingParameter
(
)
{
if
(
!
isMono
)
{
return
listing
?
"/listing"
:
"/nolisting"
;
}
return
null
;
}
public
void
setOutputFile
(
File
params
)
{
outputFile
=
params
;
}
protected
String
getOutputFileParameter
(
)
{
if
(
outputFile
==
null
)
{
return
null
;
}
return
"/output="
+
outputFile
.
toString
(
)
;
}
public
void
setResourceFile
(
File
fileName
)
{
resourceFile
=
fileName
;
}
protected
String
getResourceFileParameter
(
)
{
if
(
resourceFile
!=
null
)
{
return
"/resource="
+
resourceFile
.
toString
(
)
;
}
else
{
return
null
;
}
}
public
void
setFailOnError
(
boolean
b
)
{
failOnError
=
b
;
}
public
boolean
getFailOnError
(
)
{
return
failOnError
;
}
public
void
setDebug
(
boolean
f
)
{
debug
=
f
;
}
public
boolean
getDebug
(
)
{
return
debug
;
}
protected
String
getDebugParameter
(
)
{
return
debug
?
"/debug"
:
null
;
}
public
void
setKeyfile
(
File
keyfile
)
{
this
.
keyfile
=
keyfile
;
}
protected
String
getKeyfileParameter
(
)
{
if
(
keyfile
!=
null
)
{
return
"/keyfile:"
+
keyfile
.
toString
(
)
;
}
else
{
return
null
;
}
}
public
void
setExtraOptions
(
String
extraOptions
)
{
this
.
extraOptions
=
extraOptions
;
}
public
String
getExtraOptions
(
)
{
return
this
.
extraOptions
;
}
protected
String
getExtraOptionsParameter
(
)
{
if
(
extraOptions
!=
null
&&
extraOptions
.
length
(
)
!=
0
)
{
return
extraOptions
;
}
else
{
return
null
;
}
}
public
void
setTargetType
(
TargetTypes
targetType
)
{
this
.
targetType
=
targetType
.
getValue
(
)
;
}
public
void
setMono
(
boolean
b
)
{
isMono
=
b
;
}
public
void
execute
(
)
throws
BuildException
{
log
(
"This task is deprecated and will be removed in a future version\n"
+
"of Ant.  It is now part of the .NET Antlib:\n"
+
"http://ant.apache.org/antlibs/dotnet/index.html"
,
Project
.
MSG_WARN
)
;
NetCommand
command
=
buildIlasmCommand
(
)
;
addFilesAndExecute
(
command
,
false
)
;
}
private
NetCommand
buildIlasmCommand
(
)
{
NetCommand
command
=
new
NetCommand
(
this
,
exe_title
,
exe_name
)
;
command
.
setFailOnError
(
getFailOnError
(
)
)
;
command
.
addArgument
(
getDebugParameter
(
)
)
;
command
.
addArgument
(
getTargetTypeParameter
(
)
)
;
command
.
addArgument
(
getListingParameter
(
)
)
;
command
.
addArgument
(
getOutputFileParameter
(
)
)
;
command
.
addArgument
(
getResourceFileParameter
(
)
)
;
command
.
addArgument
(
getVerboseParameter
(
)
)
;
command
.
addArgument
(
getKeyfileParameter
(
)
)
;
command
.
addArgument
(
getExtraOptionsParameter
(
)
)
;
return
command
;
}
public
void
addReference
(
FileSet
reference
)
{
referenceFilesets
.
add
(
reference
)
;
}
protected
static
boolean
isFileManagedBinary
(
File
file
)
{
String
filename
=
file
.
toString
(
)
.
toLowerCase
(
)
;
return
filename
.
endsWith
(
".exe"
)
||
filename
.
endsWith
(
".dll"
)
||
filename
.
endsWith
(
".netmodule"
)
;
}
public
static
class
TargetTypes
extends
EnumeratedAttribute
{
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
"exe"
,
"library"
,
}
;
}
}
}
