package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
File
;
import
java
.
io
.
Reader
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
PrintStream
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
StringReader
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
PipedOutputStream
;
import
java
.
io
.
ByteArrayInputStream
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
ProjectComponent
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
filters
.
util
.
ChainReaderHelper
;
import
org
.
apache
.
tools
.
ant
.
util
.
StringUtils
;
import
org
.
apache
.
tools
.
ant
.
util
.
TeeOutputStream
;
import
org
.
apache
.
tools
.
ant
.
util
.
ReaderInputStream
;
import
org
.
apache
.
tools
.
ant
.
util
.
LeadPipeInputStream
;
import
org
.
apache
.
tools
.
ant
.
util
.
LazyFileOutputStream
;
import
org
.
apache
.
tools
.
ant
.
util
.
OutputStreamFunneler
;
import
org
.
apache
.
tools
.
ant
.
util
.
ConcatFileInputStream
;
import
org
.
apache
.
tools
.
ant
.
util
.
KeepAliveOutputStream
;
public
class
Redirector
{
private
static
final
String
DEFAULT_ENCODING
=
System
.
getProperty
(
"file.encoding"
)
;
private
class
PropertyOutputStream
extends
ByteArrayOutputStream
{
private
String
property
;
private
boolean
closed
=
false
;
PropertyOutputStream
(
String
property
)
{
super
(
)
;
this
.
property
=
property
;
}
public
void
close
(
)
throws
IOException
{
if
(
!
closed
&&
!
(
append
&&
appendProperties
)
)
{
setPropertyFromBAOS
(
this
,
property
)
;
closed
=
true
;
}
}
}
private
File
[
]
input
;
private
File
[
]
out
;
private
File
[
]
error
;
private
boolean
logError
=
false
;
private
PropertyOutputStream
baos
=
null
;
private
PropertyOutputStream
errorBaos
=
null
;
private
String
outputProperty
;
private
String
errorProperty
;
private
String
inputString
;
private
boolean
append
=
false
;
private
boolean
alwaysLog
=
false
;
private
boolean
createEmptyFiles
=
true
;
private
ProjectComponent
managingTask
;
private
OutputStream
outputStream
=
null
;
private
OutputStream
errorStream
=
null
;
private
InputStream
inputStream
=
null
;
private
PrintStream
outPrintStream
=
null
;
private
PrintStream
errorPrintStream
=
null
;
private
Vector
outputFilterChains
;
private
Vector
errorFilterChains
;
private
Vector
inputFilterChains
;
private
String
outputEncoding
=
DEFAULT_ENCODING
;
private
String
errorEncoding
=
DEFAULT_ENCODING
;
private
String
inputEncoding
=
DEFAULT_ENCODING
;
private
boolean
appendProperties
=
true
;
private
ThreadGroup
threadGroup
=
new
ThreadGroup
(
"redirector"
)
;
private
boolean
logInputString
=
true
;
public
Redirector
(
Task
managingTask
)
{
this
(
(
ProjectComponent
)
managingTask
)
;
}
public
Redirector
(
ProjectComponent
managingTask
)
{
this
.
managingTask
=
managingTask
;
}
public
void
setInput
(
File
input
)
{
setInput
(
(
input
==
null
)
?
null
:
new
File
[
]
{
input
}
)
;
}
public
synchronized
void
setInput
(
File
[
]
input
)
{
this
.
input
=
input
;
}
public
synchronized
void
setInputString
(
String
inputString
)
{
this
.
inputString
=
inputString
;
}
public
void
setLogInputString
(
boolean
logInputString
)
{
this
.
logInputString
=
logInputString
;
}
void
setInputStream
(
InputStream
inputStream
)
{
this
.
inputStream
=
inputStream
;
}
public
void
setOutput
(
File
out
)
{
setOutput
(
(
out
==
null
)
?
null
:
new
File
[
]
{
out
}
)
;
}
public
synchronized
void
setOutput
(
File
[
]
out
)
{
this
.
out
=
out
;
}
public
synchronized
void
setOutputEncoding
(
String
outputEncoding
)
{
if
(
outputEncoding
==
null
)
{
throw
new
IllegalArgumentException
(
"outputEncoding must not be null"
)
;
}
else
{
this
.
outputEncoding
=
outputEncoding
;
}
}
public
synchronized
void
setErrorEncoding
(
String
errorEncoding
)
{
if
(
errorEncoding
==
null
)
{
throw
new
IllegalArgumentException
(
"errorEncoding must not be null"
)
;
}
else
{
this
.
errorEncoding
=
errorEncoding
;
}
}
public
synchronized
void
setInputEncoding
(
String
inputEncoding
)
{
if
(
inputEncoding
==
null
)
{
throw
new
IllegalArgumentException
(
"inputEncoding must not be null"
)
;
}
else
{
this
.
inputEncoding
=
inputEncoding
;
}
}
public
synchronized
void
setLogError
(
boolean
logError
)
{
this
.
logError
=
logError
;
}
public
synchronized
void
setAppendProperties
(
boolean
appendProperties
)
{
this
.
appendProperties
=
appendProperties
;
}
public
void
setError
(
File
error
)
{
setError
(
(
error
==
null
)
?
null
:
new
File
[
]
{
error
}
)
;
}
public
synchronized
void
setError
(
File
[
]
error
)
{
this
.
error
=
error
;
}
public
synchronized
void
setOutputProperty
(
String
outputProperty
)
{
if
(
outputProperty
==
null
||
!
(
outputProperty
.
equals
(
this
.
outputProperty
)
)
)
{
this
.
outputProperty
=
outputProperty
;
baos
=
null
;
}
}
public
synchronized
void
setAppend
(
boolean
append
)
{
this
.
append
=
append
;
}
public
synchronized
void
setAlwaysLog
(
boolean
alwaysLog
)
{
this
.
alwaysLog
=
alwaysLog
;
}
public
synchronized
void
setCreateEmptyFiles
(
boolean
createEmptyFiles
)
{
this
.
createEmptyFiles
=
createEmptyFiles
;
}
public
synchronized
void
setErrorProperty
(
String
errorProperty
)
{
if
(
errorProperty
==
null
||
!
(
errorProperty
.
equals
(
this
.
errorProperty
)
)
)
{
this
.
errorProperty
=
errorProperty
;
errorBaos
=
null
;
}
}
public
synchronized
void
setInputFilterChains
(
Vector
inputFilterChains
)
{
this
.
inputFilterChains
=
inputFilterChains
;
}
public
synchronized
void
setOutputFilterChains
(
Vector
outputFilterChains
)
{
this
.
outputFilterChains
=
outputFilterChains
;
}
public
synchronized
void
setErrorFilterChains
(
Vector
errorFilterChains
)
{
this
.
errorFilterChains
=
errorFilterChains
;
}
private
void
setPropertyFromBAOS
(
ByteArrayOutputStream
baos
,
String
propertyName
)
throws
IOException
{
BufferedReader
in
=
new
BufferedReader
(
new
StringReader
(
Execute
.
toString
(
baos
)
)
)
;
String
line
=
null
;
StringBuffer
val
=
new
StringBuffer
(
)
;
while
(
(
line
=
in
.
readLine
(
)
)
!=
null
)
{
if
(
val
.
length
(
)
!=
0
)
{
val
.
append
(
StringUtils
.
LINE_SEP
)
;
}
val
.
append
(
line
)
;
}
managingTask
.
getProject
(
)
.
setNewProperty
(
propertyName
,
val
.
toString
(
)
)
;
}
public
synchronized
void
createStreams
(
)
{
if
(
out
!=
null
&&
out
.
length
>
0
)
{
String
logHead
=
new
StringBuffer
(
"Output "
)
.
append
(
(
(
append
)
?
"appended"
:
"redirected"
)
)
.
append
(
" to "
)
.
toString
(
)
;
outputStream
=
foldFiles
(
out
,
logHead
,
Project
.
MSG_VERBOSE
)
;
}
if
(
outputProperty
!=
null
)
{
if
(
baos
==
null
)
{
baos
=
new
PropertyOutputStream
(
outputProperty
)
;
managingTask
.
log
(
"Output redirected to property: "
+
outputProperty
,
Project
.
MSG_VERBOSE
)
;
}
OutputStream
keepAliveOutput
=
new
KeepAliveOutputStream
(
baos
)
;
outputStream
=
(
outputStream
==
null
)
?
keepAliveOutput
:
new
TeeOutputStream
(
outputStream
,
keepAliveOutput
)
;
}
else
{
baos
=
null
;
}
if
(
error
!=
null
&&
error
.
length
>
0
)
{
String
logHead
=
new
StringBuffer
(
"Error "
)
.
append
(
(
(
append
)
?
"appended"
:
"redirected"
)
)
.
append
(
" to "
)
.
toString
(
)
;
errorStream
=
foldFiles
(
error
,
logHead
,
Project
.
MSG_VERBOSE
)
;
}
else
if
(
!
(
logError
||
outputStream
==
null
)
)
{
long
funnelTimeout
=
0L
;
OutputStreamFunneler
funneler
=
new
OutputStreamFunneler
(
outputStream
,
funnelTimeout
)
;
try
{
outputStream
=
funneler
.
getFunnelInstance
(
)
;
errorStream
=
funneler
.
getFunnelInstance
(
)
;
}
catch
(
IOException
eyeOhEx
)
{
throw
new
BuildException
(
"error splitting output/error streams"
,
eyeOhEx
)
;
}
}
if
(
errorProperty
!=
null
)
{
if
(
errorBaos
==
null
)
{
errorBaos
=
new
PropertyOutputStream
(
errorProperty
)
;
managingTask
.
log
(
"Error redirected to property: "
+
errorProperty
,
Project
.
MSG_VERBOSE
)
;
}
OutputStream
keepAliveError
=
new
KeepAliveOutputStream
(
errorBaos
)
;
errorStream
=
(
error
==
null
||
error
.
length
==
0
)
?
keepAliveError
:
new
TeeOutputStream
(
errorStream
,
keepAliveError
)
;
}
else
{
errorBaos
=
null
;
}
if
(
alwaysLog
||
outputStream
==
null
)
{
OutputStream
outputLog
=
new
LogOutputStream
(
managingTask
,
Project
.
MSG_INFO
)
;
outputStream
=
(
outputStream
==
null
)
?
outputLog
:
new
TeeOutputStream
(
outputLog
,
outputStream
)
;
}
if
(
alwaysLog
||
errorStream
==
null
)
{
OutputStream
errorLog
=
new
LogOutputStream
(
managingTask
,
Project
.
MSG_WARN
)
;
errorStream
=
(
errorStream
==
null
)
?
errorLog
:
new
TeeOutputStream
(
errorLog
,
errorStream
)
;
}
if
(
(
outputFilterChains
!=
null
&&
outputFilterChains
.
size
(
)
>
0
)
||
!
(
outputEncoding
.
equalsIgnoreCase
(
inputEncoding
)
)
)
{
try
{
LeadPipeInputStream
snk
=
new
LeadPipeInputStream
(
)
;
snk
.
setManagingComponent
(
managingTask
)
;
InputStream
outPumpIn
=
snk
;
Reader
reader
=
new
InputStreamReader
(
outPumpIn
,
inputEncoding
)
;
if
(
outputFilterChains
!=
null
&&
outputFilterChains
.
size
(
)
>
0
)
{
ChainReaderHelper
helper
=
new
ChainReaderHelper
(
)
;
helper
.
setProject
(
managingTask
.
getProject
(
)
)
;
helper
.
setPrimaryReader
(
reader
)
;
helper
.
setFilterChains
(
outputFilterChains
)
;
reader
=
helper
.
getAssembledReader
(
)
;
}
outPumpIn
=
new
ReaderInputStream
(
reader
,
outputEncoding
)
;
Thread
t
=
new
Thread
(
threadGroup
,
new
StreamPumper
(
outPumpIn
,
outputStream
,
true
)
,
"output pumper"
)
;
t
.
setPriority
(
Thread
.
MAX_PRIORITY
)
;
outputStream
=
new
PipedOutputStream
(
snk
)
;
t
.
start
(
)
;
}
catch
(
IOException
eyeOhEx
)
{
throw
new
BuildException
(
"error setting up output stream"
,
eyeOhEx
)
;
}
}
if
(
(
errorFilterChains
!=
null
&&
errorFilterChains
.
size
(
)
>
0
)
||
!
(
errorEncoding
.
equalsIgnoreCase
(
inputEncoding
)
)
)
{
try
{
LeadPipeInputStream
snk
=
new
LeadPipeInputStream
(
)
;
snk
.
setManagingComponent
(
managingTask
)
;
InputStream
errPumpIn
=
snk
;
Reader
reader
=
new
InputStreamReader
(
errPumpIn
,
inputEncoding
)
;
if
(
errorFilterChains
!=
null
&&
errorFilterChains
.
size
(
)
>
0
)
{
ChainReaderHelper
helper
=
new
ChainReaderHelper
(
)
;
helper
.
setProject
(
managingTask
.
getProject
(
)
)
;
helper
.
setPrimaryReader
(
reader
)
;
helper
.
setFilterChains
(
errorFilterChains
)
;
reader
=
helper
.
getAssembledReader
(
)
;
}
errPumpIn
=
new
ReaderInputStream
(
reader
,
errorEncoding
)
;
Thread
t
=
new
Thread
(
threadGroup
,
new
StreamPumper
(
errPumpIn
,
errorStream
,
true
)
,
"error pumper"
)
;
t
.
setPriority
(
Thread
.
MAX_PRIORITY
)
;
errorStream
=
new
PipedOutputStream
(
snk
)
;
t
.
start
(
)
;
}
catch
(
IOException
eyeOhEx
)
{
throw
new
BuildException
(
"error setting up error stream"
,
eyeOhEx
)
;
}
}
if
(
input
!=
null
&&
input
.
length
>
0
)
{
managingTask
.
log
(
"Redirecting input from file"
+
(
(
input
.
length
==
1
)
?
""
:
"s"
)
,
Project
.
MSG_VERBOSE
)
;
try
{
inputStream
=
new
ConcatFileInputStream
(
input
)
;
}
catch
(
IOException
eyeOhEx
)
{
throw
new
BuildException
(
eyeOhEx
)
;
}
(
(
ConcatFileInputStream
)
inputStream
)
.
setManagingComponent
(
managingTask
)
;
}
else
if
(
inputString
!=
null
)
{
StringBuffer
buf
=
new
StringBuffer
(
"Using input "
)
;
if
(
logInputString
)
{
buf
.
append
(
'"'
)
.
append
(
inputString
)
.
append
(
'"'
)
;
}
else
{
buf
.
append
(
"string"
)
;
}
managingTask
.
log
(
buf
.
toString
(
)
,
Project
.
MSG_VERBOSE
)
;
inputStream
=
new
ByteArrayInputStream
(
inputString
.
getBytes
(
)
)
;
}
if
(
inputStream
!=
null
&&
inputFilterChains
!=
null
&&
inputFilterChains
.
size
(
)
>
0
)
{
ChainReaderHelper
helper
=
new
ChainReaderHelper
(
)
;
helper
.
setProject
(
managingTask
.
getProject
(
)
)
;
try
{
helper
.
setPrimaryReader
(
new
InputStreamReader
(
inputStream
,
inputEncoding
)
)
;
}
catch
(
IOException
eyeOhEx
)
{
throw
new
BuildException
(
"error setting up input stream"
,
eyeOhEx
)
;
}
helper
.
setFilterChains
(
inputFilterChains
)
;
inputStream
=
new
ReaderInputStream
(
helper
.
getAssembledReader
(
)
,
inputEncoding
)
;
}
}
public
synchronized
ExecuteStreamHandler
createHandler
(
)
throws
BuildException
{
createStreams
(
)
;
return
new
PumpStreamHandler
(
outputStream
,
errorStream
,
inputStream
)
;
}
protected
synchronized
void
handleOutput
(
String
output
)
{
if
(
outPrintStream
==
null
)
{
outPrintStream
=
new
PrintStream
(
outputStream
)
;
}
outPrintStream
.
print
(
output
)
;
}
protected
synchronized
int
handleInput
(
byte
[
]
buffer
,
int
offset
,
int
length
)
throws
IOException
{
if
(
inputStream
==
null
)
{
return
managingTask
.
getProject
(
)
.
defaultInput
(
buffer
,
offset
,
length
)
;
}
else
{
return
inputStream
.
read
(
buffer
,
offset
,
length
)
;
}
}
protected
synchronized
void
handleFlush
(
String
output
)
{
if
(
outPrintStream
==
null
)
{
outPrintStream
=
new
PrintStream
(
outputStream
)
;
}
outPrintStream
.
print
(
output
)
;
outPrintStream
.
flush
(
)
;
}
protected
synchronized
void
handleErrorOutput
(
String
output
)
{
if
(
errorPrintStream
==
null
)
{
errorPrintStream
=
new
PrintStream
(
errorStream
)
;
}
errorPrintStream
.
print
(
output
)
;
}
protected
synchronized
void
handleErrorFlush
(
String
output
)
{
if
(
errorPrintStream
==
null
)
{
errorPrintStream
=
new
PrintStream
(
errorStream
)
;
}
errorPrintStream
.
print
(
output
)
;
}
public
synchronized
OutputStream
getOutputStream
(
)
{
return
outputStream
;
}
public
synchronized
OutputStream
getErrorStream
(
)
{
return
errorStream
;
}
public
synchronized
InputStream
getInputStream
(
)
{
return
inputStream
;
}
public
synchronized
void
complete
(
)
throws
IOException
{
System
.
out
.
flush
(
)
;
System
.
err
.
flush
(
)
;
if
(
inputStream
!=
null
)
{
inputStream
.
close
(
)
;
}
outputStream
.
flush
(
)
;
outputStream
.
close
(
)
;
errorStream
.
flush
(
)
;
errorStream
.
close
(
)
;
while
(
threadGroup
.
activeCount
(
)
>
0
)
{
try
{
managingTask
.
log
(
"waiting for "
+
threadGroup
.
activeCount
(
)
+
" Threads:"
,
Project
.
MSG_DEBUG
)
;
Thread
[
]
thread
=
new
Thread
[
threadGroup
.
activeCount
(
)
]
;
threadGroup
.
enumerate
(
thread
)
;
for
(
int
i
=
0
;
i
<
thread
.
length
&&
thread
[
i
]
!=
null
;
i
++
)
{
try
{
managingTask
.
log
(
thread
[
i
]
.
toString
(
)
,
Project
.
MSG_DEBUG
)
;
}
catch
(
NullPointerException
enPeaEx
)
{
}
}
wait
(
1000
)
;
}
catch
(
InterruptedException
eyeEx
)
{
}
}
setProperties
(
)
;
inputStream
=
null
;
outputStream
=
null
;
errorStream
=
null
;
outPrintStream
=
null
;
errorPrintStream
=
null
;
}
public
synchronized
void
setProperties
(
)
{
if
(
baos
!=
null
)
{
try
{
baos
.
close
(
)
;
}
catch
(
IOException
eyeOhEx
)
{
}
}
if
(
errorBaos
!=
null
)
{
try
{
errorBaos
.
close
(
)
;
}
catch
(
IOException
eyeOhEx
)
{
}
}
}
private
OutputStream
foldFiles
(
File
[
]
file
,
String
logHead
,
int
loglevel
)
{
OutputStream
result
=
new
LazyFileOutputStream
(
file
[
0
]
,
append
,
createEmptyFiles
)
;
managingTask
.
log
(
logHead
+
file
[
0
]
,
loglevel
)
;
char
[
]
c
=
new
char
[
logHead
.
length
(
)
]
;
Arrays
.
fill
(
c
,
' '
)
;
String
indent
=
new
String
(
c
)
;
for
(
int
i
=
1
;
i
<
file
.
length
;
i
++
)
{
outputStream
=
new
TeeOutputStream
(
outputStream
,
new
LazyFileOutputStream
(
file
[
i
]
,
append
,
createEmptyFiles
)
)
;
managingTask
.
log
(
indent
+
file
[
i
]
,
loglevel
)
;
}
return
result
;
}
}
