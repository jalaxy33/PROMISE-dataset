package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
PrintStream
;
import
java
.
net
.
HttpURLConnection
;
import
java
.
net
.
URL
;
import
java
.
net
.
URLConnection
;
import
java
.
util
.
Date
;
public
class
Get
extends
Task
{
private
static
final
FileUtils
FILE_UTILS
=
FileUtils
.
getFileUtils
(
)
;
private
URL
source
;
private
File
dest
;
private
boolean
verbose
=
false
;
private
boolean
useTimestamp
=
false
;
private
boolean
ignoreErrors
=
false
;
private
String
uname
=
null
;
private
String
pword
=
null
;
public
void
execute
(
)
throws
BuildException
{
int
logLevel
=
Project
.
MSG_INFO
;
DownloadProgress
progress
=
null
;
if
(
verbose
)
{
progress
=
new
VerboseProgress
(
System
.
out
)
;
}
try
{
doGet
(
logLevel
,
progress
)
;
}
catch
(
IOException
ioe
)
{
log
(
"Error getting "
+
source
+
" to "
+
dest
)
;
if
(
!
ignoreErrors
)
{
throw
new
BuildException
(
ioe
,
getLocation
(
)
)
;
}
}
}
public
boolean
doGet
(
int
logLevel
,
DownloadProgress
progress
)
throws
IOException
{
if
(
source
==
null
)
{
throw
new
BuildException
(
"src attribute is required"
,
getLocation
(
)
)
;
}
if
(
dest
==
null
)
{
throw
new
BuildException
(
"dest attribute is required"
,
getLocation
(
)
)
;
}
if
(
dest
.
exists
(
)
&&
dest
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"The specified destination is a directory"
,
getLocation
(
)
)
;
}
if
(
dest
.
exists
(
)
&&
!
dest
.
canWrite
(
)
)
{
throw
new
BuildException
(
"Can't write to "
+
dest
.
getAbsolutePath
(
)
,
getLocation
(
)
)
;
}
if
(
progress
==
null
)
{
progress
=
new
NullProgress
(
)
;
}
log
(
"Getting: "
+
source
,
logLevel
)
;
log
(
"To: "
+
dest
.
getAbsolutePath
(
)
,
logLevel
)
;
long
timestamp
=
0
;
boolean
hasTimestamp
=
false
;
if
(
useTimestamp
&&
dest
.
exists
(
)
)
{
timestamp
=
dest
.
lastModified
(
)
;
if
(
verbose
)
{
Date
t
=
new
Date
(
timestamp
)
;
log
(
"local file date : "
+
t
.
toString
(
)
,
logLevel
)
;
}
hasTimestamp
=
true
;
}
URLConnection
connection
=
source
.
openConnection
(
)
;
if
(
hasTimestamp
)
{
connection
.
setIfModifiedSince
(
timestamp
)
;
}
if
(
uname
!=
null
||
pword
!=
null
)
{
String
up
=
uname
+
":"
+
pword
;
String
encoding
;
Base64Converter
encoder
=
new
Base64Converter
(
)
;
encoding
=
encoder
.
encode
(
up
.
getBytes
(
)
)
;
connection
.
setRequestProperty
(
"Authorization"
,
"Basic "
+
encoding
)
;
}
connection
.
connect
(
)
;
if
(
connection
instanceof
HttpURLConnection
)
{
HttpURLConnection
httpConnection
=
(
HttpURLConnection
)
connection
;
long
lastModified
=
httpConnection
.
getLastModified
(
)
;
if
(
httpConnection
.
getResponseCode
(
)
==
HttpURLConnection
.
HTTP_NOT_MODIFIED
||
(
lastModified
!=
0
&&
hasTimestamp
&&
timestamp
>=
lastModified
)
)
{
log
(
"Not modified - so not downloaded"
,
logLevel
)
;
return
false
;
}
if
(
httpConnection
.
getResponseCode
(
)
==
HttpURLConnection
.
HTTP_UNAUTHORIZED
)
{
String
message
=
"HTTP Authorization failure"
;
if
(
ignoreErrors
)
{
log
(
message
,
logLevel
)
;
return
false
;
}
else
{
throw
new
BuildException
(
message
)
;
}
}
}
InputStream
is
=
null
;
for
(
int
i
=
0
;
i
<
3
;
i
++
)
{
try
{
is
=
connection
.
getInputStream
(
)
;
break
;
}
catch
(
IOException
ex
)
{
log
(
"Error opening connection "
+
ex
,
logLevel
)
;
}
}
if
(
is
==
null
)
{
log
(
"Can't get "
+
source
+
" to "
+
dest
,
logLevel
)
;
if
(
ignoreErrors
)
{
return
false
;
}
throw
new
BuildException
(
"Can't get "
+
source
+
" to "
+
dest
,
getLocation
(
)
)
;
}
FileOutputStream
fos
=
new
FileOutputStream
(
dest
)
;
progress
.
beginDownload
(
)
;
boolean
finished
=
false
;
try
{
byte
[
]
buffer
=
new
byte
[
100
*
1024
]
;
int
length
;
while
(
(
length
=
is
.
read
(
buffer
)
)
>=
0
)
{
fos
.
write
(
buffer
,
0
,
length
)
;
progress
.
onTick
(
)
;
}
finished
=
true
;
}
finally
{
FileUtils
.
close
(
fos
)
;
FileUtils
.
close
(
is
)
;
if
(
!
finished
)
{
dest
.
delete
(
)
;
}
}
progress
.
endDownload
(
)
;
if
(
useTimestamp
)
{
long
remoteTimestamp
=
connection
.
getLastModified
(
)
;
if
(
verbose
)
{
Date
t
=
new
Date
(
remoteTimestamp
)
;
log
(
"last modified = "
+
t
.
toString
(
)
+
(
(
remoteTimestamp
==
0
)
?
" - using current time instead"
:
""
)
,
logLevel
)
;
}
if
(
remoteTimestamp
!=
0
)
{
FILE_UTILS
.
setFileLastModified
(
dest
,
remoteTimestamp
)
;
}
}
return
true
;
}
public
void
setSrc
(
URL
u
)
{
this
.
source
=
u
;
}
public
void
setDest
(
File
dest
)
{
this
.
dest
=
dest
;
}
public
void
setVerbose
(
boolean
v
)
{
verbose
=
v
;
}
public
void
setIgnoreErrors
(
boolean
v
)
{
ignoreErrors
=
v
;
}
public
void
setUseTimestamp
(
boolean
v
)
{
useTimestamp
=
v
;
}
public
void
setUsername
(
String
u
)
{
this
.
uname
=
u
;
}
public
void
setPassword
(
String
p
)
{
this
.
pword
=
p
;
}
protected
static
class
Base64Converter
extends
org
.
apache
.
tools
.
ant
.
util
.
Base64Converter
{
}
public
interface
DownloadProgress
{
void
beginDownload
(
)
;
void
onTick
(
)
;
void
endDownload
(
)
;
}
public
static
class
NullProgress
implements
DownloadProgress
{
public
void
beginDownload
(
)
{
}
public
void
onTick
(
)
{
}
public
void
endDownload
(
)
{
}
}
public
static
class
VerboseProgress
implements
DownloadProgress
{
private
int
dots
=
0
;
PrintStream
out
;
public
VerboseProgress
(
PrintStream
out
)
{
this
.
out
=
out
;
}
public
void
beginDownload
(
)
{
dots
=
0
;
}
public
void
onTick
(
)
{
out
.
print
(
"."
)
;
if
(
dots
++
>
50
)
{
out
.
flush
(
)
;
dots
=
0
;
}
}
public
void
endDownload
(
)
{
out
.
println
(
)
;
out
.
flush
(
)
;
}
}
}
