package
org
.
apache
.
tools
.
ant
.
taskdefs
.
optional
.
dotnet
;
import
java
.
io
.
File
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
types
.
Commandline
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
org
.
apache
.
tools
.
ant
.
types
.
EnumeratedAttribute
;
public
abstract
class
DotnetCompile
extends
DotnetBaseMatchingTask
{
private
String
references
;
private
boolean
includeDefaultReferences
=
true
;
private
File
win32icon
;
private
File
win32res
;
private
boolean
failOnError
;
private
Path
referenceFiles
;
private
boolean
optimize
;
protected
Vector
definitionList
=
new
Vector
(
)
;
protected
Vector
resources
=
new
Vector
(
)
;
protected
String
executable
;
protected
static
final
String
REFERENCE_OPTION
=
"/reference:"
;
protected
boolean
debug
;
private
int
warnLevel
;
protected
String
mainClass
;
protected
String
extraOptions
;
protected
String
targetType
;
protected
boolean
utf8output
=
false
;
protected
String
additionalModules
;
protected
Vector
referenceFilesets
=
new
Vector
(
)
;
private
boolean
useResponseFile
=
false
;
private
static
final
int
AUTOMATIC_RESPONSE_FILE_THRESHOLD
=
64
;
public
DotnetCompile
(
)
{
clear
(
)
;
setIncludes
(
getFilePattern
(
)
)
;
}
public
void
clear
(
)
{
targetType
=
null
;
win32icon
=
null
;
srcDir
=
null
;
mainClass
=
null
;
warnLevel
=
3
;
optimize
=
false
;
debug
=
true
;
references
=
null
;
failOnError
=
true
;
additionalModules
=
null
;
includeDefaultReferences
=
true
;
extraOptions
=
null
;
}
public
void
setReferences
(
String
s
)
{
references
=
s
;
}
protected
String
getReferencesParameter
(
)
{
if
(
notEmpty
(
references
)
)
{
if
(
isWindows
)
{
return
'\"'
+
REFERENCE_OPTION
+
references
+
'\"'
;
}
else
{
return
REFERENCE_OPTION
+
references
;
}
}
else
{
return
null
;
}
}
public
void
setReferenceFiles
(
Path
path
)
{
if
(
referenceFiles
==
null
)
{
referenceFiles
=
new
Path
(
this
.
getProject
(
)
)
;
}
referenceFiles
.
append
(
path
)
;
}
public
void
addReference
(
FileSet
reference
)
{
referenceFilesets
.
add
(
reference
)
;
}
protected
String
getReferenceFilesParameter
(
)
{
if
(
references
==
null
)
{
return
null
;
}
if
(
references
.
length
(
)
==
0
)
{
return
null
;
}
StringBuffer
s
=
new
StringBuffer
(
REFERENCE_OPTION
)
;
if
(
isWindows
)
{
s
.
append
(
'\"'
)
;
}
s
.
append
(
references
)
;
if
(
isWindows
)
{
s
.
append
(
'\"'
)
;
}
return
s
.
toString
(
)
;
}
public
void
setIncludeDefaultReferences
(
boolean
f
)
{
includeDefaultReferences
=
f
;
}
public
boolean
getIncludeDefaultReferences
(
)
{
return
includeDefaultReferences
;
}
protected
String
getIncludeDefaultReferencesParameter
(
)
{
return
"/nostdlib"
+
(
includeDefaultReferences
?
"-"
:
"+"
)
;
}
public
void
setOptimize
(
boolean
f
)
{
optimize
=
f
;
}
public
boolean
getOptimize
(
)
{
return
optimize
;
}
protected
String
getOptimizeParameter
(
)
{
return
"/optimize"
+
(
optimize
?
"+"
:
"-"
)
;
}
public
void
setDebug
(
boolean
f
)
{
debug
=
f
;
}
public
boolean
getDebug
(
)
{
return
debug
;
}
protected
String
getDebugParameter
(
)
{
return
"/debug"
+
(
debug
?
"+"
:
"-"
)
;
}
public
void
setWarnLevel
(
int
warnLevel
)
{
this
.
warnLevel
=
warnLevel
;
}
public
int
getWarnLevel
(
)
{
return
warnLevel
;
}
protected
String
getWarnLevelParameter
(
)
{
return
"/warn:"
+
warnLevel
;
}
public
void
setMainClass
(
String
mainClass
)
{
this
.
mainClass
=
mainClass
;
}
public
String
getMainClass
(
)
{
return
this
.
mainClass
;
}
protected
String
getMainClassParameter
(
)
{
if
(
mainClass
!=
null
&&
mainClass
.
length
(
)
!=
0
)
{
return
"/main:"
+
mainClass
;
}
else
{
return
null
;
}
}
public
void
setExtraOptions
(
String
extraOptions
)
{
this
.
extraOptions
=
extraOptions
;
}
public
String
getExtraOptions
(
)
{
return
this
.
extraOptions
;
}
protected
String
getExtraOptionsParameter
(
)
{
if
(
extraOptions
!=
null
&&
extraOptions
.
length
(
)
!=
0
)
{
return
extraOptions
;
}
else
{
return
null
;
}
}
protected
String
[
]
getExtraOptionsParameters
(
)
{
String
extra
=
getExtraOptionsParameter
(
)
;
return
extra
==
null
?
null
:
Commandline
.
translateCommandline
(
extra
)
;
}
public
void
setDestDir
(
File
dirName
)
{
log
(
"DestDir currently unused"
,
Project
.
MSG_WARN
)
;
}
public
void
setTargetType
(
TargetTypes
targetType
)
{
this
.
targetType
=
targetType
.
getValue
(
)
;
}
public
void
setTargetType
(
String
ttype
)
throws
BuildException
{
ttype
=
ttype
.
toLowerCase
(
)
;
if
(
ttype
.
equals
(
"exe"
)
||
ttype
.
equals
(
"library"
)
||
ttype
.
equals
(
"module"
)
||
ttype
.
equals
(
"winexe"
)
)
{
targetType
=
ttype
;
}
else
{
throw
new
BuildException
(
"targetType "
+
ttype
+
" is not one of 'exe', 'module', 'winexe' or 'library'"
)
;
}
}
public
String
getTargetType
(
)
{
return
targetType
;
}
protected
String
getTargetTypeParameter
(
)
{
if
(
notEmpty
(
targetType
)
)
{
return
"/target:"
+
targetType
;
}
else
{
return
null
;
}
}
public
void
setWin32Icon
(
File
fileName
)
{
win32icon
=
fileName
;
}
protected
String
getWin32IconParameter
(
)
{
if
(
win32icon
!=
null
)
{
return
"/win32icon:"
+
win32icon
.
toString
(
)
;
}
else
{
return
null
;
}
}
public
void
setWin32Res
(
File
fileName
)
{
win32res
=
fileName
;
}
public
File
getWin32Res
(
)
{
return
win32res
;
}
protected
String
getWin32ResParameter
(
)
{
if
(
win32res
!=
null
)
{
return
"/win32res:"
+
win32res
.
toString
(
)
;
}
else
{
return
null
;
}
}
public
void
setUtf8Output
(
boolean
enabled
)
{
utf8output
=
enabled
;
}
protected
String
getUtf8OutputParameter
(
)
{
return
utf8output
?
"/utf8output"
:
null
;
}
public
void
addDefine
(
DotnetDefine
define
)
{
definitionList
.
addElement
(
define
)
;
}
protected
String
getDefinitionsParameter
(
)
throws
BuildException
{
StringBuffer
defines
=
new
StringBuffer
(
)
;
Enumeration
defEnum
=
definitionList
.
elements
(
)
;
boolean
firstDefinition
=
true
;
while
(
defEnum
.
hasMoreElements
(
)
)
{
DotnetDefine
define
=
(
DotnetDefine
)
defEnum
.
nextElement
(
)
;
if
(
define
.
isSet
(
this
)
)
{
if
(
!
firstDefinition
)
{
defines
.
append
(
getDefinitionsDelimiter
(
)
)
;
}
defines
.
append
(
define
.
getValue
(
this
)
)
;
firstDefinition
=
false
;
}
}
if
(
defines
.
length
(
)
==
0
)
{
return
null
;
}
else
{
return
"/d:"
+
defines
;
}
}
public
void
setAdditionalModules
(
String
params
)
{
additionalModules
=
params
;
}
protected
String
getAdditionalModulesParameter
(
)
{
if
(
notEmpty
(
additionalModules
)
)
{
return
"/addmodule:"
+
additionalModules
;
}
else
{
return
null
;
}
}
protected
String
getDestFileParameter
(
)
{
if
(
outputFile
!=
null
)
{
return
"/out:"
+
outputFile
.
toString
(
)
;
}
else
{
return
null
;
}
}
public
void
setFailOnError
(
boolean
b
)
{
failOnError
=
b
;
}
public
boolean
getFailOnError
(
)
{
return
failOnError
;
}
public
void
addResource
(
DotnetResource
resource
)
{
resources
.
add
(
resource
)
;
}
protected
String
getExecutable
(
)
{
return
executable
;
}
public
void
setExecutable
(
String
executable
)
{
this
.
executable
=
executable
;
}
protected
boolean
notEmpty
(
String
s
)
{
return
s
!=
null
&&
s
.
length
(
)
!=
0
;
}
protected
void
validate
(
)
throws
BuildException
{
if
(
outputFile
!=
null
&&
outputFile
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"destFile cannot be a directory"
)
;
}
if
(
getExecutable
(
)
==
null
)
{
throw
new
BuildException
(
"There is no executable defined for this task"
)
;
}
}
public
String
getFilePattern
(
)
{
return
"**/*."
+
getFileExtension
(
)
;
}
public
boolean
isUseResponseFile
(
)
{
return
useResponseFile
;
}
public
void
setUseResponseFile
(
boolean
useResponseFile
)
{
this
.
useResponseFile
=
useResponseFile
;
}
public
void
execute
(
)
throws
BuildException
{
log
(
"This task is deprecated and will be removed in a future version\n"
+
"of Ant.  It is now part of the .NET Antlib:\n"
+
"http://ant.apache.org/antlibs/dotnet/index.html"
,
Project
.
MSG_WARN
)
;
validate
(
)
;
NetCommand
command
=
createNetCommand
(
)
;
command
.
setAutomaticResponseFileThreshold
(
AUTOMATIC_RESPONSE_FILE_THRESHOLD
)
;
command
.
setUseResponseFile
(
useResponseFile
)
;
fillInSharedParameters
(
command
)
;
addResources
(
command
)
;
addCompilerSpecificOptions
(
command
)
;
int
referencesOutOfDate
=
addReferenceFilesets
(
command
,
getOutputFileTimestamp
(
)
)
;
boolean
forceBuild
=
referencesOutOfDate
>
0
;
addFilesAndExecute
(
command
,
forceBuild
)
;
}
public
abstract
String
getReferenceDelimiter
(
)
;
public
abstract
String
getFileExtension
(
)
;
protected
void
fillInSharedParameters
(
NetCommand
command
)
{
command
.
setFailOnError
(
getFailOnError
(
)
)
;
command
.
addArgument
(
"/nologo"
)
;
command
.
addArgument
(
getAdditionalModulesParameter
(
)
)
;
command
.
addArgument
(
getDebugParameter
(
)
)
;
command
.
addArgument
(
getDefinitionsParameter
(
)
)
;
command
.
addArguments
(
getExtraOptionsParameters
(
)
)
;
command
.
addArgument
(
getMainClassParameter
(
)
)
;
command
.
addArgument
(
getOptimizeParameter
(
)
)
;
command
.
addArgument
(
getDestFileParameter
(
)
)
;
command
.
addArgument
(
getReferencesParameter
(
)
)
;
command
.
addArgument
(
getTargetTypeParameter
(
)
)
;
command
.
addArgument
(
getUtf8OutputParameter
(
)
)
;
command
.
addArgument
(
getWin32IconParameter
(
)
)
;
command
.
addArgument
(
getWin32ResParameter
(
)
)
;
}
protected
void
addResources
(
NetCommand
command
)
{
Enumeration
e
=
resources
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
DotnetResource
resource
=
(
DotnetResource
)
e
.
nextElement
(
)
;
createResourceParameter
(
command
,
resource
)
;
}
}
protected
abstract
void
createResourceParameter
(
NetCommand
command
,
DotnetResource
resource
)
;
protected
int
addReferenceFilesets
(
NetCommand
command
,
long
outputTimestamp
)
{
int
filesOutOfDate
=
0
;
Hashtable
filesToBuild
=
new
Hashtable
(
)
;
for
(
int
i
=
0
;
i
<
referenceFilesets
.
size
(
)
;
i
++
)
{
FileSet
fs
=
(
FileSet
)
referenceFilesets
.
elementAt
(
i
)
;
filesOutOfDate
+=
command
.
scanOneFileset
(
fs
.
getDirectoryScanner
(
getProject
(
)
)
,
filesToBuild
,
outputTimestamp
)
;
}
if
(
filesToBuild
.
size
(
)
==
0
)
{
return
0
;
}
Enumeration
files
=
filesToBuild
.
elements
(
)
;
while
(
files
.
hasMoreElements
(
)
)
{
File
file
=
(
File
)
files
.
nextElement
(
)
;
if
(
isFileManagedBinary
(
file
)
)
{
if
(
isWindows
)
{
command
.
addArgument
(
'"'
+
REFERENCE_OPTION
+
file
.
toString
(
)
+
'"'
)
;
}
else
{
command
.
addArgument
(
REFERENCE_OPTION
+
file
.
toString
(
)
)
;
}
}
else
{
log
(
"ignoring "
+
file
+
" as it is not a managed executable"
,
Project
.
MSG_VERBOSE
)
;
}
}
return
filesOutOfDate
;
}
protected
NetCommand
createNetCommand
(
)
{
NetCommand
command
=
new
NetCommand
(
this
,
getTaskName
(
)
,
getExecutable
(
)
)
;
return
command
;
}
protected
abstract
void
addCompilerSpecificOptions
(
NetCommand
command
)
;
public
String
getDefinitionsDelimiter
(
)
{
return
";"
;
}
protected
static
boolean
isFileManagedBinary
(
File
file
)
{
String
filename
=
file
.
toString
(
)
.
toLowerCase
(
)
;
return
filename
.
endsWith
(
".exe"
)
||
filename
.
endsWith
(
".dll"
)
||
filename
.
endsWith
(
".netmodule"
)
;
}
public
static
class
TargetTypes
extends
EnumeratedAttribute
{
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
"exe"
,
"library"
,
"module"
,
"winexe"
}
;
}
}
}
