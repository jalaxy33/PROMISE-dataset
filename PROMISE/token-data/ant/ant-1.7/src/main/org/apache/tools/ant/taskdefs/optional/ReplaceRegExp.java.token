package
org
.
apache
.
tools
.
ant
.
taskdefs
.
optional
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FileWriter
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
PrintWriter
;
import
java
.
io
.
Reader
;
import
java
.
io
.
Writer
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
org
.
apache
.
tools
.
ant
.
types
.
RegularExpression
;
import
org
.
apache
.
tools
.
ant
.
types
.
Substitution
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
import
org
.
apache
.
tools
.
ant
.
util
.
regexp
.
Regexp
;
public
class
ReplaceRegExp
extends
Task
{
private
File
file
;
private
String
flags
;
private
boolean
byline
;
private
Vector
filesets
;
private
RegularExpression
regex
;
private
Substitution
subs
;
private
static
final
FileUtils
FILE_UTILS
=
FileUtils
.
getFileUtils
(
)
;
private
String
encoding
=
null
;
public
ReplaceRegExp
(
)
{
super
(
)
;
this
.
file
=
null
;
this
.
filesets
=
new
Vector
(
)
;
this
.
flags
=
""
;
this
.
byline
=
false
;
this
.
regex
=
null
;
this
.
subs
=
null
;
}
public
void
setFile
(
File
file
)
{
this
.
file
=
file
;
}
public
void
setMatch
(
String
match
)
{
if
(
regex
!=
null
)
{
throw
new
BuildException
(
"Only one regular expression is allowed"
)
;
}
regex
=
new
RegularExpression
(
)
;
regex
.
setPattern
(
match
)
;
}
public
void
setReplace
(
String
replace
)
{
if
(
subs
!=
null
)
{
throw
new
BuildException
(
"Only one substitution expression is "
+
"allowed"
)
;
}
subs
=
new
Substitution
(
)
;
subs
.
setExpression
(
replace
)
;
}
public
void
setFlags
(
String
flags
)
{
this
.
flags
=
flags
;
}
public
void
setByLine
(
String
byline
)
{
Boolean
res
=
Boolean
.
valueOf
(
byline
)
;
if
(
res
==
null
)
{
res
=
Boolean
.
FALSE
;
}
this
.
byline
=
res
.
booleanValue
(
)
;
}
public
void
setByLine
(
boolean
byline
)
{
this
.
byline
=
byline
;
}
public
void
setEncoding
(
String
encoding
)
{
this
.
encoding
=
encoding
;
}
public
void
addFileset
(
FileSet
set
)
{
filesets
.
addElement
(
set
)
;
}
public
RegularExpression
createRegexp
(
)
{
if
(
regex
!=
null
)
{
throw
new
BuildException
(
"Only one regular expression is allowed."
)
;
}
regex
=
new
RegularExpression
(
)
;
return
regex
;
}
public
Substitution
createSubstitution
(
)
{
if
(
subs
!=
null
)
{
throw
new
BuildException
(
"Only one substitution expression is "
+
"allowed"
)
;
}
subs
=
new
Substitution
(
)
;
return
subs
;
}
protected
String
doReplace
(
RegularExpression
r
,
Substitution
s
,
String
input
,
int
options
)
{
String
res
=
input
;
Regexp
regexp
=
r
.
getRegexp
(
getProject
(
)
)
;
if
(
regexp
.
matches
(
input
,
options
)
)
{
log
(
"Found match; substituting"
,
Project
.
MSG_DEBUG
)
;
res
=
regexp
.
substitute
(
input
,
s
.
getExpression
(
getProject
(
)
)
,
options
)
;
}
return
res
;
}
protected
void
doReplace
(
File
f
,
int
options
)
throws
IOException
{
File
temp
=
FILE_UTILS
.
createTempFile
(
"replace"
,
".txt"
,
null
)
;
temp
.
deleteOnExit
(
)
;
Reader
r
=
null
;
Writer
w
=
null
;
try
{
if
(
encoding
==
null
)
{
r
=
new
FileReader
(
f
)
;
w
=
new
FileWriter
(
temp
)
;
}
else
{
r
=
new
InputStreamReader
(
new
FileInputStream
(
f
)
,
encoding
)
;
w
=
new
OutputStreamWriter
(
new
FileOutputStream
(
temp
)
,
encoding
)
;
}
BufferedReader
br
=
new
BufferedReader
(
r
)
;
BufferedWriter
bw
=
new
BufferedWriter
(
w
)
;
PrintWriter
pw
=
new
PrintWriter
(
bw
)
;
boolean
changes
=
false
;
log
(
"Replacing pattern '"
+
regex
.
getPattern
(
getProject
(
)
)
+
"' with '"
+
subs
.
getExpression
(
getProject
(
)
)
+
"' in '"
+
f
.
getPath
(
)
+
"'"
+
(
byline
?
" by line"
:
""
)
+
(
flags
.
length
(
)
>
0
?
" with flags: '"
+
flags
+
"'"
:
""
)
+
"."
,
Project
.
MSG_VERBOSE
)
;
if
(
byline
)
{
StringBuffer
linebuf
=
new
StringBuffer
(
)
;
String
line
=
null
;
String
res
=
null
;
int
c
;
boolean
hasCR
=
false
;
do
{
c
=
br
.
read
(
)
;
if
(
c
==
'\r'
)
{
if
(
hasCR
)
{
line
=
linebuf
.
toString
(
)
;
res
=
doReplace
(
regex
,
subs
,
line
,
options
)
;
if
(
!
res
.
equals
(
line
)
)
{
changes
=
true
;
}
pw
.
print
(
res
)
;
pw
.
print
(
'\r'
)
;
linebuf
=
new
StringBuffer
(
)
;
}
else
{
hasCR
=
true
;
}
}
else
if
(
c
==
'\n'
)
{
line
=
linebuf
.
toString
(
)
;
res
=
doReplace
(
regex
,
subs
,
line
,
options
)
;
if
(
!
res
.
equals
(
line
)
)
{
changes
=
true
;
}
pw
.
print
(
res
)
;
if
(
hasCR
)
{
pw
.
print
(
'\r'
)
;
hasCR
=
false
;
}
pw
.
print
(
'\n'
)
;
linebuf
=
new
StringBuffer
(
)
;
}
else
{
if
(
(
hasCR
)
||
(
c
<
0
)
)
{
line
=
linebuf
.
toString
(
)
;
res
=
doReplace
(
regex
,
subs
,
line
,
options
)
;
if
(
!
res
.
equals
(
line
)
)
{
changes
=
true
;
}
pw
.
print
(
res
)
;
if
(
hasCR
)
{
pw
.
print
(
'\r'
)
;
hasCR
=
false
;
}
linebuf
=
new
StringBuffer
(
)
;
}
if
(
c
>=
0
)
{
linebuf
.
append
(
(
char
)
c
)
;
}
}
}
while
(
c
>=
0
)
;
pw
.
flush
(
)
;
}
else
{
String
buf
=
FileUtils
.
readFully
(
br
)
;
if
(
buf
==
null
)
{
buf
=
""
;
}
String
res
=
doReplace
(
regex
,
subs
,
buf
,
options
)
;
if
(
!
res
.
equals
(
buf
)
)
{
changes
=
true
;
}
pw
.
print
(
res
)
;
pw
.
flush
(
)
;
}
r
.
close
(
)
;
r
=
null
;
w
.
close
(
)
;
w
=
null
;
if
(
changes
)
{
log
(
"File has changed; saving the updated file"
,
Project
.
MSG_VERBOSE
)
;
try
{
FILE_UTILS
.
rename
(
temp
,
f
)
;
temp
=
null
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
"Couldn't rename temporary file "
+
temp
,
getLocation
(
)
)
;
}
}
else
{
log
(
"No change made"
,
Project
.
MSG_DEBUG
)
;
}
}
finally
{
FileUtils
.
close
(
r
)
;
FileUtils
.
close
(
w
)
;
if
(
temp
!=
null
)
{
temp
.
delete
(
)
;
}
}
}
public
void
execute
(
)
throws
BuildException
{
if
(
regex
==
null
)
{
throw
new
BuildException
(
"No expression to match."
)
;
}
if
(
subs
==
null
)
{
throw
new
BuildException
(
"Nothing to replace expression with."
)
;
}
if
(
file
!=
null
&&
filesets
.
size
(
)
>
0
)
{
throw
new
BuildException
(
"You cannot supply the 'file' attribute "
+
"and filesets at the same time."
)
;
}
int
options
=
0
;
if
(
flags
.
indexOf
(
'g'
)
!=
-
1
)
{
options
|=
Regexp
.
REPLACE_ALL
;
}
if
(
flags
.
indexOf
(
'i'
)
!=
-
1
)
{
options
|=
Regexp
.
MATCH_CASE_INSENSITIVE
;
}
if
(
flags
.
indexOf
(
'm'
)
!=
-
1
)
{
options
|=
Regexp
.
MATCH_MULTILINE
;
}
if
(
flags
.
indexOf
(
's'
)
!=
-
1
)
{
options
|=
Regexp
.
MATCH_SINGLELINE
;
}
if
(
file
!=
null
&&
file
.
exists
(
)
)
{
try
{
doReplace
(
file
,
options
)
;
}
catch
(
IOException
e
)
{
log
(
"An error occurred processing file: '"
+
file
.
getAbsolutePath
(
)
+
"': "
+
e
.
toString
(
)
,
Project
.
MSG_ERR
)
;
}
}
else
if
(
file
!=
null
)
{
log
(
"The following file is missing: '"
+
file
.
getAbsolutePath
(
)
+
"'"
,
Project
.
MSG_ERR
)
;
}
int
sz
=
filesets
.
size
(
)
;
for
(
int
i
=
0
;
i
<
sz
;
i
++
)
{
FileSet
fs
=
(
FileSet
)
(
filesets
.
elementAt
(
i
)
)
;
DirectoryScanner
ds
=
fs
.
getDirectoryScanner
(
getProject
(
)
)
;
String
[
]
files
=
ds
.
getIncludedFiles
(
)
;
for
(
int
j
=
0
;
j
<
files
.
length
;
j
++
)
{
File
f
=
new
File
(
fs
.
getDir
(
getProject
(
)
)
,
files
[
j
]
)
;
if
(
f
.
exists
(
)
)
{
try
{
doReplace
(
f
,
options
)
;
}
catch
(
Exception
e
)
{
log
(
"An error occurred processing file: '"
+
f
.
getAbsolutePath
(
)
+
"': "
+
e
.
toString
(
)
,
Project
.
MSG_ERR
)
;
}
}
else
{
log
(
"The following file is missing: '"
+
f
.
getAbsolutePath
(
)
+
"'"
,
Project
.
MSG_ERR
)
;
}
}
}
}
}
