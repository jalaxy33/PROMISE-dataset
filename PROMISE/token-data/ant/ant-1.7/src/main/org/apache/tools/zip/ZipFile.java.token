package
org
.
apache
.
tools
.
zip
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
RandomAccessFile
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
util
.
Calendar
;
import
java
.
util
.
Date
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
zip
.
Inflater
;
import
java
.
util
.
zip
.
InflaterInputStream
;
import
java
.
util
.
zip
.
ZipException
;
public
class
ZipFile
{
private
Hashtable
entries
=
new
Hashtable
(
509
)
;
private
Hashtable
nameMap
=
new
Hashtable
(
509
)
;
private
static
final
class
OffsetEntry
{
private
long
headerOffset
=
-
1
;
private
long
dataOffset
=
-
1
;
}
private
String
encoding
=
null
;
private
RandomAccessFile
archive
;
public
ZipFile
(
File
f
)
throws
IOException
{
this
(
f
,
null
)
;
}
public
ZipFile
(
String
name
)
throws
IOException
{
this
(
new
File
(
name
)
,
null
)
;
}
public
ZipFile
(
String
name
,
String
encoding
)
throws
IOException
{
this
(
new
File
(
name
)
,
encoding
)
;
}
public
ZipFile
(
File
f
,
String
encoding
)
throws
IOException
{
this
.
encoding
=
encoding
;
archive
=
new
RandomAccessFile
(
f
,
"r"
)
;
try
{
populateFromCentralDirectory
(
)
;
resolveLocalFileHeaderData
(
)
;
}
catch
(
IOException
e
)
{
try
{
archive
.
close
(
)
;
}
catch
(
IOException
e2
)
{
}
throw
e
;
}
}
public
String
getEncoding
(
)
{
return
encoding
;
}
public
void
close
(
)
throws
IOException
{
archive
.
close
(
)
;
}
public
static
void
closeQuietly
(
ZipFile
zipfile
)
{
if
(
zipfile
!=
null
)
{
try
{
zipfile
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
}
public
Enumeration
getEntries
(
)
{
return
entries
.
keys
(
)
;
}
public
ZipEntry
getEntry
(
String
name
)
{
return
(
ZipEntry
)
nameMap
.
get
(
name
)
;
}
public
InputStream
getInputStream
(
ZipEntry
ze
)
throws
IOException
,
ZipException
{
OffsetEntry
offsetEntry
=
(
OffsetEntry
)
entries
.
get
(
ze
)
;
if
(
offsetEntry
==
null
)
{
return
null
;
}
long
start
=
offsetEntry
.
dataOffset
;
BoundedInputStream
bis
=
new
BoundedInputStream
(
start
,
ze
.
getCompressedSize
(
)
)
;
switch
(
ze
.
getMethod
(
)
)
{
case
ZipEntry
.
STORED
:
return
bis
;
case
ZipEntry
.
DEFLATED
:
bis
.
addDummy
(
)
;
return
new
InflaterInputStream
(
bis
,
new
Inflater
(
true
)
)
;
default
:
throw
new
ZipException
(
"Found unsupported compression method "
+
ze
.
getMethod
(
)
)
;
}
}
private
static
final
int
CFH_LEN
=
2
+
2
+
2
+
2
+
2
+
2
+
4
+
4
+
4
+
2
+
2
+
2
+
2
+
2
+
4
+
4
;
private
void
populateFromCentralDirectory
(
)
throws
IOException
{
positionAtCentralDirectory
(
)
;
byte
[
]
cfh
=
new
byte
[
CFH_LEN
]
;
byte
[
]
signatureBytes
=
new
byte
[
4
]
;
archive
.
readFully
(
signatureBytes
)
;
long
sig
=
ZipLong
.
getValue
(
signatureBytes
)
;
final
long
cfhSig
=
ZipLong
.
getValue
(
ZipOutputStream
.
CFH_SIG
)
;
while
(
sig
==
cfhSig
)
{
archive
.
readFully
(
cfh
)
;
int
off
=
0
;
ZipEntry
ze
=
new
ZipEntry
(
)
;
int
versionMadeBy
=
ZipShort
.
getValue
(
cfh
,
off
)
;
off
+=
2
;
ze
.
setPlatform
(
(
versionMadeBy
>
>
8
)
&
0x0F
)
;
off
+=
4
;
ze
.
setMethod
(
ZipShort
.
getValue
(
cfh
,
off
)
)
;
off
+=
2
;
long
time
=
dosToJavaTime
(
ZipLong
.
getValue
(
cfh
,
off
)
)
;
ze
.
setTime
(
time
)
;
off
+=
4
;
ze
.
setCrc
(
ZipLong
.
getValue
(
cfh
,
off
)
)
;
off
+=
4
;
ze
.
setCompressedSize
(
ZipLong
.
getValue
(
cfh
,
off
)
)
;
off
+=
4
;
ze
.
setSize
(
ZipLong
.
getValue
(
cfh
,
off
)
)
;
off
+=
4
;
int
fileNameLen
=
ZipShort
.
getValue
(
cfh
,
off
)
;
off
+=
2
;
int
extraLen
=
ZipShort
.
getValue
(
cfh
,
off
)
;
off
+=
2
;
int
commentLen
=
ZipShort
.
getValue
(
cfh
,
off
)
;
off
+=
2
;
off
+=
2
;
ze
.
setInternalAttributes
(
ZipShort
.
getValue
(
cfh
,
off
)
)
;
off
+=
2
;
ze
.
setExternalAttributes
(
ZipLong
.
getValue
(
cfh
,
off
)
)
;
off
+=
4
;
byte
[
]
fileName
=
new
byte
[
fileNameLen
]
;
archive
.
readFully
(
fileName
)
;
ze
.
setName
(
getString
(
fileName
)
)
;
OffsetEntry
offset
=
new
OffsetEntry
(
)
;
offset
.
headerOffset
=
ZipLong
.
getValue
(
cfh
,
off
)
;
entries
.
put
(
ze
,
offset
)
;
nameMap
.
put
(
ze
.
getName
(
)
,
ze
)
;
archive
.
skipBytes
(
extraLen
)
;
byte
[
]
comment
=
new
byte
[
commentLen
]
;
archive
.
readFully
(
comment
)
;
ze
.
setComment
(
getString
(
comment
)
)
;
archive
.
readFully
(
signatureBytes
)
;
sig
=
ZipLong
.
getValue
(
signatureBytes
)
;
}
}
private
static
final
int
MIN_EOCD_SIZE
=
4
+
2
+
2
+
2
+
2
+
4
+
4
+
2
;
private
static
final
int
CFD_LOCATOR_OFFSET
=
4
+
2
+
2
+
2
+
2
+
4
;
private
void
positionAtCentralDirectory
(
)
throws
IOException
{
boolean
found
=
false
;
long
off
=
archive
.
length
(
)
-
MIN_EOCD_SIZE
;
if
(
off
>=
0
)
{
archive
.
seek
(
off
)
;
byte
[
]
sig
=
ZipOutputStream
.
EOCD_SIG
;
int
curr
=
archive
.
read
(
)
;
while
(
curr
!=
-
1
)
{
if
(
curr
==
sig
[
0
]
)
{
curr
=
archive
.
read
(
)
;
if
(
curr
==
sig
[
1
]
)
{
curr
=
archive
.
read
(
)
;
if
(
curr
==
sig
[
2
]
)
{
curr
=
archive
.
read
(
)
;
if
(
curr
==
sig
[
3
]
)
{
found
=
true
;
break
;
}
}
}
}
archive
.
seek
(
--
off
)
;
curr
=
archive
.
read
(
)
;
}
}
if
(
!
found
)
{
throw
new
ZipException
(
"archive is not a ZIP archive"
)
;
}
archive
.
seek
(
off
+
CFD_LOCATOR_OFFSET
)
;
byte
[
]
cfdOffset
=
new
byte
[
4
]
;
archive
.
readFully
(
cfdOffset
)
;
archive
.
seek
(
ZipLong
.
getValue
(
cfdOffset
)
)
;
}
private
static
final
long
LFH_OFFSET_FOR_FILENAME_LENGTH
=
4
+
2
+
2
+
2
+
2
+
2
+
4
+
4
+
4
;
private
void
resolveLocalFileHeaderData
(
)
throws
IOException
{
Enumeration
e
=
getEntries
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
ZipEntry
ze
=
(
ZipEntry
)
e
.
nextElement
(
)
;
OffsetEntry
offsetEntry
=
(
OffsetEntry
)
entries
.
get
(
ze
)
;
long
offset
=
offsetEntry
.
headerOffset
;
archive
.
seek
(
offset
+
LFH_OFFSET_FOR_FILENAME_LENGTH
)
;
byte
[
]
b
=
new
byte
[
2
]
;
archive
.
readFully
(
b
)
;
int
fileNameLen
=
ZipShort
.
getValue
(
b
)
;
archive
.
readFully
(
b
)
;
int
extraFieldLen
=
ZipShort
.
getValue
(
b
)
;
archive
.
skipBytes
(
fileNameLen
)
;
byte
[
]
localExtraData
=
new
byte
[
extraFieldLen
]
;
archive
.
readFully
(
localExtraData
)
;
ze
.
setExtra
(
localExtraData
)
;
offsetEntry
.
dataOffset
=
offset
+
LFH_OFFSET_FOR_FILENAME_LENGTH
+
2
+
2
+
fileNameLen
+
extraFieldLen
;
}
}
protected
static
Date
fromDosTime
(
ZipLong
zipDosTime
)
{
long
dosTime
=
zipDosTime
.
getValue
(
)
;
return
new
Date
(
dosToJavaTime
(
dosTime
)
)
;
}
private
static
long
dosToJavaTime
(
long
dosTime
)
{
Calendar
cal
=
Calendar
.
getInstance
(
)
;
cal
.
set
(
Calendar
.
YEAR
,
(
int
)
(
(
dosTime
>
>
25
)
&
0x7f
)
+
1980
)
;
cal
.
set
(
Calendar
.
MONTH
,
(
int
)
(
(
dosTime
>
>
21
)
&
0x0f
)
-
1
)
;
cal
.
set
(
Calendar
.
DATE
,
(
int
)
(
dosTime
>
>
16
)
&
0x1f
)
;
cal
.
set
(
Calendar
.
HOUR_OF_DAY
,
(
int
)
(
dosTime
>
>
11
)
&
0x1f
)
;
cal
.
set
(
Calendar
.
MINUTE
,
(
int
)
(
dosTime
>
>
5
)
&
0x3f
)
;
cal
.
set
(
Calendar
.
SECOND
,
(
int
)
(
dosTime
<<
1
)
&
0x3e
)
;
return
cal
.
getTime
(
)
.
getTime
(
)
;
}
protected
String
getString
(
byte
[
]
bytes
)
throws
ZipException
{
if
(
encoding
==
null
)
{
return
new
String
(
bytes
)
;
}
else
{
try
{
return
new
String
(
bytes
,
encoding
)
;
}
catch
(
UnsupportedEncodingException
uee
)
{
throw
new
ZipException
(
uee
.
getMessage
(
)
)
;
}
}
}
private
class
BoundedInputStream
extends
InputStream
{
private
long
remaining
;
private
long
loc
;
private
boolean
addDummyByte
=
false
;
BoundedInputStream
(
long
start
,
long
remaining
)
{
this
.
remaining
=
remaining
;
loc
=
start
;
}
public
int
read
(
)
throws
IOException
{
if
(
remaining
--
<=
0
)
{
if
(
addDummyByte
)
{
addDummyByte
=
false
;
return
0
;
}
return
-
1
;
}
synchronized
(
archive
)
{
archive
.
seek
(
loc
++
)
;
return
archive
.
read
(
)
;
}
}
public
int
read
(
byte
[
]
b
,
int
off
,
int
len
)
throws
IOException
{
if
(
remaining
<=
0
)
{
if
(
addDummyByte
)
{
addDummyByte
=
false
;
b
[
off
]
=
0
;
return
1
;
}
return
-
1
;
}
if
(
len
<=
0
)
{
return
0
;
}
if
(
len
>
remaining
)
{
len
=
(
int
)
remaining
;
}
int
ret
=
-
1
;
synchronized
(
archive
)
{
archive
.
seek
(
loc
)
;
ret
=
archive
.
read
(
b
,
off
,
len
)
;
}
if
(
ret
>
0
)
{
loc
+=
ret
;
remaining
-=
ret
;
}
return
ret
;
}
void
addDummy
(
)
{
addDummyByte
=
true
;
}
}
}
