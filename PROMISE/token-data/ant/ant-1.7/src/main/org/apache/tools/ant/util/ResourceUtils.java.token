package
org
.
apache
.
tools
.
ant
.
util
;
import
java
.
io
.
File
;
import
java
.
io
.
Reader
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Iterator
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
ProjectComponent
;
import
org
.
apache
.
tools
.
ant
.
filters
.
util
.
ChainReaderHelper
;
import
org
.
apache
.
tools
.
ant
.
types
.
Resource
;
import
org
.
apache
.
tools
.
ant
.
types
.
TimeComparison
;
import
org
.
apache
.
tools
.
ant
.
types
.
ResourceFactory
;
import
org
.
apache
.
tools
.
ant
.
types
.
ResourceCollection
;
import
org
.
apache
.
tools
.
ant
.
types
.
FilterSetCollection
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
Union
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
Restrict
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
Resources
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
Touchable
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Or
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
And
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Not
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Date
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Type
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
Exists
;
import
org
.
apache
.
tools
.
ant
.
types
.
resources
.
selectors
.
ResourceSelector
;
import
org
.
apache
.
tools
.
ant
.
types
.
selectors
.
SelectorUtils
;
public
class
ResourceUtils
{
private
static
final
class
Outdated
implements
ResourceSelector
{
private
Resource
control
;
private
long
granularity
;
private
Outdated
(
Resource
control
,
long
granularity
)
{
this
.
control
=
control
;
this
.
granularity
=
granularity
;
}
public
boolean
isSelected
(
Resource
r
)
{
return
SelectorUtils
.
isOutOfDate
(
control
,
r
,
granularity
)
;
}
}
private
static
final
FileUtils
FILE_UTILS
=
FileUtils
.
getFileUtils
(
)
;
private
static
final
ResourceSelector
NOT_EXISTS
=
new
Not
(
new
Exists
(
)
)
;
public
static
Resource
[
]
selectOutOfDateSources
(
ProjectComponent
logTo
,
Resource
[
]
source
,
FileNameMapper
mapper
,
ResourceFactory
targets
)
{
return
selectOutOfDateSources
(
logTo
,
source
,
mapper
,
targets
,
FILE_UTILS
.
getFileTimestampGranularity
(
)
)
;
}
public
static
Resource
[
]
selectOutOfDateSources
(
ProjectComponent
logTo
,
Resource
[
]
source
,
FileNameMapper
mapper
,
ResourceFactory
targets
,
long
granularity
)
{
Union
u
=
new
Union
(
)
;
u
.
addAll
(
Arrays
.
asList
(
source
)
)
;
ResourceCollection
rc
=
selectOutOfDateSources
(
logTo
,
u
,
mapper
,
targets
,
granularity
)
;
return
rc
.
size
(
)
==
0
?
new
Resource
[
0
]
:
(
(
Union
)
rc
)
.
listResources
(
)
;
}
public
static
ResourceCollection
selectOutOfDateSources
(
ProjectComponent
logTo
,
ResourceCollection
source
,
FileNameMapper
mapper
,
ResourceFactory
targets
,
long
granularity
)
{
if
(
source
.
size
(
)
==
0
)
{
logTo
.
log
(
"No sources found."
,
Project
.
MSG_VERBOSE
)
;
return
Resources
.
NONE
;
}
source
=
Union
.
getInstance
(
source
)
;
logFuture
(
logTo
,
source
,
granularity
)
;
Union
result
=
new
Union
(
)
;
for
(
Iterator
iter
=
source
.
iterator
(
)
;
iter
.
hasNext
(
)
;
)
{
Resource
sr
=
(
Resource
)
iter
.
next
(
)
;
String
srName
=
sr
.
getName
(
)
;
srName
=
srName
==
null
?
srName
:
srName
.
replace
(
'/'
,
File
.
separatorChar
)
;
String
[
]
targetnames
=
null
;
try
{
targetnames
=
mapper
.
mapFileName
(
srName
)
;
}
catch
(
Exception
e
)
{
logTo
.
log
(
"Caught "
+
e
+
" mapping resource "
+
sr
,
Project
.
MSG_VERBOSE
)
;
}
if
(
targetnames
==
null
||
targetnames
.
length
==
0
)
{
logTo
.
log
(
sr
+
" skipped - don\'t know how to handle it"
,
Project
.
MSG_VERBOSE
)
;
continue
;
}
Union
targetColl
=
new
Union
(
)
;
for
(
int
i
=
0
;
i
<
targetnames
.
length
;
i
++
)
{
targetColl
.
add
(
targets
.
getResource
(
targetnames
[
i
]
.
replace
(
File
.
separatorChar
,
'/'
)
)
)
;
}
Restrict
r
=
new
Restrict
(
)
;
r
.
add
(
new
And
(
new
ResourceSelector
[
]
{
Type
.
FILE
,
new
Or
(
new
ResourceSelector
[
]
{
NOT_EXISTS
,
new
Outdated
(
sr
,
granularity
)
}
)
}
)
)
;
r
.
add
(
targetColl
)
;
if
(
r
.
size
(
)
>
0
)
{
result
.
add
(
sr
)
;
Resource
t
=
(
Resource
)
(
r
.
iterator
(
)
.
next
(
)
)
;
logTo
.
log
(
sr
.
getName
(
)
+
" added as "
+
t
.
getName
(
)
+
(
t
.
isExists
(
)
?
" is outdated."
:
" doesn\'t exist."
)
,
Project
.
MSG_VERBOSE
)
;
continue
;
}
logTo
.
log
(
sr
.
getName
(
)
+
" omitted as "
+
targetColl
.
toString
(
)
+
(
targetColl
.
size
(
)
==
1
?
" is"
:
" are "
)
+
" up to date."
,
Project
.
MSG_VERBOSE
)
;
}
return
result
;
}
public
static
void
copyResource
(
Resource
source
,
Resource
dest
)
throws
IOException
{
copyResource
(
source
,
dest
,
null
)
;
}
public
static
void
copyResource
(
Resource
source
,
Resource
dest
,
Project
project
)
throws
IOException
{
copyResource
(
source
,
dest
,
null
,
null
,
false
,
false
,
null
,
null
,
project
)
;
}
public
static
void
copyResource
(
Resource
source
,
Resource
dest
,
FilterSetCollection
filters
,
Vector
filterChains
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
inputEncoding
,
String
outputEncoding
,
Project
project
)
throws
IOException
{
if
(
!
overwrite
)
{
long
slm
=
source
.
getLastModified
(
)
;
if
(
dest
.
isExists
(
)
&&
slm
!=
0
&&
dest
.
getLastModified
(
)
>
slm
)
{
return
;
}
}
final
boolean
filterSetsAvailable
=
(
filters
!=
null
&&
filters
.
hasFilters
(
)
)
;
final
boolean
filterChainsAvailable
=
(
filterChains
!=
null
&&
filterChains
.
size
(
)
>
0
)
;
if
(
filterSetsAvailable
)
{
BufferedReader
in
=
null
;
BufferedWriter
out
=
null
;
try
{
InputStreamReader
isr
=
null
;
if
(
inputEncoding
==
null
)
{
isr
=
new
InputStreamReader
(
source
.
getInputStream
(
)
)
;
}
else
{
isr
=
new
InputStreamReader
(
source
.
getInputStream
(
)
,
inputEncoding
)
;
}
in
=
new
BufferedReader
(
isr
)
;
OutputStreamWriter
osw
=
null
;
if
(
outputEncoding
==
null
)
{
osw
=
new
OutputStreamWriter
(
dest
.
getOutputStream
(
)
)
;
}
else
{
osw
=
new
OutputStreamWriter
(
dest
.
getOutputStream
(
)
,
outputEncoding
)
;
}
out
=
new
BufferedWriter
(
osw
)
;
if
(
filterChainsAvailable
)
{
ChainReaderHelper
crh
=
new
ChainReaderHelper
(
)
;
crh
.
setBufferSize
(
FileUtils
.
BUF_SIZE
)
;
crh
.
setPrimaryReader
(
in
)
;
crh
.
setFilterChains
(
filterChains
)
;
crh
.
setProject
(
project
)
;
Reader
rdr
=
crh
.
getAssembledReader
(
)
;
in
=
new
BufferedReader
(
rdr
)
;
}
LineTokenizer
lineTokenizer
=
new
LineTokenizer
(
)
;
lineTokenizer
.
setIncludeDelims
(
true
)
;
String
newline
=
null
;
String
line
=
lineTokenizer
.
getToken
(
in
)
;
while
(
line
!=
null
)
{
if
(
line
.
length
(
)
==
0
)
{
out
.
newLine
(
)
;
}
else
{
newline
=
filters
.
replaceTokens
(
line
)
;
out
.
write
(
newline
)
;
}
line
=
lineTokenizer
.
getToken
(
in
)
;
}
}
finally
{
FileUtils
.
close
(
out
)
;
FileUtils
.
close
(
in
)
;
}
}
else
if
(
filterChainsAvailable
||
(
inputEncoding
!=
null
&&
!
inputEncoding
.
equals
(
outputEncoding
)
)
||
(
inputEncoding
==
null
&&
outputEncoding
!=
null
)
)
{
BufferedReader
in
=
null
;
BufferedWriter
out
=
null
;
try
{
InputStreamReader
isr
=
null
;
if
(
inputEncoding
==
null
)
{
isr
=
new
InputStreamReader
(
source
.
getInputStream
(
)
)
;
}
else
{
isr
=
new
InputStreamReader
(
source
.
getInputStream
(
)
,
inputEncoding
)
;
}
in
=
new
BufferedReader
(
isr
)
;
OutputStreamWriter
osw
=
null
;
if
(
outputEncoding
==
null
)
{
osw
=
new
OutputStreamWriter
(
dest
.
getOutputStream
(
)
)
;
}
else
{
osw
=
new
OutputStreamWriter
(
dest
.
getOutputStream
(
)
,
outputEncoding
)
;
}
out
=
new
BufferedWriter
(
osw
)
;
if
(
filterChainsAvailable
)
{
ChainReaderHelper
crh
=
new
ChainReaderHelper
(
)
;
crh
.
setBufferSize
(
FileUtils
.
BUF_SIZE
)
;
crh
.
setPrimaryReader
(
in
)
;
crh
.
setFilterChains
(
filterChains
)
;
crh
.
setProject
(
project
)
;
Reader
rdr
=
crh
.
getAssembledReader
(
)
;
in
=
new
BufferedReader
(
rdr
)
;
}
char
[
]
buffer
=
new
char
[
FileUtils
.
BUF_SIZE
]
;
while
(
true
)
{
int
nRead
=
in
.
read
(
buffer
,
0
,
buffer
.
length
)
;
if
(
nRead
==
-
1
)
{
break
;
}
out
.
write
(
buffer
,
0
,
nRead
)
;
}
}
finally
{
FileUtils
.
close
(
out
)
;
FileUtils
.
close
(
in
)
;
}
}
else
{
InputStream
in
=
null
;
OutputStream
out
=
null
;
try
{
in
=
source
.
getInputStream
(
)
;
out
=
dest
.
getOutputStream
(
)
;
byte
[
]
buffer
=
new
byte
[
FileUtils
.
BUF_SIZE
]
;
int
count
=
0
;
do
{
out
.
write
(
buffer
,
0
,
count
)
;
count
=
in
.
read
(
buffer
,
0
,
buffer
.
length
)
;
}
while
(
count
!=
-
1
)
;
}
finally
{
FileUtils
.
close
(
out
)
;
FileUtils
.
close
(
in
)
;
}
}
if
(
preserveLastModified
&&
dest
instanceof
Touchable
)
{
setLastModified
(
(
Touchable
)
dest
,
source
.
getLastModified
(
)
)
;
}
}
public
static
void
setLastModified
(
Touchable
t
,
long
time
)
{
t
.
touch
(
(
time
<
0
)
?
System
.
currentTimeMillis
(
)
:
time
)
;
}
public
static
boolean
contentEquals
(
Resource
r1
,
Resource
r2
,
boolean
text
)
throws
IOException
{
if
(
r1
.
isExists
(
)
!=
r2
.
isExists
(
)
)
{
return
false
;
}
if
(
!
r1
.
isExists
(
)
)
{
return
true
;
}
if
(
r1
.
isDirectory
(
)
||
r2
.
isDirectory
(
)
)
{
return
false
;
}
if
(
r1
.
equals
(
r2
)
)
{
return
true
;
}
if
(
!
text
&&
r1
.
getSize
(
)
!=
r2
.
getSize
(
)
)
{
return
false
;
}
return
compareContent
(
r1
,
r2
,
text
)
==
0
;
}
public
static
int
compareContent
(
Resource
r1
,
Resource
r2
,
boolean
text
)
throws
IOException
{
if
(
r1
.
equals
(
r2
)
)
{
return
0
;
}
boolean
e1
=
r1
.
isExists
(
)
;
boolean
e2
=
r2
.
isExists
(
)
;
if
(
!
(
e1
||
e2
)
)
{
return
0
;
}
if
(
e1
!=
e2
)
{
return
e1
?
1
:
-
1
;
}
boolean
d1
=
r1
.
isDirectory
(
)
;
boolean
d2
=
r2
.
isDirectory
(
)
;
if
(
d1
&&
d2
)
{
return
0
;
}
if
(
d1
||
d2
)
{
return
d1
?
-
1
:
1
;
}
return
text
?
textCompare
(
r1
,
r2
)
:
binaryCompare
(
r1
,
r2
)
;
}
private
static
int
binaryCompare
(
Resource
r1
,
Resource
r2
)
throws
IOException
{
InputStream
in1
=
null
;
InputStream
in2
=
null
;
try
{
in1
=
new
BufferedInputStream
(
r1
.
getInputStream
(
)
)
;
in2
=
new
BufferedInputStream
(
r2
.
getInputStream
(
)
)
;
for
(
int
b1
=
in1
.
read
(
)
;
b1
!=
-
1
;
b1
=
in1
.
read
(
)
)
{
int
b2
=
in2
.
read
(
)
;
if
(
b1
!=
b2
)
{
return
b1
>
b2
?
1
:
-
1
;
}
}
return
in2
.
read
(
)
==
-
1
?
0
:
-
1
;
}
finally
{
FileUtils
.
close
(
in1
)
;
FileUtils
.
close
(
in2
)
;
}
}
private
static
int
textCompare
(
Resource
r1
,
Resource
r2
)
throws
IOException
{
BufferedReader
in1
=
null
;
BufferedReader
in2
=
null
;
try
{
in1
=
new
BufferedReader
(
new
InputStreamReader
(
r1
.
getInputStream
(
)
)
)
;
in2
=
new
BufferedReader
(
new
InputStreamReader
(
r2
.
getInputStream
(
)
)
)
;
String
expected
=
in1
.
readLine
(
)
;
while
(
expected
!=
null
)
{
String
actual
=
in2
.
readLine
(
)
;
if
(
!
expected
.
equals
(
actual
)
)
{
return
expected
.
compareTo
(
actual
)
;
}
expected
=
in1
.
readLine
(
)
;
}
return
in2
.
readLine
(
)
==
null
?
0
:
-
1
;
}
finally
{
FileUtils
.
close
(
in1
)
;
FileUtils
.
close
(
in2
)
;
}
}
private
static
void
logFuture
(
ProjectComponent
logTo
,
ResourceCollection
rc
,
long
granularity
)
{
long
now
=
System
.
currentTimeMillis
(
)
+
granularity
;
Date
sel
=
new
Date
(
)
;
sel
.
setMillis
(
now
)
;
sel
.
setWhen
(
TimeComparison
.
AFTER
)
;
Restrict
future
=
new
Restrict
(
)
;
future
.
add
(
sel
)
;
future
.
add
(
rc
)
;
for
(
Iterator
iter
=
future
.
iterator
(
)
;
iter
.
hasNext
(
)
;
)
{
logTo
.
log
(
"Warning: "
+
(
(
Resource
)
iter
.
next
(
)
)
.
getName
(
)
+
" modified in the future."
,
Project
.
MSG_WARN
)
;
}
}
}
