package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
org
.
apache
.
tools
.
ant
.
*
;
import
org
.
apache
.
tools
.
ant
.
types
.
*
;
import
java
.
io
.
*
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Properties
;
import
java
.
util
.
zip
.
*
;
import
java
.
sql
.
*
;
public
class
SQLExec
extends
Task
{
static
public
class
DelimiterType
extends
EnumeratedAttribute
{
static
public
final
String
NORMAL
=
"normal"
;
static
public
final
String
ROW
=
"row"
;
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
NORMAL
,
ROW
}
;
}
}
private
int
goodSql
=
0
,
totalSql
=
0
;
private
Path
classpath
;
private
AntClassLoader
loader
;
private
Vector
filesets
=
new
Vector
(
)
;
private
Connection
conn
=
null
;
private
boolean
autocommit
=
false
;
private
Statement
statement
=
null
;
private
String
driver
=
null
;
private
String
url
=
null
;
private
String
userId
=
null
;
private
String
password
=
null
;
private
File
srcFile
=
null
;
private
String
sqlCommand
=
""
;
private
Vector
transactions
=
new
Vector
(
)
;
private
String
delimiter
=
";"
;
private
String
delimiterType
=
DelimiterType
.
NORMAL
;
private
boolean
print
=
false
;
private
boolean
showheaders
=
true
;
private
File
output
=
null
;
private
String
rdbms
=
null
;
private
String
version
=
null
;
private
String
onError
=
"abort"
;
public
void
setClasspath
(
Path
classpath
)
{
if
(
this
.
classpath
==
null
)
{
this
.
classpath
=
classpath
;
}
else
{
this
.
classpath
.
append
(
classpath
)
;
}
}
public
Path
createClasspath
(
)
{
if
(
this
.
classpath
==
null
)
{
this
.
classpath
=
new
Path
(
project
)
;
}
return
this
.
classpath
.
createPath
(
)
;
}
public
void
setClasspathRef
(
Reference
r
)
{
createClasspath
(
)
.
setRefid
(
r
)
;
}
public
void
setSrc
(
File
srcFile
)
{
this
.
srcFile
=
srcFile
;
}
public
void
addText
(
String
sql
)
{
this
.
sqlCommand
+=
sql
;
}
public
void
addFileset
(
FileSet
set
)
{
filesets
.
addElement
(
set
)
;
}
public
Transaction
createTransaction
(
)
{
Transaction
t
=
new
Transaction
(
)
;
transactions
.
addElement
(
t
)
;
return
t
;
}
public
void
setDriver
(
String
driver
)
{
this
.
driver
=
driver
;
}
public
void
setUrl
(
String
url
)
{
this
.
url
=
url
;
}
public
void
setUserid
(
String
userId
)
{
this
.
userId
=
userId
;
}
public
void
setPassword
(
String
password
)
{
this
.
password
=
password
;
}
public
void
setAutocommit
(
boolean
autocommit
)
{
this
.
autocommit
=
autocommit
;
}
public
void
setDelimiter
(
String
delimiter
)
{
this
.
delimiter
=
delimiter
;
}
public
void
setDelimiterType
(
DelimiterType
delimiterType
)
{
this
.
delimiterType
=
delimiterType
.
getValue
(
)
;
}
public
void
setPrint
(
boolean
print
)
{
this
.
print
=
print
;
}
public
void
setShowheaders
(
boolean
showheaders
)
{
this
.
showheaders
=
showheaders
;
}
public
void
setOutput
(
File
output
)
{
this
.
output
=
output
;
}
public
void
setRdbms
(
String
vendor
)
{
this
.
rdbms
=
vendor
.
toLowerCase
(
)
;
}
public
void
setVersion
(
String
version
)
{
this
.
version
=
version
.
toLowerCase
(
)
;
}
public
void
setOnerror
(
OnError
action
)
{
this
.
onError
=
action
.
getValue
(
)
;
}
public
void
execute
(
)
throws
BuildException
{
sqlCommand
=
sqlCommand
.
trim
(
)
;
if
(
srcFile
==
null
&&
sqlCommand
.
length
(
)
==
0
&&
filesets
.
isEmpty
(
)
)
{
if
(
transactions
.
size
(
)
==
0
)
{
throw
new
BuildException
(
"Source file or fileset, transactions or sql statement must be set!"
,
location
)
;
}
}
else
{
for
(
int
i
=
0
;
i
<
filesets
.
size
(
)
;
i
++
)
{
FileSet
fs
=
(
FileSet
)
filesets
.
elementAt
(
i
)
;
DirectoryScanner
ds
=
fs
.
getDirectoryScanner
(
project
)
;
File
srcDir
=
fs
.
getDir
(
project
)
;
String
[
]
srcFiles
=
ds
.
getIncludedFiles
(
)
;
for
(
int
j
=
0
;
j
<
srcFiles
.
length
;
j
++
)
{
Transaction
t
=
createTransaction
(
)
;
t
.
setSrc
(
new
File
(
srcDir
,
srcFiles
[
j
]
)
)
;
}
}
Transaction
t
=
createTransaction
(
)
;
t
.
setSrc
(
srcFile
)
;
t
.
addText
(
sqlCommand
)
;
}
if
(
driver
==
null
)
{
throw
new
BuildException
(
"Driver attribute must be set!"
,
location
)
;
}
if
(
userId
==
null
)
{
throw
new
BuildException
(
"User Id attribute must be set!"
,
location
)
;
}
if
(
password
==
null
)
{
throw
new
BuildException
(
"Password attribute must be set!"
,
location
)
;
}
if
(
url
==
null
)
{
throw
new
BuildException
(
"Url attribute must be set!"
,
location
)
;
}
if
(
srcFile
!=
null
&&
!
srcFile
.
exists
(
)
)
{
throw
new
BuildException
(
"Source file does not exist!"
,
location
)
;
}
Driver
driverInstance
=
null
;
try
{
Class
dc
;
if
(
classpath
!=
null
)
{
log
(
"Loading "
+
driver
+
" using AntClassLoader with classpath "
+
classpath
,
Project
.
MSG_VERBOSE
)
;
loader
=
new
AntClassLoader
(
project
,
classpath
)
;
dc
=
loader
.
loadClass
(
driver
)
;
}
else
{
log
(
"Loading "
+
driver
+
" using system loader."
,
Project
.
MSG_VERBOSE
)
;
dc
=
Class
.
forName
(
driver
)
;
}
driverInstance
=
(
Driver
)
dc
.
newInstance
(
)
;
}
catch
(
ClassNotFoundException
e
)
{
throw
new
BuildException
(
"Class Not Found: JDBC driver "
+
driver
+
" could not be loaded"
,
location
)
;
}
catch
(
IllegalAccessException
e
)
{
throw
new
BuildException
(
"Illegal Access: JDBC driver "
+
driver
+
" could not be loaded"
,
location
)
;
}
catch
(
InstantiationException
e
)
{
throw
new
BuildException
(
"Instantiation Exception: JDBC driver "
+
driver
+
" could not be loaded"
,
location
)
;
}
try
{
log
(
"connecting to "
+
url
,
Project
.
MSG_VERBOSE
)
;
Properties
info
=
new
Properties
(
)
;
info
.
put
(
"user"
,
userId
)
;
info
.
put
(
"password"
,
password
)
;
conn
=
driverInstance
.
connect
(
url
,
info
)
;
if
(
conn
==
null
)
{
throw
new
SQLException
(
"No suitable Driver for "
+
url
)
;
}
if
(
!
isValidRdbms
(
conn
)
)
return
;
conn
.
setAutoCommit
(
autocommit
)
;
statement
=
conn
.
createStatement
(
)
;
PrintStream
out
=
System
.
out
;
try
{
if
(
output
!=
null
)
{
log
(
"Opening PrintStream to output file "
+
output
,
Project
.
MSG_VERBOSE
)
;
out
=
new
PrintStream
(
new
BufferedOutputStream
(
new
FileOutputStream
(
output
)
)
)
;
}
for
(
Enumeration
e
=
transactions
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
(
(
Transaction
)
e
.
nextElement
(
)
)
.
runTransaction
(
out
)
;
if
(
!
autocommit
)
{
log
(
"Commiting transaction"
,
Project
.
MSG_VERBOSE
)
;
conn
.
commit
(
)
;
}
}
}
finally
{
if
(
out
!=
null
&&
out
!=
System
.
out
)
{
out
.
close
(
)
;
}
}
}
catch
(
IOException
e
)
{
if
(
!
autocommit
&&
conn
!=
null
&&
onError
.
equals
(
"abort"
)
)
{
try
{
conn
.
rollback
(
)
;
}
catch
(
SQLException
ex
)
{
}
}
throw
new
BuildException
(
e
,
location
)
;
}
catch
(
SQLException
e
)
{
if
(
!
autocommit
&&
conn
!=
null
&&
onError
.
equals
(
"abort"
)
)
{
try
{
conn
.
rollback
(
)
;
}
catch
(
SQLException
ex
)
{
}
}
throw
new
BuildException
(
e
,
location
)
;
}
finally
{
try
{
if
(
statement
!=
null
)
{
statement
.
close
(
)
;
}
if
(
conn
!=
null
)
{
conn
.
close
(
)
;
}
}
catch
(
SQLException
e
)
{
}
}
log
(
goodSql
+
" of "
+
totalSql
+
" SQL statements executed successfully"
)
;
}
protected
void
runStatements
(
Reader
reader
,
PrintStream
out
)
throws
SQLException
,
IOException
{
String
sql
=
""
;
String
line
=
""
;
BufferedReader
in
=
new
BufferedReader
(
reader
)
;
try
{
while
(
(
line
=
in
.
readLine
(
)
)
!=
null
)
{
line
=
line
.
trim
(
)
;
line
=
ProjectHelper
.
replaceProperties
(
project
,
line
,
project
.
getProperties
(
)
)
;
if
(
line
.
startsWith
(
"//"
)
)
continue
;
if
(
line
.
startsWith
(
"--"
)
)
continue
;
if
(
line
.
length
(
)
>
2
&&
line
.
substring
(
0
,
3
)
.
equalsIgnoreCase
(
"REM"
)
)
continue
;
sql
+=
" "
+
line
;
sql
=
sql
.
trim
(
)
;
if
(
line
.
indexOf
(
"--"
)
>=
0
)
sql
+=
"\n"
;
if
(
delimiterType
.
equals
(
DelimiterType
.
NORMAL
)
&&
sql
.
endsWith
(
delimiter
)
||
delimiterType
.
equals
(
DelimiterType
.
ROW
)
&&
line
.
equals
(
delimiter
)
)
{
log
(
"SQL: "
+
sql
,
Project
.
MSG_VERBOSE
)
;
execSQL
(
sql
.
substring
(
0
,
sql
.
length
(
)
-
delimiter
.
length
(
)
)
,
out
)
;
sql
=
""
;
}
}
if
(
!
sql
.
equals
(
""
)
)
{
execSQL
(
sql
,
out
)
;
}
}
catch
(
SQLException
e
)
{
throw
e
;
}
}
protected
boolean
isValidRdbms
(
Connection
conn
)
{
if
(
rdbms
==
null
&&
version
==
null
)
return
true
;
try
{
DatabaseMetaData
dmd
=
conn
.
getMetaData
(
)
;
if
(
rdbms
!=
null
)
{
String
theVendor
=
dmd
.
getDatabaseProductName
(
)
.
toLowerCase
(
)
;
log
(
"RDBMS = "
+
theVendor
,
Project
.
MSG_VERBOSE
)
;
if
(
theVendor
==
null
||
theVendor
.
indexOf
(
rdbms
)
<
0
)
{
log
(
"Not the required RDBMS: "
+
rdbms
,
Project
.
MSG_VERBOSE
)
;
return
false
;
}
}
if
(
version
!=
null
)
{
String
theVersion
=
dmd
.
getDatabaseProductVersion
(
)
.
toLowerCase
(
)
;
log
(
"Version = "
+
theVersion
,
Project
.
MSG_VERBOSE
)
;
if
(
theVersion
==
null
||
!
(
theVersion
.
startsWith
(
version
)
||
theVersion
.
indexOf
(
" "
+
version
)
>=
0
)
)
{
log
(
"Not the required version: \""
+
version
+
"\""
,
Project
.
MSG_VERBOSE
)
;
return
false
;
}
}
}
catch
(
SQLException
e
)
{
log
(
"Failed to obtain required RDBMS information"
,
Project
.
MSG_ERR
)
;
return
false
;
}
return
true
;
}
protected
void
execSQL
(
String
sql
,
PrintStream
out
)
throws
SQLException
{
if
(
""
.
equals
(
sql
.
trim
(
)
)
)
return
;
try
{
totalSql
++
;
if
(
!
statement
.
execute
(
sql
)
)
{
log
(
statement
.
getUpdateCount
(
)
+
" rows affected"
,
Project
.
MSG_VERBOSE
)
;
}
else
{
if
(
print
)
{
printResults
(
out
)
;
}
}
SQLWarning
warning
=
conn
.
getWarnings
(
)
;
while
(
warning
!=
null
)
{
log
(
warning
+
" sql warning"
,
Project
.
MSG_VERBOSE
)
;
warning
=
warning
.
getNextWarning
(
)
;
}
conn
.
clearWarnings
(
)
;
goodSql
++
;
}
catch
(
SQLException
e
)
{
log
(
"Failed to execute: "
+
sql
,
Project
.
MSG_ERR
)
;
if
(
!
onError
.
equals
(
"continue"
)
)
throw
e
;
log
(
e
.
toString
(
)
,
Project
.
MSG_ERR
)
;
}
}
protected
void
printResults
(
PrintStream
out
)
throws
java
.
sql
.
SQLException
{
ResultSet
rs
=
null
;
do
{
rs
=
statement
.
getResultSet
(
)
;
if
(
rs
!=
null
)
{
log
(
"Processing new result set."
,
Project
.
MSG_VERBOSE
)
;
ResultSetMetaData
md
=
rs
.
getMetaData
(
)
;
int
columnCount
=
md
.
getColumnCount
(
)
;
StringBuffer
line
=
new
StringBuffer
(
)
;
if
(
showheaders
)
{
for
(
int
col
=
1
;
col
<
columnCount
;
col
++
)
{
line
.
append
(
md
.
getColumnName
(
col
)
)
;
line
.
append
(
","
)
;
}
line
.
append
(
md
.
getColumnName
(
columnCount
)
)
;
out
.
println
(
line
)
;
line
.
setLength
(
0
)
;
}
while
(
rs
.
next
(
)
)
{
boolean
first
=
true
;
for
(
int
col
=
1
;
col
<=
columnCount
;
col
++
)
{
String
columnValue
=
rs
.
getString
(
col
)
;
if
(
columnValue
!=
null
)
{
columnValue
=
columnValue
.
trim
(
)
;
}
if
(
first
)
{
first
=
false
;
}
else
{
line
.
append
(
","
)
;
}
line
.
append
(
columnValue
)
;
}
out
.
println
(
line
)
;
line
.
setLength
(
0
)
;
}
}
}
while
(
statement
.
getMoreResults
(
)
)
;
out
.
println
(
)
;
}
public
static
class
OnError
extends
EnumeratedAttribute
{
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
"continue"
,
"stop"
,
"abort"
}
;
}
}
public
class
Transaction
{
private
File
tSrcFile
=
null
;
private
String
tSqlCommand
=
""
;
public
void
setSrc
(
File
src
)
{
this
.
tSrcFile
=
src
;
}
public
void
addText
(
String
sql
)
{
this
.
tSqlCommand
+=
sql
;
}
private
void
runTransaction
(
PrintStream
out
)
throws
IOException
,
SQLException
{
if
(
tSqlCommand
.
length
(
)
!=
0
)
{
log
(
"Executing commands"
,
Project
.
MSG_INFO
)
;
runStatements
(
new
StringReader
(
tSqlCommand
)
,
out
)
;
}
if
(
tSrcFile
!=
null
)
{
log
(
"Executing file: "
+
tSrcFile
.
getAbsolutePath
(
)
,
Project
.
MSG_INFO
)
;
FileReader
reader
=
new
FileReader
(
tSrcFile
)
;
runStatements
(
reader
,
out
)
;
reader
.
close
(
)
;
}
}
}
}
