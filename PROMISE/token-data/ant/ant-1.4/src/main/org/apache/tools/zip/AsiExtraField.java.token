package
org
.
apache
.
tools
.
zip
;
import
java
.
util
.
zip
.
CRC32
;
import
java
.
util
.
zip
.
ZipException
;
public
class
AsiExtraField
implements
ZipExtraField
,
UnixStat
,
Cloneable
{
private
final
static
ZipShort
HEADER_ID
=
new
ZipShort
(
0x756E
)
;
private
int
mode
=
0
;
private
int
uid
=
0
;
private
int
gid
=
0
;
private
String
link
=
""
;
private
boolean
dirFlag
=
false
;
private
CRC32
crc
=
new
CRC32
(
)
;
public
AsiExtraField
(
)
{
}
public
ZipShort
getHeaderId
(
)
{
return
HEADER_ID
;
}
public
ZipShort
getLocalFileDataLength
(
)
{
return
new
ZipShort
(
4
+
2
+
4
+
2
+
2
+
getLinkedFile
(
)
.
getBytes
(
)
.
length
)
;
}
public
ZipShort
getCentralDirectoryLength
(
)
{
return
getLocalFileDataLength
(
)
;
}
public
byte
[
]
getLocalFileDataData
(
)
{
byte
[
]
data
=
new
byte
[
getLocalFileDataLength
(
)
.
getValue
(
)
-
4
]
;
System
.
arraycopy
(
(
new
ZipShort
(
getMode
(
)
)
)
.
getBytes
(
)
,
0
,
data
,
0
,
2
)
;
byte
[
]
linkArray
=
getLinkedFile
(
)
.
getBytes
(
)
;
System
.
arraycopy
(
(
new
ZipLong
(
linkArray
.
length
)
)
.
getBytes
(
)
,
0
,
data
,
2
,
4
)
;
System
.
arraycopy
(
(
new
ZipShort
(
getUserId
(
)
)
)
.
getBytes
(
)
,
0
,
data
,
6
,
2
)
;
System
.
arraycopy
(
(
new
ZipShort
(
getGroupId
(
)
)
)
.
getBytes
(
)
,
0
,
data
,
8
,
2
)
;
System
.
arraycopy
(
linkArray
,
0
,
data
,
10
,
linkArray
.
length
)
;
crc
.
reset
(
)
;
crc
.
update
(
data
)
;
long
checksum
=
crc
.
getValue
(
)
;
byte
[
]
result
=
new
byte
[
data
.
length
+
4
]
;
System
.
arraycopy
(
(
new
ZipLong
(
checksum
)
)
.
getBytes
(
)
,
0
,
result
,
0
,
4
)
;
System
.
arraycopy
(
data
,
0
,
result
,
4
,
data
.
length
)
;
return
result
;
}
public
byte
[
]
getCentralDirectoryData
(
)
{
return
getLocalFileDataData
(
)
;
}
public
void
setUserId
(
int
uid
)
{
this
.
uid
=
uid
;
}
public
int
getUserId
(
)
{
return
uid
;
}
public
void
setGroupId
(
int
gid
)
{
this
.
gid
=
gid
;
}
public
int
getGroupId
(
)
{
return
gid
;
}
public
void
setLinkedFile
(
String
name
)
{
link
=
name
;
mode
=
getMode
(
mode
)
;
}
public
String
getLinkedFile
(
)
{
return
link
;
}
public
boolean
isLink
(
)
{
return
getLinkedFile
(
)
.
length
(
)
!=
0
;
}
public
void
setMode
(
int
mode
)
{
this
.
mode
=
getMode
(
mode
)
;
}
public
int
getMode
(
)
{
return
mode
;
}
public
void
setDirectory
(
boolean
dirFlag
)
{
this
.
dirFlag
=
dirFlag
;
mode
=
getMode
(
mode
)
;
}
public
boolean
isDirectory
(
)
{
return
dirFlag
&&
!
isLink
(
)
;
}
public
void
parseFromLocalFileData
(
byte
[
]
data
,
int
offset
,
int
length
)
throws
ZipException
{
long
givenChecksum
=
(
new
ZipLong
(
data
,
offset
)
)
.
getValue
(
)
;
byte
[
]
tmp
=
new
byte
[
length
-
4
]
;
System
.
arraycopy
(
data
,
offset
+
4
,
tmp
,
0
,
length
-
4
)
;
crc
.
reset
(
)
;
crc
.
update
(
tmp
)
;
long
realChecksum
=
crc
.
getValue
(
)
;
if
(
givenChecksum
!=
realChecksum
)
{
throw
new
ZipException
(
"bad CRC checksum "
+
Long
.
toHexString
(
givenChecksum
)
+
" instead of "
+
Long
.
toHexString
(
realChecksum
)
)
;
}
int
newMode
=
(
new
ZipShort
(
tmp
,
0
)
)
.
getValue
(
)
;
byte
[
]
linkArray
=
new
byte
[
(
int
)
(
new
ZipLong
(
tmp
,
2
)
)
.
getValue
(
)
]
;
uid
=
(
new
ZipShort
(
tmp
,
6
)
)
.
getValue
(
)
;
gid
=
(
new
ZipShort
(
tmp
,
8
)
)
.
getValue
(
)
;
if
(
linkArray
.
length
==
0
)
{
link
=
""
;
}
else
{
System
.
arraycopy
(
tmp
,
10
,
linkArray
,
0
,
linkArray
.
length
)
;
link
=
new
String
(
linkArray
)
;
}
setDirectory
(
(
newMode
&
DIR_FLAG
)
!=
0
)
;
setMode
(
newMode
)
;
}
protected
int
getMode
(
int
mode
)
{
int
type
=
FILE_FLAG
;
if
(
isLink
(
)
)
{
type
=
LINK_FLAG
;
}
else
if
(
isDirectory
(
)
)
{
type
=
DIR_FLAG
;
}
return
type
|
(
mode
&
PERM_MASK
)
;
}
}
