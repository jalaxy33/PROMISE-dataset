package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
*
;
import
java
.
net
.
*
;
import
java
.
util
.
*
;
import
org
.
apache
.
tools
.
ant
.
*
;
public
class
Get
extends
Task
{
private
URL
source
;
private
File
dest
;
private
boolean
verbose
=
false
;
private
boolean
useTimestamp
=
false
;
private
boolean
ignoreErrors
=
false
;
public
void
execute
(
)
throws
BuildException
{
if
(
source
==
null
)
{
throw
new
BuildException
(
"src attribute is required"
,
location
)
;
}
if
(
dest
==
null
)
{
throw
new
BuildException
(
"dest attribute is required"
,
location
)
;
}
if
(
dest
.
exists
(
)
&&
dest
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"The specified destination is a directory"
,
location
)
;
}
if
(
dest
.
exists
(
)
&&
!
dest
.
canWrite
(
)
)
{
throw
new
BuildException
(
"Can't write to "
+
dest
.
getAbsolutePath
(
)
,
location
)
;
}
try
{
log
(
"Getting: "
+
source
)
;
long
timestamp
=
0
;
boolean
hasTimestamp
=
false
;
if
(
useTimestamp
&&
dest
.
exists
(
)
)
{
timestamp
=
dest
.
lastModified
(
)
;
if
(
verbose
)
{
Date
t
=
new
Date
(
timestamp
)
;
log
(
"local file date : "
+
t
.
toString
(
)
)
;
}
hasTimestamp
=
true
;
}
URLConnection
connection
=
source
.
openConnection
(
)
;
if
(
useTimestamp
&&
hasTimestamp
)
{
connection
.
setIfModifiedSince
(
timestamp
)
;
}
connection
.
connect
(
)
;
if
(
connection
instanceof
HttpURLConnection
)
{
HttpURLConnection
httpConnection
=
(
HttpURLConnection
)
connection
;
if
(
httpConnection
.
getResponseCode
(
)
==
HttpURLConnection
.
HTTP_NOT_MODIFIED
)
{
log
(
"Not modified - so not downloaded"
)
;
return
;
}
}
FileOutputStream
fos
=
new
FileOutputStream
(
dest
)
;
InputStream
is
=
null
;
for
(
int
i
=
0
;
i
<
3
;
i
++
)
{
try
{
is
=
connection
.
getInputStream
(
)
;
break
;
}
catch
(
IOException
ex
)
{
log
(
"Error opening connection "
+
ex
)
;
}
}
if
(
is
==
null
)
{
log
(
"Can't get "
+
source
+
" to "
+
dest
)
;
if
(
ignoreErrors
)
return
;
throw
new
BuildException
(
"Can't get "
+
source
+
" to "
+
dest
,
location
)
;
}
byte
[
]
buffer
=
new
byte
[
100
*
1024
]
;
int
length
;
while
(
(
length
=
is
.
read
(
buffer
)
)
>=
0
)
{
fos
.
write
(
buffer
,
0
,
length
)
;
if
(
verbose
)
System
.
out
.
print
(
"."
)
;
}
if
(
verbose
)
System
.
out
.
println
(
)
;
fos
.
close
(
)
;
is
.
close
(
)
;
if
(
useTimestamp
)
{
long
remoteTimestamp
=
connection
.
getLastModified
(
)
;
if
(
verbose
)
{
Date
t
=
new
Date
(
remoteTimestamp
)
;
log
(
"last modified = "
+
t
.
toString
(
)
+
(
(
remoteTimestamp
==
0
)
?
" - using current time instead"
:
""
)
)
;
}
if
(
remoteTimestamp
!=
0
)
touchFile
(
dest
,
remoteTimestamp
)
;
}
}
catch
(
IOException
ioe
)
{
log
(
"Error getting "
+
source
+
" to "
+
dest
)
;
if
(
ignoreErrors
)
return
;
throw
new
BuildException
(
ioe
,
location
)
;
}
}
protected
boolean
touchFile
(
File
file
,
long
timemillis
)
throws
BuildException
{
if
(
project
.
getJavaVersion
(
)
!=
Project
.
JAVA_1_1
)
{
Touch
touch
=
(
Touch
)
project
.
createTask
(
"touch"
)
;
touch
.
setOwningTarget
(
target
)
;
touch
.
setTaskName
(
getTaskName
(
)
)
;
touch
.
setLocation
(
getLocation
(
)
)
;
touch
.
setFile
(
file
)
;
touch
.
setMillis
(
timemillis
)
;
touch
.
touch
(
)
;
return
true
;
}
else
{
return
false
;
}
}
public
void
setSrc
(
URL
u
)
{
this
.
source
=
u
;
}
public
void
setDest
(
File
dest
)
{
this
.
dest
=
dest
;
}
public
void
setVerbose
(
boolean
v
)
{
verbose
=
v
;
}
public
void
setIgnoreErrors
(
boolean
v
)
{
ignoreErrors
=
v
;
}
public
void
setUseTimestamp
(
boolean
v
)
{
if
(
project
.
getJavaVersion
(
)
!=
Project
.
JAVA_1_1
)
{
useTimestamp
=
v
;
}
}
}
