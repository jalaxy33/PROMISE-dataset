package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
*
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
*
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
types
.
Reference
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
public
class
XSLTProcess
extends
MatchingTask
{
private
File
destDir
=
null
;
private
File
baseDir
=
null
;
private
String
xslFile
=
null
;
private
String
targetExtension
=
".html"
;
private
Vector
params
=
new
Vector
(
)
;
private
File
inFile
=
null
;
private
File
outFile
=
null
;
private
String
processor
;
private
Path
classpath
=
null
;
private
XSLTLiaison
liaison
;
private
boolean
stylesheetLoaded
=
false
;
private
boolean
force
=
false
;
private
FileUtils
fileUtils
;
public
XSLTProcess
(
)
{
fileUtils
=
FileUtils
.
newFileUtils
(
)
;
}
public
void
execute
(
)
throws
BuildException
{
DirectoryScanner
scanner
;
String
[
]
list
;
String
[
]
dirs
;
if
(
xslFile
==
null
)
{
throw
new
BuildException
(
"no stylesheet specified"
,
location
)
;
}
if
(
baseDir
==
null
)
{
baseDir
=
project
.
resolveFile
(
"."
)
;
}
liaison
=
getLiaison
(
)
;
log
(
"Using "
+
liaison
.
getClass
(
)
.
toString
(
)
,
Project
.
MSG_VERBOSE
)
;
File
stylesheet
=
project
.
resolveFile
(
xslFile
)
;
if
(
!
stylesheet
.
exists
(
)
)
{
stylesheet
=
fileUtils
.
resolveFile
(
baseDir
,
xslFile
)
;
if
(
stylesheet
.
exists
(
)
)
{
log
(
"DEPRECATED - the style attribute should be relative to the project\'s"
)
;
log
(
"             basedir, not the tasks\'s basedir."
)
;
}
}
if
(
inFile
!=
null
&&
outFile
!=
null
)
{
process
(
inFile
,
outFile
,
stylesheet
)
;
return
;
}
if
(
destDir
==
null
)
{
String
msg
=
"destdir attributes must be set!"
;
throw
new
BuildException
(
msg
)
;
}
scanner
=
getDirectoryScanner
(
baseDir
)
;
log
(
"Transforming into "
+
destDir
,
Project
.
MSG_INFO
)
;
list
=
scanner
.
getIncludedFiles
(
)
;
for
(
int
i
=
0
;
i
<
list
.
length
;
++
i
)
{
process
(
baseDir
,
list
[
i
]
,
destDir
,
stylesheet
)
;
}
dirs
=
scanner
.
getIncludedDirectories
(
)
;
for
(
int
j
=
0
;
j
<
dirs
.
length
;
++
j
)
{
list
=
new
File
(
baseDir
,
dirs
[
j
]
)
.
list
(
)
;
for
(
int
i
=
0
;
i
<
list
.
length
;
++
i
)
process
(
baseDir
,
list
[
i
]
,
destDir
,
stylesheet
)
;
}
}
public
void
setForce
(
boolean
force
)
{
this
.
force
=
force
;
}
public
void
setBasedir
(
File
dir
)
{
baseDir
=
dir
;
}
public
void
setDestdir
(
File
dir
)
{
destDir
=
dir
;
}
public
void
setExtension
(
String
name
)
{
targetExtension
=
name
;
}
public
void
setStyle
(
String
xslFile
)
{
this
.
xslFile
=
xslFile
;
}
public
void
setClasspath
(
Path
classpath
)
{
createClasspath
(
)
.
append
(
classpath
)
;
}
public
Path
createClasspath
(
)
{
if
(
classpath
==
null
)
{
classpath
=
new
Path
(
project
)
;
}
return
classpath
.
createPath
(
)
;
}
public
void
setClasspathRef
(
Reference
r
)
{
createClasspath
(
)
.
setRefid
(
r
)
;
}
public
void
setProcessor
(
String
processor
)
{
this
.
processor
=
processor
;
}
private
void
resolveProcessor
(
String
proc
)
throws
Exception
{
if
(
proc
.
equals
(
"trax"
)
)
{
final
Class
clazz
=
loadClass
(
"org.apache.tools.ant.taskdefs.optional.TraXLiaison"
)
;
liaison
=
(
XSLTLiaison
)
clazz
.
newInstance
(
)
;
}
else
if
(
proc
.
equals
(
"xslp"
)
)
{
log
(
"DEPRECATED - xslp processor is deprecated. Use trax or xalan instead."
)
;
final
Class
clazz
=
loadClass
(
"org.apache.tools.ant.taskdefs.optional.XslpLiaison"
)
;
liaison
=
(
XSLTLiaison
)
clazz
.
newInstance
(
)
;
}
else
if
(
proc
.
equals
(
"xalan"
)
)
{
final
Class
clazz
=
loadClass
(
"org.apache.tools.ant.taskdefs.optional.XalanLiaison"
)
;
liaison
=
(
XSLTLiaison
)
clazz
.
newInstance
(
)
;
}
else
{
liaison
=
(
XSLTLiaison
)
loadClass
(
proc
)
.
newInstance
(
)
;
}
}
private
Class
loadClass
(
String
classname
)
throws
Exception
{
if
(
classpath
==
null
)
{
return
Class
.
forName
(
classname
)
;
}
else
{
AntClassLoader
al
=
new
AntClassLoader
(
project
,
classpath
)
;
Class
c
=
al
.
loadClass
(
classname
)
;
AntClassLoader
.
initializeClass
(
c
)
;
return
c
;
}
}
public
void
setOut
(
File
outFile
)
{
this
.
outFile
=
outFile
;
}
public
void
setIn
(
File
inFile
)
{
this
.
inFile
=
inFile
;
}
private
void
process
(
File
baseDir
,
String
xmlFile
,
File
destDir
,
File
stylesheet
)
throws
BuildException
{
String
fileExt
=
targetExtension
;
File
outFile
=
null
;
File
inFile
=
null
;
try
{
long
styleSheetLastModified
=
stylesheet
.
lastModified
(
)
;
inFile
=
new
File
(
baseDir
,
xmlFile
)
;
int
dotPos
=
xmlFile
.
lastIndexOf
(
'.'
)
;
if
(
dotPos
>
0
)
{
outFile
=
new
File
(
destDir
,
xmlFile
.
substring
(
0
,
xmlFile
.
lastIndexOf
(
'.'
)
)
+
fileExt
)
;
}
else
{
outFile
=
new
File
(
destDir
,
xmlFile
+
fileExt
)
;
}
if
(
force
||
inFile
.
lastModified
(
)
>
outFile
.
lastModified
(
)
||
styleSheetLastModified
>
outFile
.
lastModified
(
)
)
{
ensureDirectoryFor
(
outFile
)
;
log
(
"Transforming into "
+
destDir
)
;
configureLiaison
(
stylesheet
)
;
liaison
.
transform
(
inFile
,
outFile
)
;
}
}
catch
(
Exception
ex
)
{
log
(
"Failed to process "
+
inFile
,
Project
.
MSG_INFO
)
;
if
(
outFile
!=
null
)
{
outFile
.
delete
(
)
;
}
throw
new
BuildException
(
ex
)
;
}
}
private
void
process
(
File
inFile
,
File
outFile
,
File
stylesheet
)
throws
BuildException
{
try
{
long
styleSheetLastModified
=
stylesheet
.
lastModified
(
)
;
log
(
"In file "
+
inFile
+
" time: "
+
inFile
.
lastModified
(
)
,
Project
.
MSG_DEBUG
)
;
log
(
"Out file "
+
outFile
+
" time: "
+
outFile
.
lastModified
(
)
,
Project
.
MSG_DEBUG
)
;
log
(
"Style file "
+
xslFile
+
" time: "
+
styleSheetLastModified
,
Project
.
MSG_DEBUG
)
;
if
(
force
||
inFile
.
lastModified
(
)
>
outFile
.
lastModified
(
)
||
styleSheetLastModified
>
outFile
.
lastModified
(
)
)
{
ensureDirectoryFor
(
outFile
)
;
log
(
"Processing "
+
inFile
+
" to "
+
outFile
,
Project
.
MSG_INFO
)
;
configureLiaison
(
stylesheet
)
;
liaison
.
transform
(
inFile
,
outFile
)
;
}
}
catch
(
Exception
ex
)
{
log
(
"Failed to process "
+
inFile
,
Project
.
MSG_INFO
)
;
if
(
outFile
!=
null
)
outFile
.
delete
(
)
;
throw
new
BuildException
(
ex
)
;
}
}
private
void
ensureDirectoryFor
(
File
targetFile
)
throws
BuildException
{
File
directory
=
new
File
(
targetFile
.
getParent
(
)
)
;
if
(
!
directory
.
exists
(
)
)
{
if
(
!
directory
.
mkdirs
(
)
)
{
throw
new
BuildException
(
"Unable to create directory: "
+
directory
.
getAbsolutePath
(
)
)
;
}
}
}
protected
XSLTLiaison
getLiaison
(
)
{
if
(
liaison
==
null
)
{
if
(
processor
!=
null
)
{
try
{
resolveProcessor
(
processor
)
;
}
catch
(
Exception
e
)
{
throw
new
BuildException
(
e
)
;
}
}
else
{
try
{
resolveProcessor
(
"trax"
)
;
}
catch
(
Throwable
e1
)
{
try
{
resolveProcessor
(
"xslp"
)
;
}
catch
(
Throwable
e2
)
{
try
{
resolveProcessor
(
"xalan"
)
;
}
catch
(
Throwable
e3
)
{
e3
.
printStackTrace
(
)
;
e2
.
printStackTrace
(
)
;
throw
new
BuildException
(
e1
)
;
}
}
}
}
}
return
liaison
;
}
public
Param
createParam
(
)
{
Param
p
=
new
Param
(
)
;
params
.
addElement
(
p
)
;
return
p
;
}
public
class
Param
{
private
String
name
=
null
;
private
String
expression
=
null
;
public
void
setName
(
String
name
)
{
this
.
name
=
name
;
}
public
void
setExpression
(
String
expression
)
{
this
.
expression
=
expression
;
}
public
String
getName
(
)
throws
BuildException
{
if
(
name
==
null
)
throw
new
BuildException
(
"Name attribute is missing."
)
;
return
name
;
}
public
String
getExpression
(
)
throws
BuildException
{
if
(
expression
==
null
)
throw
new
BuildException
(
"Expression attribute is missing."
)
;
return
expression
;
}
}
protected
void
configureLiaison
(
File
stylesheet
)
throws
BuildException
{
if
(
stylesheetLoaded
)
{
return
;
}
stylesheetLoaded
=
true
;
try
{
log
(
"Loading stylesheet "
+
stylesheet
,
Project
.
MSG_INFO
)
;
liaison
.
setStylesheet
(
stylesheet
)
;
for
(
Enumeration
e
=
params
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
Param
p
=
(
Param
)
e
.
nextElement
(
)
;
liaison
.
addParam
(
p
.
getName
(
)
,
p
.
getExpression
(
)
)
;
}
}
catch
(
Exception
ex
)
{
log
(
"Failed to read stylesheet "
+
stylesheet
,
Project
.
MSG_INFO
)
;
throw
new
BuildException
(
ex
)
;
}
}
}
