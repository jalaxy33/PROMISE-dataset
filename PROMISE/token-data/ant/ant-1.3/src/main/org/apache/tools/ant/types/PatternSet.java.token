package
org
.
apache
.
tools
.
ant
.
types
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
ProjectHelper
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
java
.
io
.
*
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Stack
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Vector
;
public
class
PatternSet
extends
DataType
{
private
Vector
includeList
=
new
Vector
(
)
;
private
Vector
excludeList
=
new
Vector
(
)
;
private
File
incl
=
null
;
private
File
excl
=
null
;
public
class
NameEntry
{
private
String
name
;
private
String
ifCond
;
private
String
unlessCond
;
public
void
setName
(
String
name
)
{
this
.
name
=
name
;
}
public
void
setIf
(
String
cond
)
{
ifCond
=
cond
;
}
public
void
setUnless
(
String
cond
)
{
unlessCond
=
cond
;
}
public
String
getName
(
)
{
return
name
;
}
public
String
evalName
(
Project
p
)
{
return
valid
(
p
)
?
name
:
null
;
}
private
boolean
valid
(
Project
p
)
{
if
(
ifCond
!=
null
&&
p
.
getProperty
(
ifCond
)
==
null
)
{
return
false
;
}
else
if
(
unlessCond
!=
null
&&
p
.
getProperty
(
unlessCond
)
!=
null
)
{
return
false
;
}
return
true
;
}
}
public
PatternSet
(
)
{
super
(
)
;
}
public
void
setRefid
(
Reference
r
)
throws
BuildException
{
if
(
!
includeList
.
isEmpty
(
)
||
!
excludeList
.
isEmpty
(
)
)
{
throw
tooManyAttributes
(
)
;
}
super
.
setRefid
(
r
)
;
}
public
NameEntry
createInclude
(
)
{
if
(
isReference
(
)
)
{
throw
noChildrenAllowed
(
)
;
}
return
addPatternToList
(
includeList
)
;
}
public
NameEntry
createExclude
(
)
{
if
(
isReference
(
)
)
{
throw
noChildrenAllowed
(
)
;
}
return
addPatternToList
(
excludeList
)
;
}
public
void
setIncludes
(
String
includes
)
{
if
(
isReference
(
)
)
{
throw
tooManyAttributes
(
)
;
}
if
(
includes
!=
null
&&
includes
.
length
(
)
>
0
)
{
StringTokenizer
tok
=
new
StringTokenizer
(
includes
,
", "
,
false
)
;
while
(
tok
.
hasMoreTokens
(
)
)
{
createInclude
(
)
.
setName
(
tok
.
nextToken
(
)
)
;
}
}
}
public
void
setExcludes
(
String
excludes
)
{
if
(
isReference
(
)
)
{
throw
tooManyAttributes
(
)
;
}
if
(
excludes
!=
null
&&
excludes
.
length
(
)
>
0
)
{
StringTokenizer
tok
=
new
StringTokenizer
(
excludes
,
", "
,
false
)
;
while
(
tok
.
hasMoreTokens
(
)
)
{
createExclude
(
)
.
setName
(
tok
.
nextToken
(
)
)
;
}
}
}
private
NameEntry
addPatternToList
(
Vector
list
)
{
NameEntry
result
=
new
NameEntry
(
)
;
list
.
addElement
(
result
)
;
return
result
;
}
public
void
setIncludesfile
(
File
incl
)
throws
BuildException
{
if
(
isReference
(
)
)
{
throw
tooManyAttributes
(
)
;
}
if
(
!
incl
.
exists
(
)
)
{
throw
new
BuildException
(
"Includesfile "
+
incl
.
getAbsolutePath
(
)
+
" not found."
)
;
}
this
.
incl
=
incl
;
}
public
void
setExcludesfile
(
File
excl
)
throws
BuildException
{
if
(
isReference
(
)
)
{
throw
tooManyAttributes
(
)
;
}
if
(
!
excl
.
exists
(
)
)
{
throw
new
BuildException
(
"Excludesfile "
+
excl
.
getAbsolutePath
(
)
+
" not found."
)
;
}
this
.
excl
=
excl
;
}
private
void
readPatterns
(
File
patternfile
,
Vector
patternlist
,
Project
p
)
throws
BuildException
{
try
{
BufferedReader
patternReader
=
new
BufferedReader
(
new
FileReader
(
patternfile
)
)
;
String
line
=
patternReader
.
readLine
(
)
;
while
(
line
!=
null
)
{
if
(
line
.
length
(
)
>
0
)
{
line
=
ProjectHelper
.
replaceProperties
(
p
,
line
,
p
.
getProperties
(
)
)
;
addPatternToList
(
patternlist
)
.
setName
(
line
)
;
}
line
=
patternReader
.
readLine
(
)
;
}
}
catch
(
IOException
ioe
)
{
String
msg
=
"An error occured while reading from pattern file: "
+
patternfile
;
throw
new
BuildException
(
msg
,
ioe
)
;
}
}
public
void
append
(
PatternSet
other
,
Project
p
)
{
if
(
isReference
(
)
)
{
throw
new
BuildException
(
"Cannot append to a reference"
)
;
}
String
[
]
incl
=
other
.
getIncludePatterns
(
p
)
;
if
(
incl
!=
null
)
{
for
(
int
i
=
0
;
i
<
incl
.
length
;
i
++
)
{
createInclude
(
)
.
setName
(
incl
[
i
]
)
;
}
}
String
[
]
excl
=
other
.
getExcludePatterns
(
p
)
;
if
(
excl
!=
null
)
{
for
(
int
i
=
0
;
i
<
excl
.
length
;
i
++
)
{
createExclude
(
)
.
setName
(
excl
[
i
]
)
;
}
}
}
public
String
[
]
getIncludePatterns
(
Project
p
)
{
if
(
isReference
(
)
)
{
return
getRef
(
p
)
.
getIncludePatterns
(
p
)
;
}
else
{
readFiles
(
p
)
;
return
makeArray
(
includeList
,
p
)
;
}
}
public
String
[
]
getExcludePatterns
(
Project
p
)
{
if
(
isReference
(
)
)
{
return
getRef
(
p
)
.
getExcludePatterns
(
p
)
;
}
else
{
readFiles
(
p
)
;
return
makeArray
(
excludeList
,
p
)
;
}
}
boolean
hasPatterns
(
)
{
return
incl
!=
null
||
excl
!=
null
||
includeList
.
size
(
)
>
0
||
excludeList
.
size
(
)
>
0
;
}
private
PatternSet
getRef
(
Project
p
)
{
if
(
!
checked
)
{
Stack
stk
=
new
Stack
(
)
;
stk
.
push
(
this
)
;
dieOnCircularReference
(
stk
,
p
)
;
}
Object
o
=
ref
.
getReferencedObject
(
p
)
;
if
(
!
(
o
instanceof
PatternSet
)
)
{
String
msg
=
ref
.
getRefId
(
)
+
" doesn\'t denote a patternset"
;
throw
new
BuildException
(
msg
)
;
}
else
{
return
(
PatternSet
)
o
;
}
}
private
String
[
]
makeArray
(
Vector
list
,
Project
p
)
{
if
(
list
.
size
(
)
==
0
)
return
null
;
Vector
tmpNames
=
new
Vector
(
)
;
for
(
Enumeration
e
=
list
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
NameEntry
ne
=
(
NameEntry
)
e
.
nextElement
(
)
;
String
pattern
=
ne
.
evalName
(
p
)
;
if
(
pattern
!=
null
&&
pattern
.
length
(
)
>
0
)
{
tmpNames
.
addElement
(
pattern
)
;
}
}
String
result
[
]
=
new
String
[
tmpNames
.
size
(
)
]
;
tmpNames
.
copyInto
(
result
)
;
return
result
;
}
private
void
readFiles
(
Project
p
)
{
if
(
incl
!=
null
)
{
readPatterns
(
incl
,
includeList
,
p
)
;
incl
=
null
;
}
if
(
excl
!=
null
)
{
readPatterns
(
excl
,
excludeList
,
p
)
;
excl
=
null
;
}
}
}
