package
org
.
apache
.
tools
.
ant
;
import
java
.
io
.
*
;
import
java
.
util
.
*
;
public
class
Main
{
public
static
final
String
DEFAULT_BUILD_FILENAME
=
"build.xml"
;
private
int
msgOutputLevel
=
Project
.
MSG_INFO
;
private
File
buildFile
;
private
PrintStream
out
=
System
.
out
;
private
PrintStream
err
=
System
.
err
;
private
Vector
targets
=
new
Vector
(
5
)
;
private
Properties
definedProps
=
new
Properties
(
)
;
private
Vector
listeners
=
new
Vector
(
5
)
;
private
String
loggerClassname
=
null
;
private
boolean
emacsMode
=
false
;
private
boolean
readyToRun
=
false
;
private
boolean
projectHelp
=
false
;
private
static
void
printMessage
(
Throwable
t
)
{
String
message
=
t
.
getMessage
(
)
;
if
(
message
!=
null
)
{
System
.
err
.
println
(
message
)
;
}
}
public
static
void
main
(
String
[
]
args
)
{
Main
m
=
null
;
try
{
m
=
new
Main
(
args
)
;
}
catch
(
Throwable
exc
)
{
printMessage
(
exc
)
;
System
.
exit
(
1
)
;
}
try
{
m
.
runBuild
(
)
;
System
.
exit
(
0
)
;
}
catch
(
BuildException
be
)
{
if
(
m
.
err
!=
System
.
err
)
{
printMessage
(
be
)
;
}
System
.
exit
(
1
)
;
}
catch
(
Throwable
exc
)
{
printMessage
(
exc
)
;
System
.
exit
(
1
)
;
}
}
protected
Main
(
String
[
]
args
)
throws
BuildException
{
String
searchForThis
=
null
;
for
(
int
i
=
0
;
i
<
args
.
length
;
i
++
)
{
String
arg
=
args
[
i
]
;
if
(
arg
.
equals
(
"-help"
)
)
{
printUsage
(
)
;
return
;
}
else
if
(
arg
.
equals
(
"-version"
)
)
{
printVersion
(
)
;
return
;
}
else
if
(
arg
.
equals
(
"-quiet"
)
||
arg
.
equals
(
"-q"
)
)
{
msgOutputLevel
=
Project
.
MSG_WARN
;
}
else
if
(
arg
.
equals
(
"-verbose"
)
||
arg
.
equals
(
"-v"
)
)
{
printVersion
(
)
;
msgOutputLevel
=
Project
.
MSG_VERBOSE
;
}
else
if
(
arg
.
equals
(
"-debug"
)
)
{
printVersion
(
)
;
msgOutputLevel
=
Project
.
MSG_DEBUG
;
}
else
if
(
arg
.
equals
(
"-logfile"
)
||
arg
.
equals
(
"-l"
)
)
{
try
{
File
logFile
=
new
File
(
args
[
i
+
1
]
)
;
i
++
;
out
=
new
PrintStream
(
new
FileOutputStream
(
logFile
)
)
;
err
=
out
;
System
.
setOut
(
out
)
;
System
.
setErr
(
out
)
;
}
catch
(
IOException
ioe
)
{
String
msg
=
"Cannot write on the specified log file. "
+
"Make sure the path exists and you have write permissions."
;
System
.
out
.
println
(
msg
)
;
return
;
}
catch
(
ArrayIndexOutOfBoundsException
aioobe
)
{
String
msg
=
"You must specify a log file when "
+
"using the -log argument"
;
System
.
out
.
println
(
msg
)
;
return
;
}
}
else
if
(
arg
.
equals
(
"-buildfile"
)
||
arg
.
equals
(
"-file"
)
||
arg
.
equals
(
"-f"
)
)
{
try
{
buildFile
=
new
File
(
args
[
i
+
1
]
)
;
i
++
;
}
catch
(
ArrayIndexOutOfBoundsException
aioobe
)
{
String
msg
=
"You must specify a buildfile when "
+
"using the -buildfile argument"
;
System
.
out
.
println
(
msg
)
;
return
;
}
}
else
if
(
arg
.
equals
(
"-listener"
)
)
{
try
{
listeners
.
addElement
(
args
[
i
+
1
]
)
;
i
++
;
}
catch
(
ArrayIndexOutOfBoundsException
aioobe
)
{
String
msg
=
"You must specify a classname when "
+
"using the -listener argument"
;
System
.
out
.
println
(
msg
)
;
return
;
}
}
else
if
(
arg
.
startsWith
(
"-D"
)
)
{
String
name
=
arg
.
substring
(
2
,
arg
.
length
(
)
)
;
String
value
=
null
;
int
posEq
=
name
.
indexOf
(
"="
)
;
if
(
posEq
>
0
)
{
value
=
name
.
substring
(
posEq
+
1
)
;
name
=
name
.
substring
(
0
,
posEq
)
;
}
else
if
(
i
<
args
.
length
-
1
)
value
=
args
[
++
i
]
;
definedProps
.
put
(
name
,
value
)
;
}
else
if
(
arg
.
equals
(
"-logger"
)
)
{
if
(
loggerClassname
!=
null
)
{
System
.
out
.
println
(
"Only one logger class may be specified."
)
;
return
;
}
loggerClassname
=
args
[
++
i
]
;
}
else
if
(
arg
.
equals
(
"-emacs"
)
)
{
emacsMode
=
true
;
}
else
if
(
arg
.
equals
(
"-projecthelp"
)
)
{
projectHelp
=
true
;
}
else
if
(
arg
.
equals
(
"-find"
)
)
{
if
(
i
<
args
.
length
-
1
)
{
searchForThis
=
args
[
++
i
]
;
}
else
{
searchForThis
=
DEFAULT_BUILD_FILENAME
;
}
}
else
if
(
arg
.
startsWith
(
"-"
)
)
{
String
msg
=
"Unknown argument: "
+
arg
;
System
.
out
.
println
(
msg
)
;
printUsage
(
)
;
return
;
}
else
{
targets
.
addElement
(
arg
)
;
}
}
if
(
buildFile
==
null
)
{
if
(
searchForThis
!=
null
)
{
buildFile
=
findBuildFile
(
"."
,
searchForThis
)
;
}
else
{
buildFile
=
new
File
(
DEFAULT_BUILD_FILENAME
)
;
}
}
if
(
!
buildFile
.
exists
(
)
)
{
System
.
out
.
println
(
"Buildfile: "
+
buildFile
+
" does not exist!"
)
;
throw
new
BuildException
(
"Build failed"
)
;
}
if
(
buildFile
.
isDirectory
(
)
)
{
System
.
out
.
println
(
"What? Buildfile: "
+
buildFile
+
" is a dir!"
)
;
throw
new
BuildException
(
"Build failed"
)
;
}
readyToRun
=
true
;
}
private
File
getParentFile
(
File
file
)
{
String
filename
=
file
.
getAbsolutePath
(
)
;
file
=
new
File
(
filename
)
;
filename
=
file
.
getParent
(
)
;
if
(
filename
!=
null
&&
msgOutputLevel
>=
Project
.
MSG_VERBOSE
)
{
System
.
out
.
println
(
"Searching in "
+
filename
)
;
}
return
(
filename
==
null
)
?
null
:
new
File
(
filename
)
;
}
private
File
findBuildFile
(
String
start
,
String
suffix
)
throws
BuildException
{
if
(
msgOutputLevel
>=
Project
.
MSG_INFO
)
{
System
.
out
.
println
(
"Searching for "
+
suffix
+
" ..."
)
;
}
File
parent
=
new
File
(
new
File
(
start
)
.
getAbsolutePath
(
)
)
;
File
file
=
new
File
(
parent
,
suffix
)
;
while
(
!
file
.
exists
(
)
)
{
parent
=
getParentFile
(
parent
)
;
if
(
parent
==
null
)
{
throw
new
BuildException
(
"Could not locate a build file!"
)
;
}
file
=
new
File
(
parent
,
suffix
)
;
}
return
file
;
}
private
void
runBuild
(
)
throws
BuildException
{
if
(
!
readyToRun
)
{
return
;
}
if
(
msgOutputLevel
>=
Project
.
MSG_INFO
)
{
System
.
out
.
println
(
"Buildfile: "
+
buildFile
)
;
}
Project
project
=
new
Project
(
)
;
Throwable
error
=
null
;
try
{
addBuildListeners
(
project
)
;
project
.
fireBuildStarted
(
)
;
project
.
init
(
)
;
Enumeration
e
=
definedProps
.
keys
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
String
arg
=
(
String
)
e
.
nextElement
(
)
;
String
value
=
(
String
)
definedProps
.
get
(
arg
)
;
project
.
setUserProperty
(
arg
,
value
)
;
}
project
.
setUserProperty
(
"ant.file"
,
buildFile
.
getAbsolutePath
(
)
)
;
try
{
Class
.
forName
(
"javax.xml.parsers.SAXParserFactory"
)
;
ProjectHelper
.
configureProject
(
project
,
buildFile
)
;
}
catch
(
NoClassDefFoundError
ncdfe
)
{
throw
new
BuildException
(
"No JAXP compliant XML parser found. See http://java.sun.com/xml for the\nreference implementation."
,
ncdfe
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
throw
new
BuildException
(
"No JAXP compliant XML parser found. See http://java.sun.com/xml for the\nreference implementation."
,
cnfe
)
;
}
catch
(
NullPointerException
npe
)
{
throw
new
BuildException
(
"No JAXP compliant XML parser found. See http://java.sun.com/xml for the\nreference implementation."
,
npe
)
;
}
if
(
targets
.
size
(
)
==
0
)
{
targets
.
addElement
(
project
.
getDefaultTarget
(
)
)
;
}
if
(
projectHelp
)
{
printTargets
(
project
)
;
}
else
{
project
.
executeTargets
(
targets
)
;
}
}
catch
(
RuntimeException
exc
)
{
error
=
exc
;
throw
exc
;
}
catch
(
Error
err
)
{
error
=
err
;
throw
err
;
}
finally
{
project
.
fireBuildFinished
(
error
)
;
}
}
protected
void
addBuildListeners
(
Project
project
)
{
project
.
addBuildListener
(
createLogger
(
)
)
;
for
(
int
i
=
0
;
i
<
listeners
.
size
(
)
;
i
++
)
{
String
className
=
(
String
)
listeners
.
elementAt
(
i
)
;
try
{
BuildListener
listener
=
(
BuildListener
)
Class
.
forName
(
className
)
.
newInstance
(
)
;
project
.
addBuildListener
(
listener
)
;
}
catch
(
Exception
exc
)
{
throw
new
BuildException
(
"Unable to instantiate listener "
+
className
,
exc
)
;
}
}
}
private
BuildLogger
createLogger
(
)
{
BuildLogger
logger
=
null
;
if
(
loggerClassname
!=
null
)
{
try
{
logger
=
(
BuildLogger
)
(
Class
.
forName
(
loggerClassname
)
.
newInstance
(
)
)
;
}
catch
(
ClassCastException
e
)
{
System
.
err
.
println
(
"The specified logger class "
+
loggerClassname
+
" does not implement the BuildLogger interface"
)
;
throw
new
RuntimeException
(
)
;
}
catch
(
Exception
e
)
{
System
.
err
.
println
(
"Unable to instantiate specified logger class "
+
loggerClassname
+
" : "
+
e
.
getClass
(
)
.
getName
(
)
)
;
throw
new
RuntimeException
(
)
;
}
}
else
{
logger
=
new
DefaultLogger
(
)
;
}
logger
.
setMessageOutputLevel
(
msgOutputLevel
)
;
logger
.
setOutputPrintStream
(
out
)
;
logger
.
setErrorPrintStream
(
err
)
;
logger
.
setEmacsMode
(
emacsMode
)
;
return
logger
;
}
private
static
void
printUsage
(
)
{
String
lSep
=
System
.
getProperty
(
"line.separator"
)
;
StringBuffer
msg
=
new
StringBuffer
(
)
;
msg
.
append
(
"ant [options] [target [target2 [target3] ...]]"
+
lSep
)
;
msg
.
append
(
"Options: "
+
lSep
)
;
msg
.
append
(
"  -help                  print this message"
+
lSep
)
;
msg
.
append
(
"  -projecthelp           print project help information"
+
lSep
)
;
msg
.
append
(
"  -version               print the version information and exit"
+
lSep
)
;
msg
.
append
(
"  -quiet                 be extra quiet"
+
lSep
)
;
msg
.
append
(
"  -verbose               be extra verbose"
+
lSep
)
;
msg
.
append
(
"  -debug                 print debugging information"
+
lSep
)
;
msg
.
append
(
"  -emacs                 produce logging information without adornments"
+
lSep
)
;
msg
.
append
(
"  -logfile <file>        use given file for log"
+
lSep
)
;
msg
.
append
(
"  -logger <classname>    the class which is to perform logging"
+
lSep
)
;
msg
.
append
(
"  -listener <classname>  add an instance of class as a project listener"
+
lSep
)
;
msg
.
append
(
"  -buildfile <file>      use given buildfile"
+
lSep
)
;
msg
.
append
(
"  -D<property>=<value>   use value for given property"
+
lSep
)
;
msg
.
append
(
"  -find <file>           search for buildfile towards the root of the"
+
lSep
)
;
msg
.
append
(
"                         filesystem and use it"
+
lSep
)
;
System
.
out
.
println
(
msg
.
toString
(
)
)
;
}
private
static
void
printVersion
(
)
{
try
{
Properties
props
=
new
Properties
(
)
;
InputStream
in
=
Main
.
class
.
getResourceAsStream
(
"/org/apache/tools/ant/version.txt"
)
;
props
.
load
(
in
)
;
in
.
close
(
)
;
String
lSep
=
System
.
getProperty
(
"line.separator"
)
;
StringBuffer
msg
=
new
StringBuffer
(
)
;
msg
.
append
(
"Ant version "
)
;
msg
.
append
(
props
.
getProperty
(
"VERSION"
)
)
;
msg
.
append
(
" compiled on "
)
;
msg
.
append
(
props
.
getProperty
(
"DATE"
)
)
;
msg
.
append
(
lSep
)
;
System
.
out
.
println
(
msg
.
toString
(
)
)
;
}
catch
(
IOException
ioe
)
{
System
.
err
.
println
(
"Could not load the version information."
)
;
System
.
err
.
println
(
ioe
.
getMessage
(
)
)
;
}
catch
(
NullPointerException
npe
)
{
System
.
err
.
println
(
"Could not load the version information."
)
;
}
}
private
static
void
printTargets
(
Project
project
)
{
int
maxLength
=
0
;
Enumeration
ptargets
=
project
.
getTargets
(
)
.
elements
(
)
;
String
targetName
;
String
targetDescription
;
Target
currentTarget
;
Vector
topNames
=
new
Vector
(
)
;
Vector
topDescriptions
=
new
Vector
(
)
;
Vector
subNames
=
new
Vector
(
)
;
while
(
ptargets
.
hasMoreElements
(
)
)
{
currentTarget
=
(
Target
)
ptargets
.
nextElement
(
)
;
targetName
=
currentTarget
.
getName
(
)
;
targetDescription
=
currentTarget
.
getDescription
(
)
;
if
(
targetDescription
==
null
)
{
int
pos
=
findTargetPosition
(
subNames
,
targetName
)
;
subNames
.
insertElementAt
(
targetName
,
pos
)
;
}
else
{
int
pos
=
findTargetPosition
(
topNames
,
targetName
)
;
topNames
.
insertElementAt
(
targetName
,
pos
)
;
topDescriptions
.
insertElementAt
(
targetDescription
,
pos
)
;
if
(
targetName
.
length
(
)
>
maxLength
)
{
maxLength
=
targetName
.
length
(
)
;
}
}
}
printTargets
(
topNames
,
topDescriptions
,
"Main targets:"
,
maxLength
)
;
printTargets
(
subNames
,
null
,
"Subtargets:"
,
0
)
;
}
private
static
int
findTargetPosition
(
Vector
names
,
String
name
)
{
int
res
=
names
.
size
(
)
;
for
(
int
i
=
0
;
i
<
names
.
size
(
)
&&
res
==
names
.
size
(
)
;
i
++
)
{
if
(
name
.
compareTo
(
(
String
)
names
.
elementAt
(
i
)
)
<
0
)
{
res
=
i
;
}
}
return
res
;
}
private
static
void
printTargets
(
Vector
names
,
Vector
descriptions
,
String
heading
,
int
maxlen
)
{
String
lSep
=
System
.
getProperty
(
"line.separator"
)
;
String
spaces
=
"    "
;
while
(
spaces
.
length
(
)
<
maxlen
)
{
spaces
+=
spaces
;
}
StringBuffer
msg
=
new
StringBuffer
(
)
;
msg
.
append
(
heading
+
lSep
+
lSep
)
;
for
(
int
i
=
0
;
i
<
names
.
size
(
)
;
i
++
)
{
msg
.
append
(
" "
)
;
msg
.
append
(
names
.
elementAt
(
i
)
)
;
if
(
descriptions
!=
null
)
{
msg
.
append
(
spaces
.
substring
(
0
,
maxlen
-
(
(
String
)
names
.
elementAt
(
i
)
)
.
length
(
)
+
2
)
)
;
msg
.
append
(
descriptions
.
elementAt
(
i
)
)
;
}
msg
.
append
(
lSep
)
;
}
System
.
out
.
println
(
msg
.
toString
(
)
)
;
}
}
