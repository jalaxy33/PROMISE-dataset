package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
org
.
apache
.
tools
.
ant
.
AntClassLoader
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
types
.
Commandline
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
types
.
Reference
;
import
org
.
apache
.
tools
.
ant
.
util
.
*
;
import
java
.
io
.
*
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Date
;
public
class
Rmic
extends
MatchingTask
{
private
File
baseDir
;
private
String
classname
;
private
File
sourceBase
;
private
String
stubVersion
;
private
Path
compileClasspath
;
private
boolean
verify
=
false
;
private
boolean
filtering
=
false
;
private
boolean
iiop
=
false
;
private
String
iiopopts
;
private
boolean
idl
=
false
;
private
String
idlopts
;
private
boolean
debug
=
false
;
private
Vector
compileList
=
new
Vector
(
)
;
private
ClassLoader
loader
=
null
;
public
void
setBase
(
File
base
)
{
this
.
baseDir
=
base
;
}
public
void
setClassname
(
String
classname
)
{
this
.
classname
=
classname
;
}
public
void
setSourceBase
(
File
sourceBase
)
{
this
.
sourceBase
=
sourceBase
;
}
public
void
setStubVersion
(
String
stubVersion
)
{
this
.
stubVersion
=
stubVersion
;
}
public
void
setFiltering
(
boolean
filter
)
{
filtering
=
filter
;
}
public
void
setDebug
(
boolean
debug
)
{
this
.
debug
=
debug
;
}
public
void
setClasspath
(
Path
classpath
)
{
if
(
compileClasspath
==
null
)
{
compileClasspath
=
classpath
;
}
else
{
compileClasspath
.
append
(
classpath
)
;
}
}
public
Path
createClasspath
(
)
{
if
(
compileClasspath
==
null
)
{
compileClasspath
=
new
Path
(
project
)
;
}
return
compileClasspath
.
createPath
(
)
;
}
public
void
setClasspathRef
(
Reference
r
)
{
createClasspath
(
)
.
setRefid
(
r
)
;
}
public
void
setVerify
(
boolean
verify
)
{
this
.
verify
=
verify
;
}
public
void
setIiop
(
boolean
iiop
)
{
this
.
iiop
=
iiop
;
}
public
void
setIiopopts
(
String
iiopopts
)
{
this
.
iiopopts
=
iiopopts
;
}
public
void
setIdl
(
boolean
idl
)
{
this
.
idl
=
idl
;
}
public
void
setIdlopts
(
String
idlopts
)
{
this
.
idlopts
=
idlopts
;
}
public
void
execute
(
)
throws
BuildException
{
if
(
baseDir
==
null
)
{
throw
new
BuildException
(
"base attribute must be set!"
,
location
)
;
}
if
(
!
baseDir
.
exists
(
)
)
{
throw
new
BuildException
(
"base does not exist!"
,
location
)
;
}
if
(
verify
)
{
log
(
"Verify has been turned on."
,
Project
.
MSG_INFO
)
;
}
if
(
iiop
)
{
log
(
"IIOP has been turned on."
,
Project
.
MSG_INFO
)
;
if
(
iiopopts
!=
null
)
{
log
(
"IIOP Options: "
+
iiopopts
,
Project
.
MSG_INFO
)
;
}
}
if
(
idl
)
{
log
(
"IDL has been turned on."
,
Project
.
MSG_INFO
)
;
if
(
idlopts
!=
null
)
{
log
(
"IDL Options: "
+
idlopts
,
Project
.
MSG_INFO
)
;
}
}
Path
classpath
=
getCompileClasspath
(
baseDir
)
;
loader
=
new
AntClassLoader
(
project
,
classpath
)
;
if
(
classname
==
null
)
{
DirectoryScanner
ds
=
this
.
getDirectoryScanner
(
baseDir
)
;
String
[
]
files
=
ds
.
getIncludedFiles
(
)
;
scanDir
(
baseDir
,
files
)
;
}
else
{
scanDir
(
baseDir
,
new
String
[
]
{
classname
.
replace
(
'.'
,
File
.
separatorChar
)
+
".class"
}
)
;
}
OutputStream
logstr
=
new
LogOutputStream
(
this
,
Project
.
MSG_WARN
)
;
sun
.
rmi
.
rmic
.
Main
compiler
=
new
sun
.
rmi
.
rmic
.
Main
(
logstr
,
"rmic"
)
;
Commandline
cmd
=
new
Commandline
(
)
;
cmd
.
createArgument
(
)
.
setValue
(
"-d"
)
;
cmd
.
createArgument
(
)
.
setFile
(
baseDir
)
;
cmd
.
createArgument
(
)
.
setValue
(
"-classpath"
)
;
cmd
.
createArgument
(
)
.
setPath
(
classpath
)
;
if
(
null
!=
stubVersion
)
{
if
(
"1.1"
.
equals
(
stubVersion
)
)
cmd
.
createArgument
(
)
.
setValue
(
"-v1.1"
)
;
else
if
(
"1.2"
.
equals
(
stubVersion
)
)
cmd
.
createArgument
(
)
.
setValue
(
"-v1.2"
)
;
else
cmd
.
createArgument
(
)
.
setValue
(
"-vcompat"
)
;
}
if
(
null
!=
sourceBase
)
cmd
.
createArgument
(
)
.
setValue
(
"-keepgenerated"
)
;
if
(
iiop
)
{
cmd
.
createArgument
(
)
.
setValue
(
"-iiop"
)
;
if
(
iiopopts
!=
null
)
cmd
.
createArgument
(
)
.
setValue
(
iiopopts
)
;
}
if
(
idl
)
{
cmd
.
createArgument
(
)
.
setValue
(
"-idl"
)
;
if
(
idlopts
!=
null
)
cmd
.
createArgument
(
)
.
setValue
(
idlopts
)
;
}
if
(
debug
)
{
cmd
.
createArgument
(
)
.
setValue
(
"-g"
)
;
}
int
fileCount
=
compileList
.
size
(
)
;
if
(
fileCount
>
0
)
{
log
(
"RMI Compiling "
+
fileCount
+
" class"
+
(
fileCount
>
1
?
"es"
:
""
)
+
" to "
+
baseDir
,
Project
.
MSG_INFO
)
;
for
(
int
j
=
0
;
j
<
fileCount
;
j
++
)
{
cmd
.
createArgument
(
)
.
setValue
(
(
String
)
compileList
.
elementAt
(
j
)
)
;
}
log
(
"Compilation args: "
+
cmd
.
toString
(
)
,
Project
.
MSG_VERBOSE
)
;
compiler
.
compile
(
cmd
.
getArguments
(
)
)
;
}
if
(
null
!=
sourceBase
)
{
for
(
int
j
=
0
;
j
<
fileCount
;
j
++
)
{
moveGeneratedFile
(
baseDir
,
sourceBase
,
(
String
)
compileList
.
elementAt
(
j
)
)
;
}
}
compileList
.
removeAllElements
(
)
;
}
private
void
moveGeneratedFile
(
File
baseDir
,
File
sourceBaseFile
,
String
classname
)
throws
BuildException
{
String
stubFileName
=
classname
.
replace
(
'.'
,
File
.
separatorChar
)
+
"_Stub.java"
;
File
oldStubFile
=
new
File
(
baseDir
,
stubFileName
)
;
File
newStubFile
=
new
File
(
sourceBaseFile
,
stubFileName
)
;
try
{
project
.
copyFile
(
oldStubFile
,
newStubFile
,
filtering
)
;
oldStubFile
.
delete
(
)
;
}
catch
(
IOException
ioe
)
{
String
msg
=
"Failed to copy "
+
oldStubFile
+
" to "
+
newStubFile
+
" due to "
+
ioe
.
getMessage
(
)
;
throw
new
BuildException
(
msg
,
ioe
,
location
)
;
}
if
(
!
"1.2"
.
equals
(
stubVersion
)
)
{
String
skelFileName
=
classname
.
replace
(
'.'
,
'/'
)
+
"_Skel.java"
;
File
oldSkelFile
=
new
File
(
baseDir
,
skelFileName
)
;
File
newSkelFile
=
new
File
(
sourceBaseFile
,
skelFileName
)
;
try
{
project
.
copyFile
(
oldSkelFile
,
newSkelFile
,
filtering
)
;
oldSkelFile
.
delete
(
)
;
}
catch
(
IOException
ioe
)
{
String
msg
=
"Failed to copy "
+
oldSkelFile
+
" to "
+
newSkelFile
+
" due to "
+
ioe
.
getMessage
(
)
;
throw
new
BuildException
(
msg
,
ioe
,
location
)
;
}
}
}
protected
void
scanDir
(
File
baseDir
,
String
files
[
]
)
{
SourceFileScanner
sfs
=
new
SourceFileScanner
(
this
)
;
String
[
]
newFiles
=
sfs
.
restrict
(
files
,
baseDir
,
baseDir
,
new
RmicFileNameMapper
(
)
)
;
for
(
int
i
=
0
;
i
<
newFiles
.
length
;
i
++
)
{
String
classname
=
newFiles
[
i
]
.
replace
(
File
.
separatorChar
,
'.'
)
;
classname
=
classname
.
substring
(
0
,
classname
.
indexOf
(
".class"
)
)
;
compileList
.
addElement
(
classname
)
;
}
}
private
Path
getCompileClasspath
(
File
baseFile
)
{
Path
classpath
=
new
Path
(
project
,
baseFile
.
getAbsolutePath
(
)
)
;
if
(
compileClasspath
==
null
)
{
classpath
.
addExisting
(
Path
.
systemClasspath
)
;
}
else
{
classpath
.
addExisting
(
compileClasspath
.
concatSystemClasspath
(
)
)
;
}
if
(
Project
.
getJavaVersion
(
)
.
startsWith
(
"1.2"
)
)
{
String
bootcp
=
System
.
getProperty
(
"sun.boot.class.path"
)
;
if
(
bootcp
!=
null
)
{
classpath
.
addExisting
(
new
Path
(
project
,
bootcp
)
)
;
}
}
return
classpath
;
}
private
class
RmicFileNameMapper
implements
FileNameMapper
{
private
GlobPatternMapper
stubMapper
;
private
GlobPatternMapper
skelMapper
;
RmicFileNameMapper
(
)
{
stubMapper
=
new
GlobPatternMapper
(
)
;
stubMapper
.
setFrom
(
"*.class"
)
;
stubMapper
.
setTo
(
"*_Stub.class"
)
;
if
(
!
"1.2"
.
equals
(
stubVersion
)
)
{
skelMapper
=
new
GlobPatternMapper
(
)
;
skelMapper
.
setFrom
(
"*.class"
)
;
skelMapper
.
setTo
(
"*_Skel.class"
)
;
}
}
public
void
setFrom
(
String
s
)
{
}
public
void
setTo
(
String
s
)
{
}
public
String
[
]
mapFileName
(
String
name
)
{
String
[
]
stubName
=
stubMapper
.
mapFileName
(
name
)
;
if
(
stubName
==
null
||
name
.
endsWith
(
"_Stub.class"
)
||
name
.
endsWith
(
"_Skel.class"
)
)
{
return
null
;
}
String
classname
=
name
.
replace
(
File
.
separatorChar
,
'.'
)
;
classname
=
classname
.
substring
(
0
,
classname
.
indexOf
(
".class"
)
)
;
if
(
verify
)
{
try
{
Class
testClass
=
loader
.
loadClass
(
classname
)
;
if
(
testClass
.
isInterface
(
)
||
!
isValidRmiRemote
(
testClass
)
)
{
return
null
;
}
}
catch
(
ClassNotFoundException
e
)
{
log
(
"Unable to verify class "
+
classname
+
". It could not be found."
,
Project
.
MSG_WARN
)
;
}
catch
(
NoClassDefFoundError
e
)
{
log
(
"Unable to verify class "
+
classname
+
". It is not defined."
,
Project
.
MSG_WARN
)
;
}
}
if
(
skelMapper
!=
null
)
{
return
new
String
[
]
{
stubName
[
0
]
,
skelMapper
.
mapFileName
(
name
)
[
0
]
}
;
}
else
{
return
stubName
;
}
}
private
boolean
isValidRmiRemote
(
Class
testClass
)
{
Class
rmiRemote
=
java
.
rmi
.
Remote
.
class
;
if
(
rmiRemote
.
equals
(
testClass
)
)
{
return
true
;
}
Class
[
]
interfaces
=
testClass
.
getInterfaces
(
)
;
if
(
interfaces
!=
null
)
{
for
(
int
i
=
0
;
i
<
interfaces
.
length
;
i
++
)
{
if
(
rmiRemote
.
equals
(
interfaces
[
i
]
)
)
{
return
true
;
}
if
(
isValidRmiRemote
(
interfaces
[
i
]
)
)
{
return
true
;
}
}
}
return
false
;
}
}
}
