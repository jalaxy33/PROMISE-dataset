package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
types
.
*
;
import
org
.
apache
.
tools
.
ant
.
util
.
*
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
compilers
.
*
;
import
java
.
io
.
File
;
public
class
Javac
extends
MatchingTask
{
private
static
final
String
FAIL_MSG
=
"Compile failed, messages should have been provided."
;
private
Path
src
;
private
File
destDir
;
private
Path
compileClasspath
;
private
String
encoding
;
private
boolean
debug
=
false
;
private
boolean
optimize
=
false
;
private
boolean
deprecation
=
false
;
private
boolean
depend
=
false
;
private
boolean
verbose
=
false
;
private
String
target
;
private
Path
bootclasspath
;
private
Path
extdirs
;
private
boolean
includeAntRuntime
=
true
;
private
boolean
includeJavaRuntime
=
false
;
protected
boolean
failOnError
=
true
;
protected
File
[
]
compileList
=
new
File
[
0
]
;
public
Path
createSrc
(
)
{
if
(
src
==
null
)
{
src
=
new
Path
(
project
)
;
}
return
src
.
createPath
(
)
;
}
public
void
setSrcdir
(
Path
srcDir
)
{
if
(
src
==
null
)
{
src
=
srcDir
;
}
else
{
src
.
append
(
srcDir
)
;
}
}
public
Path
getSrcdir
(
)
{
return
src
;
}
public
void
setDestdir
(
File
destDir
)
{
this
.
destDir
=
destDir
;
}
public
File
getDestdir
(
)
{
return
destDir
;
}
public
void
setClasspath
(
Path
classpath
)
{
if
(
compileClasspath
==
null
)
{
compileClasspath
=
classpath
;
}
else
{
compileClasspath
.
append
(
classpath
)
;
}
}
public
Path
getClasspath
(
)
{
return
compileClasspath
;
}
public
Path
createClasspath
(
)
{
if
(
compileClasspath
==
null
)
{
compileClasspath
=
new
Path
(
project
)
;
}
return
compileClasspath
.
createPath
(
)
;
}
public
void
setClasspathRef
(
Reference
r
)
{
createClasspath
(
)
.
setRefid
(
r
)
;
}
public
void
setBootclasspath
(
Path
bootclasspath
)
{
if
(
this
.
bootclasspath
==
null
)
{
this
.
bootclasspath
=
bootclasspath
;
}
else
{
this
.
bootclasspath
.
append
(
bootclasspath
)
;
}
}
public
Path
getBootclasspath
(
)
{
return
bootclasspath
;
}
public
Path
createBootclasspath
(
)
{
if
(
bootclasspath
==
null
)
{
bootclasspath
=
new
Path
(
project
)
;
}
return
bootclasspath
.
createPath
(
)
;
}
public
void
setBootClasspathRef
(
Reference
r
)
{
createBootclasspath
(
)
.
setRefid
(
r
)
;
}
public
void
setExtdirs
(
Path
extdirs
)
{
if
(
this
.
extdirs
==
null
)
{
this
.
extdirs
=
extdirs
;
}
else
{
this
.
extdirs
.
append
(
extdirs
)
;
}
}
public
Path
getExtdirs
(
)
{
return
extdirs
;
}
public
Path
createExtdirs
(
)
{
if
(
extdirs
==
null
)
{
extdirs
=
new
Path
(
project
)
;
}
return
extdirs
.
createPath
(
)
;
}
public
void
setFailonerror
(
boolean
fail
)
{
failOnError
=
fail
;
}
public
void
setProceed
(
boolean
proceed
)
{
failOnError
=
!
proceed
;
}
public
boolean
getFailonerror
(
)
{
return
failOnError
;
}
public
void
setDeprecation
(
boolean
deprecation
)
{
this
.
deprecation
=
deprecation
;
}
public
boolean
getDeprecation
(
)
{
return
deprecation
;
}
public
void
setEncoding
(
String
encoding
)
{
this
.
encoding
=
encoding
;
}
public
String
getEncoding
(
)
{
return
encoding
;
}
public
void
setDebug
(
boolean
debug
)
{
this
.
debug
=
debug
;
}
public
boolean
getDebug
(
)
{
return
debug
;
}
public
void
setOptimize
(
boolean
optimize
)
{
this
.
optimize
=
optimize
;
}
public
boolean
getOptimize
(
)
{
return
optimize
;
}
public
void
setDepend
(
boolean
depend
)
{
this
.
depend
=
depend
;
}
public
boolean
getDepend
(
)
{
return
depend
;
}
public
void
setVerbose
(
boolean
verbose
)
{
this
.
verbose
=
verbose
;
}
public
boolean
getVerbose
(
)
{
return
verbose
;
}
public
void
setTarget
(
String
target
)
{
this
.
target
=
target
;
}
public
String
getTarget
(
)
{
return
target
;
}
public
void
setIncludeantruntime
(
boolean
include
)
{
includeAntRuntime
=
include
;
}
public
boolean
getIncludeantruntime
(
)
{
return
includeAntRuntime
;
}
public
void
setIncludejavaruntime
(
boolean
include
)
{
includeJavaRuntime
=
include
;
}
public
boolean
getIncludejavaruntime
(
)
{
return
includeJavaRuntime
;
}
public
void
execute
(
)
throws
BuildException
{
if
(
src
==
null
)
{
throw
new
BuildException
(
"srcdir attribute must be set!"
,
location
)
;
}
String
[
]
list
=
src
.
list
(
)
;
if
(
list
.
length
==
0
)
{
throw
new
BuildException
(
"srcdir attribute must be set!"
,
location
)
;
}
if
(
destDir
!=
null
&&
!
destDir
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"destination directory \""
+
destDir
+
"\" does not exist or is not a directory"
,
location
)
;
}
resetFileLists
(
)
;
for
(
int
i
=
0
;
i
<
list
.
length
;
i
++
)
{
File
srcDir
=
(
File
)
project
.
resolveFile
(
list
[
i
]
)
;
if
(
!
srcDir
.
exists
(
)
)
{
throw
new
BuildException
(
"srcdir \""
+
srcDir
.
getPath
(
)
+
"\" does not exist!"
,
location
)
;
}
DirectoryScanner
ds
=
this
.
getDirectoryScanner
(
srcDir
)
;
String
[
]
files
=
ds
.
getIncludedFiles
(
)
;
scanDir
(
srcDir
,
destDir
!=
null
?
destDir
:
srcDir
,
files
)
;
}
String
compiler
=
project
.
getProperty
(
"build.compiler"
)
;
if
(
compiler
==
null
)
{
if
(
Project
.
getJavaVersion
(
)
.
startsWith
(
"1.3"
)
)
{
compiler
=
"modern"
;
}
else
{
compiler
=
"classic"
;
}
}
if
(
compileList
.
length
>
0
)
{
CompilerAdapter
adapter
=
CompilerAdapterFactory
.
getCompiler
(
compiler
,
this
)
;
log
(
"Compiling "
+
compileList
.
length
+
" source file"
+
(
compileList
.
length
==
1
?
""
:
"s"
)
+
(
destDir
!=
null
?
" to "
+
destDir
:
""
)
)
;
adapter
.
setJavac
(
this
)
;
if
(
!
adapter
.
execute
(
)
)
{
if
(
failOnError
)
{
throw
new
BuildException
(
FAIL_MSG
,
location
)
;
}
else
{
log
(
FAIL_MSG
,
Project
.
MSG_ERR
)
;
}
}
}
}
protected
void
resetFileLists
(
)
{
compileList
=
new
File
[
0
]
;
}
protected
void
scanDir
(
File
srcDir
,
File
destDir
,
String
files
[
]
)
{
GlobPatternMapper
m
=
new
GlobPatternMapper
(
)
;
m
.
setFrom
(
"*.java"
)
;
m
.
setTo
(
"*.class"
)
;
SourceFileScanner
sfs
=
new
SourceFileScanner
(
this
)
;
File
[
]
newFiles
=
sfs
.
restrictAsFiles
(
files
,
srcDir
,
destDir
,
m
)
;
if
(
newFiles
.
length
>
0
)
{
File
[
]
newCompileList
=
new
File
[
compileList
.
length
+
newFiles
.
length
]
;
System
.
arraycopy
(
compileList
,
0
,
newCompileList
,
0
,
compileList
.
length
)
;
System
.
arraycopy
(
newFiles
,
0
,
newCompileList
,
compileList
.
length
,
newFiles
.
length
)
;
compileList
=
newCompileList
;
}
}
public
File
[
]
getFileList
(
)
{
return
compileList
;
}
}
