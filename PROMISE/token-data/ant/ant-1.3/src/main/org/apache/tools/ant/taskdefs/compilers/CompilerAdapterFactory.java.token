package
org
.
apache
.
tools
.
ant
.
taskdefs
.
compilers
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
Project
;
public
class
CompilerAdapterFactory
{
private
CompilerAdapterFactory
(
)
{
}
public
static
CompilerAdapter
getCompiler
(
String
compilerType
,
Task
task
)
throws
BuildException
{
if
(
compilerType
.
equalsIgnoreCase
(
"jikes"
)
)
{
return
new
Jikes
(
)
;
}
if
(
compilerType
.
equalsIgnoreCase
(
"classic"
)
||
compilerType
.
equalsIgnoreCase
(
"javac1.1"
)
||
compilerType
.
equalsIgnoreCase
(
"javac1.2"
)
)
{
return
new
Javac12
(
)
;
}
if
(
compilerType
.
equalsIgnoreCase
(
"modern"
)
||
compilerType
.
equalsIgnoreCase
(
"javac1.3"
)
)
{
try
{
Class
.
forName
(
"com.sun.tools.javac.Main"
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
task
.
log
(
"Modern compiler is not available - using "
+
"classic compiler"
,
Project
.
MSG_WARN
)
;
return
new
Javac12
(
)
;
}
return
new
Javac13
(
)
;
}
if
(
compilerType
.
equalsIgnoreCase
(
"jvc"
)
||
compilerType
.
equalsIgnoreCase
(
"microsoft"
)
)
{
return
new
Jvc
(
)
;
}
return
resolveClassName
(
compilerType
)
;
}
private
static
CompilerAdapter
resolveClassName
(
String
className
)
throws
BuildException
{
try
{
Class
c
=
Class
.
forName
(
className
)
;
Object
o
=
c
.
newInstance
(
)
;
return
(
CompilerAdapter
)
o
;
}
catch
(
ClassNotFoundException
cnfe
)
{
throw
new
BuildException
(
className
+
" can\'t be found."
,
cnfe
)
;
}
catch
(
ClassCastException
cce
)
{
throw
new
BuildException
(
className
+
" isn\'t the classname of "
+
"a compiler adapter."
,
cce
)
;
}
catch
(
Throwable
t
)
{
throw
new
BuildException
(
className
+
" caused an interesting "
+
"exception."
,
t
)
;
}
}
}
