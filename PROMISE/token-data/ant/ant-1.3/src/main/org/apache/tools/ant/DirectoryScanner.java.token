package
org
.
apache
.
tools
.
ant
;
import
java
.
io
.
*
;
import
java
.
util
.
*
;
public
class
DirectoryScanner
implements
FileScanner
{
protected
final
static
String
[
]
DEFAULTEXCLUDES
=
{
"**/*~"
,
"**/#*#"
,
"**/%*%"
,
"**/CVS"
,
"**/CVS/**"
,
"**/.cvsignore"
}
;
protected
File
basedir
;
protected
String
[
]
includes
;
protected
String
[
]
excludes
;
protected
Vector
filesIncluded
;
protected
Vector
filesNotIncluded
;
protected
Vector
filesExcluded
;
protected
Vector
dirsIncluded
;
protected
Vector
dirsNotIncluded
;
protected
Vector
dirsExcluded
;
protected
boolean
haveSlowResults
=
false
;
public
DirectoryScanner
(
)
{
}
protected
static
boolean
matchPatternStart
(
String
pattern
,
String
str
)
{
if
(
str
.
startsWith
(
File
.
separator
)
!=
pattern
.
startsWith
(
File
.
separator
)
)
{
return
false
;
}
Vector
patDirs
=
new
Vector
(
)
;
StringTokenizer
st
=
new
StringTokenizer
(
pattern
,
File
.
separator
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
patDirs
.
addElement
(
st
.
nextToken
(
)
)
;
}
Vector
strDirs
=
new
Vector
(
)
;
st
=
new
StringTokenizer
(
str
,
File
.
separator
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
strDirs
.
addElement
(
st
.
nextToken
(
)
)
;
}
int
patIdxStart
=
0
;
int
patIdxEnd
=
patDirs
.
size
(
)
-
1
;
int
strIdxStart
=
0
;
int
strIdxEnd
=
strDirs
.
size
(
)
-
1
;
while
(
patIdxStart
<=
patIdxEnd
&&
strIdxStart
<=
strIdxEnd
)
{
String
patDir
=
(
String
)
patDirs
.
elementAt
(
patIdxStart
)
;
if
(
patDir
.
equals
(
"**"
)
)
{
break
;
}
if
(
!
match
(
patDir
,
(
String
)
strDirs
.
elementAt
(
strIdxStart
)
)
)
{
return
false
;
}
patIdxStart
++
;
strIdxStart
++
;
}
if
(
strIdxStart
>
strIdxEnd
)
{
return
true
;
}
else
if
(
patIdxStart
>
patIdxEnd
)
{
return
false
;
}
else
{
return
true
;
}
}
protected
static
boolean
matchPath
(
String
pattern
,
String
str
)
{
if
(
str
.
startsWith
(
File
.
separator
)
!=
pattern
.
startsWith
(
File
.
separator
)
)
{
return
false
;
}
Vector
patDirs
=
new
Vector
(
)
;
StringTokenizer
st
=
new
StringTokenizer
(
pattern
,
File
.
separator
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
patDirs
.
addElement
(
st
.
nextToken
(
)
)
;
}
Vector
strDirs
=
new
Vector
(
)
;
st
=
new
StringTokenizer
(
str
,
File
.
separator
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
strDirs
.
addElement
(
st
.
nextToken
(
)
)
;
}
int
patIdxStart
=
0
;
int
patIdxEnd
=
patDirs
.
size
(
)
-
1
;
int
strIdxStart
=
0
;
int
strIdxEnd
=
strDirs
.
size
(
)
-
1
;
while
(
patIdxStart
<=
patIdxEnd
&&
strIdxStart
<=
strIdxEnd
)
{
String
patDir
=
(
String
)
patDirs
.
elementAt
(
patIdxStart
)
;
if
(
patDir
.
equals
(
"**"
)
)
{
break
;
}
if
(
!
match
(
patDir
,
(
String
)
strDirs
.
elementAt
(
strIdxStart
)
)
)
{
return
false
;
}
patIdxStart
++
;
strIdxStart
++
;
}
if
(
strIdxStart
>
strIdxEnd
)
{
for
(
int
i
=
patIdxStart
;
i
<=
patIdxEnd
;
i
++
)
{
if
(
!
patDirs
.
elementAt
(
i
)
.
equals
(
"**"
)
)
{
return
false
;
}
}
return
true
;
}
else
{
if
(
patIdxStart
>
patIdxEnd
)
{
return
false
;
}
}
while
(
patIdxStart
<=
patIdxEnd
&&
strIdxStart
<=
strIdxEnd
)
{
String
patDir
=
(
String
)
patDirs
.
elementAt
(
patIdxEnd
)
;
if
(
patDir
.
equals
(
"**"
)
)
{
break
;
}
if
(
!
match
(
patDir
,
(
String
)
strDirs
.
elementAt
(
strIdxEnd
)
)
)
{
return
false
;
}
patIdxEnd
--
;
strIdxEnd
--
;
}
if
(
strIdxStart
>
strIdxEnd
)
{
for
(
int
i
=
patIdxStart
;
i
<=
patIdxEnd
;
i
++
)
{
if
(
!
patDirs
.
elementAt
(
i
)
.
equals
(
"**"
)
)
{
return
false
;
}
}
return
true
;
}
while
(
patIdxStart
!=
patIdxEnd
&&
strIdxStart
<=
strIdxEnd
)
{
int
patIdxTmp
=
-
1
;
for
(
int
i
=
patIdxStart
+
1
;
i
<=
patIdxEnd
;
i
++
)
{
if
(
patDirs
.
elementAt
(
i
)
.
equals
(
"**"
)
)
{
patIdxTmp
=
i
;
break
;
}
}
if
(
patIdxTmp
==
patIdxStart
+
1
)
{
patIdxStart
++
;
continue
;
}
int
patLength
=
(
patIdxTmp
-
patIdxStart
-
1
)
;
int
strLength
=
(
strIdxEnd
-
strIdxStart
+
1
)
;
int
foundIdx
=
-
1
;
strLoop
:
for
(
int
i
=
0
;
i
<=
strLength
-
patLength
;
i
++
)
{
for
(
int
j
=
0
;
j
<
patLength
;
j
++
)
{
String
subPat
=
(
String
)
patDirs
.
elementAt
(
patIdxStart
+
j
+
1
)
;
String
subStr
=
(
String
)
strDirs
.
elementAt
(
strIdxStart
+
i
+
j
)
;
if
(
!
match
(
subPat
,
subStr
)
)
{
continue
strLoop
;
}
}
foundIdx
=
strIdxStart
+
i
;
break
;
}
if
(
foundIdx
==
-
1
)
{
return
false
;
}
patIdxStart
=
patIdxTmp
;
strIdxStart
=
foundIdx
+
patLength
;
}
for
(
int
i
=
patIdxStart
;
i
<=
patIdxEnd
;
i
++
)
{
if
(
!
patDirs
.
elementAt
(
i
)
.
equals
(
"**"
)
)
{
return
false
;
}
}
return
true
;
}
protected
static
boolean
match
(
String
pattern
,
String
str
)
{
char
[
]
patArr
=
pattern
.
toCharArray
(
)
;
char
[
]
strArr
=
str
.
toCharArray
(
)
;
int
patIdxStart
=
0
;
int
patIdxEnd
=
patArr
.
length
-
1
;
int
strIdxStart
=
0
;
int
strIdxEnd
=
strArr
.
length
-
1
;
char
ch
;
boolean
containsStar
=
false
;
for
(
int
i
=
0
;
i
<
patArr
.
length
;
i
++
)
{
if
(
patArr
[
i
]
==
'*'
)
{
containsStar
=
true
;
break
;
}
}
if
(
!
containsStar
)
{
if
(
patIdxEnd
!=
strIdxEnd
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<=
patIdxEnd
;
i
++
)
{
ch
=
patArr
[
i
]
;
if
(
ch
!=
'?'
&&
ch
!=
strArr
[
i
]
)
{
return
false
;
}
}
return
true
;
}
if
(
patIdxEnd
==
0
)
{
return
true
;
}
while
(
(
ch
=
patArr
[
patIdxStart
]
)
!=
'*'
&&
strIdxStart
<=
strIdxEnd
)
{
if
(
ch
!=
'?'
&&
ch
!=
strArr
[
strIdxStart
]
)
{
return
false
;
}
patIdxStart
++
;
strIdxStart
++
;
}
if
(
strIdxStart
>
strIdxEnd
)
{
for
(
int
i
=
patIdxStart
;
i
<=
patIdxEnd
;
i
++
)
{
if
(
patArr
[
i
]
!=
'*'
)
{
return
false
;
}
}
return
true
;
}
while
(
(
ch
=
patArr
[
patIdxEnd
]
)
!=
'*'
&&
strIdxStart
<=
strIdxEnd
)
{
if
(
ch
!=
'?'
&&
ch
!=
strArr
[
strIdxEnd
]
)
{
return
false
;
}
patIdxEnd
--
;
strIdxEnd
--
;
}
if
(
strIdxStart
>
strIdxEnd
)
{
for
(
int
i
=
patIdxStart
;
i
<=
patIdxEnd
;
i
++
)
{
if
(
patArr
[
i
]
!=
'*'
)
{
return
false
;
}
}
return
true
;
}
while
(
patIdxStart
!=
patIdxEnd
&&
strIdxStart
<=
strIdxEnd
)
{
int
patIdxTmp
=
-
1
;
for
(
int
i
=
patIdxStart
+
1
;
i
<=
patIdxEnd
;
i
++
)
{
if
(
patArr
[
i
]
==
'*'
)
{
patIdxTmp
=
i
;
break
;
}
}
if
(
patIdxTmp
==
patIdxStart
+
1
)
{
patIdxStart
++
;
continue
;
}
int
patLength
=
(
patIdxTmp
-
patIdxStart
-
1
)
;
int
strLength
=
(
strIdxEnd
-
strIdxStart
+
1
)
;
int
foundIdx
=
-
1
;
strLoop
:
for
(
int
i
=
0
;
i
<=
strLength
-
patLength
;
i
++
)
{
for
(
int
j
=
0
;
j
<
patLength
;
j
++
)
{
ch
=
patArr
[
patIdxStart
+
j
+
1
]
;
if
(
ch
!=
'?'
&&
ch
!=
strArr
[
strIdxStart
+
i
+
j
]
)
{
continue
strLoop
;
}
}
foundIdx
=
strIdxStart
+
i
;
break
;
}
if
(
foundIdx
==
-
1
)
{
return
false
;
}
patIdxStart
=
patIdxTmp
;
strIdxStart
=
foundIdx
+
patLength
;
}
for
(
int
i
=
patIdxStart
;
i
<=
patIdxEnd
;
i
++
)
{
if
(
patArr
[
i
]
!=
'*'
)
{
return
false
;
}
}
return
true
;
}
public
void
setBasedir
(
String
basedir
)
{
setBasedir
(
new
File
(
basedir
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
)
)
;
}
public
void
setBasedir
(
File
basedir
)
{
this
.
basedir
=
basedir
;
}
public
File
getBasedir
(
)
{
return
basedir
;
}
public
void
setIncludes
(
String
[
]
includes
)
{
if
(
includes
==
null
)
{
this
.
includes
=
null
;
}
else
{
this
.
includes
=
new
String
[
includes
.
length
]
;
for
(
int
i
=
0
;
i
<
includes
.
length
;
i
++
)
{
String
pattern
;
pattern
=
includes
[
i
]
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
if
(
pattern
.
endsWith
(
File
.
separator
)
)
{
pattern
+=
"**"
;
}
this
.
includes
[
i
]
=
pattern
;
}
}
}
public
void
setExcludes
(
String
[
]
excludes
)
{
if
(
excludes
==
null
)
{
this
.
excludes
=
null
;
}
else
{
this
.
excludes
=
new
String
[
excludes
.
length
]
;
for
(
int
i
=
0
;
i
<
excludes
.
length
;
i
++
)
{
String
pattern
;
pattern
=
excludes
[
i
]
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
if
(
pattern
.
endsWith
(
File
.
separator
)
)
{
pattern
+=
"**"
;
}
this
.
excludes
[
i
]
=
pattern
;
}
}
}
public
void
scan
(
)
{
if
(
basedir
==
null
)
{
throw
new
IllegalStateException
(
"No basedir set"
)
;
}
if
(
!
basedir
.
exists
(
)
)
{
throw
new
IllegalStateException
(
"basedir does not exist"
)
;
}
if
(
!
basedir
.
isDirectory
(
)
)
{
throw
new
IllegalStateException
(
"basedir is not a directory"
)
;
}
if
(
includes
==
null
)
{
includes
=
new
String
[
1
]
;
includes
[
0
]
=
"**"
;
}
if
(
excludes
==
null
)
{
excludes
=
new
String
[
0
]
;
}
filesIncluded
=
new
Vector
(
)
;
filesNotIncluded
=
new
Vector
(
)
;
filesExcluded
=
new
Vector
(
)
;
dirsIncluded
=
new
Vector
(
)
;
dirsNotIncluded
=
new
Vector
(
)
;
dirsExcluded
=
new
Vector
(
)
;
scandir
(
basedir
,
""
,
true
)
;
}
protected
void
slowScan
(
)
{
if
(
haveSlowResults
)
{
return
;
}
String
[
]
excl
=
new
String
[
dirsExcluded
.
size
(
)
]
;
dirsExcluded
.
copyInto
(
excl
)
;
String
[
]
notIncl
=
new
String
[
dirsNotIncluded
.
size
(
)
]
;
dirsNotIncluded
.
copyInto
(
notIncl
)
;
for
(
int
i
=
0
;
i
<
excl
.
length
;
i
++
)
{
scandir
(
new
File
(
basedir
,
excl
[
i
]
)
,
excl
[
i
]
+
File
.
separator
,
false
)
;
}
for
(
int
i
=
0
;
i
<
notIncl
.
length
;
i
++
)
{
if
(
!
couldHoldIncluded
(
notIncl
[
i
]
)
)
{
scandir
(
new
File
(
basedir
,
notIncl
[
i
]
)
,
notIncl
[
i
]
+
File
.
separator
,
false
)
;
}
}
haveSlowResults
=
true
;
}
protected
void
scandir
(
File
dir
,
String
vpath
,
boolean
fast
)
{
String
[
]
newfiles
=
dir
.
list
(
)
;
if
(
newfiles
==
null
)
{
throw
new
BuildException
(
"IO error scanning directory "
+
dir
.
getAbsolutePath
(
)
)
;
}
for
(
int
i
=
0
;
i
<
newfiles
.
length
;
i
++
)
{
String
name
=
vpath
+
newfiles
[
i
]
;
File
file
=
new
File
(
dir
,
newfiles
[
i
]
)
;
if
(
file
.
isDirectory
(
)
)
{
if
(
isIncluded
(
name
)
)
{
if
(
!
isExcluded
(
name
)
)
{
dirsIncluded
.
addElement
(
name
)
;
if
(
fast
)
{
scandir
(
file
,
name
+
File
.
separator
,
fast
)
;
}
}
else
{
dirsExcluded
.
addElement
(
name
)
;
}
}
else
{
dirsNotIncluded
.
addElement
(
name
)
;
if
(
fast
&&
couldHoldIncluded
(
name
)
)
{
scandir
(
file
,
name
+
File
.
separator
,
fast
)
;
}
}
if
(
!
fast
)
{
scandir
(
file
,
name
+
File
.
separator
,
fast
)
;
}
}
else
if
(
file
.
isFile
(
)
)
{
if
(
isIncluded
(
name
)
)
{
if
(
!
isExcluded
(
name
)
)
{
filesIncluded
.
addElement
(
name
)
;
}
else
{
filesExcluded
.
addElement
(
name
)
;
}
}
else
{
filesNotIncluded
.
addElement
(
name
)
;
}
}
}
}
protected
boolean
isIncluded
(
String
name
)
{
for
(
int
i
=
0
;
i
<
includes
.
length
;
i
++
)
{
if
(
matchPath
(
includes
[
i
]
,
name
)
)
{
return
true
;
}
}
return
false
;
}
protected
boolean
couldHoldIncluded
(
String
name
)
{
for
(
int
i
=
0
;
i
<
includes
.
length
;
i
++
)
{
if
(
matchPatternStart
(
includes
[
i
]
,
name
)
)
{
return
true
;
}
}
return
false
;
}
protected
boolean
isExcluded
(
String
name
)
{
for
(
int
i
=
0
;
i
<
excludes
.
length
;
i
++
)
{
if
(
matchPath
(
excludes
[
i
]
,
name
)
)
{
return
true
;
}
}
return
false
;
}
public
String
[
]
getIncludedFiles
(
)
{
int
count
=
filesIncluded
.
size
(
)
;
String
[
]
files
=
new
String
[
count
]
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
files
[
i
]
=
(
String
)
filesIncluded
.
elementAt
(
i
)
;
}
return
files
;
}
public
String
[
]
getNotIncludedFiles
(
)
{
slowScan
(
)
;
int
count
=
filesNotIncluded
.
size
(
)
;
String
[
]
files
=
new
String
[
count
]
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
files
[
i
]
=
(
String
)
filesNotIncluded
.
elementAt
(
i
)
;
}
return
files
;
}
public
String
[
]
getExcludedFiles
(
)
{
slowScan
(
)
;
int
count
=
filesExcluded
.
size
(
)
;
String
[
]
files
=
new
String
[
count
]
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
files
[
i
]
=
(
String
)
filesExcluded
.
elementAt
(
i
)
;
}
return
files
;
}
public
String
[
]
getIncludedDirectories
(
)
{
int
count
=
dirsIncluded
.
size
(
)
;
String
[
]
directories
=
new
String
[
count
]
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
directories
[
i
]
=
(
String
)
dirsIncluded
.
elementAt
(
i
)
;
}
return
directories
;
}
public
String
[
]
getNotIncludedDirectories
(
)
{
slowScan
(
)
;
int
count
=
dirsNotIncluded
.
size
(
)
;
String
[
]
directories
=
new
String
[
count
]
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
directories
[
i
]
=
(
String
)
dirsNotIncluded
.
elementAt
(
i
)
;
}
return
directories
;
}
public
String
[
]
getExcludedDirectories
(
)
{
slowScan
(
)
;
int
count
=
dirsExcluded
.
size
(
)
;
String
[
]
directories
=
new
String
[
count
]
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
directories
[
i
]
=
(
String
)
dirsExcluded
.
elementAt
(
i
)
;
}
return
directories
;
}
public
void
addDefaultExcludes
(
)
{
int
excludesLength
=
excludes
==
null
?
0
:
excludes
.
length
;
String
[
]
newExcludes
;
newExcludes
=
new
String
[
excludesLength
+
DEFAULTEXCLUDES
.
length
]
;
if
(
excludesLength
>
0
)
{
System
.
arraycopy
(
excludes
,
0
,
newExcludes
,
0
,
excludesLength
)
;
}
for
(
int
i
=
0
;
i
<
DEFAULTEXCLUDES
.
length
;
i
++
)
{
newExcludes
[
i
+
excludesLength
]
=
DEFAULTEXCLUDES
[
i
]
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
}
excludes
=
newExcludes
;
}
}
