package
org
.
apache
.
tools
.
ant
.
types
.
selectors
;
import
java
.
io
.
File
;
import
java
.
text
.
DateFormat
;
import
java
.
text
.
ParseException
;
import
java
.
util
.
Locale
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
types
.
EnumeratedAttribute
;
import
org
.
apache
.
tools
.
ant
.
types
.
Parameter
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
condition
.
Os
;
public
class
DateSelector
extends
BaseExtendSelector
{
private
long
millis
=
-
1
;
private
String
dateTime
=
null
;
private
boolean
includeDirs
=
false
;
private
int
granularity
=
0
;
private
int
cmp
=
2
;
public
final
static
String
MILLIS_KEY
=
"millis"
;
public
final
static
String
DATETIME_KEY
=
"datetime"
;
public
final
static
String
CHECKDIRS_KEY
=
"checkdirs"
;
public
final
static
String
GRANULARITY_KEY
=
"granularity"
;
public
final
static
String
WHEN_KEY
=
"when"
;
public
DateSelector
(
)
{
if
(
Os
.
isFamily
(
"dos"
)
)
{
granularity
=
2000
;
}
}
public
String
toString
(
)
{
StringBuffer
buf
=
new
StringBuffer
(
"{dateselector date: "
)
;
buf
.
append
(
dateTime
)
;
buf
.
append
(
" compare: "
)
;
if
(
cmp
==
0
)
{
buf
.
append
(
"before"
)
;
}
else
if
(
cmp
==
1
)
{
buf
.
append
(
"after"
)
;
}
else
{
buf
.
append
(
"equal"
)
;
}
buf
.
append
(
" granularity: "
)
;
buf
.
append
(
granularity
)
;
buf
.
append
(
"}"
)
;
return
buf
.
toString
(
)
;
}
public
void
setMillis
(
long
millis
)
{
this
.
millis
=
millis
;
}
public
long
getMillis
(
)
{
return
millis
;
}
public
void
setDatetime
(
String
dateTime
)
{
this
.
dateTime
=
dateTime
;
if
(
dateTime
!=
null
)
{
DateFormat
df
=
DateFormat
.
getDateTimeInstance
(
DateFormat
.
SHORT
,
DateFormat
.
SHORT
,
Locale
.
US
)
;
try
{
setMillis
(
df
.
parse
(
dateTime
)
.
getTime
(
)
)
;
if
(
millis
<
0
)
{
setError
(
"Date of "
+
dateTime
+
" results in negative milliseconds value relative"
+
" to epoch (January 1, 1970, 00:00:00 GMT)."
)
;
}
}
catch
(
ParseException
pe
)
{
setError
(
"Date of "
+
dateTime
+
" Cannot be parsed correctly. It should be in"
+
" MM/DD/YYYY HH:MM AM_PM format."
)
;
}
}
}
public
void
setCheckdirs
(
boolean
includeDirs
)
{
this
.
includeDirs
=
includeDirs
;
}
public
void
setGranularity
(
int
granularity
)
{
this
.
granularity
=
granularity
;
}
public
void
setWhen
(
TimeComparisons
cmp
)
{
this
.
cmp
=
cmp
.
getIndex
(
)
;
}
public
void
setParameters
(
Parameter
[
]
parameters
)
{
super
.
setParameters
(
parameters
)
;
if
(
parameters
!=
null
)
{
for
(
int
i
=
0
;
i
<
parameters
.
length
;
i
++
)
{
String
paramname
=
parameters
[
i
]
.
getName
(
)
;
if
(
MILLIS_KEY
.
equalsIgnoreCase
(
paramname
)
)
{
try
{
setMillis
(
new
Long
(
parameters
[
i
]
.
getValue
(
)
)
.
longValue
(
)
)
;
}
catch
(
NumberFormatException
nfe
)
{
setError
(
"Invalid millisecond setting "
+
parameters
[
i
]
.
getValue
(
)
)
;
}
}
else
if
(
DATETIME_KEY
.
equalsIgnoreCase
(
paramname
)
)
{
setDatetime
(
parameters
[
i
]
.
getValue
(
)
)
;
}
else
if
(
CHECKDIRS_KEY
.
equalsIgnoreCase
(
paramname
)
)
{
setCheckdirs
(
Project
.
toBoolean
(
parameters
[
i
]
.
getValue
(
)
)
)
;
}
else
if
(
GRANULARITY_KEY
.
equalsIgnoreCase
(
paramname
)
)
{
try
{
setGranularity
(
new
Integer
(
parameters
[
i
]
.
getValue
(
)
)
.
intValue
(
)
)
;
}
catch
(
NumberFormatException
nfe
)
{
setError
(
"Invalid granularity setting "
+
parameters
[
i
]
.
getValue
(
)
)
;
}
}
else
if
(
WHEN_KEY
.
equalsIgnoreCase
(
paramname
)
)
{
TimeComparisons
cmp
=
new
TimeComparisons
(
)
;
cmp
.
setValue
(
parameters
[
i
]
.
getValue
(
)
)
;
setWhen
(
cmp
)
;
}
else
{
setError
(
"Invalid parameter "
+
paramname
)
;
}
}
}
}
public
void
verifySettings
(
)
{
if
(
dateTime
==
null
&&
millis
<
0
)
{
setError
(
"You must provide a datetime or the number of "
+
"milliseconds."
)
;
}
else
if
(
millis
<
0
)
{
setError
(
"Date of "
+
dateTime
+
" results in negative milliseconds"
+
" value relative to epoch (January 1, 1970, 00:00:00 GMT)."
)
;
}
}
public
boolean
isSelected
(
File
basedir
,
String
filename
,
File
file
)
{
validate
(
)
;
if
(
file
.
isDirectory
(
)
&&
(
includeDirs
==
false
)
)
{
return
true
;
}
if
(
cmp
==
0
)
{
return
(
(
file
.
lastModified
(
)
-
granularity
)
<
millis
)
;
}
else
if
(
cmp
==
1
)
{
return
(
(
file
.
lastModified
(
)
+
granularity
)
>
millis
)
;
}
else
{
return
(
Math
.
abs
(
file
.
lastModified
(
)
-
millis
)
<=
granularity
)
;
}
}
public
static
class
TimeComparisons
extends
EnumeratedAttribute
{
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
"before"
,
"after"
,
"equal"
}
;
}
}
}
