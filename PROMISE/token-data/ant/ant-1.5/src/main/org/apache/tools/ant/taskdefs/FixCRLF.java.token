package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
condition
.
Os
;
import
org
.
apache
.
tools
.
ant
.
types
.
EnumeratedAttribute
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
FileWriter
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
Reader
;
import
java
.
io
.
Writer
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
NoSuchElementException
;
public
class
FixCRLF
extends
MatchingTask
{
private
static
final
int
UNDEF
=
-
1
;
private
static
final
int
NOTJAVA
=
0
;
private
static
final
int
LOOKING
=
1
;
private
static
final
int
IN_CHAR_CONST
=
2
;
private
static
final
int
IN_STR_CONST
=
3
;
private
static
final
int
IN_SINGLE_COMMENT
=
4
;
private
static
final
int
IN_MULTI_COMMENT
=
5
;
private
static
final
int
ASIS
=
0
;
private
static
final
int
CR
=
1
;
private
static
final
int
LF
=
2
;
private
static
final
int
CRLF
=
3
;
private
static
final
int
ADD
=
1
;
private
static
final
int
REMOVE
=
-
1
;
private
static
final
int
SPACES
=
-
1
;
private
static
final
int
TABS
=
1
;
private
static
final
int
INBUFLEN
=
8192
;
private
static
final
int
LINEBUFLEN
=
200
;
private
static
final
char
CTRLZ
=
''
;
private
int
tablength
=
8
;
private
String
spaces
=
"        "
;
private
StringBuffer
linebuf
=
new
StringBuffer
(
1024
)
;
private
StringBuffer
linebuf2
=
new
StringBuffer
(
1024
)
;
private
int
eol
;
private
String
eolstr
;
private
int
ctrlz
;
private
int
tabs
;
private
boolean
javafiles
=
false
;
private
File
srcDir
;
private
File
destDir
=
null
;
private
FileUtils
fileUtils
=
FileUtils
.
newFileUtils
(
)
;
private
String
encoding
=
null
;
public
FixCRLF
(
)
{
tabs
=
ASIS
;
if
(
Os
.
isFamily
(
"mac"
)
)
{
ctrlz
=
REMOVE
;
eol
=
CR
;
eolstr
=
"\r"
;
}
else
if
(
Os
.
isFamily
(
"dos"
)
)
{
ctrlz
=
ASIS
;
eol
=
CRLF
;
eolstr
=
"\r\n"
;
}
else
{
ctrlz
=
REMOVE
;
eol
=
LF
;
eolstr
=
"\n"
;
}
}
public
void
setSrcdir
(
File
srcDir
)
{
this
.
srcDir
=
srcDir
;
}
public
void
setDestdir
(
File
destDir
)
{
this
.
destDir
=
destDir
;
}
public
void
setJavafiles
(
boolean
javafiles
)
{
this
.
javafiles
=
javafiles
;
}
public
void
setEol
(
CrLf
attr
)
{
String
option
=
attr
.
getValue
(
)
;
if
(
option
.
equals
(
"asis"
)
)
{
eol
=
ASIS
;
}
else
if
(
option
.
equals
(
"cr"
)
)
{
eol
=
CR
;
eolstr
=
"\r"
;
}
else
if
(
option
.
equals
(
"lf"
)
)
{
eol
=
LF
;
eolstr
=
"\n"
;
}
else
{
eol
=
CRLF
;
eolstr
=
"\r\n"
;
}
}
public
void
setCr
(
AddAsisRemove
attr
)
{
log
(
"DEPRECATED: The cr attribute has been deprecated,"
,
Project
.
MSG_WARN
)
;
log
(
"Please use the eol attribute instead"
,
Project
.
MSG_WARN
)
;
String
option
=
attr
.
getValue
(
)
;
CrLf
c
=
new
CrLf
(
)
;
if
(
option
.
equals
(
"remove"
)
)
{
c
.
setValue
(
"lf"
)
;
}
else
if
(
option
.
equals
(
"asis"
)
)
{
c
.
setValue
(
"asis"
)
;
}
else
{
c
.
setValue
(
"crlf"
)
;
}
setEol
(
c
)
;
}
public
void
setTab
(
AddAsisRemove
attr
)
{
String
option
=
attr
.
getValue
(
)
;
if
(
option
.
equals
(
"remove"
)
)
{
tabs
=
SPACES
;
}
else
if
(
option
.
equals
(
"asis"
)
)
{
tabs
=
ASIS
;
}
else
{
tabs
=
TABS
;
}
}
public
void
setTablength
(
int
tlength
)
throws
BuildException
{
if
(
tlength
<
2
||
tlength
>
80
)
{
throw
new
BuildException
(
"tablength must be between 2 and 80"
,
location
)
;
}
tablength
=
tlength
;
StringBuffer
sp
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
tablength
;
i
++
)
{
sp
.
append
(
' '
)
;
}
spaces
=
sp
.
toString
(
)
;
}
public
void
setEof
(
AddAsisRemove
attr
)
{
String
option
=
attr
.
getValue
(
)
;
if
(
option
.
equals
(
"remove"
)
)
{
ctrlz
=
REMOVE
;
}
else
if
(
option
.
equals
(
"asis"
)
)
{
ctrlz
=
ASIS
;
}
else
{
ctrlz
=
ADD
;
}
}
public
void
setEncoding
(
String
encoding
)
{
this
.
encoding
=
encoding
;
}
public
void
execute
(
)
throws
BuildException
{
if
(
srcDir
==
null
)
{
throw
new
BuildException
(
"srcdir attribute must be set!"
)
;
}
if
(
!
srcDir
.
exists
(
)
)
{
throw
new
BuildException
(
"srcdir does not exist!"
)
;
}
if
(
!
srcDir
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"srcdir is not a directory!"
)
;
}
if
(
destDir
!=
null
)
{
if
(
!
destDir
.
exists
(
)
)
{
throw
new
BuildException
(
"destdir does not exist!"
)
;
}
if
(
!
destDir
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"destdir is not a directory!"
)
;
}
}
log
(
"options:"
+
" eol="
+
(
eol
==
ASIS
?
"asis"
:
eol
==
CR
?
"cr"
:
eol
==
LF
?
"lf"
:
"crlf"
)
+
" tab="
+
(
tabs
==
TABS
?
"add"
:
tabs
==
ASIS
?
"asis"
:
"remove"
)
+
" eof="
+
(
ctrlz
==
ADD
?
"add"
:
ctrlz
==
ASIS
?
"asis"
:
"remove"
)
+
" tablength="
+
tablength
+
" encoding="
+
(
encoding
==
null
?
"default"
:
encoding
)
,
Project
.
MSG_VERBOSE
)
;
DirectoryScanner
ds
=
super
.
getDirectoryScanner
(
srcDir
)
;
String
[
]
files
=
ds
.
getIncludedFiles
(
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
processFile
(
files
[
i
]
)
;
}
}
private
Reader
getReader
(
File
f
)
throws
IOException
{
return
(
encoding
==
null
)
?
new
FileReader
(
f
)
:
new
InputStreamReader
(
new
FileInputStream
(
f
)
,
encoding
)
;
}
private
void
processFile
(
String
file
)
throws
BuildException
{
File
srcFile
=
new
File
(
srcDir
,
file
)
;
File
destD
=
destDir
==
null
?
srcDir
:
destDir
;
File
tmpFile
=
null
;
BufferedWriter
outWriter
;
OneLiner
.
BufferLine
line
;
OneLiner
lines
=
new
OneLiner
(
srcFile
)
;
try
{
try
{
tmpFile
=
fileUtils
.
createTempFile
(
"fixcrlf"
,
""
,
destD
)
;
Writer
writer
=
(
encoding
==
null
)
?
new
FileWriter
(
tmpFile
)
:
new
OutputStreamWriter
(
new
FileOutputStream
(
tmpFile
)
,
encoding
)
;
outWriter
=
new
BufferedWriter
(
writer
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
while
(
lines
.
hasMoreElements
(
)
)
{
int
endComment
;
try
{
line
=
(
OneLiner
.
BufferLine
)
lines
.
nextElement
(
)
;
}
catch
(
NoSuchElementException
e
)
{
throw
new
BuildException
(
e
)
;
}
String
lineString
=
line
.
getLineString
(
)
;
int
linelen
=
line
.
length
(
)
;
if
(
tabs
==
ASIS
)
{
try
{
outWriter
.
write
(
lineString
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
}
else
{
int
ptr
;
while
(
(
ptr
=
line
.
getNext
(
)
)
<
linelen
)
{
switch
(
lines
.
getState
(
)
)
{
case
NOTJAVA
:
notInConstant
(
line
,
line
.
length
(
)
,
outWriter
)
;
break
;
case
IN_MULTI_COMMENT
:
endComment
=
lineString
.
indexOf
(
"*/"
,
line
.
getNext
(
)
)
;
if
(
endComment
>=
0
)
{
endComment
+=
2
;
lines
.
setState
(
LOOKING
)
;
}
else
{
endComment
=
linelen
;
}
notInConstant
(
line
,
endComment
,
outWriter
)
;
break
;
case
IN_SINGLE_COMMENT
:
notInConstant
(
line
,
line
.
length
(
)
,
outWriter
)
;
lines
.
setState
(
LOOKING
)
;
break
;
case
IN_CHAR_CONST
:
case
IN_STR_CONST
:
int
begin
=
line
.
getNext
(
)
;
char
terminator
=
(
lines
.
getState
(
)
==
IN_STR_CONST
?
'\"'
:
'\''
)
;
endOfCharConst
(
line
,
terminator
)
;
while
(
line
.
getNext
(
)
<
line
.
getLookahead
(
)
)
{
if
(
line
.
getNextCharInc
(
)
==
'\t'
)
{
line
.
setColumn
(
line
.
getColumn
(
)
+
tablength
-
(
line
.
getColumn
(
)
%
tablength
)
)
;
}
else
{
line
.
incColumn
(
)
;
}
}
try
{
outWriter
.
write
(
line
.
substring
(
begin
,
line
.
getNext
(
)
)
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
lines
.
setState
(
LOOKING
)
;
break
;
case
LOOKING
:
nextStateChange
(
line
)
;
notInConstant
(
line
,
line
.
getLookahead
(
)
,
outWriter
)
;
break
;
}
}
}
try
{
outWriter
.
write
(
eolstr
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
}
try
{
if
(
ctrlz
==
ASIS
)
{
outWriter
.
write
(
lines
.
getEofStr
(
)
)
;
}
else
if
(
ctrlz
==
ADD
)
{
outWriter
.
write
(
CTRLZ
)
;
}
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
finally
{
try
{
outWriter
.
close
(
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
}
try
{
lines
.
close
(
)
;
lines
=
null
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
"Unable to close source file "
+
srcFile
)
;
}
File
destFile
=
new
File
(
destD
,
file
)
;
if
(
destFile
.
exists
(
)
)
{
log
(
"destFile exists"
,
Project
.
MSG_DEBUG
)
;
if
(
!
fileUtils
.
contentEquals
(
destFile
,
tmpFile
)
)
{
log
(
destFile
+
" is being written"
,
Project
.
MSG_DEBUG
)
;
if
(
!
destFile
.
delete
(
)
)
{
throw
new
BuildException
(
"Unable to delete "
+
destFile
)
;
}
if
(
!
tmpFile
.
renameTo
(
destFile
)
)
{
throw
new
BuildException
(
"Failed to transform "
+
srcFile
+
" to "
+
destFile
+
". Couldn't rename temporary file: "
+
tmpFile
)
;
}
}
else
{
log
(
destFile
+
" is not written, as the contents are identical"
,
Project
.
MSG_DEBUG
)
;
if
(
!
tmpFile
.
delete
(
)
)
{
throw
new
BuildException
(
"Unable to delete "
+
tmpFile
)
;
}
}
}
else
{
log
(
"destFile does not exist"
,
Project
.
MSG_DEBUG
)
;
if
(
!
tmpFile
.
renameTo
(
destFile
)
)
{
throw
new
BuildException
(
"Failed to transform "
+
srcFile
+
" to "
+
destFile
+
". Couldn't rename temporary file: "
+
tmpFile
)
;
}
}
tmpFile
=
null
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
finally
{
try
{
if
(
lines
!=
null
)
{
lines
.
close
(
)
;
}
}
catch
(
IOException
io
)
{
log
(
"Error closing "
+
srcFile
,
Project
.
MSG_ERR
)
;
}
if
(
tmpFile
!=
null
)
{
tmpFile
.
delete
(
)
;
}
}
}
private
void
nextStateChange
(
OneLiner
.
BufferLine
bufline
)
throws
BuildException
{
int
eol
=
bufline
.
length
(
)
;
int
ptr
=
bufline
.
getNext
(
)
;
while
(
ptr
<
eol
)
{
switch
(
bufline
.
getChar
(
ptr
++
)
)
{
case
'\''
:
bufline
.
setState
(
IN_CHAR_CONST
)
;
bufline
.
setLookahead
(
--
ptr
)
;
return
;
case
'\"'
:
bufline
.
setState
(
IN_STR_CONST
)
;
bufline
.
setLookahead
(
--
ptr
)
;
return
;
case
'/'
:
if
(
ptr
<
eol
)
{
if
(
bufline
.
getChar
(
ptr
)
==
'*'
)
{
bufline
.
setState
(
IN_MULTI_COMMENT
)
;
bufline
.
setLookahead
(
--
ptr
)
;
return
;
}
else
if
(
bufline
.
getChar
(
ptr
)
==
'/'
)
{
bufline
.
setState
(
IN_SINGLE_COMMENT
)
;
bufline
.
setLookahead
(
--
ptr
)
;
return
;
}
}
break
;
}
}
bufline
.
setLookahead
(
ptr
)
;
}
private
void
endOfCharConst
(
OneLiner
.
BufferLine
bufline
,
char
terminator
)
throws
BuildException
{
int
ptr
=
bufline
.
getNext
(
)
;
int
eol
=
bufline
.
length
(
)
;
char
c
;
ptr
++
;
while
(
ptr
<
eol
)
{
if
(
(
c
=
bufline
.
getChar
(
ptr
++
)
)
==
'\\'
)
{
ptr
++
;
}
else
{
if
(
c
==
terminator
)
{
bufline
.
setLookahead
(
ptr
)
;
return
;
}
}
}
throw
new
BuildException
(
"endOfCharConst: unterminated char constant"
)
;
}
private
void
notInConstant
(
OneLiner
.
BufferLine
bufline
,
int
end
,
BufferedWriter
outWriter
)
{
int
nextTab
;
int
nextStop
;
int
tabspaces
;
String
line
=
bufline
.
substring
(
bufline
.
getNext
(
)
,
end
)
;
int
place
=
0
;
int
col
=
bufline
.
getColumn
(
)
;
linebuf
.
setLength
(
0
)
;
while
(
(
nextTab
=
line
.
indexOf
(
(
int
)
'\t'
,
place
)
)
>=
0
)
{
linebuf
.
append
(
line
.
substring
(
place
,
nextTab
)
)
;
col
+=
nextTab
-
place
;
tabspaces
=
tablength
-
(
col
%
tablength
)
;
linebuf
.
append
(
spaces
.
substring
(
0
,
tabspaces
)
)
;
col
+=
tabspaces
;
place
=
nextTab
+
1
;
}
linebuf
.
append
(
line
.
substring
(
place
,
line
.
length
(
)
)
)
;
String
linestring
=
new
String
(
linebuf
.
toString
(
)
)
;
if
(
tabs
==
REMOVE
)
{
try
{
outWriter
.
write
(
linestring
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
}
else
{
int
tabCol
;
linebuf2
.
setLength
(
0
)
;
place
=
0
;
col
=
bufline
.
getColumn
(
)
;
int
placediff
=
col
-
0
;
nextStop
=
col
+
(
tablength
-
col
%
tablength
)
;
if
(
nextStop
-
col
<
2
)
{
linebuf2
.
append
(
linestring
.
substring
(
place
,
nextStop
-
placediff
)
)
;
place
=
nextStop
-
placediff
;
nextStop
+=
tablength
;
}
for
(
;
nextStop
-
placediff
<=
linestring
.
length
(
)
;
nextStop
+=
tablength
)
{
for
(
tabCol
=
nextStop
;
--
tabCol
-
placediff
>=
place
&&
linestring
.
charAt
(
tabCol
-
placediff
)
==
' '
;
)
{
;
}
if
(
nextStop
-
tabCol
>
2
)
{
linebuf2
.
append
(
linestring
.
substring
(
place
,
++
tabCol
-
placediff
)
)
;
linebuf2
.
append
(
'\t'
)
;
}
else
{
linebuf2
.
append
(
linestring
.
substring
(
place
,
nextStop
-
placediff
)
)
;
}
place
=
nextStop
-
placediff
;
}
linebuf2
.
append
(
linestring
.
substring
(
place
,
linestring
.
length
(
)
)
)
;
try
{
outWriter
.
write
(
linebuf2
.
toString
(
)
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
}
bufline
.
setColumn
(
bufline
.
getColumn
(
)
+
linestring
.
length
(
)
)
;
bufline
.
setNext
(
end
)
;
}
class
OneLiner
implements
Enumeration
{
private
int
state
=
javafiles
?
LOOKING
:
NOTJAVA
;
private
StringBuffer
eolStr
=
new
StringBuffer
(
LINEBUFLEN
)
;
private
StringBuffer
eofStr
=
new
StringBuffer
(
)
;
private
BufferedReader
reader
;
private
StringBuffer
line
=
new
StringBuffer
(
)
;
private
boolean
reachedEof
=
false
;
public
OneLiner
(
File
srcFile
)
throws
BuildException
{
try
{
reader
=
new
BufferedReader
(
getReader
(
srcFile
)
,
INBUFLEN
)
;
nextLine
(
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
}
protected
void
nextLine
(
)
throws
BuildException
{
int
ch
=
-
1
;
int
eolcount
=
0
;
eolStr
.
setLength
(
0
)
;
line
.
setLength
(
0
)
;
try
{
ch
=
reader
.
read
(
)
;
while
(
ch
!=
-
1
&&
ch
!=
'\r'
&&
ch
!=
'\n'
)
{
line
.
append
(
(
char
)
ch
)
;
ch
=
reader
.
read
(
)
;
}
if
(
ch
==
-
1
&&
line
.
length
(
)
==
0
)
{
reachedEof
=
true
;
return
;
}
switch
(
(
char
)
ch
)
{
case
'\r'
:
++
eolcount
;
eolStr
.
append
(
'\r'
)
;
reader
.
mark
(
2
)
;
switch
(
(
ch
=
reader
.
read
(
)
)
)
{
case
'\r'
:
if
(
(
char
)
(
ch
=
reader
.
read
(
)
)
==
'\n'
)
{
eolcount
+=
2
;
eolStr
.
append
(
"\r\n"
)
;
}
else
{
reader
.
reset
(
)
;
}
break
;
case
'\n'
:
++
eolcount
;
eolStr
.
append
(
'\n'
)
;
break
;
case
-
1
:
break
;
default
:
reader
.
reset
(
)
;
break
;
}
break
;
case
'\n'
:
++
eolcount
;
eolStr
.
append
(
'\n'
)
;
break
;
}
if
(
eolcount
==
0
)
{
int
i
=
line
.
length
(
)
;
while
(
--
i
>=
0
&&
line
.
charAt
(
i
)
==
CTRLZ
)
{
}
if
(
i
<
line
.
length
(
)
-
1
)
{
eofStr
.
append
(
line
.
toString
(
)
.
substring
(
i
+
1
)
)
;
if
(
i
<
0
)
{
line
.
setLength
(
0
)
;
reachedEof
=
true
;
}
else
{
line
.
setLength
(
i
+
1
)
;
}
}
}
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
}
public
String
getEofStr
(
)
{
return
eofStr
.
toString
(
)
;
}
public
int
getState
(
)
{
return
state
;
}
public
void
setState
(
int
state
)
{
this
.
state
=
state
;
}
public
boolean
hasMoreElements
(
)
{
return
!
reachedEof
;
}
public
Object
nextElement
(
)
throws
NoSuchElementException
{
if
(
!
hasMoreElements
(
)
)
{
throw
new
NoSuchElementException
(
"OneLiner"
)
;
}
BufferLine
tmpLine
=
new
BufferLine
(
line
.
toString
(
)
,
eolStr
.
toString
(
)
)
;
nextLine
(
)
;
return
tmpLine
;
}
public
void
close
(
)
throws
IOException
{
if
(
reader
!=
null
)
{
reader
.
close
(
)
;
}
}
class
BufferLine
{
private
int
next
=
0
;
private
int
column
=
0
;
private
int
lookahead
=
UNDEF
;
private
String
line
;
private
String
eolStr
;
public
BufferLine
(
String
line
,
String
eolStr
)
throws
BuildException
{
next
=
0
;
column
=
0
;
this
.
line
=
line
;
this
.
eolStr
=
eolStr
;
}
public
int
getNext
(
)
{
return
next
;
}
public
void
setNext
(
int
next
)
{
this
.
next
=
next
;
}
public
int
getLookahead
(
)
{
return
lookahead
;
}
public
void
setLookahead
(
int
lookahead
)
{
this
.
lookahead
=
lookahead
;
}
public
char
getChar
(
int
i
)
{
return
line
.
charAt
(
i
)
;
}
public
char
getNextChar
(
)
{
return
getChar
(
next
)
;
}
public
char
getNextCharInc
(
)
{
return
getChar
(
next
++
)
;
}
public
int
getColumn
(
)
{
return
column
;
}
public
void
setColumn
(
int
col
)
{
column
=
col
;
}
public
int
incColumn
(
)
{
return
column
++
;
}
public
int
length
(
)
{
return
line
.
length
(
)
;
}
public
int
getEolLength
(
)
{
return
eolStr
.
length
(
)
;
}
public
String
getLineString
(
)
{
return
line
;
}
public
String
getEol
(
)
{
return
eolStr
;
}
public
String
substring
(
int
begin
)
{
return
line
.
substring
(
begin
)
;
}
public
String
substring
(
int
begin
,
int
end
)
{
return
line
.
substring
(
begin
,
end
)
;
}
public
void
setState
(
int
state
)
{
OneLiner
.
this
.
setState
(
state
)
;
}
public
int
getState
(
)
{
return
OneLiner
.
this
.
getState
(
)
;
}
}
}
public
static
class
AddAsisRemove
extends
EnumeratedAttribute
{
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
"add"
,
"asis"
,
"remove"
}
;
}
}
public
static
class
CrLf
extends
EnumeratedAttribute
{
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
"asis"
,
"cr"
,
"lf"
,
"crlf"
}
;
}
}
}
