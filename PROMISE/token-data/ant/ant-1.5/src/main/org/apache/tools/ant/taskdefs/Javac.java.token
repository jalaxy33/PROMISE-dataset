package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
types
.
Reference
;
import
org
.
apache
.
tools
.
ant
.
util
.
GlobPatternMapper
;
import
org
.
apache
.
tools
.
ant
.
util
.
JavaEnvUtils
;
import
org
.
apache
.
tools
.
ant
.
util
.
SourceFileScanner
;
import
org
.
apache
.
tools
.
ant
.
util
.
facade
.
FacadeTaskHelper
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
compilers
.
CompilerAdapter
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
compilers
.
CompilerAdapterFactory
;
import
java
.
io
.
File
;
public
class
Javac
extends
MatchingTask
{
private
static
final
String
FAIL_MSG
=
"Compile failed; see the compiler error output for details."
;
private
Path
src
;
private
File
destDir
;
private
Path
compileClasspath
;
private
Path
compileSourcepath
;
private
String
encoding
;
private
boolean
debug
=
false
;
private
boolean
optimize
=
false
;
private
boolean
deprecation
=
false
;
private
boolean
depend
=
false
;
private
boolean
verbose
=
false
;
private
String
target
;
private
Path
bootclasspath
;
private
Path
extdirs
;
private
boolean
includeAntRuntime
=
true
;
private
boolean
includeJavaRuntime
=
false
;
private
boolean
fork
=
false
;
private
String
forkedExecutable
=
null
;
private
boolean
nowarn
=
false
;
private
String
memoryInitialSize
;
private
String
memoryMaximumSize
;
private
FacadeTaskHelper
facade
=
null
;
protected
boolean
failOnError
=
true
;
protected
boolean
listFiles
=
false
;
protected
File
[
]
compileList
=
new
File
[
0
]
;
private
String
source
;
private
String
debugLevel
;
public
Javac
(
)
{
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_1
)
)
{
facade
=
new
FacadeTaskHelper
(
"javac1.1"
)
;
}
else
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_2
)
)
{
facade
=
new
FacadeTaskHelper
(
"javac1.2"
)
;
}
else
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_3
)
)
{
facade
=
new
FacadeTaskHelper
(
"javac1.3"
)
;
}
else
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_4
)
)
{
facade
=
new
FacadeTaskHelper
(
"javac1.4"
)
;
}
else
{
facade
=
new
FacadeTaskHelper
(
"classic"
)
;
}
}
public
String
getDebugLevel
(
)
{
return
debugLevel
;
}
public
void
setDebugLevel
(
String
v
)
{
this
.
debugLevel
=
v
;
}
public
String
getSource
(
)
{
return
source
;
}
public
void
setSource
(
String
v
)
{
this
.
source
=
v
;
}
public
Path
createSrc
(
)
{
if
(
src
==
null
)
{
src
=
new
Path
(
project
)
;
}
return
src
.
createPath
(
)
;
}
protected
Path
recreateSrc
(
)
{
src
=
null
;
return
createSrc
(
)
;
}
public
void
setSrcdir
(
Path
srcDir
)
{
if
(
src
==
null
)
{
src
=
srcDir
;
}
else
{
src
.
append
(
srcDir
)
;
}
}
public
Path
getSrcdir
(
)
{
return
src
;
}
public
void
setDestdir
(
File
destDir
)
{
this
.
destDir
=
destDir
;
}
public
File
getDestdir
(
)
{
return
destDir
;
}
public
void
setSourcepath
(
Path
sourcepath
)
{
if
(
compileSourcepath
==
null
)
{
compileSourcepath
=
sourcepath
;
}
else
{
compileSourcepath
.
append
(
sourcepath
)
;
}
}
public
Path
getSourcepath
(
)
{
return
compileSourcepath
;
}
public
Path
createSourcepath
(
)
{
if
(
compileSourcepath
==
null
)
{
compileSourcepath
=
new
Path
(
project
)
;
}
return
compileSourcepath
.
createPath
(
)
;
}
public
void
setSourcepathRef
(
Reference
r
)
{
createSourcepath
(
)
.
setRefid
(
r
)
;
}
public
void
setClasspath
(
Path
classpath
)
{
if
(
compileClasspath
==
null
)
{
compileClasspath
=
classpath
;
}
else
{
compileClasspath
.
append
(
classpath
)
;
}
}
public
Path
getClasspath
(
)
{
return
compileClasspath
;
}
public
Path
createClasspath
(
)
{
if
(
compileClasspath
==
null
)
{
compileClasspath
=
new
Path
(
project
)
;
}
return
compileClasspath
.
createPath
(
)
;
}
public
void
setClasspathRef
(
Reference
r
)
{
createClasspath
(
)
.
setRefid
(
r
)
;
}
public
void
setBootclasspath
(
Path
bootclasspath
)
{
if
(
this
.
bootclasspath
==
null
)
{
this
.
bootclasspath
=
bootclasspath
;
}
else
{
this
.
bootclasspath
.
append
(
bootclasspath
)
;
}
}
public
Path
getBootclasspath
(
)
{
return
bootclasspath
;
}
public
Path
createBootclasspath
(
)
{
if
(
bootclasspath
==
null
)
{
bootclasspath
=
new
Path
(
project
)
;
}
return
bootclasspath
.
createPath
(
)
;
}
public
void
setBootClasspathRef
(
Reference
r
)
{
createBootclasspath
(
)
.
setRefid
(
r
)
;
}
public
void
setExtdirs
(
Path
extdirs
)
{
if
(
this
.
extdirs
==
null
)
{
this
.
extdirs
=
extdirs
;
}
else
{
this
.
extdirs
.
append
(
extdirs
)
;
}
}
public
Path
getExtdirs
(
)
{
return
extdirs
;
}
public
Path
createExtdirs
(
)
{
if
(
extdirs
==
null
)
{
extdirs
=
new
Path
(
project
)
;
}
return
extdirs
.
createPath
(
)
;
}
public
void
setListfiles
(
boolean
list
)
{
listFiles
=
list
;
}
public
boolean
getListfiles
(
)
{
return
listFiles
;
}
public
void
setFailonerror
(
boolean
fail
)
{
failOnError
=
fail
;
}
public
void
setProceed
(
boolean
proceed
)
{
failOnError
=
!
proceed
;
}
public
boolean
getFailonerror
(
)
{
return
failOnError
;
}
public
void
setDeprecation
(
boolean
deprecation
)
{
this
.
deprecation
=
deprecation
;
}
public
boolean
getDeprecation
(
)
{
return
deprecation
;
}
public
void
setMemoryInitialSize
(
String
memoryInitialSize
)
{
this
.
memoryInitialSize
=
memoryInitialSize
;
}
public
String
getMemoryInitialSize
(
)
{
return
memoryInitialSize
;
}
public
void
setMemoryMaximumSize
(
String
memoryMaximumSize
)
{
this
.
memoryMaximumSize
=
memoryMaximumSize
;
}
public
String
getMemoryMaximumSize
(
)
{
return
memoryMaximumSize
;
}
public
void
setEncoding
(
String
encoding
)
{
this
.
encoding
=
encoding
;
}
public
String
getEncoding
(
)
{
return
encoding
;
}
public
void
setDebug
(
boolean
debug
)
{
this
.
debug
=
debug
;
}
public
boolean
getDebug
(
)
{
return
debug
;
}
public
void
setOptimize
(
boolean
optimize
)
{
this
.
optimize
=
optimize
;
}
public
boolean
getOptimize
(
)
{
return
optimize
;
}
public
void
setDepend
(
boolean
depend
)
{
this
.
depend
=
depend
;
}
public
boolean
getDepend
(
)
{
return
depend
;
}
public
void
setVerbose
(
boolean
verbose
)
{
this
.
verbose
=
verbose
;
}
public
boolean
getVerbose
(
)
{
return
verbose
;
}
public
void
setTarget
(
String
target
)
{
this
.
target
=
target
;
}
public
String
getTarget
(
)
{
return
target
;
}
public
void
setIncludeantruntime
(
boolean
include
)
{
includeAntRuntime
=
include
;
}
public
boolean
getIncludeantruntime
(
)
{
return
includeAntRuntime
;
}
public
void
setIncludejavaruntime
(
boolean
include
)
{
includeJavaRuntime
=
include
;
}
public
boolean
getIncludejavaruntime
(
)
{
return
includeJavaRuntime
;
}
public
void
setFork
(
boolean
f
)
{
fork
=
f
;
}
public
void
setExecutable
(
String
forkExec
)
{
forkedExecutable
=
forkExec
;
}
public
boolean
isForkedJavac
(
)
{
return
fork
||
"extJavac"
.
equals
(
getCompiler
(
)
)
;
}
public
String
getJavacExecutable
(
)
{
if
(
forkedExecutable
==
null
&&
isForkedJavac
(
)
)
{
forkedExecutable
=
getSystemJavac
(
)
;
}
else
if
(
forkedExecutable
!=
null
&&
!
isForkedJavac
(
)
)
{
forkedExecutable
=
null
;
}
return
forkedExecutable
;
}
public
void
setNowarn
(
boolean
flag
)
{
this
.
nowarn
=
flag
;
}
public
boolean
getNowarn
(
)
{
return
nowarn
;
}
public
ImplementationSpecificArgument
createCompilerArg
(
)
{
ImplementationSpecificArgument
arg
=
new
ImplementationSpecificArgument
(
)
;
facade
.
addImplementationArgument
(
arg
)
;
return
arg
;
}
public
String
[
]
getCurrentCompilerArgs
(
)
{
String
chosen
=
facade
.
getExplicitChoice
(
)
;
facade
.
setImplementation
(
getCompiler
(
)
)
;
try
{
return
facade
.
getArgs
(
)
;
}
finally
{
facade
.
setImplementation
(
chosen
)
;
}
}
public
void
execute
(
)
throws
BuildException
{
checkParameters
(
)
;
resetFileLists
(
)
;
String
[
]
list
=
src
.
list
(
)
;
for
(
int
i
=
0
;
i
<
list
.
length
;
i
++
)
{
File
srcDir
=
project
.
resolveFile
(
list
[
i
]
)
;
if
(
!
srcDir
.
exists
(
)
)
{
throw
new
BuildException
(
"srcdir \""
+
srcDir
.
getPath
(
)
+
"\" does not exist!"
,
location
)
;
}
DirectoryScanner
ds
=
this
.
getDirectoryScanner
(
srcDir
)
;
String
[
]
files
=
ds
.
getIncludedFiles
(
)
;
scanDir
(
srcDir
,
destDir
!=
null
?
destDir
:
srcDir
,
files
)
;
}
compile
(
)
;
}
protected
void
resetFileLists
(
)
{
compileList
=
new
File
[
0
]
;
}
protected
void
scanDir
(
File
srcDir
,
File
destDir
,
String
[
]
files
)
{
GlobPatternMapper
m
=
new
GlobPatternMapper
(
)
;
m
.
setFrom
(
"*.java"
)
;
m
.
setTo
(
"*.class"
)
;
SourceFileScanner
sfs
=
new
SourceFileScanner
(
this
)
;
File
[
]
newFiles
=
sfs
.
restrictAsFiles
(
files
,
srcDir
,
destDir
,
m
)
;
if
(
newFiles
.
length
>
0
)
{
File
[
]
newCompileList
=
new
File
[
compileList
.
length
+
newFiles
.
length
]
;
System
.
arraycopy
(
compileList
,
0
,
newCompileList
,
0
,
compileList
.
length
)
;
System
.
arraycopy
(
newFiles
,
0
,
newCompileList
,
compileList
.
length
,
newFiles
.
length
)
;
compileList
=
newCompileList
;
}
}
public
File
[
]
getFileList
(
)
{
return
compileList
;
}
protected
boolean
isJdkCompiler
(
String
compilerImpl
)
{
return
"modern"
.
equals
(
compilerImpl
)
||
"classic"
.
equals
(
compilerImpl
)
||
"javac1.1"
.
equals
(
compilerImpl
)
||
"javac1.2"
.
equals
(
compilerImpl
)
||
"javac1.3"
.
equals
(
compilerImpl
)
||
"javac1.4"
.
equals
(
compilerImpl
)
;
}
protected
String
getSystemJavac
(
)
{
return
JavaEnvUtils
.
getJdkExecutable
(
"javac"
)
;
}
public
void
setCompiler
(
String
compiler
)
{
facade
.
setImplementation
(
compiler
)
;
}
public
String
getCompiler
(
)
{
String
compilerImpl
=
getCompilerVersion
(
)
;
if
(
fork
)
{
if
(
isJdkCompiler
(
compilerImpl
)
)
{
log
(
"Since fork is true, ignoring compiler setting."
,
Project
.
MSG_WARN
)
;
compilerImpl
=
"extJavac"
;
}
else
{
log
(
"Since compiler setting isn't classic or modern,"
+
"ignoring fork setting."
,
Project
.
MSG_WARN
)
;
}
}
return
compilerImpl
;
}
public
String
getCompilerVersion
(
)
{
facade
.
setMagicValue
(
getProject
(
)
.
getProperty
(
"build.compiler"
)
)
;
return
facade
.
getImplementation
(
)
;
}
protected
void
checkParameters
(
)
throws
BuildException
{
if
(
src
==
null
)
{
throw
new
BuildException
(
"srcdir attribute must be set!"
,
location
)
;
}
if
(
src
.
size
(
)
==
0
)
{
throw
new
BuildException
(
"srcdir attribute must be set!"
,
location
)
;
}
if
(
destDir
!=
null
&&
!
destDir
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"destination directory \""
+
destDir
+
"\" does not exist "
+
"or is not a directory"
,
location
)
;
}
}
protected
void
compile
(
)
{
String
compilerImpl
=
getCompiler
(
)
;
if
(
compileList
.
length
>
0
)
{
log
(
"Compiling "
+
compileList
.
length
+
" source file"
+
(
compileList
.
length
==
1
?
""
:
"s"
)
+
(
destDir
!=
null
?
" to "
+
destDir
:
""
)
)
;
if
(
listFiles
)
{
for
(
int
i
=
0
;
i
<
compileList
.
length
;
i
++
)
{
String
filename
=
compileList
[
i
]
.
getAbsolutePath
(
)
;
log
(
filename
)
;
}
}
CompilerAdapter
adapter
=
CompilerAdapterFactory
.
getCompiler
(
compilerImpl
,
this
)
;
adapter
.
setJavac
(
this
)
;
if
(
!
adapter
.
execute
(
)
)
{
if
(
failOnError
)
{
throw
new
BuildException
(
FAIL_MSG
,
location
)
;
}
else
{
log
(
FAIL_MSG
,
Project
.
MSG_ERR
)
;
}
}
}
}
public
class
ImplementationSpecificArgument
extends
org
.
apache
.
tools
.
ant
.
util
.
facade
.
ImplementationSpecificArgument
{
public
void
setCompiler
(
String
impl
)
{
super
.
setImplementation
(
impl
)
;
}
}
}
