package
org
.
apache
.
tools
.
ant
.
util
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
FileWriter
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
Reader
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
text
.
DecimalFormat
;
import
java
.
util
.
Random
;
import
java
.
util
.
Stack
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Vector
;
import
java
.
net
.
URL
;
import
java
.
net
.
MalformedURLException
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
filters
.
util
.
ChainReaderHelper
;
import
org
.
apache
.
tools
.
ant
.
types
.
FilterSetCollection
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
condition
.
Os
;
public
class
FileUtils
{
private
static
Random
rand
=
new
Random
(
System
.
currentTimeMillis
(
)
)
;
private
static
Object
lockReflection
=
new
Object
(
)
;
private
static
java
.
lang
.
reflect
.
Method
setLastModified
=
null
;
private
boolean
onNetWare
=
Os
.
isFamily
(
"netware"
)
;
public
static
FileUtils
newFileUtils
(
)
{
return
new
FileUtils
(
)
;
}
protected
FileUtils
(
)
{
}
public
URL
getFileURL
(
File
file
)
throws
MalformedURLException
{
String
uri
=
"file:"
+
file
.
getAbsolutePath
(
)
.
replace
(
'\\'
,
'/'
)
;
for
(
int
i
=
uri
.
indexOf
(
'#'
)
;
i
!=
-
1
;
i
=
uri
.
indexOf
(
'#'
)
)
{
uri
=
uri
.
substring
(
0
,
i
)
+
"%23"
+
uri
.
substring
(
i
+
1
)
;
}
if
(
file
.
isDirectory
(
)
)
{
uri
+=
"/"
;
}
return
new
URL
(
uri
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
null
,
false
,
false
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
false
,
false
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
overwrite
,
false
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
,
boolean
preserveLastModified
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
overwrite
,
preserveLastModified
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
encoding
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
overwrite
,
preserveLastModified
,
encoding
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
,
Vector
filterChains
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
encoding
,
Project
project
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
filterChains
,
overwrite
,
preserveLastModified
,
encoding
,
project
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
null
,
false
,
false
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
filters
,
false
,
false
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
filters
,
overwrite
,
false
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
,
boolean
preserveLastModified
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
filters
,
overwrite
,
preserveLastModified
,
null
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
encoding
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
filters
,
null
,
overwrite
,
preserveLastModified
,
encoding
,
null
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
,
Vector
filterChains
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
encoding
,
Project
project
)
throws
IOException
{
if
(
overwrite
||
!
destFile
.
exists
(
)
||
destFile
.
lastModified
(
)
<
sourceFile
.
lastModified
(
)
)
{
if
(
destFile
.
exists
(
)
&&
destFile
.
isFile
(
)
)
{
destFile
.
delete
(
)
;
}
File
parent
=
getParentFile
(
destFile
)
;
if
(
!
parent
.
exists
(
)
)
{
parent
.
mkdirs
(
)
;
}
final
boolean
filterSetsAvailable
=
(
filters
!=
null
&&
filters
.
hasFilters
(
)
)
;
final
boolean
filterChainsAvailable
=
(
filterChains
!=
null
&&
filterChains
.
size
(
)
>
0
)
;
if
(
filterSetsAvailable
||
filterChainsAvailable
)
{
BufferedReader
in
=
null
;
BufferedWriter
out
=
null
;
try
{
if
(
encoding
==
null
)
{
in
=
new
BufferedReader
(
new
FileReader
(
sourceFile
)
)
;
out
=
new
BufferedWriter
(
new
FileWriter
(
destFile
)
)
;
}
else
{
in
=
new
BufferedReader
(
new
InputStreamReader
(
new
FileInputStream
(
sourceFile
)
,
encoding
)
)
;
out
=
new
BufferedWriter
(
new
OutputStreamWriter
(
new
FileOutputStream
(
destFile
)
,
encoding
)
)
;
}
if
(
filterChainsAvailable
)
{
ChainReaderHelper
crh
=
new
ChainReaderHelper
(
)
;
crh
.
setBufferSize
(
8192
)
;
crh
.
setPrimaryReader
(
in
)
;
crh
.
setFilterChains
(
filterChains
)
;
crh
.
setProject
(
project
)
;
Reader
rdr
=
crh
.
getAssembledReader
(
)
;
in
=
new
BufferedReader
(
rdr
)
;
}
int
length
;
String
newline
=
null
;
String
line
=
in
.
readLine
(
)
;
while
(
line
!=
null
)
{
if
(
line
.
length
(
)
==
0
)
{
out
.
newLine
(
)
;
}
else
{
if
(
filterSetsAvailable
)
{
newline
=
filters
.
replaceTokens
(
line
)
;
}
else
{
newline
=
line
;
}
out
.
write
(
newline
)
;
out
.
newLine
(
)
;
}
line
=
in
.
readLine
(
)
;
}
}
finally
{
if
(
out
!=
null
)
{
out
.
close
(
)
;
}
if
(
in
!=
null
)
{
in
.
close
(
)
;
}
}
}
else
{
FileInputStream
in
=
null
;
FileOutputStream
out
=
null
;
try
{
in
=
new
FileInputStream
(
sourceFile
)
;
out
=
new
FileOutputStream
(
destFile
)
;
byte
[
]
buffer
=
new
byte
[
8
*
1024
]
;
int
count
=
0
;
do
{
out
.
write
(
buffer
,
0
,
count
)
;
count
=
in
.
read
(
buffer
,
0
,
buffer
.
length
)
;
}
while
(
count
!=
-
1
)
;
}
finally
{
if
(
out
!=
null
)
{
out
.
close
(
)
;
}
if
(
in
!=
null
)
{
in
.
close
(
)
;
}
}
}
if
(
preserveLastModified
)
{
setFileLastModified
(
destFile
,
sourceFile
.
lastModified
(
)
)
;
}
}
}
protected
final
Method
getSetLastModified
(
)
{
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_1
)
)
{
return
null
;
}
if
(
setLastModified
==
null
)
{
synchronized
(
lockReflection
)
{
if
(
setLastModified
==
null
)
{
try
{
setLastModified
=
java
.
io
.
File
.
class
.
getMethod
(
"setLastModified"
,
new
Class
[
]
{
Long
.
TYPE
}
)
;
}
catch
(
NoSuchMethodException
nse
)
{
throw
new
BuildException
(
"File.setlastModified not in JDK > 1.1?"
,
nse
)
;
}
}
}
}
return
setLastModified
;
}
public
void
setFileLastModified
(
File
file
,
long
time
)
throws
BuildException
{
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_1
)
)
{
return
;
}
Long
[
]
times
=
new
Long
[
1
]
;
if
(
time
<
0
)
{
times
[
0
]
=
new
Long
(
System
.
currentTimeMillis
(
)
)
;
}
else
{
times
[
0
]
=
new
Long
(
time
)
;
}
try
{
getSetLastModified
(
)
.
invoke
(
file
,
times
)
;
}
catch
(
java
.
lang
.
reflect
.
InvocationTargetException
ite
)
{
Throwable
nested
=
ite
.
getTargetException
(
)
;
throw
new
BuildException
(
"Exception setting the modification time "
+
"of "
+
file
,
nested
)
;
}
catch
(
Throwable
other
)
{
throw
new
BuildException
(
"Exception setting the modification time "
+
"of "
+
file
,
other
)
;
}
}
public
File
resolveFile
(
File
file
,
String
filename
)
{
filename
=
filename
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
if
(
!
onNetWare
)
{
if
(
filename
.
startsWith
(
File
.
separator
)
||
(
filename
.
length
(
)
>=
2
&&
Character
.
isLetter
(
filename
.
charAt
(
0
)
)
&&
filename
.
charAt
(
1
)
==
':'
)
)
{
return
normalize
(
filename
)
;
}
}
else
{
int
colon
=
filename
.
indexOf
(
":"
)
;
if
(
filename
.
startsWith
(
File
.
separator
)
||
(
colon
>
-
1
)
)
{
return
normalize
(
filename
)
;
}
}
if
(
file
==
null
)
{
return
new
File
(
filename
)
;
}
File
helpFile
=
new
File
(
file
.
getAbsolutePath
(
)
)
;
StringTokenizer
tok
=
new
StringTokenizer
(
filename
,
File
.
separator
)
;
while
(
tok
.
hasMoreTokens
(
)
)
{
String
part
=
tok
.
nextToken
(
)
;
if
(
part
.
equals
(
".."
)
)
{
helpFile
=
getParentFile
(
helpFile
)
;
if
(
helpFile
==
null
)
{
String
msg
=
"The file or path you specified ("
+
filename
+
") is invalid relative to "
+
file
.
getPath
(
)
;
throw
new
BuildException
(
msg
)
;
}
}
else
if
(
part
.
equals
(
"."
)
)
{
}
else
{
helpFile
=
new
File
(
helpFile
,
part
)
;
}
}
return
new
File
(
helpFile
.
getAbsolutePath
(
)
)
;
}
public
File
normalize
(
String
path
)
{
String
orig
=
path
;
path
=
path
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
int
colon
=
path
.
indexOf
(
":"
)
;
if
(
!
onNetWare
)
{
if
(
!
path
.
startsWith
(
File
.
separator
)
&&
!
(
path
.
length
(
)
>=
2
&&
Character
.
isLetter
(
path
.
charAt
(
0
)
)
&&
colon
==
1
)
)
{
String
msg
=
path
+
" is not an absolute path"
;
throw
new
BuildException
(
msg
)
;
}
}
else
{
if
(
!
path
.
startsWith
(
File
.
separator
)
&&
(
colon
==
-
1
)
)
{
String
msg
=
path
+
" is not an absolute path"
;
throw
new
BuildException
(
msg
)
;
}
}
boolean
dosWithDrive
=
false
;
String
root
=
null
;
if
(
(
!
onNetWare
&&
path
.
length
(
)
>=
2
&&
Character
.
isLetter
(
path
.
charAt
(
0
)
)
&&
path
.
charAt
(
1
)
==
':'
)
||
(
onNetWare
&&
colon
>
-
1
)
)
{
dosWithDrive
=
true
;
char
[
]
ca
=
path
.
replace
(
'/'
,
'\\'
)
.
toCharArray
(
)
;
StringBuffer
sbRoot
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
colon
;
i
++
)
{
sbRoot
.
append
(
Character
.
toUpperCase
(
ca
[
i
]
)
)
;
}
sbRoot
.
append
(
':'
)
;
if
(
colon
+
1
<
path
.
length
(
)
)
{
sbRoot
.
append
(
File
.
separatorChar
)
;
}
root
=
sbRoot
.
toString
(
)
;
StringBuffer
sbPath
=
new
StringBuffer
(
)
;
for
(
int
i
=
colon
+
1
;
i
<
ca
.
length
;
i
++
)
{
if
(
(
ca
[
i
]
!=
'\\'
)
||
(
ca
[
i
]
==
'\\'
&&
ca
[
i
-
1
]
!=
'\\'
)
)
{
sbPath
.
append
(
ca
[
i
]
)
;
}
}
path
=
sbPath
.
toString
(
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
}
else
{
if
(
path
.
length
(
)
==
1
)
{
root
=
File
.
separator
;
path
=
""
;
}
else
if
(
path
.
charAt
(
1
)
==
File
.
separatorChar
)
{
root
=
File
.
separator
+
File
.
separator
;
path
=
path
.
substring
(
2
)
;
}
else
{
root
=
File
.
separator
;
path
=
path
.
substring
(
1
)
;
}
}
Stack
s
=
new
Stack
(
)
;
s
.
push
(
root
)
;
StringTokenizer
tok
=
new
StringTokenizer
(
path
,
File
.
separator
)
;
while
(
tok
.
hasMoreTokens
(
)
)
{
String
thisToken
=
tok
.
nextToken
(
)
;
if
(
"."
.
equals
(
thisToken
)
)
{
continue
;
}
else
if
(
".."
.
equals
(
thisToken
)
)
{
if
(
s
.
size
(
)
<
2
)
{
throw
new
BuildException
(
"Cannot resolve path "
+
orig
)
;
}
else
{
s
.
pop
(
)
;
}
}
else
{
s
.
push
(
thisToken
)
;
}
}
StringBuffer
sb
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
s
.
size
(
)
;
i
++
)
{
if
(
i
>
1
)
{
sb
.
append
(
File
.
separatorChar
)
;
}
sb
.
append
(
s
.
elementAt
(
i
)
)
;
}
path
=
sb
.
toString
(
)
;
if
(
dosWithDrive
)
{
path
=
path
.
replace
(
'/'
,
'\\'
)
;
}
return
new
File
(
path
)
;
}
public
File
createTempFile
(
String
prefix
,
String
suffix
,
File
parentDir
)
{
File
result
=
null
;
String
parent
=
null
;
if
(
parentDir
!=
null
)
{
parent
=
parentDir
.
getPath
(
)
;
}
DecimalFormat
fmt
=
new
DecimalFormat
(
"#####"
)
;
synchronized
(
rand
)
{
do
{
result
=
new
File
(
parent
,
prefix
+
fmt
.
format
(
rand
.
nextInt
(
)
)
+
suffix
)
;
}
while
(
result
.
exists
(
)
)
;
}
return
result
;
}
public
boolean
contentEquals
(
File
f1
,
File
f2
)
throws
IOException
{
if
(
f1
.
exists
(
)
!=
f2
.
exists
(
)
)
{
return
false
;
}
if
(
!
f1
.
exists
(
)
)
{
return
true
;
}
if
(
f1
.
isDirectory
(
)
||
f2
.
isDirectory
(
)
)
{
return
false
;
}
if
(
f1
.
equals
(
f2
)
)
{
return
true
;
}
if
(
f1
.
length
(
)
!=
f2
.
length
(
)
)
{
return
false
;
}
InputStream
in1
=
null
;
InputStream
in2
=
null
;
try
{
in1
=
new
BufferedInputStream
(
new
FileInputStream
(
f1
)
)
;
in2
=
new
BufferedInputStream
(
new
FileInputStream
(
f2
)
)
;
int
expectedByte
=
in1
.
read
(
)
;
while
(
expectedByte
!=
-
1
)
{
if
(
expectedByte
!=
in2
.
read
(
)
)
{
return
false
;
}
expectedByte
=
in1
.
read
(
)
;
}
if
(
in2
.
read
(
)
!=
-
1
)
{
return
false
;
}
return
true
;
}
finally
{
if
(
in1
!=
null
)
{
try
{
in1
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
if
(
in2
!=
null
)
{
try
{
in2
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
}
}
public
File
getParentFile
(
File
f
)
{
if
(
f
!=
null
)
{
String
p
=
f
.
getParent
(
)
;
if
(
p
!=
null
)
{
return
new
File
(
p
)
;
}
}
return
null
;
}
public
static
final
String
readFully
(
Reader
rdr
)
throws
IOException
{
return
readFully
(
rdr
,
8192
)
;
}
public
static
final
String
readFully
(
Reader
rdr
,
int
bufferSize
)
throws
IOException
{
if
(
bufferSize
<=
0
)
{
throw
new
IllegalArgumentException
(
"Buffer size must be greater "
+
"than 0"
)
;
}
final
char
[
]
buffer
=
new
char
[
bufferSize
]
;
int
bufferLength
=
0
;
String
text
=
null
;
StringBuffer
textBuffer
=
null
;
while
(
bufferLength
!=
-
1
)
{
bufferLength
=
rdr
.
read
(
buffer
)
;
if
(
bufferLength
!=
-
1
)
{
if
(
textBuffer
==
null
)
{
textBuffer
=
new
StringBuffer
(
new
String
(
buffer
,
0
,
bufferLength
)
)
;
}
else
{
textBuffer
.
append
(
new
String
(
buffer
,
0
,
bufferLength
)
)
;
}
}
}
if
(
textBuffer
!=
null
)
{
text
=
textBuffer
.
toString
(
)
;
}
return
text
;
}
public
boolean
createNewFile
(
File
f
)
throws
IOException
{
if
(
f
!=
null
)
{
if
(
f
.
exists
(
)
)
{
return
false
;
}
FileOutputStream
fos
=
null
;
try
{
fos
=
new
FileOutputStream
(
f
)
;
fos
.
write
(
new
byte
[
0
]
)
;
}
finally
{
if
(
fos
!=
null
)
{
fos
.
close
(
)
;
}
}
return
true
;
}
return
false
;
}
public
boolean
isSymbolicLink
(
File
parent
,
String
name
)
throws
IOException
{
File
resolvedParent
=
new
File
(
parent
.
getCanonicalPath
(
)
)
;
File
toTest
=
new
File
(
resolvedParent
,
name
)
;
return
!
toTest
.
getAbsolutePath
(
)
.
equals
(
toTest
.
getCanonicalPath
(
)
)
;
}
public
String
removeLeadingPath
(
File
leading
,
File
path
)
{
String
l
=
normalize
(
leading
.
getAbsolutePath
(
)
)
.
getAbsolutePath
(
)
+
File
.
separator
;
String
p
=
normalize
(
path
.
getAbsolutePath
(
)
)
.
getAbsolutePath
(
)
;
if
(
p
.
startsWith
(
l
)
)
{
return
p
.
substring
(
l
.
length
(
)
)
;
}
else
{
return
p
;
}
}
}
