package
org
.
apache
.
tools
.
ant
.
taskdefs
.
compilers
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
util
.
JavaEnvUtils
;
public
class
CompilerAdapterFactory
{
private
static
final
String
MODERN_COMPILER
=
"com.sun.tools.javac.Main"
;
private
CompilerAdapterFactory
(
)
{
}
public
static
CompilerAdapter
getCompiler
(
String
compilerType
,
Task
task
)
throws
BuildException
{
boolean
isClassicCompilerSupported
=
true
;
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_4
)
)
{
isClassicCompilerSupported
=
false
;
}
if
(
compilerType
.
equalsIgnoreCase
(
"jikes"
)
)
{
return
new
Jikes
(
)
;
}
if
(
compilerType
.
equalsIgnoreCase
(
"extJavac"
)
)
{
return
new
JavacExternal
(
)
;
}
if
(
compilerType
.
equalsIgnoreCase
(
"classic"
)
||
compilerType
.
equalsIgnoreCase
(
"javac1.1"
)
||
compilerType
.
equalsIgnoreCase
(
"javac1.2"
)
)
{
if
(
isClassicCompilerSupported
)
{
return
new
Javac12
(
)
;
}
else
{
task
.
log
(
"This version of java does "
+
"not support the classic "
+
"compiler; upgrading to modern"
,
Project
.
MSG_WARN
)
;
compilerType
=
"modern"
;
}
}
if
(
compilerType
.
equalsIgnoreCase
(
"modern"
)
||
compilerType
.
equalsIgnoreCase
(
"javac1.3"
)
||
compilerType
.
equalsIgnoreCase
(
"javac1.4"
)
)
{
if
(
doesModernCompilerExist
(
)
)
{
return
new
Javac13
(
)
;
}
else
{
if
(
isClassicCompilerSupported
)
{
task
.
log
(
"Modern compiler not found - looking for "
+
"classic compiler"
,
Project
.
MSG_WARN
)
;
return
new
Javac12
(
)
;
}
else
{
throw
new
BuildException
(
"Unable to find a javac "
+
"compiler;\n"
+
MODERN_COMPILER
+
" is not on the "
+
"classpath.\n"
+
"Perhaps JAVA_HOME does not"
+
" point to the JDK"
)
;
}
}
}
if
(
compilerType
.
equalsIgnoreCase
(
"jvc"
)
||
compilerType
.
equalsIgnoreCase
(
"microsoft"
)
)
{
return
new
Jvc
(
)
;
}
if
(
compilerType
.
equalsIgnoreCase
(
"kjc"
)
)
{
return
new
Kjc
(
)
;
}
if
(
compilerType
.
equalsIgnoreCase
(
"gcj"
)
)
{
return
new
Gcj
(
)
;
}
if
(
compilerType
.
equalsIgnoreCase
(
"sj"
)
||
compilerType
.
equalsIgnoreCase
(
"symantec"
)
)
{
return
new
Sj
(
)
;
}
return
resolveClassName
(
compilerType
)
;
}
private
static
boolean
doesModernCompilerExist
(
)
{
try
{
Class
.
forName
(
MODERN_COMPILER
)
;
return
true
;
}
catch
(
ClassNotFoundException
cnfe
)
{
try
{
CompilerAdapterFactory
.
class
.
getClassLoader
(
)
.
loadClass
(
MODERN_COMPILER
)
;
return
true
;
}
catch
(
ClassNotFoundException
cnfe2
)
{
}
}
return
false
;
}
private
static
CompilerAdapter
resolveClassName
(
String
className
)
throws
BuildException
{
try
{
Class
c
=
Class
.
forName
(
className
)
;
Object
o
=
c
.
newInstance
(
)
;
return
(
CompilerAdapter
)
o
;
}
catch
(
ClassNotFoundException
cnfe
)
{
throw
new
BuildException
(
"Compiler Adapter '"
+
className
+
"' can\'t be found."
,
cnfe
)
;
}
catch
(
ClassCastException
cce
)
{
throw
new
BuildException
(
className
+
" isn\'t the classname of "
+
"a compiler adapter."
,
cce
)
;
}
catch
(
Throwable
t
)
{
throw
new
BuildException
(
"Compiler Adapter "
+
className
+
" caused an interesting exception."
,
t
)
;
}
}
}
