package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
File
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
AntClassLoader
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
DynamicConfigurator
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
types
.
Reference
;
import
org
.
apache
.
tools
.
ant
.
types
.
XMLCatalog
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
public
class
XSLTProcess
extends
MatchingTask
implements
XSLTLogger
{
private
File
destDir
=
null
;
private
File
baseDir
=
null
;
private
String
xslFile
=
null
;
private
String
targetExtension
=
".html"
;
private
Vector
params
=
new
Vector
(
)
;
private
File
inFile
=
null
;
private
File
outFile
=
null
;
private
String
processor
;
private
Path
classpath
=
null
;
private
XSLTLiaison
liaison
;
private
boolean
stylesheetLoaded
=
false
;
private
boolean
force
=
false
;
private
FileUtils
fileUtils
;
private
Vector
outputProperties
=
new
Vector
(
)
;
private
XMLCatalog
xmlCatalog
=
new
XMLCatalog
(
)
;
private
static
final
String
TRAX_LIAISON_CLASS
=
"org.apache.tools.ant.taskdefs.optional.TraXLiaison"
;
private
static
final
String
XSLP_LIAISON_CLASS
=
"org.apache.tools.ant.taskdefs.optional.XslpLiaison"
;
private
static
final
String
XALAN_LIAISON_CLASS
=
"org.apache.tools.ant.taskdefs.optional.XalanLiaison"
;
private
boolean
performDirectoryScan
=
true
;
private
Factory
factory
=
null
;
private
boolean
reuseLoadedStylesheet
=
true
;
public
XSLTProcess
(
)
{
fileUtils
=
FileUtils
.
newFileUtils
(
)
;
}
public
void
setScanIncludedDirectories
(
boolean
b
)
{
performDirectoryScan
=
b
;
}
public
void
setReloadStylesheet
(
boolean
b
)
{
reuseLoadedStylesheet
=
!
b
;
}
public
void
execute
(
)
throws
BuildException
{
File
savedBaseDir
=
baseDir
;
DirectoryScanner
scanner
;
String
[
]
list
;
String
[
]
dirs
;
if
(
xslFile
==
null
)
{
throw
new
BuildException
(
"no stylesheet specified"
,
getLocation
(
)
)
;
}
if
(
inFile
!=
null
&&
!
inFile
.
exists
(
)
)
{
throw
new
BuildException
(
"input file "
+
inFile
.
toString
(
)
+
" does not exist"
,
getLocation
(
)
)
;
}
try
{
if
(
baseDir
==
null
)
{
baseDir
=
getProject
(
)
.
resolveFile
(
"."
)
;
}
liaison
=
getLiaison
(
)
;
if
(
liaison
instanceof
XSLTLoggerAware
)
{
(
(
XSLTLoggerAware
)
liaison
)
.
setLogger
(
this
)
;
}
log
(
"Using "
+
liaison
.
getClass
(
)
.
toString
(
)
,
Project
.
MSG_VERBOSE
)
;
File
stylesheet
=
getProject
(
)
.
resolveFile
(
xslFile
)
;
if
(
!
stylesheet
.
exists
(
)
)
{
stylesheet
=
fileUtils
.
resolveFile
(
baseDir
,
xslFile
)
;
if
(
stylesheet
.
exists
(
)
)
{
log
(
"DEPRECATED - the style attribute should be relative "
+
"to the project\'s"
)
;
log
(
"             basedir, not the tasks\'s basedir."
)
;
}
}
if
(
inFile
!=
null
&&
outFile
!=
null
)
{
process
(
inFile
,
outFile
,
stylesheet
)
;
return
;
}
if
(
destDir
==
null
)
{
String
msg
=
"destdir attributes must be set!"
;
throw
new
BuildException
(
msg
)
;
}
scanner
=
getDirectoryScanner
(
baseDir
)
;
log
(
"Transforming into "
+
destDir
,
Project
.
MSG_INFO
)
;
list
=
scanner
.
getIncludedFiles
(
)
;
for
(
int
i
=
0
;
i
<
list
.
length
;
++
i
)
{
process
(
baseDir
,
list
[
i
]
,
destDir
,
stylesheet
)
;
}
if
(
performDirectoryScan
)
{
dirs
=
scanner
.
getIncludedDirectories
(
)
;
for
(
int
j
=
0
;
j
<
dirs
.
length
;
++
j
)
{
list
=
new
File
(
baseDir
,
dirs
[
j
]
)
.
list
(
)
;
for
(
int
i
=
0
;
i
<
list
.
length
;
++
i
)
{
process
(
baseDir
,
list
[
i
]
,
destDir
,
stylesheet
)
;
}
}
}
}
finally
{
liaison
=
null
;
stylesheetLoaded
=
false
;
baseDir
=
savedBaseDir
;
}
}
public
void
setForce
(
boolean
force
)
{
this
.
force
=
force
;
}
public
void
setBasedir
(
File
dir
)
{
baseDir
=
dir
;
}
public
void
setDestdir
(
File
dir
)
{
destDir
=
dir
;
}
public
void
setExtension
(
String
name
)
{
targetExtension
=
name
;
}
public
void
setStyle
(
String
xslFile
)
{
this
.
xslFile
=
xslFile
;
}
public
void
setClasspath
(
Path
classpath
)
{
createClasspath
(
)
.
append
(
classpath
)
;
}
public
Path
createClasspath
(
)
{
if
(
classpath
==
null
)
{
classpath
=
new
Path
(
getProject
(
)
)
;
}
return
classpath
.
createPath
(
)
;
}
public
void
setClasspathRef
(
Reference
r
)
{
createClasspath
(
)
.
setRefid
(
r
)
;
}
public
void
setProcessor
(
String
processor
)
{
this
.
processor
=
processor
;
}
public
void
addConfiguredXMLCatalog
(
XMLCatalog
xmlCatalog
)
{
this
.
xmlCatalog
.
addConfiguredXMLCatalog
(
xmlCatalog
)
;
}
private
void
resolveProcessor
(
String
proc
)
throws
Exception
{
if
(
proc
.
equals
(
"trax"
)
)
{
final
Class
clazz
=
loadClass
(
TRAX_LIAISON_CLASS
)
;
liaison
=
(
XSLTLiaison
)
clazz
.
newInstance
(
)
;
}
else
if
(
proc
.
equals
(
"xslp"
)
)
{
log
(
"DEPRECATED - xslp processor is deprecated. Use trax "
+
"instead."
)
;
final
Class
clazz
=
loadClass
(
XSLP_LIAISON_CLASS
)
;
liaison
=
(
XSLTLiaison
)
clazz
.
newInstance
(
)
;
}
else
if
(
proc
.
equals
(
"xalan"
)
)
{
log
(
"DEPRECATED - xalan processor is deprecated. Use trax "
+
"instead."
)
;
final
Class
clazz
=
loadClass
(
XALAN_LIAISON_CLASS
)
;
liaison
=
(
XSLTLiaison
)
clazz
.
newInstance
(
)
;
}
else
{
liaison
=
(
XSLTLiaison
)
loadClass
(
proc
)
.
newInstance
(
)
;
}
}
private
Class
loadClass
(
String
classname
)
throws
Exception
{
if
(
classpath
==
null
)
{
return
Class
.
forName
(
classname
)
;
}
else
{
AntClassLoader
al
=
getProject
(
)
.
createClassLoader
(
classpath
)
;
Class
c
=
Class
.
forName
(
classname
,
true
,
al
)
;
return
c
;
}
}
public
void
setOut
(
File
outFile
)
{
this
.
outFile
=
outFile
;
}
public
void
setIn
(
File
inFile
)
{
this
.
inFile
=
inFile
;
}
private
void
process
(
File
baseDir
,
String
xmlFile
,
File
destDir
,
File
stylesheet
)
throws
BuildException
{
String
fileExt
=
targetExtension
;
File
outFile
=
null
;
File
inFile
=
null
;
try
{
long
styleSheetLastModified
=
stylesheet
.
lastModified
(
)
;
inFile
=
new
File
(
baseDir
,
xmlFile
)
;
if
(
inFile
.
isDirectory
(
)
)
{
log
(
"Skipping "
+
inFile
+
" it is a directory."
,
Project
.
MSG_VERBOSE
)
;
return
;
}
int
dotPos
=
xmlFile
.
lastIndexOf
(
'.'
)
;
if
(
dotPos
>
0
)
{
outFile
=
new
File
(
destDir
,
xmlFile
.
substring
(
0
,
xmlFile
.
lastIndexOf
(
'.'
)
)
+
fileExt
)
;
}
else
{
outFile
=
new
File
(
destDir
,
xmlFile
+
fileExt
)
;
}
if
(
force
||
inFile
.
lastModified
(
)
>
outFile
.
lastModified
(
)
||
styleSheetLastModified
>
outFile
.
lastModified
(
)
)
{
ensureDirectoryFor
(
outFile
)
;
log
(
"Processing "
+
inFile
+
" to "
+
outFile
)
;
configureLiaison
(
stylesheet
)
;
liaison
.
transform
(
inFile
,
outFile
)
;
}
}
catch
(
Exception
ex
)
{
log
(
"Failed to process "
+
inFile
,
Project
.
MSG_INFO
)
;
if
(
outFile
!=
null
)
{
outFile
.
delete
(
)
;
}
throw
new
BuildException
(
ex
)
;
}
}
private
void
process
(
File
inFile
,
File
outFile
,
File
stylesheet
)
throws
BuildException
{
try
{
long
styleSheetLastModified
=
stylesheet
.
lastModified
(
)
;
log
(
"In file "
+
inFile
+
" time: "
+
inFile
.
lastModified
(
)
,
Project
.
MSG_DEBUG
)
;
log
(
"Out file "
+
outFile
+
" time: "
+
outFile
.
lastModified
(
)
,
Project
.
MSG_DEBUG
)
;
log
(
"Style file "
+
xslFile
+
" time: "
+
styleSheetLastModified
,
Project
.
MSG_DEBUG
)
;
if
(
force
||
inFile
.
lastModified
(
)
>=
outFile
.
lastModified
(
)
||
styleSheetLastModified
>=
outFile
.
lastModified
(
)
)
{
ensureDirectoryFor
(
outFile
)
;
log
(
"Processing "
+
inFile
+
" to "
+
outFile
,
Project
.
MSG_INFO
)
;
configureLiaison
(
stylesheet
)
;
liaison
.
transform
(
inFile
,
outFile
)
;
}
else
{
log
(
"Skipping input file "
+
inFile
+
" because it is older than output file "
+
outFile
+
" and so is the stylesheet "
+
stylesheet
,
Project
.
MSG_DEBUG
)
;
}
}
catch
(
Exception
ex
)
{
log
(
"Failed to process "
+
inFile
,
Project
.
MSG_INFO
)
;
if
(
outFile
!=
null
)
{
outFile
.
delete
(
)
;
}
throw
new
BuildException
(
ex
)
;
}
}
private
void
ensureDirectoryFor
(
File
targetFile
)
throws
BuildException
{
File
directory
=
fileUtils
.
getParentFile
(
targetFile
)
;
if
(
!
directory
.
exists
(
)
)
{
if
(
!
directory
.
mkdirs
(
)
)
{
throw
new
BuildException
(
"Unable to create directory: "
+
directory
.
getAbsolutePath
(
)
)
;
}
}
}
public
Factory
getFactory
(
)
{
return
factory
;
}
public
XMLCatalog
getXMLCatalog
(
)
{
return
xmlCatalog
;
}
public
Enumeration
getOutputProperties
(
)
{
return
outputProperties
.
elements
(
)
;
}
protected
XSLTLiaison
getLiaison
(
)
{
if
(
liaison
==
null
)
{
if
(
processor
!=
null
)
{
try
{
resolveProcessor
(
processor
)
;
}
catch
(
Exception
e
)
{
throw
new
BuildException
(
e
)
;
}
}
else
{
try
{
resolveProcessor
(
"trax"
)
;
}
catch
(
Throwable
e1
)
{
try
{
resolveProcessor
(
"xalan"
)
;
}
catch
(
Throwable
e2
)
{
try
{
resolveProcessor
(
"xslp"
)
;
}
catch
(
Throwable
e3
)
{
e3
.
printStackTrace
(
)
;
e2
.
printStackTrace
(
)
;
throw
new
BuildException
(
e1
)
;
}
}
}
}
}
return
liaison
;
}
public
Param
createParam
(
)
{
Param
p
=
new
Param
(
)
;
params
.
addElement
(
p
)
;
return
p
;
}
public
static
class
Param
{
private
String
name
=
null
;
private
String
expression
=
null
;
private
String
ifProperty
;
private
String
unlessProperty
;
private
Project
project
;
public
void
setProject
(
Project
project
)
{
this
.
project
=
project
;
}
public
void
setName
(
String
name
)
{
this
.
name
=
name
;
}
public
void
setExpression
(
String
expression
)
{
this
.
expression
=
expression
;
}
public
String
getName
(
)
throws
BuildException
{
if
(
name
==
null
)
{
throw
new
BuildException
(
"Name attribute is missing."
)
;
}
return
name
;
}
public
String
getExpression
(
)
throws
BuildException
{
if
(
expression
==
null
)
{
throw
new
BuildException
(
"Expression attribute is missing."
)
;
}
return
expression
;
}
public
void
setIf
(
String
ifProperty
)
{
this
.
ifProperty
=
ifProperty
;
}
public
void
setUnless
(
String
unlessProperty
)
{
this
.
unlessProperty
=
unlessProperty
;
}
public
boolean
shouldUse
(
)
{
if
(
ifProperty
!=
null
&&
project
.
getProperty
(
ifProperty
)
==
null
)
{
return
false
;
}
else
if
(
unlessProperty
!=
null
&&
project
.
getProperty
(
unlessProperty
)
!=
null
)
{
return
false
;
}
return
true
;
}
}
public
OutputProperty
createOutputProperty
(
)
{
OutputProperty
p
=
new
OutputProperty
(
)
;
outputProperties
.
addElement
(
p
)
;
return
p
;
}
public
static
class
OutputProperty
{
private
String
name
;
private
String
value
;
public
String
getName
(
)
{
return
name
;
}
public
void
setName
(
String
name
)
{
this
.
name
=
name
;
}
public
String
getValue
(
)
{
return
value
;
}
public
void
setValue
(
String
value
)
{
this
.
value
=
value
;
}
}
public
void
init
(
)
throws
BuildException
{
super
.
init
(
)
;
xmlCatalog
.
setProject
(
getProject
(
)
)
;
}
protected
void
configureLiaison
(
File
stylesheet
)
throws
BuildException
{
if
(
stylesheetLoaded
&&
reuseLoadedStylesheet
)
{
return
;
}
stylesheetLoaded
=
true
;
try
{
log
(
"Loading stylesheet "
+
stylesheet
,
Project
.
MSG_INFO
)
;
liaison
.
setStylesheet
(
stylesheet
)
;
for
(
Enumeration
e
=
params
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
Param
p
=
(
Param
)
e
.
nextElement
(
)
;
if
(
p
.
shouldUse
(
)
)
{
liaison
.
addParam
(
p
.
getName
(
)
,
p
.
getExpression
(
)
)
;
}
}
if
(
liaison
instanceof
XSLTLiaison2
)
{
(
(
XSLTLiaison2
)
liaison
)
.
configure
(
this
)
;
}
}
catch
(
Exception
ex
)
{
log
(
"Failed to transform using stylesheet "
+
stylesheet
,
Project
.
MSG_INFO
)
;
throw
new
BuildException
(
ex
)
;
}
}
public
Factory
createFactory
(
)
throws
BuildException
{
if
(
factory
!=
null
)
{
throw
new
BuildException
(
"'factory' element must be unique"
)
;
}
factory
=
new
Factory
(
)
;
return
factory
;
}
public
static
class
Factory
{
private
String
name
;
private
Vector
attributes
=
new
Vector
(
)
;
public
String
getName
(
)
{
return
name
;
}
public
void
setName
(
String
name
)
{
this
.
name
=
name
;
}
public
void
addAttribute
(
Attribute
attr
)
{
attributes
.
addElement
(
attr
)
;
}
public
Enumeration
getAttributes
(
)
{
return
attributes
.
elements
(
)
;
}
public
static
class
Attribute
implements
DynamicConfigurator
{
private
String
name
;
private
Object
value
;
public
String
getName
(
)
{
return
name
;
}
public
Object
getValue
(
)
{
return
value
;
}
public
Object
createDynamicElement
(
String
name
)
throws
BuildException
{
return
null
;
}
public
void
setDynamicAttribute
(
String
name
,
String
value
)
throws
BuildException
{
if
(
"name"
.
equalsIgnoreCase
(
name
)
)
{
this
.
name
=
value
;
}
else
if
(
"value"
.
equalsIgnoreCase
(
name
)
)
{
if
(
"true"
.
equalsIgnoreCase
(
value
)
||
"false"
.
equalsIgnoreCase
(
value
)
)
{
this
.
value
=
new
Boolean
(
value
)
;
}
else
{
try
{
this
.
value
=
new
Integer
(
value
)
;
}
catch
(
NumberFormatException
e
)
{
this
.
value
=
value
;
}
}
}
else
{
throw
new
BuildException
(
"Unsupported attribute: "
+
name
)
;
}
}
}
}
}
