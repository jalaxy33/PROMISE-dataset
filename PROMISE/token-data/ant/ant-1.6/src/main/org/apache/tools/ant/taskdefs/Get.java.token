package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
net
.
HttpURLConnection
;
import
java
.
net
.
URL
;
import
java
.
net
.
URLConnection
;
import
java
.
util
.
Date
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
import
org
.
apache
.
tools
.
ant
.
util
.
JavaEnvUtils
;
public
class
Get
extends
Task
{
private
URL
source
;
private
File
dest
;
private
boolean
verbose
=
false
;
private
boolean
useTimestamp
=
false
;
private
boolean
ignoreErrors
=
false
;
private
String
uname
=
null
;
private
String
pword
=
null
;
public
void
execute
(
)
throws
BuildException
{
if
(
source
==
null
)
{
throw
new
BuildException
(
"src attribute is required"
,
getLocation
(
)
)
;
}
if
(
dest
==
null
)
{
throw
new
BuildException
(
"dest attribute is required"
,
getLocation
(
)
)
;
}
if
(
dest
.
exists
(
)
&&
dest
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"The specified destination is a directory"
,
getLocation
(
)
)
;
}
if
(
dest
.
exists
(
)
&&
!
dest
.
canWrite
(
)
)
{
throw
new
BuildException
(
"Can't write to "
+
dest
.
getAbsolutePath
(
)
,
getLocation
(
)
)
;
}
try
{
log
(
"Getting: "
+
source
)
;
long
timestamp
=
0
;
boolean
hasTimestamp
=
false
;
if
(
useTimestamp
&&
dest
.
exists
(
)
)
{
timestamp
=
dest
.
lastModified
(
)
;
if
(
verbose
)
{
Date
t
=
new
Date
(
timestamp
)
;
log
(
"local file date : "
+
t
.
toString
(
)
)
;
}
hasTimestamp
=
true
;
}
URLConnection
connection
=
source
.
openConnection
(
)
;
if
(
useTimestamp
&&
hasTimestamp
)
{
connection
.
setIfModifiedSince
(
timestamp
)
;
}
if
(
uname
!=
null
||
pword
!=
null
)
{
String
up
=
uname
+
":"
+
pword
;
String
encoding
;
try
{
Object
encoder
=
Class
.
forName
(
"sun.misc.BASE64Encoder"
)
.
newInstance
(
)
;
encoding
=
(
String
)
encoder
.
getClass
(
)
.
getMethod
(
"encode"
,
new
Class
[
]
{
byte
[
]
.
class
}
)
.
invoke
(
encoder
,
new
Object
[
]
{
up
.
getBytes
(
)
}
)
;
}
catch
(
Exception
ex
)
{
Base64Converter
encoder
=
new
Base64Converter
(
)
;
encoding
=
encoder
.
encode
(
up
.
getBytes
(
)
)
;
}
connection
.
setRequestProperty
(
"Authorization"
,
"Basic "
+
encoding
)
;
}
connection
.
connect
(
)
;
if
(
connection
instanceof
HttpURLConnection
)
{
HttpURLConnection
httpConnection
=
(
HttpURLConnection
)
connection
;
if
(
httpConnection
.
getResponseCode
(
)
==
HttpURLConnection
.
HTTP_NOT_MODIFIED
)
{
log
(
"Not modified - so not downloaded"
)
;
return
;
}
if
(
httpConnection
.
getResponseCode
(
)
==
HttpURLConnection
.
HTTP_UNAUTHORIZED
)
{
String
message
=
"HTTP Authorization failure"
;
if
(
ignoreErrors
)
{
log
(
message
,
Project
.
MSG_WARN
)
;
return
;
}
else
{
throw
new
BuildException
(
message
)
;
}
}
}
InputStream
is
=
null
;
for
(
int
i
=
0
;
i
<
3
;
i
++
)
{
try
{
is
=
connection
.
getInputStream
(
)
;
break
;
}
catch
(
IOException
ex
)
{
log
(
"Error opening connection "
+
ex
)
;
}
}
if
(
is
==
null
)
{
log
(
"Can't get "
+
source
+
" to "
+
dest
)
;
if
(
ignoreErrors
)
{
return
;
}
throw
new
BuildException
(
"Can't get "
+
source
+
" to "
+
dest
,
getLocation
(
)
)
;
}
FileOutputStream
fos
=
new
FileOutputStream
(
dest
)
;
boolean
finished
=
false
;
try
{
byte
[
]
buffer
=
new
byte
[
100
*
1024
]
;
int
length
;
int
dots
=
0
;
while
(
(
length
=
is
.
read
(
buffer
)
)
>=
0
)
{
fos
.
write
(
buffer
,
0
,
length
)
;
if
(
verbose
)
{
System
.
out
.
print
(
"."
)
;
if
(
dots
++
>
50
)
{
System
.
out
.
flush
(
)
;
dots
=
0
;
}
}
}
if
(
verbose
)
{
System
.
out
.
println
(
)
;
}
finished
=
true
;
}
finally
{
if
(
fos
!=
null
)
{
fos
.
close
(
)
;
}
is
.
close
(
)
;
if
(
!
finished
)
{
dest
.
delete
(
)
;
}
}
if
(
useTimestamp
)
{
long
remoteTimestamp
=
connection
.
getLastModified
(
)
;
if
(
verbose
)
{
Date
t
=
new
Date
(
remoteTimestamp
)
;
log
(
"last modified = "
+
t
.
toString
(
)
+
(
(
remoteTimestamp
==
0
)
?
" - using current time instead"
:
""
)
)
;
}
if
(
remoteTimestamp
!=
0
)
{
FileUtils
.
newFileUtils
(
)
.
setFileLastModified
(
dest
,
remoteTimestamp
)
;
}
}
}
catch
(
IOException
ioe
)
{
log
(
"Error getting "
+
source
+
" to "
+
dest
)
;
if
(
ignoreErrors
)
{
return
;
}
throw
new
BuildException
(
ioe
,
getLocation
(
)
)
;
}
}
public
void
setSrc
(
URL
u
)
{
this
.
source
=
u
;
}
public
void
setDest
(
File
dest
)
{
this
.
dest
=
dest
;
}
public
void
setVerbose
(
boolean
v
)
{
verbose
=
v
;
}
public
void
setIgnoreErrors
(
boolean
v
)
{
ignoreErrors
=
v
;
}
public
void
setUseTimestamp
(
boolean
v
)
{
if
(
!
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_1
)
)
{
useTimestamp
=
v
;
}
}
public
void
setUsername
(
String
u
)
{
this
.
uname
=
u
;
}
public
void
setPassword
(
String
p
)
{
this
.
pword
=
p
;
}
private
static
class
Base64Converter
{
public
final
char
[
]
alphabet
=
{
'A'
,
'B'
,
'C'
,
'D'
,
'E'
,
'F'
,
'G'
,
'H'
,
'I'
,
'J'
,
'K'
,
'L'
,
'M'
,
'N'
,
'O'
,
'P'
,
'Q'
,
'R'
,
'S'
,
'T'
,
'U'
,
'V'
,
'W'
,
'X'
,
'Y'
,
'Z'
,
'a'
,
'b'
,
'c'
,
'd'
,
'e'
,
'f'
,
'g'
,
'h'
,
'i'
,
'j'
,
'k'
,
'l'
,
'm'
,
'n'
,
'o'
,
'p'
,
'q'
,
'r'
,
's'
,
't'
,
'u'
,
'v'
,
'w'
,
'x'
,
'y'
,
'z'
,
'0'
,
'1'
,
'2'
,
'3'
,
'4'
,
'5'
,
'6'
,
'7'
,
'8'
,
'9'
,
'+'
,
'/'
}
;
public
String
encode
(
String
s
)
{
return
encode
(
s
.
getBytes
(
)
)
;
}
public
String
encode
(
byte
[
]
octetString
)
{
int
bits24
;
int
bits6
;
char
[
]
out
=
new
char
[
(
(
octetString
.
length
-
1
)
/
3
+
1
)
*
4
]
;
int
outIndex
=
0
;
int
i
=
0
;
while
(
(
i
+
3
)
<=
octetString
.
length
)
{
bits24
=
(
octetString
[
i
++
]
&
0xFF
)
<<
16
;
bits24
|=
(
octetString
[
i
++
]
&
0xFF
)
<<
8
;
bits6
=
(
bits24
&
0x00FC0000
)
>
>
18
;
out
[
outIndex
++
]
=
alphabet
[
bits6
]
;
bits6
=
(
bits24
&
0x0003F000
)
>
>
12
;
out
[
outIndex
++
]
=
alphabet
[
bits6
]
;
bits6
=
(
bits24
&
0x00000FC0
)
>
>
6
;
out
[
outIndex
++
]
=
alphabet
[
bits6
]
;
bits6
=
(
bits24
&
0x0000003F
)
;
out
[
outIndex
++
]
=
alphabet
[
bits6
]
;
}
if
(
octetString
.
length
-
i
==
2
)
{
bits24
=
(
octetString
[
i
]
&
0xFF
)
<<
16
;
bits24
|=
(
octetString
[
i
+
1
]
&
0xFF
)
<<
8
;
bits6
=
(
bits24
&
0x00FC0000
)
>
>
18
;
out
[
outIndex
++
]
=
alphabet
[
bits6
]
;
bits6
=
(
bits24
&
0x0003F000
)
>
>
12
;
out
[
outIndex
++
]
=
alphabet
[
bits6
]
;
bits6
=
(
bits24
&
0x00000FC0
)
>
>
6
;
out
[
outIndex
++
]
=
alphabet
[
bits6
]
;
out
[
outIndex
++
]
=
'='
;
}
else
if
(
octetString
.
length
-
i
==
1
)
{
bits24
=
(
octetString
[
i
]
&
0xFF
)
<<
16
;
bits6
=
(
bits24
&
0x00FC0000
)
>
>
18
;
out
[
outIndex
++
]
=
alphabet
[
bits6
]
;
bits6
=
(
bits24
&
0x0003F000
)
>
>
12
;
out
[
outIndex
++
]
=
alphabet
[
bits6
]
;
out
[
outIndex
++
]
=
'='
;
out
[
outIndex
++
]
=
'='
;
}
return
new
String
(
out
)
;
}
}
}
