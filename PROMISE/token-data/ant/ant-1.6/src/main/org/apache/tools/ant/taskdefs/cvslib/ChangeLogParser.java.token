package
org
.
apache
.
tools
.
ant
.
taskdefs
.
cvslib
;
import
java
.
text
.
ParseException
;
import
java
.
text
.
SimpleDateFormat
;
import
java
.
util
.
Date
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
TimeZone
;
class
ChangeLogParser
{
private
static
final
int
GET_FILE
=
1
;
private
static
final
int
GET_DATE
=
2
;
private
static
final
int
GET_COMMENT
=
3
;
private
static
final
int
GET_REVISION
=
4
;
private
static
final
int
GET_PREVIOUS_REV
=
5
;
private
static
final
SimpleDateFormat
c_inputDate
=
new
SimpleDateFormat
(
"yyyy/MM/dd HH:mm:ss"
)
;
static
{
TimeZone
utc
=
TimeZone
.
getTimeZone
(
"UTC"
)
;
c_inputDate
.
setTimeZone
(
utc
)
;
}
private
String
m_file
;
private
String
m_date
;
private
String
m_author
;
private
String
m_comment
;
private
String
m_revision
;
private
String
m_previousRevision
;
private
int
m_status
=
GET_FILE
;
private
final
Hashtable
m_entries
=
new
Hashtable
(
)
;
CVSEntry
[
]
getEntrySetAsArray
(
)
{
final
CVSEntry
[
]
array
=
new
CVSEntry
[
m_entries
.
size
(
)
]
;
Enumeration
e
=
m_entries
.
elements
(
)
;
int
i
=
0
;
while
(
e
.
hasMoreElements
(
)
)
{
array
[
i
++
]
=
(
CVSEntry
)
e
.
nextElement
(
)
;
}
return
array
;
}
public
void
stdout
(
final
String
line
)
{
switch
(
m_status
)
{
case
GET_FILE
:
reset
(
)
;
processFile
(
line
)
;
break
;
case
GET_REVISION
:
processRevision
(
line
)
;
break
;
case
GET_DATE
:
processDate
(
line
)
;
break
;
case
GET_COMMENT
:
processComment
(
line
)
;
break
;
case
GET_PREVIOUS_REV
:
processGetPreviousRevision
(
line
)
;
break
;
}
}
private
void
processComment
(
final
String
line
)
{
final
String
lineSeparator
=
System
.
getProperty
(
"line.separator"
)
;
if
(
line
.
startsWith
(
"======"
)
)
{
final
int
end
=
m_comment
.
length
(
)
-
lineSeparator
.
length
(
)
;
m_comment
=
m_comment
.
substring
(
0
,
end
)
;
saveEntry
(
)
;
m_status
=
GET_FILE
;
}
else
if
(
line
.
startsWith
(
"----------------------------"
)
)
{
final
int
end
=
m_comment
.
length
(
)
-
lineSeparator
.
length
(
)
;
m_comment
=
m_comment
.
substring
(
0
,
end
)
;
m_status
=
GET_PREVIOUS_REV
;
}
else
{
m_comment
+=
line
+
lineSeparator
;
}
}
private
void
processFile
(
final
String
line
)
{
if
(
line
.
startsWith
(
"Working file:"
)
)
{
m_file
=
line
.
substring
(
14
,
line
.
length
(
)
)
;
m_status
=
GET_REVISION
;
}
}
private
void
processRevision
(
final
String
line
)
{
if
(
line
.
startsWith
(
"revision"
)
)
{
m_revision
=
line
.
substring
(
9
)
;
m_status
=
GET_DATE
;
}
else
if
(
line
.
startsWith
(
"======"
)
)
{
m_status
=
GET_FILE
;
}
}
private
void
processDate
(
final
String
line
)
{
if
(
line
.
startsWith
(
"date:"
)
)
{
m_date
=
line
.
substring
(
6
,
25
)
;
String
lineData
=
line
.
substring
(
line
.
indexOf
(
";"
)
+
1
)
;
m_author
=
lineData
.
substring
(
10
,
lineData
.
indexOf
(
";"
)
)
;
m_status
=
GET_COMMENT
;
m_comment
=
""
;
}
}
private
void
processGetPreviousRevision
(
final
String
line
)
{
if
(
!
line
.
startsWith
(
"revision"
)
)
{
throw
new
IllegalStateException
(
"Unexpected line from CVS: "
+
line
)
;
}
m_previousRevision
=
line
.
substring
(
9
)
;
saveEntry
(
)
;
m_revision
=
m_previousRevision
;
m_status
=
GET_DATE
;
}
private
void
saveEntry
(
)
{
final
String
entryKey
=
m_date
+
m_author
+
m_comment
;
CVSEntry
entry
;
if
(
!
m_entries
.
containsKey
(
entryKey
)
)
{
entry
=
new
CVSEntry
(
parseDate
(
m_date
)
,
m_author
,
m_comment
)
;
m_entries
.
put
(
entryKey
,
entry
)
;
}
else
{
entry
=
(
CVSEntry
)
m_entries
.
get
(
entryKey
)
;
}
entry
.
addFile
(
m_file
,
m_revision
,
m_previousRevision
)
;
}
private
Date
parseDate
(
final
String
date
)
{
try
{
return
c_inputDate
.
parse
(
date
)
;
}
catch
(
ParseException
e
)
{
return
null
;
}
}
private
void
reset
(
)
{
m_file
=
null
;
m_date
=
null
;
m_author
=
null
;
m_comment
=
null
;
m_revision
=
null
;
m_previousRevision
=
null
;
}
}
