package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
PrintWriter
;
import
java
.
io
.
Reader
;
import
java
.
io
.
StringWriter
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
util
.
CollectionUtils
;
public
class
Manifest
{
public
static
final
String
ATTRIBUTE_MANIFEST_VERSION
=
"Manifest-Version"
;
public
static
final
String
ATTRIBUTE_SIGNATURE_VERSION
=
"Signature-Version"
;
public
static
final
String
ATTRIBUTE_NAME
=
"Name"
;
public
static
final
String
ATTRIBUTE_FROM
=
"From"
;
public
static
final
String
ATTRIBUTE_CLASSPATH
=
"Class-Path"
;
public
static
final
String
DEFAULT_MANIFEST_VERSION
=
"1.0"
;
public
static
final
int
MAX_LINE_LENGTH
=
72
;
public
static
final
int
MAX_SECTION_LENGTH
=
MAX_LINE_LENGTH
-
2
;
public
static
final
String
EOL
=
"\r\n"
;
public
static
class
Attribute
{
private
String
name
=
null
;
private
Vector
values
=
new
Vector
(
)
;
private
int
currentIndex
=
0
;
public
Attribute
(
)
{
}
public
Attribute
(
String
line
)
throws
ManifestException
{
parse
(
line
)
;
}
public
Attribute
(
String
name
,
String
value
)
{
this
.
name
=
name
;
setValue
(
value
)
;
}
public
int
hashCode
(
)
{
int
hashCode
=
0
;
if
(
name
!=
null
)
{
hashCode
+=
name
.
hashCode
(
)
;
}
hashCode
+=
values
.
hashCode
(
)
;
return
hashCode
;
}
public
boolean
equals
(
Object
rhs
)
{
if
(
rhs
==
null
||
rhs
.
getClass
(
)
!=
getClass
(
)
)
{
return
false
;
}
if
(
rhs
==
this
)
{
return
true
;
}
Attribute
rhsAttribute
=
(
Attribute
)
rhs
;
String
lhsKey
=
getKey
(
)
;
String
rhsKey
=
rhsAttribute
.
getKey
(
)
;
if
(
(
lhsKey
==
null
&&
rhsKey
!=
null
)
||
(
lhsKey
!=
null
&&
rhsKey
==
null
)
||
!
lhsKey
.
equals
(
rhsKey
)
)
{
return
false
;
}
return
CollectionUtils
.
equals
(
values
,
rhsAttribute
.
values
)
;
}
public
void
parse
(
String
line
)
throws
ManifestException
{
int
index
=
line
.
indexOf
(
": "
)
;
if
(
index
==
-
1
)
{
throw
new
ManifestException
(
"Manifest line \""
+
line
+
"\" is not valid as it does not "
+
"contain a name and a value separated by ': ' "
)
;
}
name
=
line
.
substring
(
0
,
index
)
;
setValue
(
line
.
substring
(
index
+
2
)
)
;
}
public
void
setName
(
String
name
)
{
this
.
name
=
name
;
}
public
String
getName
(
)
{
return
name
;
}
public
String
getKey
(
)
{
if
(
name
==
null
)
{
return
null
;
}
return
name
.
toLowerCase
(
)
;
}
public
void
setValue
(
String
value
)
{
if
(
currentIndex
>=
values
.
size
(
)
)
{
values
.
addElement
(
value
)
;
currentIndex
=
values
.
size
(
)
-
1
;
}
else
{
values
.
setElementAt
(
value
,
currentIndex
)
;
}
}
public
String
getValue
(
)
{
if
(
values
.
size
(
)
==
0
)
{
return
null
;
}
String
fullValue
=
""
;
for
(
Enumeration
e
=
getValues
(
)
;
e
.
hasMoreElements
(
)
;
)
{
String
value
=
(
String
)
e
.
nextElement
(
)
;
fullValue
+=
value
+
" "
;
}
return
fullValue
.
trim
(
)
;
}
public
void
addValue
(
String
value
)
{
currentIndex
++
;
setValue
(
value
)
;
}
public
Enumeration
getValues
(
)
{
return
values
.
elements
(
)
;
}
public
void
addContinuation
(
String
line
)
{
String
currentValue
=
(
String
)
values
.
elementAt
(
currentIndex
)
;
setValue
(
currentValue
+
line
.
substring
(
1
)
)
;
}
public
void
write
(
PrintWriter
writer
)
throws
IOException
{
for
(
Enumeration
e
=
getValues
(
)
;
e
.
hasMoreElements
(
)
;
)
{
writeValue
(
writer
,
(
String
)
e
.
nextElement
(
)
)
;
}
}
private
void
writeValue
(
PrintWriter
writer
,
String
value
)
throws
IOException
{
String
line
=
name
+
": "
+
value
;
while
(
line
.
getBytes
(
)
.
length
>
MAX_LINE_LENGTH
)
{
int
breakIndex
=
MAX_SECTION_LENGTH
;
String
section
=
line
.
substring
(
0
,
breakIndex
)
;
while
(
section
.
getBytes
(
)
.
length
>
MAX_SECTION_LENGTH
&&
breakIndex
>
0
)
{
breakIndex
--
;
section
=
line
.
substring
(
0
,
breakIndex
)
;
}
if
(
breakIndex
==
0
)
{
throw
new
IOException
(
"Unable to write manifest line "
+
name
+
": "
+
value
)
;
}
writer
.
print
(
section
+
EOL
)
;
line
=
" "
+
line
.
substring
(
breakIndex
)
;
}
writer
.
print
(
line
+
EOL
)
;
}
}
public
static
class
Section
{
private
Vector
warnings
=
new
Vector
(
)
;
private
String
name
=
null
;
private
Hashtable
attributes
=
new
Hashtable
(
)
;
private
Vector
attributeIndex
=
new
Vector
(
)
;
public
void
setName
(
String
name
)
{
this
.
name
=
name
;
}
public
String
getName
(
)
{
return
name
;
}
public
String
read
(
BufferedReader
reader
)
throws
ManifestException
,
IOException
{
Attribute
attribute
=
null
;
while
(
true
)
{
String
line
=
reader
.
readLine
(
)
;
if
(
line
==
null
||
line
.
length
(
)
==
0
)
{
return
null
;
}
if
(
line
.
charAt
(
0
)
==
' '
)
{
if
(
attribute
==
null
)
{
if
(
name
!=
null
)
{
name
+=
line
.
substring
(
1
)
;
}
else
{
throw
new
ManifestException
(
"Can't start an "
+
"attribute with a continuation line "
+
line
)
;
}
}
else
{
attribute
.
addContinuation
(
line
)
;
}
}
else
{
attribute
=
new
Attribute
(
line
)
;
String
nameReadAhead
=
addAttributeAndCheck
(
attribute
)
;
attribute
=
getAttribute
(
attribute
.
getKey
(
)
)
;
if
(
nameReadAhead
!=
null
)
{
return
nameReadAhead
;
}
}
}
}
public
void
merge
(
Section
section
)
throws
ManifestException
{
if
(
name
==
null
&&
section
.
getName
(
)
!=
null
||
name
!=
null
&&
!
(
name
.
equalsIgnoreCase
(
section
.
getName
(
)
)
)
)
{
throw
new
ManifestException
(
"Unable to merge sections "
+
"with different names"
)
;
}
Enumeration
e
=
section
.
getAttributeKeys
(
)
;
Attribute
classpathAttribute
=
null
;
while
(
e
.
hasMoreElements
(
)
)
{
String
attributeName
=
(
String
)
e
.
nextElement
(
)
;
Attribute
attribute
=
section
.
getAttribute
(
attributeName
)
;
if
(
attributeName
.
equalsIgnoreCase
(
ATTRIBUTE_CLASSPATH
)
)
{
if
(
classpathAttribute
==
null
)
{
classpathAttribute
=
new
Attribute
(
)
;
classpathAttribute
.
setName
(
ATTRIBUTE_CLASSPATH
)
;
}
Enumeration
cpe
=
attribute
.
getValues
(
)
;
while
(
cpe
.
hasMoreElements
(
)
)
{
String
value
=
(
String
)
cpe
.
nextElement
(
)
;
classpathAttribute
.
addValue
(
value
)
;
}
}
else
{
storeAttribute
(
attribute
)
;
}
}
if
(
classpathAttribute
!=
null
)
{
storeAttribute
(
classpathAttribute
)
;
}
Enumeration
warnEnum
=
section
.
warnings
.
elements
(
)
;
while
(
warnEnum
.
hasMoreElements
(
)
)
{
warnings
.
addElement
(
warnEnum
.
nextElement
(
)
)
;
}
}
public
void
write
(
PrintWriter
writer
)
throws
IOException
{
if
(
name
!=
null
)
{
Attribute
nameAttr
=
new
Attribute
(
ATTRIBUTE_NAME
,
name
)
;
nameAttr
.
write
(
writer
)
;
}
Enumeration
e
=
getAttributeKeys
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
String
key
=
(
String
)
e
.
nextElement
(
)
;
Attribute
attribute
=
getAttribute
(
key
)
;
attribute
.
write
(
writer
)
;
}
writer
.
print
(
EOL
)
;
}
public
Attribute
getAttribute
(
String
attributeName
)
{
return
(
Attribute
)
attributes
.
get
(
attributeName
.
toLowerCase
(
)
)
;
}
public
Enumeration
getAttributeKeys
(
)
{
return
attributeIndex
.
elements
(
)
;
}
public
String
getAttributeValue
(
String
attributeName
)
{
Attribute
attribute
=
getAttribute
(
attributeName
.
toLowerCase
(
)
)
;
if
(
attribute
==
null
)
{
return
null
;
}
return
attribute
.
getValue
(
)
;
}
public
void
removeAttribute
(
String
attributeName
)
{
String
key
=
attributeName
.
toLowerCase
(
)
;
attributes
.
remove
(
key
)
;
attributeIndex
.
removeElement
(
key
)
;
}
public
void
addConfiguredAttribute
(
Attribute
attribute
)
throws
ManifestException
{
String
check
=
addAttributeAndCheck
(
attribute
)
;
if
(
check
!=
null
)
{
throw
new
BuildException
(
"Specify the section name using "
+
"the \"name\" attribute of the <section> element rather "
+
"than using a \"Name\" manifest attribute"
)
;
}
}
public
String
addAttributeAndCheck
(
Attribute
attribute
)
throws
ManifestException
{
if
(
attribute
.
getName
(
)
==
null
||
attribute
.
getValue
(
)
==
null
)
{
throw
new
BuildException
(
"Attributes must have name and value"
)
;
}
if
(
attribute
.
getKey
(
)
.
equalsIgnoreCase
(
ATTRIBUTE_NAME
)
)
{
warnings
.
addElement
(
"\""
+
ATTRIBUTE_NAME
+
"\" attributes "
+
"should not occur in the main section and must be the "
+
"first element in all other sections: \""
+
attribute
.
getName
(
)
+
": "
+
attribute
.
getValue
(
)
+
"\""
)
;
return
attribute
.
getValue
(
)
;
}
if
(
attribute
.
getKey
(
)
.
startsWith
(
ATTRIBUTE_FROM
.
toLowerCase
(
)
)
)
{
warnings
.
addElement
(
"Manifest attributes should not start "
+
"with \""
+
ATTRIBUTE_FROM
+
"\" in \""
+
attribute
.
getName
(
)
+
": "
+
attribute
.
getValue
(
)
+
"\""
)
;
}
else
{
String
attributeKey
=
attribute
.
getKey
(
)
;
if
(
attributeKey
.
equalsIgnoreCase
(
ATTRIBUTE_CLASSPATH
)
)
{
Attribute
classpathAttribute
=
(
Attribute
)
attributes
.
get
(
attributeKey
)
;
if
(
classpathAttribute
==
null
)
{
storeAttribute
(
attribute
)
;
}
else
{
warnings
.
addElement
(
"Multiple Class-Path attributes "
+
"are supported but violate the Jar "
+
"specification and may not be correctly "
+
"processed in all environments"
)
;
Enumeration
e
=
attribute
.
getValues
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
String
value
=
(
String
)
e
.
nextElement
(
)
;
classpathAttribute
.
addValue
(
value
)
;
}
}
}
else
if
(
attributes
.
containsKey
(
attributeKey
)
)
{
throw
new
ManifestException
(
"The attribute \""
+
attribute
.
getName
(
)
+
"\" may not occur more "
+
"than once in the same section"
)
;
}
else
{
storeAttribute
(
attribute
)
;
}
}
return
null
;
}
public
Object
clone
(
)
{
Section
cloned
=
new
Section
(
)
;
cloned
.
setName
(
name
)
;
Enumeration
e
=
getAttributeKeys
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
String
key
=
(
String
)
e
.
nextElement
(
)
;
Attribute
attribute
=
getAttribute
(
key
)
;
cloned
.
storeAttribute
(
new
Attribute
(
attribute
.
getName
(
)
,
attribute
.
getValue
(
)
)
)
;
}
return
cloned
;
}
private
void
storeAttribute
(
Attribute
attribute
)
{
if
(
attribute
==
null
)
{
return
;
}
String
attributeKey
=
attribute
.
getKey
(
)
;
attributes
.
put
(
attributeKey
,
attribute
)
;
if
(
!
attributeIndex
.
contains
(
attributeKey
)
)
{
attributeIndex
.
addElement
(
attributeKey
)
;
}
}
public
Enumeration
getWarnings
(
)
{
return
warnings
.
elements
(
)
;
}
public
int
hashCode
(
)
{
int
hashCode
=
0
;
if
(
name
!=
null
)
{
hashCode
+=
name
.
hashCode
(
)
;
}
hashCode
+=
attributes
.
hashCode
(
)
;
return
hashCode
;
}
public
boolean
equals
(
Object
rhs
)
{
if
(
rhs
==
null
||
rhs
.
getClass
(
)
!=
getClass
(
)
)
{
return
false
;
}
if
(
rhs
==
this
)
{
return
true
;
}
Section
rhsSection
=
(
Section
)
rhs
;
return
CollectionUtils
.
equals
(
attributes
,
rhsSection
.
attributes
)
;
}
}
private
String
manifestVersion
=
DEFAULT_MANIFEST_VERSION
;
private
Section
mainSection
=
new
Section
(
)
;
private
Hashtable
sections
=
new
Hashtable
(
)
;
private
Vector
sectionIndex
=
new
Vector
(
)
;
public
static
Manifest
getDefaultManifest
(
)
throws
BuildException
{
try
{
String
defManifest
=
"/org/apache/tools/ant/defaultManifest.mf"
;
InputStream
in
=
Manifest
.
class
.
getResourceAsStream
(
defManifest
)
;
if
(
in
==
null
)
{
throw
new
BuildException
(
"Could not find default manifest: "
+
defManifest
)
;
}
try
{
Manifest
defaultManifest
=
new
Manifest
(
new
InputStreamReader
(
in
,
"UTF-8"
)
)
;
Attribute
createdBy
=
new
Attribute
(
"Created-By"
,
System
.
getProperty
(
"java.vm.version"
)
+
" ("
+
System
.
getProperty
(
"java.vm.vendor"
)
+
")"
)
;
defaultManifest
.
getMainSection
(
)
.
storeAttribute
(
createdBy
)
;
return
defaultManifest
;
}
catch
(
UnsupportedEncodingException
e
)
{
return
new
Manifest
(
new
InputStreamReader
(
in
)
)
;
}
}
catch
(
ManifestException
e
)
{
throw
new
BuildException
(
"Default manifest is invalid !!"
,
e
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
"Unable to read default manifest"
,
e
)
;
}
}
public
Manifest
(
)
{
manifestVersion
=
null
;
}
public
Manifest
(
Reader
r
)
throws
ManifestException
,
IOException
{
BufferedReader
reader
=
new
BufferedReader
(
r
)
;
String
nextSectionName
=
mainSection
.
read
(
reader
)
;
String
readManifestVersion
=
mainSection
.
getAttributeValue
(
ATTRIBUTE_MANIFEST_VERSION
)
;
if
(
readManifestVersion
!=
null
)
{
manifestVersion
=
readManifestVersion
;
mainSection
.
removeAttribute
(
ATTRIBUTE_MANIFEST_VERSION
)
;
}
String
line
=
null
;
while
(
(
line
=
reader
.
readLine
(
)
)
!=
null
)
{
if
(
line
.
length
(
)
==
0
)
{
continue
;
}
Section
section
=
new
Section
(
)
;
if
(
nextSectionName
==
null
)
{
Attribute
sectionName
=
new
Attribute
(
line
)
;
if
(
!
sectionName
.
getName
(
)
.
equalsIgnoreCase
(
ATTRIBUTE_NAME
)
)
{
throw
new
ManifestException
(
"Manifest sections should "
+
"start with a \""
+
ATTRIBUTE_NAME
+
"\" attribute and not \""
+
sectionName
.
getName
(
)
+
"\""
)
;
}
nextSectionName
=
sectionName
.
getValue
(
)
;
}
else
{
Attribute
firstAttribute
=
new
Attribute
(
line
)
;
section
.
addAttributeAndCheck
(
firstAttribute
)
;
}
section
.
setName
(
nextSectionName
)
;
nextSectionName
=
section
.
read
(
reader
)
;
addConfiguredSection
(
section
)
;
}
}
public
void
addConfiguredSection
(
Section
section
)
throws
ManifestException
{
String
sectionName
=
section
.
getName
(
)
;
if
(
sectionName
==
null
)
{
throw
new
BuildException
(
"Sections must have a name"
)
;
}
sections
.
put
(
sectionName
,
section
)
;
if
(
!
sectionIndex
.
contains
(
sectionName
)
)
{
sectionIndex
.
addElement
(
sectionName
)
;
}
}
public
void
addConfiguredAttribute
(
Attribute
attribute
)
throws
ManifestException
{
if
(
attribute
.
getKey
(
)
==
null
||
attribute
.
getValue
(
)
==
null
)
{
throw
new
BuildException
(
"Attributes must have name and value"
)
;
}
if
(
attribute
.
getKey
(
)
.
equalsIgnoreCase
(
ATTRIBUTE_MANIFEST_VERSION
)
)
{
manifestVersion
=
attribute
.
getValue
(
)
;
}
else
{
mainSection
.
addConfiguredAttribute
(
attribute
)
;
}
}
public
void
merge
(
Manifest
other
)
throws
ManifestException
{
merge
(
other
,
false
)
;
}
public
void
merge
(
Manifest
other
,
boolean
overwriteMain
)
throws
ManifestException
{
if
(
other
!=
null
)
{
if
(
overwriteMain
)
{
mainSection
=
(
Section
)
other
.
mainSection
.
clone
(
)
;
}
else
{
mainSection
.
merge
(
other
.
mainSection
)
;
}
if
(
other
.
manifestVersion
!=
null
)
{
manifestVersion
=
other
.
manifestVersion
;
}
Enumeration
e
=
other
.
getSectionNames
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
String
sectionName
=
(
String
)
e
.
nextElement
(
)
;
Section
ourSection
=
(
Section
)
sections
.
get
(
sectionName
)
;
Section
otherSection
=
(
Section
)
other
.
sections
.
get
(
sectionName
)
;
if
(
ourSection
==
null
)
{
if
(
otherSection
!=
null
)
{
addConfiguredSection
(
(
Section
)
otherSection
.
clone
(
)
)
;
}
}
else
{
ourSection
.
merge
(
otherSection
)
;
}
}
}
}
public
void
write
(
PrintWriter
writer
)
throws
IOException
{
writer
.
print
(
ATTRIBUTE_MANIFEST_VERSION
+
": "
+
manifestVersion
+
EOL
)
;
String
signatureVersion
=
mainSection
.
getAttributeValue
(
ATTRIBUTE_SIGNATURE_VERSION
)
;
if
(
signatureVersion
!=
null
)
{
writer
.
print
(
ATTRIBUTE_SIGNATURE_VERSION
+
": "
+
signatureVersion
+
EOL
)
;
mainSection
.
removeAttribute
(
ATTRIBUTE_SIGNATURE_VERSION
)
;
}
mainSection
.
write
(
writer
)
;
if
(
signatureVersion
!=
null
)
{
try
{
Attribute
svAttr
=
new
Attribute
(
ATTRIBUTE_SIGNATURE_VERSION
,
signatureVersion
)
;
mainSection
.
addConfiguredAttribute
(
svAttr
)
;
}
catch
(
ManifestException
e
)
{
}
}
Enumeration
e
=
sectionIndex
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
String
sectionName
=
(
String
)
e
.
nextElement
(
)
;
Section
section
=
getSection
(
sectionName
)
;
section
.
write
(
writer
)
;
}
}
public
String
toString
(
)
{
StringWriter
sw
=
new
StringWriter
(
)
;
try
{
write
(
new
PrintWriter
(
sw
)
)
;
}
catch
(
IOException
e
)
{
return
null
;
}
return
sw
.
toString
(
)
;
}
public
Enumeration
getWarnings
(
)
{
Vector
warnings
=
new
Vector
(
)
;
Enumeration
warnEnum
=
mainSection
.
getWarnings
(
)
;
while
(
warnEnum
.
hasMoreElements
(
)
)
{
warnings
.
addElement
(
warnEnum
.
nextElement
(
)
)
;
}
Enumeration
e
=
sections
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
Section
section
=
(
Section
)
e
.
nextElement
(
)
;
Enumeration
e2
=
section
.
getWarnings
(
)
;
while
(
e2
.
hasMoreElements
(
)
)
{
warnings
.
addElement
(
e2
.
nextElement
(
)
)
;
}
}
return
warnings
.
elements
(
)
;
}
public
int
hashCode
(
)
{
int
hashCode
=
0
;
if
(
manifestVersion
!=
null
)
{
hashCode
+=
manifestVersion
.
hashCode
(
)
;
}
hashCode
+=
mainSection
.
hashCode
(
)
;
hashCode
+=
sections
.
hashCode
(
)
;
return
hashCode
;
}
public
boolean
equals
(
Object
rhs
)
{
if
(
rhs
==
null
||
rhs
.
getClass
(
)
!=
getClass
(
)
)
{
return
false
;
}
if
(
rhs
==
this
)
{
return
true
;
}
Manifest
rhsManifest
=
(
Manifest
)
rhs
;
if
(
manifestVersion
==
null
)
{
if
(
rhsManifest
.
manifestVersion
!=
null
)
{
return
false
;
}
}
else
if
(
!
manifestVersion
.
equals
(
rhsManifest
.
manifestVersion
)
)
{
return
false
;
}
if
(
!
mainSection
.
equals
(
rhsManifest
.
mainSection
)
)
{
return
false
;
}
return
CollectionUtils
.
equals
(
sections
,
rhsManifest
.
sections
)
;
}
public
String
getManifestVersion
(
)
{
return
manifestVersion
;
}
public
Section
getMainSection
(
)
{
return
mainSection
;
}
public
Section
getSection
(
String
name
)
{
return
(
Section
)
sections
.
get
(
name
)
;
}
public
Enumeration
getSectionNames
(
)
{
return
sectionIndex
.
elements
(
)
;
}
}
