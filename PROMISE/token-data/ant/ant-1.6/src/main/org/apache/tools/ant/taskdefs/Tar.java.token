package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
BufferedOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStream
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Vector
;
import
java
.
util
.
zip
.
GZIPOutputStream
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
types
.
EnumeratedAttribute
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
org
.
apache
.
tools
.
ant
.
util
.
MergingMapper
;
import
org
.
apache
.
tools
.
ant
.
util
.
SourceFileScanner
;
import
org
.
apache
.
tools
.
bzip2
.
CBZip2OutputStream
;
import
org
.
apache
.
tools
.
tar
.
TarConstants
;
import
org
.
apache
.
tools
.
tar
.
TarEntry
;
import
org
.
apache
.
tools
.
tar
.
TarOutputStream
;
import
org
.
apache
.
tools
.
zip
.
UnixStat
;
public
class
Tar
extends
MatchingTask
{
public
static
final
String
WARN
=
"warn"
;
public
static
final
String
FAIL
=
"fail"
;
public
static
final
String
TRUNCATE
=
"truncate"
;
public
static
final
String
GNU
=
"gnu"
;
public
static
final
String
OMIT
=
"omit"
;
File
tarFile
;
File
baseDir
;
private
TarLongFileMode
longFileMode
=
new
TarLongFileMode
(
)
;
Vector
filesets
=
new
Vector
(
)
;
Vector
fileSetFiles
=
new
Vector
(
)
;
private
boolean
longWarningGiven
=
false
;
private
TarCompressionMethod
compression
=
new
TarCompressionMethod
(
)
;
public
TarFileSet
createTarFileSet
(
)
{
TarFileSet
fileset
=
new
TarFileSet
(
)
;
filesets
.
addElement
(
fileset
)
;
return
fileset
;
}
public
void
setTarfile
(
File
tarFile
)
{
this
.
tarFile
=
tarFile
;
}
public
void
setDestFile
(
File
destFile
)
{
this
.
tarFile
=
destFile
;
}
public
void
setBasedir
(
File
baseDir
)
{
this
.
baseDir
=
baseDir
;
}
public
void
setLongfile
(
String
mode
)
{
log
(
"DEPRECATED - The setLongfile(String) method has been deprecated."
+
" Use setLongfile(Tar.TarLongFileMode) instead."
)
;
this
.
longFileMode
=
new
TarLongFileMode
(
)
;
longFileMode
.
setValue
(
mode
)
;
}
public
void
setLongfile
(
TarLongFileMode
mode
)
{
this
.
longFileMode
=
mode
;
}
public
void
setCompression
(
TarCompressionMethod
mode
)
{
this
.
compression
=
mode
;
}
public
void
execute
(
)
throws
BuildException
{
if
(
tarFile
==
null
)
{
throw
new
BuildException
(
"tarfile attribute must be set!"
,
getLocation
(
)
)
;
}
if
(
tarFile
.
exists
(
)
&&
tarFile
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"tarfile is a directory!"
,
getLocation
(
)
)
;
}
if
(
tarFile
.
exists
(
)
&&
!
tarFile
.
canWrite
(
)
)
{
throw
new
BuildException
(
"Can not write to the specified tarfile!"
,
getLocation
(
)
)
;
}
Vector
savedFileSets
=
(
Vector
)
filesets
.
clone
(
)
;
try
{
if
(
baseDir
!=
null
)
{
if
(
!
baseDir
.
exists
(
)
)
{
throw
new
BuildException
(
"basedir does not exist!"
,
getLocation
(
)
)
;
}
TarFileSet
mainFileSet
=
new
TarFileSet
(
fileset
)
;
mainFileSet
.
setDir
(
baseDir
)
;
filesets
.
addElement
(
mainFileSet
)
;
}
if
(
filesets
.
size
(
)
==
0
)
{
throw
new
BuildException
(
"You must supply either a basedir "
+
"attribute or some nested filesets."
,
getLocation
(
)
)
;
}
boolean
upToDate
=
true
;
for
(
Enumeration
e
=
filesets
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
TarFileSet
fs
=
(
TarFileSet
)
e
.
nextElement
(
)
;
String
[
]
files
=
fs
.
getFiles
(
getProject
(
)
)
;
if
(
!
archiveIsUpToDate
(
files
,
fs
.
getDir
(
getProject
(
)
)
)
)
{
upToDate
=
false
;
}
for
(
int
i
=
0
;
i
<
files
.
length
;
++
i
)
{
if
(
tarFile
.
equals
(
new
File
(
fs
.
getDir
(
getProject
(
)
)
,
files
[
i
]
)
)
)
{
throw
new
BuildException
(
"A tar file cannot include "
+
"itself"
,
getLocation
(
)
)
;
}
}
}
if
(
upToDate
)
{
log
(
"Nothing to do: "
+
tarFile
.
getAbsolutePath
(
)
+
" is up to date."
,
Project
.
MSG_INFO
)
;
return
;
}
log
(
"Building tar: "
+
tarFile
.
getAbsolutePath
(
)
,
Project
.
MSG_INFO
)
;
TarOutputStream
tOut
=
null
;
try
{
tOut
=
new
TarOutputStream
(
compression
.
compress
(
new
BufferedOutputStream
(
new
FileOutputStream
(
tarFile
)
)
)
)
;
tOut
.
setDebug
(
true
)
;
if
(
longFileMode
.
isTruncateMode
(
)
)
{
tOut
.
setLongFileMode
(
TarOutputStream
.
LONGFILE_TRUNCATE
)
;
}
else
if
(
longFileMode
.
isFailMode
(
)
||
longFileMode
.
isOmitMode
(
)
)
{
tOut
.
setLongFileMode
(
TarOutputStream
.
LONGFILE_ERROR
)
;
}
else
{
tOut
.
setLongFileMode
(
TarOutputStream
.
LONGFILE_GNU
)
;
}
longWarningGiven
=
false
;
for
(
Enumeration
e
=
filesets
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
TarFileSet
fs
=
(
TarFileSet
)
e
.
nextElement
(
)
;
String
[
]
files
=
fs
.
getFiles
(
getProject
(
)
)
;
if
(
files
.
length
>
1
&&
fs
.
getFullpath
(
)
.
length
(
)
>
0
)
{
throw
new
BuildException
(
"fullpath attribute may only "
+
"be specified for "
+
"filesets that specify a "
+
"single file."
)
;
}
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
File
f
=
new
File
(
fs
.
getDir
(
getProject
(
)
)
,
files
[
i
]
)
;
String
name
=
files
[
i
]
.
replace
(
File
.
separatorChar
,
'/'
)
;
tarFile
(
f
,
tOut
,
name
,
fs
)
;
}
}
}
catch
(
IOException
ioe
)
{
String
msg
=
"Problem creating TAR: "
+
ioe
.
getMessage
(
)
;
throw
new
BuildException
(
msg
,
ioe
,
getLocation
(
)
)
;
}
finally
{
if
(
tOut
!=
null
)
{
try
{
tOut
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
}
}
finally
{
filesets
=
savedFileSets
;
}
}
protected
void
tarFile
(
File
file
,
TarOutputStream
tOut
,
String
vPath
,
TarFileSet
tarFileSet
)
throws
IOException
{
FileInputStream
fIn
=
null
;
String
fullpath
=
tarFileSet
.
getFullpath
(
)
;
if
(
fullpath
.
length
(
)
>
0
)
{
vPath
=
fullpath
;
}
else
{
if
(
vPath
.
length
(
)
<=
0
)
{
return
;
}
if
(
file
.
isDirectory
(
)
&&
!
vPath
.
endsWith
(
"/"
)
)
{
vPath
+=
"/"
;
}
String
prefix
=
tarFileSet
.
getPrefix
(
)
;
if
(
prefix
.
length
(
)
>
0
&&
!
prefix
.
endsWith
(
"/"
)
)
{
prefix
=
prefix
+
"/"
;
}
vPath
=
prefix
+
vPath
;
}
if
(
vPath
.
startsWith
(
"/"
)
&&
!
tarFileSet
.
getPreserveLeadingSlashes
(
)
)
{
int
l
=
vPath
.
length
(
)
;
if
(
l
<=
1
)
{
return
;
}
vPath
=
vPath
.
substring
(
1
,
l
)
;
}
try
{
if
(
vPath
.
length
(
)
>=
TarConstants
.
NAMELEN
)
{
if
(
longFileMode
.
isOmitMode
(
)
)
{
log
(
"Omitting: "
+
vPath
,
Project
.
MSG_INFO
)
;
return
;
}
else
if
(
longFileMode
.
isWarnMode
(
)
)
{
log
(
"Entry: "
+
vPath
+
" longer than "
+
TarConstants
.
NAMELEN
+
" characters."
,
Project
.
MSG_WARN
)
;
if
(
!
longWarningGiven
)
{
log
(
"Resulting tar file can only be processed "
+
"successfully by GNU compatible tar commands"
,
Project
.
MSG_WARN
)
;
longWarningGiven
=
true
;
}
}
else
if
(
longFileMode
.
isFailMode
(
)
)
{
throw
new
BuildException
(
"Entry: "
+
vPath
+
" longer than "
+
TarConstants
.
NAMELEN
+
"characters."
,
getLocation
(
)
)
;
}
}
TarEntry
te
=
new
TarEntry
(
vPath
)
;
te
.
setModTime
(
file
.
lastModified
(
)
)
;
if
(
!
file
.
isDirectory
(
)
)
{
te
.
setSize
(
file
.
length
(
)
)
;
te
.
setMode
(
tarFileSet
.
getMode
(
)
)
;
}
else
{
te
.
setMode
(
tarFileSet
.
getDirMode
(
)
)
;
}
te
.
setUserName
(
tarFileSet
.
getUserName
(
)
)
;
te
.
setGroupName
(
tarFileSet
.
getGroup
(
)
)
;
tOut
.
putNextEntry
(
te
)
;
if
(
!
file
.
isDirectory
(
)
)
{
fIn
=
new
FileInputStream
(
file
)
;
byte
[
]
buffer
=
new
byte
[
8
*
1024
]
;
int
count
=
0
;
do
{
tOut
.
write
(
buffer
,
0
,
count
)
;
count
=
fIn
.
read
(
buffer
,
0
,
buffer
.
length
)
;
}
while
(
count
!=
-
1
)
;
}
tOut
.
closeEntry
(
)
;
}
finally
{
if
(
fIn
!=
null
)
{
fIn
.
close
(
)
;
}
}
}
protected
boolean
archiveIsUpToDate
(
String
[
]
files
)
{
return
archiveIsUpToDate
(
files
,
baseDir
)
;
}
protected
boolean
archiveIsUpToDate
(
String
[
]
files
,
File
dir
)
{
SourceFileScanner
sfs
=
new
SourceFileScanner
(
this
)
;
MergingMapper
mm
=
new
MergingMapper
(
)
;
mm
.
setTo
(
tarFile
.
getAbsolutePath
(
)
)
;
return
sfs
.
restrict
(
files
,
dir
,
null
,
mm
)
.
length
==
0
;
}
public
static
class
TarFileSet
extends
FileSet
{
private
String
[
]
files
=
null
;
private
int
fileMode
=
UnixStat
.
FILE_FLAG
|
UnixStat
.
DEFAULT_FILE_PERM
;
private
int
dirMode
=
UnixStat
.
DIR_FLAG
|
UnixStat
.
DEFAULT_DIR_PERM
;
private
String
userName
=
""
;
private
String
groupName
=
""
;
private
String
prefix
=
""
;
private
String
fullpath
=
""
;
private
boolean
preserveLeadingSlashes
=
false
;
public
TarFileSet
(
FileSet
fileset
)
{
super
(
fileset
)
;
}
public
TarFileSet
(
)
{
super
(
)
;
}
public
String
[
]
getFiles
(
Project
p
)
{
if
(
files
==
null
)
{
DirectoryScanner
ds
=
getDirectoryScanner
(
p
)
;
String
[
]
directories
=
ds
.
getIncludedDirectories
(
)
;
String
[
]
filesPerSe
=
ds
.
getIncludedFiles
(
)
;
files
=
new
String
[
directories
.
length
+
filesPerSe
.
length
]
;
System
.
arraycopy
(
directories
,
0
,
files
,
0
,
directories
.
length
)
;
System
.
arraycopy
(
filesPerSe
,
0
,
files
,
directories
.
length
,
filesPerSe
.
length
)
;
}
return
files
;
}
public
void
setMode
(
String
octalString
)
{
this
.
fileMode
=
UnixStat
.
FILE_FLAG
|
Integer
.
parseInt
(
octalString
,
8
)
;
}
public
int
getMode
(
)
{
return
fileMode
;
}
public
void
setDirMode
(
String
octalString
)
{
this
.
dirMode
=
UnixStat
.
DIR_FLAG
|
Integer
.
parseInt
(
octalString
,
8
)
;
}
public
int
getDirMode
(
)
{
return
dirMode
;
}
public
void
setUserName
(
String
userName
)
{
this
.
userName
=
userName
;
}
public
String
getUserName
(
)
{
return
userName
;
}
public
void
setGroup
(
String
groupName
)
{
this
.
groupName
=
groupName
;
}
public
String
getGroup
(
)
{
return
groupName
;
}
public
void
setPrefix
(
String
prefix
)
{
this
.
prefix
=
prefix
;
}
public
String
getPrefix
(
)
{
return
prefix
;
}
public
void
setFullpath
(
String
fullpath
)
{
this
.
fullpath
=
fullpath
;
}
public
String
getFullpath
(
)
{
return
fullpath
;
}
public
void
setPreserveLeadingSlashes
(
boolean
b
)
{
this
.
preserveLeadingSlashes
=
b
;
}
public
boolean
getPreserveLeadingSlashes
(
)
{
return
preserveLeadingSlashes
;
}
}
public
static
class
TarLongFileMode
extends
EnumeratedAttribute
{
public
static
final
String
WARN
=
"warn"
;
public
static
final
String
FAIL
=
"fail"
;
public
static
final
String
TRUNCATE
=
"truncate"
;
public
static
final
String
GNU
=
"gnu"
;
public
static
final
String
OMIT
=
"omit"
;
private
final
String
[
]
validModes
=
{
WARN
,
FAIL
,
TRUNCATE
,
GNU
,
OMIT
}
;
public
TarLongFileMode
(
)
{
super
(
)
;
setValue
(
WARN
)
;
}
public
String
[
]
getValues
(
)
{
return
validModes
;
}
public
boolean
isTruncateMode
(
)
{
return
TRUNCATE
.
equalsIgnoreCase
(
getValue
(
)
)
;
}
public
boolean
isWarnMode
(
)
{
return
WARN
.
equalsIgnoreCase
(
getValue
(
)
)
;
}
public
boolean
isGnuMode
(
)
{
return
GNU
.
equalsIgnoreCase
(
getValue
(
)
)
;
}
public
boolean
isFailMode
(
)
{
return
FAIL
.
equalsIgnoreCase
(
getValue
(
)
)
;
}
public
boolean
isOmitMode
(
)
{
return
OMIT
.
equalsIgnoreCase
(
getValue
(
)
)
;
}
}
public
static
final
class
TarCompressionMethod
extends
EnumeratedAttribute
{
private
static
final
String
NONE
=
"none"
;
private
static
final
String
GZIP
=
"gzip"
;
private
static
final
String
BZIP2
=
"bzip2"
;
public
TarCompressionMethod
(
)
{
super
(
)
;
setValue
(
NONE
)
;
}
public
String
[
]
getValues
(
)
{
return
new
String
[
]
{
NONE
,
GZIP
,
BZIP2
}
;
}
private
OutputStream
compress
(
final
OutputStream
ostream
)
throws
IOException
{
final
String
value
=
getValue
(
)
;
if
(
GZIP
.
equals
(
value
)
)
{
return
new
GZIPOutputStream
(
ostream
)
;
}
else
{
if
(
BZIP2
.
equals
(
value
)
)
{
ostream
.
write
(
'B'
)
;
ostream
.
write
(
'Z'
)
;
return
new
CBZip2OutputStream
(
ostream
)
;
}
}
return
ostream
;
}
}
}
