package
org
.
apache
.
tools
.
ant
.
util
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
FileWriter
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
Reader
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
net
.
MalformedURLException
;
import
java
.
net
.
URL
;
import
java
.
text
.
CharacterIterator
;
import
java
.
text
.
DecimalFormat
;
import
java
.
text
.
StringCharacterIterator
;
import
java
.
util
.
Random
;
import
java
.
util
.
Stack
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
filters
.
util
.
ChainReaderHelper
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
condition
.
Os
;
import
org
.
apache
.
tools
.
ant
.
types
.
FilterSetCollection
;
import
org
.
apache
.
tools
.
ant
.
launch
.
Locator
;
public
class
FileUtils
{
private
static
Random
rand
=
new
Random
(
System
.
currentTimeMillis
(
)
)
;
private
static
Object
lockReflection
=
new
Object
(
)
;
private
static
java
.
lang
.
reflect
.
Method
setLastModified
=
null
;
private
boolean
onNetWare
=
Os
.
isFamily
(
"netware"
)
;
private
static
boolean
[
]
isSpecial
=
new
boolean
[
256
]
;
private
static
char
[
]
escapedChar1
=
new
char
[
256
]
;
private
static
char
[
]
escapedChar2
=
new
char
[
256
]
;
public
static
final
long
FAT_FILE_TIMESTAMP_GRANULARITY
=
2000
;
static
{
for
(
int
i
=
0
;
i
<=
0x20
;
i
++
)
{
isSpecial
[
i
]
=
true
;
escapedChar1
[
i
]
=
Character
.
forDigit
(
i
>
>
4
,
16
)
;
escapedChar2
[
i
]
=
Character
.
forDigit
(
i
&
0xf
,
16
)
;
}
isSpecial
[
0x7f
]
=
true
;
escapedChar1
[
0x7f
]
=
'7'
;
escapedChar2
[
0x7f
]
=
'F'
;
char
[
]
escChs
=
{
'<'
,
'>'
,
'#'
,
'%'
,
'"'
,
'{'
,
'}'
,
'|'
,
'\\'
,
'^'
,
'~'
,
'['
,
']'
,
'`'
}
;
int
len
=
escChs
.
length
;
char
ch
;
for
(
int
i
=
0
;
i
<
len
;
i
++
)
{
ch
=
escChs
[
i
]
;
isSpecial
[
ch
]
=
true
;
escapedChar1
[
ch
]
=
Character
.
forDigit
(
ch
>
>
4
,
16
)
;
escapedChar2
[
ch
]
=
Character
.
forDigit
(
ch
&
0xf
,
16
)
;
}
}
public
static
FileUtils
newFileUtils
(
)
{
return
new
FileUtils
(
)
;
}
protected
FileUtils
(
)
{
}
public
URL
getFileURL
(
File
file
)
throws
MalformedURLException
{
return
new
URL
(
toURI
(
file
.
getAbsolutePath
(
)
)
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
null
,
false
,
false
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
false
,
false
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
overwrite
,
false
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
,
boolean
preserveLastModified
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
overwrite
,
preserveLastModified
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
encoding
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
overwrite
,
preserveLastModified
,
encoding
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
,
Vector
filterChains
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
encoding
,
Project
project
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
filterChains
,
overwrite
,
preserveLastModified
,
encoding
,
project
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
FilterSetCollection
filters
,
Vector
filterChains
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
inputEncoding
,
String
outputEncoding
,
Project
project
)
throws
IOException
{
copyFile
(
new
File
(
sourceFile
)
,
new
File
(
destFile
)
,
filters
,
filterChains
,
overwrite
,
preserveLastModified
,
inputEncoding
,
outputEncoding
,
project
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
null
,
false
,
false
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
filters
,
false
,
false
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
filters
,
overwrite
,
false
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
,
boolean
preserveLastModified
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
filters
,
overwrite
,
preserveLastModified
,
null
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
encoding
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
filters
,
null
,
overwrite
,
preserveLastModified
,
encoding
,
null
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
,
Vector
filterChains
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
encoding
,
Project
project
)
throws
IOException
{
copyFile
(
sourceFile
,
destFile
,
filters
,
filterChains
,
overwrite
,
preserveLastModified
,
encoding
,
encoding
,
project
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
FilterSetCollection
filters
,
Vector
filterChains
,
boolean
overwrite
,
boolean
preserveLastModified
,
String
inputEncoding
,
String
outputEncoding
,
Project
project
)
throws
IOException
{
if
(
overwrite
||
!
destFile
.
exists
(
)
||
destFile
.
lastModified
(
)
<
sourceFile
.
lastModified
(
)
)
{
if
(
destFile
.
exists
(
)
&&
destFile
.
isFile
(
)
)
{
destFile
.
delete
(
)
;
}
File
parent
=
getParentFile
(
destFile
)
;
if
(
parent
!=
null
&&
!
parent
.
exists
(
)
)
{
parent
.
mkdirs
(
)
;
}
final
boolean
filterSetsAvailable
=
(
filters
!=
null
&&
filters
.
hasFilters
(
)
)
;
final
boolean
filterChainsAvailable
=
(
filterChains
!=
null
&&
filterChains
.
size
(
)
>
0
)
;
if
(
filterSetsAvailable
)
{
BufferedReader
in
=
null
;
BufferedWriter
out
=
null
;
try
{
if
(
inputEncoding
==
null
)
{
in
=
new
BufferedReader
(
new
FileReader
(
sourceFile
)
)
;
}
else
{
InputStreamReader
isr
=
new
InputStreamReader
(
new
FileInputStream
(
sourceFile
)
,
inputEncoding
)
;
in
=
new
BufferedReader
(
isr
)
;
}
if
(
outputEncoding
==
null
)
{
out
=
new
BufferedWriter
(
new
FileWriter
(
destFile
)
)
;
}
else
{
OutputStreamWriter
osw
=
new
OutputStreamWriter
(
new
FileOutputStream
(
destFile
)
,
outputEncoding
)
;
out
=
new
BufferedWriter
(
osw
)
;
}
if
(
filterChainsAvailable
)
{
ChainReaderHelper
crh
=
new
ChainReaderHelper
(
)
;
crh
.
setBufferSize
(
8192
)
;
crh
.
setPrimaryReader
(
in
)
;
crh
.
setFilterChains
(
filterChains
)
;
crh
.
setProject
(
project
)
;
Reader
rdr
=
crh
.
getAssembledReader
(
)
;
in
=
new
BufferedReader
(
rdr
)
;
}
LineTokenizer
lineTokenizer
=
new
LineTokenizer
(
)
;
lineTokenizer
.
setIncludeDelims
(
true
)
;
String
newline
=
null
;
String
line
=
lineTokenizer
.
getToken
(
in
)
;
while
(
line
!=
null
)
{
if
(
line
.
length
(
)
==
0
)
{
out
.
newLine
(
)
;
}
else
{
newline
=
filters
.
replaceTokens
(
line
)
;
out
.
write
(
newline
)
;
}
line
=
lineTokenizer
.
getToken
(
in
)
;
}
}
finally
{
if
(
out
!=
null
)
{
out
.
close
(
)
;
}
if
(
in
!=
null
)
{
in
.
close
(
)
;
}
}
}
else
if
(
filterChainsAvailable
||
(
inputEncoding
!=
null
&&
!
inputEncoding
.
equals
(
outputEncoding
)
)
||
(
inputEncoding
==
null
&&
outputEncoding
!=
null
)
)
{
BufferedReader
in
=
null
;
BufferedWriter
out
=
null
;
try
{
if
(
inputEncoding
==
null
)
{
in
=
new
BufferedReader
(
new
FileReader
(
sourceFile
)
)
;
}
else
{
in
=
new
BufferedReader
(
new
InputStreamReader
(
new
FileInputStream
(
sourceFile
)
,
inputEncoding
)
)
;
}
if
(
outputEncoding
==
null
)
{
out
=
new
BufferedWriter
(
new
FileWriter
(
destFile
)
)
;
}
else
{
out
=
new
BufferedWriter
(
new
OutputStreamWriter
(
new
FileOutputStream
(
destFile
)
,
outputEncoding
)
)
;
}
if
(
filterChainsAvailable
)
{
ChainReaderHelper
crh
=
new
ChainReaderHelper
(
)
;
crh
.
setBufferSize
(
8192
)
;
crh
.
setPrimaryReader
(
in
)
;
crh
.
setFilterChains
(
filterChains
)
;
crh
.
setProject
(
project
)
;
Reader
rdr
=
crh
.
getAssembledReader
(
)
;
in
=
new
BufferedReader
(
rdr
)
;
}
char
[
]
buffer
=
new
char
[
1024
*
8
]
;
while
(
true
)
{
int
nRead
=
in
.
read
(
buffer
,
0
,
buffer
.
length
)
;
if
(
nRead
==
-
1
)
{
break
;
}
out
.
write
(
buffer
,
0
,
nRead
)
;
}
}
finally
{
if
(
out
!=
null
)
{
out
.
close
(
)
;
}
if
(
in
!=
null
)
{
in
.
close
(
)
;
}
}
}
else
{
FileInputStream
in
=
null
;
FileOutputStream
out
=
null
;
try
{
in
=
new
FileInputStream
(
sourceFile
)
;
out
=
new
FileOutputStream
(
destFile
)
;
byte
[
]
buffer
=
new
byte
[
8
*
1024
]
;
int
count
=
0
;
do
{
out
.
write
(
buffer
,
0
,
count
)
;
count
=
in
.
read
(
buffer
,
0
,
buffer
.
length
)
;
}
while
(
count
!=
-
1
)
;
}
finally
{
if
(
out
!=
null
)
{
out
.
close
(
)
;
}
if
(
in
!=
null
)
{
in
.
close
(
)
;
}
}
}
if
(
preserveLastModified
)
{
setFileLastModified
(
destFile
,
sourceFile
.
lastModified
(
)
)
;
}
}
}
protected
final
Method
getSetLastModified
(
)
{
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_1
)
)
{
return
null
;
}
synchronized
(
lockReflection
)
{
if
(
setLastModified
==
null
)
{
try
{
setLastModified
=
java
.
io
.
File
.
class
.
getMethod
(
"setLastModified"
,
new
Class
[
]
{
Long
.
TYPE
}
)
;
}
catch
(
NoSuchMethodException
nse
)
{
throw
new
BuildException
(
"File.setlastModified not in JDK > 1.1?"
,
nse
)
;
}
}
}
return
setLastModified
;
}
public
void
setFileLastModified
(
File
file
,
long
time
)
throws
BuildException
{
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_1
)
)
{
return
;
}
Long
[
]
times
=
new
Long
[
1
]
;
if
(
time
<
0
)
{
times
[
0
]
=
new
Long
(
System
.
currentTimeMillis
(
)
)
;
}
else
{
times
[
0
]
=
new
Long
(
time
)
;
}
try
{
getSetLastModified
(
)
.
invoke
(
file
,
times
)
;
}
catch
(
java
.
lang
.
reflect
.
InvocationTargetException
ite
)
{
Throwable
nested
=
ite
.
getTargetException
(
)
;
throw
new
BuildException
(
"Exception setting the modification time "
+
"of "
+
file
,
nested
)
;
}
catch
(
Throwable
other
)
{
throw
new
BuildException
(
"Exception setting the modification time "
+
"of "
+
file
,
other
)
;
}
}
public
File
resolveFile
(
File
file
,
String
filename
)
{
filename
=
filename
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
if
(
!
onNetWare
)
{
if
(
filename
.
startsWith
(
File
.
separator
)
||
(
filename
.
length
(
)
>=
2
&&
Character
.
isLetter
(
filename
.
charAt
(
0
)
)
&&
filename
.
charAt
(
1
)
==
':'
)
)
{
return
normalize
(
filename
)
;
}
}
else
{
int
colon
=
filename
.
indexOf
(
":"
)
;
if
(
filename
.
startsWith
(
File
.
separator
)
||
(
colon
>
-
1
)
)
{
return
normalize
(
filename
)
;
}
}
if
(
file
==
null
)
{
return
new
File
(
filename
)
;
}
File
helpFile
=
new
File
(
file
.
getAbsolutePath
(
)
)
;
StringTokenizer
tok
=
new
StringTokenizer
(
filename
,
File
.
separator
)
;
while
(
tok
.
hasMoreTokens
(
)
)
{
String
part
=
tok
.
nextToken
(
)
;
if
(
part
.
equals
(
".."
)
)
{
helpFile
=
getParentFile
(
helpFile
)
;
if
(
helpFile
==
null
)
{
String
msg
=
"The file or path you specified ("
+
filename
+
") is invalid relative to "
+
file
.
getPath
(
)
;
throw
new
BuildException
(
msg
)
;
}
}
else
if
(
part
.
equals
(
"."
)
)
{
}
else
{
helpFile
=
new
File
(
helpFile
,
part
)
;
}
}
return
new
File
(
helpFile
.
getAbsolutePath
(
)
)
;
}
public
File
normalize
(
String
path
)
{
String
orig
=
path
;
path
=
path
.
replace
(
'/'
,
File
.
separatorChar
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
int
colon
=
path
.
indexOf
(
":"
)
;
if
(
!
onNetWare
)
{
if
(
!
path
.
startsWith
(
File
.
separator
)
&&
!
(
path
.
length
(
)
>=
2
&&
Character
.
isLetter
(
path
.
charAt
(
0
)
)
&&
colon
==
1
)
)
{
String
msg
=
path
+
" is not an absolute path"
;
throw
new
BuildException
(
msg
)
;
}
}
else
{
if
(
!
path
.
startsWith
(
File
.
separator
)
&&
(
colon
==
-
1
)
)
{
String
msg
=
path
+
" is not an absolute path"
;
throw
new
BuildException
(
msg
)
;
}
}
boolean
dosWithDrive
=
false
;
String
root
=
null
;
if
(
(
!
onNetWare
&&
path
.
length
(
)
>=
2
&&
Character
.
isLetter
(
path
.
charAt
(
0
)
)
&&
path
.
charAt
(
1
)
==
':'
)
||
(
onNetWare
&&
colon
>
-
1
)
)
{
dosWithDrive
=
true
;
char
[
]
ca
=
path
.
replace
(
'/'
,
'\\'
)
.
toCharArray
(
)
;
StringBuffer
sbRoot
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
colon
;
i
++
)
{
sbRoot
.
append
(
Character
.
toUpperCase
(
ca
[
i
]
)
)
;
}
sbRoot
.
append
(
':'
)
;
if
(
colon
+
1
<
path
.
length
(
)
)
{
sbRoot
.
append
(
File
.
separatorChar
)
;
}
root
=
sbRoot
.
toString
(
)
;
StringBuffer
sbPath
=
new
StringBuffer
(
)
;
for
(
int
i
=
colon
+
1
;
i
<
ca
.
length
;
i
++
)
{
if
(
(
ca
[
i
]
!=
'\\'
)
||
(
ca
[
i
]
==
'\\'
&&
ca
[
i
-
1
]
!=
'\\'
)
)
{
sbPath
.
append
(
ca
[
i
]
)
;
}
}
path
=
sbPath
.
toString
(
)
.
replace
(
'\\'
,
File
.
separatorChar
)
;
}
else
{
if
(
path
.
length
(
)
==
1
)
{
root
=
File
.
separator
;
path
=
""
;
}
else
if
(
path
.
charAt
(
1
)
==
File
.
separatorChar
)
{
root
=
File
.
separator
+
File
.
separator
;
path
=
path
.
substring
(
2
)
;
}
else
{
root
=
File
.
separator
;
path
=
path
.
substring
(
1
)
;
}
}
Stack
s
=
new
Stack
(
)
;
s
.
push
(
root
)
;
StringTokenizer
tok
=
new
StringTokenizer
(
path
,
File
.
separator
)
;
while
(
tok
.
hasMoreTokens
(
)
)
{
String
thisToken
=
tok
.
nextToken
(
)
;
if
(
"."
.
equals
(
thisToken
)
)
{
continue
;
}
else
if
(
".."
.
equals
(
thisToken
)
)
{
if
(
s
.
size
(
)
<
2
)
{
throw
new
BuildException
(
"Cannot resolve path "
+
orig
)
;
}
else
{
s
.
pop
(
)
;
}
}
else
{
s
.
push
(
thisToken
)
;
}
}
StringBuffer
sb
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
s
.
size
(
)
;
i
++
)
{
if
(
i
>
1
)
{
sb
.
append
(
File
.
separatorChar
)
;
}
sb
.
append
(
s
.
elementAt
(
i
)
)
;
}
path
=
sb
.
toString
(
)
;
if
(
dosWithDrive
)
{
path
=
path
.
replace
(
'/'
,
'\\'
)
;
}
return
new
File
(
path
)
;
}
public
String
toVMSPath
(
File
f
)
{
String
osPath
;
String
path
=
normalize
(
f
.
getAbsolutePath
(
)
)
.
getPath
(
)
;
String
name
=
f
.
getName
(
)
;
boolean
isAbsolute
=
path
.
charAt
(
0
)
==
File
.
separatorChar
;
boolean
isDirectory
=
f
.
isDirectory
(
)
&&
!
name
.
regionMatches
(
true
,
name
.
length
(
)
-
4
,
".DIR"
,
0
,
4
)
;
String
device
=
null
;
StringBuffer
directory
=
null
;
String
file
=
null
;
int
index
=
0
;
if
(
isAbsolute
)
{
index
=
path
.
indexOf
(
File
.
separatorChar
,
1
)
;
if
(
index
==
-
1
)
{
return
path
.
substring
(
1
)
+
":[000000]"
;
}
else
{
device
=
path
.
substring
(
1
,
index
++
)
;
}
}
if
(
isDirectory
)
{
directory
=
new
StringBuffer
(
path
.
substring
(
index
)
.
replace
(
File
.
separatorChar
,
'.'
)
)
;
}
else
{
int
dirEnd
=
path
.
lastIndexOf
(
File
.
separatorChar
,
path
.
length
(
)
)
;
if
(
dirEnd
==
-
1
||
dirEnd
<
index
)
{
file
=
path
.
substring
(
index
)
;
}
else
{
directory
=
new
StringBuffer
(
path
.
substring
(
index
,
dirEnd
)
.
replace
(
File
.
separatorChar
,
'.'
)
)
;
index
=
dirEnd
+
1
;
if
(
path
.
length
(
)
>
index
)
{
file
=
path
.
substring
(
index
)
;
}
}
}
if
(
!
isAbsolute
&&
directory
!=
null
)
{
directory
.
insert
(
0
,
'.'
)
;
}
osPath
=
(
(
device
!=
null
)
?
device
+
":"
:
""
)
+
(
(
directory
!=
null
)
?
"["
+
directory
+
"]"
:
""
)
+
(
(
file
!=
null
)
?
file
:
""
)
;
return
osPath
;
}
public
File
createTempFile
(
String
prefix
,
String
suffix
,
File
parentDir
)
{
File
result
=
null
;
String
parent
=
System
.
getProperty
(
"java.io.tmpdir"
)
;
if
(
parentDir
!=
null
)
{
parent
=
parentDir
.
getPath
(
)
;
}
DecimalFormat
fmt
=
new
DecimalFormat
(
"#####"
)
;
synchronized
(
rand
)
{
do
{
result
=
new
File
(
parent
,
prefix
+
fmt
.
format
(
Math
.
abs
(
rand
.
nextInt
(
)
)
)
+
suffix
)
;
}
while
(
result
.
exists
(
)
)
;
}
return
result
;
}
public
boolean
contentEquals
(
File
f1
,
File
f2
)
throws
IOException
{
if
(
f1
.
exists
(
)
!=
f2
.
exists
(
)
)
{
return
false
;
}
if
(
!
f1
.
exists
(
)
)
{
return
true
;
}
if
(
f1
.
isDirectory
(
)
||
f2
.
isDirectory
(
)
)
{
return
false
;
}
if
(
fileNameEquals
(
f1
,
f2
)
)
{
return
true
;
}
if
(
f1
.
length
(
)
!=
f2
.
length
(
)
)
{
return
false
;
}
InputStream
in1
=
null
;
InputStream
in2
=
null
;
try
{
in1
=
new
BufferedInputStream
(
new
FileInputStream
(
f1
)
)
;
in2
=
new
BufferedInputStream
(
new
FileInputStream
(
f2
)
)
;
int
expectedByte
=
in1
.
read
(
)
;
while
(
expectedByte
!=
-
1
)
{
if
(
expectedByte
!=
in2
.
read
(
)
)
{
return
false
;
}
expectedByte
=
in1
.
read
(
)
;
}
if
(
in2
.
read
(
)
!=
-
1
)
{
return
false
;
}
return
true
;
}
finally
{
if
(
in1
!=
null
)
{
try
{
in1
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
if
(
in2
!=
null
)
{
try
{
in2
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
}
}
public
File
getParentFile
(
File
f
)
{
if
(
f
!=
null
)
{
String
p
=
f
.
getParent
(
)
;
if
(
p
!=
null
)
{
return
new
File
(
p
)
;
}
}
return
null
;
}
public
static
final
String
readFully
(
Reader
rdr
)
throws
IOException
{
return
readFully
(
rdr
,
8192
)
;
}
public
static
final
String
readFully
(
Reader
rdr
,
int
bufferSize
)
throws
IOException
{
if
(
bufferSize
<=
0
)
{
throw
new
IllegalArgumentException
(
"Buffer size must be greater "
+
"than 0"
)
;
}
final
char
[
]
buffer
=
new
char
[
bufferSize
]
;
int
bufferLength
=
0
;
String
text
=
null
;
StringBuffer
textBuffer
=
null
;
while
(
bufferLength
!=
-
1
)
{
bufferLength
=
rdr
.
read
(
buffer
)
;
if
(
bufferLength
!=
-
1
)
{
if
(
textBuffer
==
null
)
{
textBuffer
=
new
StringBuffer
(
new
String
(
buffer
,
0
,
bufferLength
)
)
;
}
else
{
textBuffer
.
append
(
new
String
(
buffer
,
0
,
bufferLength
)
)
;
}
}
}
if
(
textBuffer
!=
null
)
{
text
=
textBuffer
.
toString
(
)
;
}
return
text
;
}
public
boolean
createNewFile
(
File
f
)
throws
IOException
{
if
(
f
!=
null
)
{
if
(
f
.
exists
(
)
)
{
return
false
;
}
FileOutputStream
fos
=
null
;
try
{
fos
=
new
FileOutputStream
(
f
)
;
fos
.
write
(
new
byte
[
0
]
)
;
}
finally
{
if
(
fos
!=
null
)
{
fos
.
close
(
)
;
}
}
return
true
;
}
return
false
;
}
public
boolean
isSymbolicLink
(
File
parent
,
String
name
)
throws
IOException
{
File
resolvedParent
=
new
File
(
parent
.
getCanonicalPath
(
)
)
;
File
toTest
=
new
File
(
resolvedParent
,
name
)
;
return
!
toTest
.
getAbsolutePath
(
)
.
equals
(
toTest
.
getCanonicalPath
(
)
)
;
}
public
String
removeLeadingPath
(
File
leading
,
File
path
)
{
String
l
=
normalize
(
leading
.
getAbsolutePath
(
)
)
.
getAbsolutePath
(
)
;
String
p
=
normalize
(
path
.
getAbsolutePath
(
)
)
.
getAbsolutePath
(
)
;
if
(
l
.
equals
(
p
)
)
{
return
""
;
}
if
(
!
l
.
endsWith
(
File
.
separator
)
)
{
l
+=
File
.
separator
;
}
if
(
p
.
startsWith
(
l
)
)
{
return
p
.
substring
(
l
.
length
(
)
)
;
}
else
{
return
p
;
}
}
public
String
toURI
(
String
path
)
{
boolean
isDir
=
(
new
File
(
path
)
)
.
isDirectory
(
)
;
StringBuffer
sb
=
new
StringBuffer
(
"file:"
)
;
try
{
path
=
normalize
(
path
)
.
getAbsolutePath
(
)
;
sb
.
append
(
"//"
)
;
if
(
!
path
.
startsWith
(
File
.
separator
)
)
{
sb
.
append
(
"/"
)
;
}
}
catch
(
BuildException
e
)
{
}
path
=
path
.
replace
(
'\\'
,
'/'
)
;
CharacterIterator
iter
=
new
StringCharacterIterator
(
path
)
;
for
(
char
c
=
iter
.
first
(
)
;
c
!=
CharacterIterator
.
DONE
;
c
=
iter
.
next
(
)
)
{
if
(
isSpecial
[
c
]
)
{
sb
.
append
(
'%'
)
;
sb
.
append
(
escapedChar1
[
c
]
)
;
sb
.
append
(
escapedChar2
[
c
]
)
;
}
else
{
sb
.
append
(
c
)
;
}
}
if
(
isDir
&&
!
path
.
endsWith
(
"/"
)
)
{
sb
.
append
(
'/'
)
;
}
return
sb
.
toString
(
)
;
}
public
String
fromURI
(
String
uri
)
{
String
path
=
Locator
.
fromURI
(
uri
)
;
try
{
path
=
normalize
(
path
)
.
getAbsolutePath
(
)
;
}
catch
(
BuildException
e
)
{
}
return
path
;
}
public
boolean
fileNameEquals
(
File
f1
,
File
f2
)
{
return
normalize
(
f1
.
getAbsolutePath
(
)
)
.
equals
(
normalize
(
f2
.
getAbsolutePath
(
)
)
)
;
}
public
void
rename
(
File
from
,
File
to
)
throws
IOException
{
if
(
to
.
exists
(
)
&&
!
to
.
delete
(
)
)
{
throw
new
IOException
(
"Failed to delete "
+
to
+
" while trying to rename "
+
from
)
;
}
File
parent
=
getParentFile
(
to
)
;
if
(
parent
!=
null
&&
!
parent
.
exists
(
)
&&
!
parent
.
mkdirs
(
)
)
{
throw
new
IOException
(
"Failed to create directory "
+
parent
+
" while trying to rename "
+
from
)
;
}
if
(
!
from
.
renameTo
(
to
)
)
{
copyFile
(
from
,
to
)
;
if
(
!
from
.
delete
(
)
)
{
throw
new
IOException
(
"Failed to delete "
+
from
+
" while trying to rename it."
)
;
}
}
}
public
long
getFileTimestampGranularity
(
)
{
if
(
Os
.
isFamily
(
"dos"
)
)
{
return
FAT_FILE_TIMESTAMP_GRANULARITY
;
}
else
{
return
0
;
}
}
}
