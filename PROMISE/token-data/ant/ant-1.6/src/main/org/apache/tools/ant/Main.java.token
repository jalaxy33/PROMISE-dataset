package
org
.
apache
.
tools
.
ant
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
PrintStream
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Properties
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
input
.
DefaultInputHandler
;
import
org
.
apache
.
tools
.
ant
.
input
.
InputHandler
;
import
org
.
apache
.
tools
.
ant
.
util
.
JavaEnvUtils
;
import
org
.
apache
.
tools
.
ant
.
launch
.
AntMain
;
public
class
Main
implements
AntMain
{
public
static
final
String
DEFAULT_BUILD_FILENAME
=
"build.xml"
;
private
int
msgOutputLevel
=
Project
.
MSG_INFO
;
private
File
buildFile
;
private
static
PrintStream
out
=
System
.
out
;
private
static
PrintStream
err
=
System
.
err
;
private
Vector
targets
=
new
Vector
(
)
;
private
Properties
definedProps
=
new
Properties
(
)
;
private
Vector
listeners
=
new
Vector
(
1
)
;
private
Vector
propertyFiles
=
new
Vector
(
1
)
;
private
boolean
allowInput
=
true
;
private
boolean
keepGoingMode
=
false
;
private
String
loggerClassname
=
null
;
private
String
inputHandlerClassname
=
null
;
private
boolean
emacsMode
=
false
;
private
boolean
readyToRun
=
false
;
private
boolean
projectHelp
=
false
;
private
static
boolean
isLogFileUsed
=
false
;
private
static
void
printMessage
(
Throwable
t
)
{
String
message
=
t
.
getMessage
(
)
;
if
(
message
!=
null
)
{
System
.
err
.
println
(
message
)
;
}
}
public
static
void
start
(
String
[
]
args
,
Properties
additionalUserProperties
,
ClassLoader
coreLoader
)
{
Main
m
=
new
Main
(
)
;
m
.
startAnt
(
args
,
additionalUserProperties
,
coreLoader
)
;
}
public
void
startAnt
(
String
[
]
args
,
Properties
additionalUserProperties
,
ClassLoader
coreLoader
)
{
try
{
Diagnostics
.
validateVersion
(
)
;
processArgs
(
args
)
;
}
catch
(
Throwable
exc
)
{
handleLogfile
(
)
;
printMessage
(
exc
)
;
System
.
exit
(
1
)
;
}
if
(
additionalUserProperties
!=
null
)
{
for
(
Enumeration
e
=
additionalUserProperties
.
keys
(
)
;
e
.
hasMoreElements
(
)
;
)
{
String
key
=
(
String
)
e
.
nextElement
(
)
;
String
property
=
additionalUserProperties
.
getProperty
(
key
)
;
definedProps
.
put
(
key
,
property
)
;
}
}
int
exitCode
=
1
;
try
{
runBuild
(
coreLoader
)
;
exitCode
=
0
;
}
catch
(
BuildException
be
)
{
if
(
err
!=
System
.
err
)
{
printMessage
(
be
)
;
}
}
catch
(
Throwable
exc
)
{
exc
.
printStackTrace
(
)
;
printMessage
(
exc
)
;
}
finally
{
handleLogfile
(
)
;
}
System
.
exit
(
exitCode
)
;
}
private
static
void
handleLogfile
(
)
{
if
(
isLogFileUsed
)
{
if
(
out
!=
null
)
{
try
{
out
.
close
(
)
;
}
catch
(
final
Exception
e
)
{
}
}
if
(
err
!=
null
)
{
try
{
err
.
close
(
)
;
}
catch
(
final
Exception
e
)
{
}
}
}
}
public
static
void
main
(
String
[
]
args
)
{
start
(
args
,
null
,
null
)
;
}
public
Main
(
)
{
}
protected
Main
(
String
[
]
args
)
throws
BuildException
{
processArgs
(
args
)
;
}
private
void
processArgs
(
String
[
]
args
)
{
String
searchForThis
=
null
;
PrintStream
logTo
=
null
;
for
(
int
i
=
0
;
i
<
args
.
length
;
i
++
)
{
String
arg
=
args
[
i
]
;
if
(
arg
.
equals
(
"-help"
)
||
arg
.
equals
(
"-h"
)
)
{
printUsage
(
)
;
return
;
}
else
if
(
arg
.
equals
(
"-version"
)
)
{
printVersion
(
)
;
return
;
}
else
if
(
arg
.
equals
(
"-diagnostics"
)
)
{
Diagnostics
.
doReport
(
System
.
out
)
;
return
;
}
else
if
(
arg
.
equals
(
"-quiet"
)
||
arg
.
equals
(
"-q"
)
)
{
msgOutputLevel
=
Project
.
MSG_WARN
;
}
else
if
(
arg
.
equals
(
"-verbose"
)
||
arg
.
equals
(
"-v"
)
)
{
printVersion
(
)
;
msgOutputLevel
=
Project
.
MSG_VERBOSE
;
}
else
if
(
arg
.
equals
(
"-debug"
)
||
arg
.
equals
(
"-d"
)
)
{
printVersion
(
)
;
msgOutputLevel
=
Project
.
MSG_DEBUG
;
}
else
if
(
arg
.
equals
(
"-noinput"
)
)
{
allowInput
=
false
;
}
else
if
(
arg
.
equals
(
"-logfile"
)
||
arg
.
equals
(
"-l"
)
)
{
try
{
File
logFile
=
new
File
(
args
[
i
+
1
]
)
;
i
++
;
logTo
=
new
PrintStream
(
new
FileOutputStream
(
logFile
)
)
;
isLogFileUsed
=
true
;
}
catch
(
IOException
ioe
)
{
String
msg
=
"Cannot write on the specified log file. "
+
"Make sure the path exists and you have write "
+
"permissions."
;
throw
new
BuildException
(
msg
)
;
}
catch
(
ArrayIndexOutOfBoundsException
aioobe
)
{
String
msg
=
"You must specify a log file when "
+
"using the -log argument"
;
throw
new
BuildException
(
msg
)
;
}
}
else
if
(
arg
.
equals
(
"-buildfile"
)
||
arg
.
equals
(
"-file"
)
||
arg
.
equals
(
"-f"
)
)
{
try
{
buildFile
=
new
File
(
args
[
i
+
1
]
.
replace
(
'/'
,
File
.
separatorChar
)
)
;
i
++
;
}
catch
(
ArrayIndexOutOfBoundsException
aioobe
)
{
String
msg
=
"You must specify a buildfile when "
+
"using the -buildfile argument"
;
throw
new
BuildException
(
msg
)
;
}
}
else
if
(
arg
.
equals
(
"-listener"
)
)
{
try
{
listeners
.
addElement
(
args
[
i
+
1
]
)
;
i
++
;
}
catch
(
ArrayIndexOutOfBoundsException
aioobe
)
{
String
msg
=
"You must specify a classname when "
+
"using the -listener argument"
;
throw
new
BuildException
(
msg
)
;
}
}
else
if
(
arg
.
startsWith
(
"-D"
)
)
{
String
name
=
arg
.
substring
(
2
,
arg
.
length
(
)
)
;
String
value
=
null
;
int
posEq
=
name
.
indexOf
(
"="
)
;
if
(
posEq
>
0
)
{
value
=
name
.
substring
(
posEq
+
1
)
;
name
=
name
.
substring
(
0
,
posEq
)
;
}
else
if
(
i
<
args
.
length
-
1
)
{
value
=
args
[
++
i
]
;
}
else
{
throw
new
BuildException
(
"Missing value for property "
+
name
)
;
}
definedProps
.
put
(
name
,
value
)
;
}
else
if
(
arg
.
equals
(
"-logger"
)
)
{
if
(
loggerClassname
!=
null
)
{
throw
new
BuildException
(
"Only one logger class may "
+
" be specified."
)
;
}
try
{
loggerClassname
=
args
[
++
i
]
;
}
catch
(
ArrayIndexOutOfBoundsException
aioobe
)
{
throw
new
BuildException
(
"You must specify a classname when"
+
" using the -logger argument"
)
;
}
}
else
if
(
arg
.
equals
(
"-inputhandler"
)
)
{
if
(
inputHandlerClassname
!=
null
)
{
throw
new
BuildException
(
"Only one input handler class may "
+
"be specified."
)
;
}
try
{
inputHandlerClassname
=
args
[
++
i
]
;
}
catch
(
ArrayIndexOutOfBoundsException
aioobe
)
{
throw
new
BuildException
(
"You must specify a classname when"
+
" using the -inputhandler"
+
" argument"
)
;
}
}
else
if
(
arg
.
equals
(
"-emacs"
)
||
arg
.
equals
(
"-e"
)
)
{
emacsMode
=
true
;
}
else
if
(
arg
.
equals
(
"-projecthelp"
)
||
arg
.
equals
(
"-p"
)
)
{
projectHelp
=
true
;
}
else
if
(
arg
.
equals
(
"-find"
)
||
arg
.
equals
(
"-s"
)
)
{
if
(
i
<
args
.
length
-
1
)
{
searchForThis
=
args
[
++
i
]
;
}
else
{
searchForThis
=
DEFAULT_BUILD_FILENAME
;
}
}
else
if
(
arg
.
startsWith
(
"-propertyfile"
)
)
{
try
{
propertyFiles
.
addElement
(
args
[
i
+
1
]
)
;
i
++
;
}
catch
(
ArrayIndexOutOfBoundsException
aioobe
)
{
String
msg
=
"You must specify a property filename when "
+
"using the -propertyfile argument"
;
throw
new
BuildException
(
msg
)
;
}
}
else
if
(
arg
.
equals
(
"-k"
)
||
arg
.
equals
(
"-keep-going"
)
)
{
keepGoingMode
=
true
;
}
else
if
(
arg
.
startsWith
(
"-"
)
)
{
String
msg
=
"Unknown argument: "
+
arg
;
System
.
out
.
println
(
msg
)
;
printUsage
(
)
;
throw
new
BuildException
(
""
)
;
}
else
{
targets
.
addElement
(
arg
)
;
}
}
if
(
buildFile
==
null
)
{
if
(
searchForThis
!=
null
)
{
buildFile
=
findBuildFile
(
System
.
getProperty
(
"user.dir"
)
,
searchForThis
)
;
}
else
{
buildFile
=
new
File
(
DEFAULT_BUILD_FILENAME
)
;
}
}
if
(
!
buildFile
.
exists
(
)
)
{
System
.
out
.
println
(
"Buildfile: "
+
buildFile
+
" does not exist!"
)
;
throw
new
BuildException
(
"Build failed"
)
;
}
if
(
buildFile
.
isDirectory
(
)
)
{
System
.
out
.
println
(
"What? Buildfile: "
+
buildFile
+
" is a dir!"
)
;
throw
new
BuildException
(
"Build failed"
)
;
}
for
(
int
propertyFileIndex
=
0
;
propertyFileIndex
<
propertyFiles
.
size
(
)
;
propertyFileIndex
++
)
{
String
filename
=
(
String
)
propertyFiles
.
elementAt
(
propertyFileIndex
)
;
Properties
props
=
new
Properties
(
)
;
FileInputStream
fis
=
null
;
try
{
fis
=
new
FileInputStream
(
filename
)
;
props
.
load
(
fis
)
;
}
catch
(
IOException
e
)
{
System
.
out
.
println
(
"Could not load property file "
+
filename
+
": "
+
e
.
getMessage
(
)
)
;
}
finally
{
if
(
fis
!=
null
)
{
try
{
fis
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
}
Enumeration
propertyNames
=
props
.
propertyNames
(
)
;
while
(
propertyNames
.
hasMoreElements
(
)
)
{
String
name
=
(
String
)
propertyNames
.
nextElement
(
)
;
if
(
definedProps
.
getProperty
(
name
)
==
null
)
{
definedProps
.
put
(
name
,
props
.
getProperty
(
name
)
)
;
}
}
}
if
(
msgOutputLevel
>=
Project
.
MSG_INFO
)
{
System
.
out
.
println
(
"Buildfile: "
+
buildFile
)
;
}
if
(
logTo
!=
null
)
{
out
=
logTo
;
err
=
logTo
;
System
.
setOut
(
out
)
;
System
.
setErr
(
err
)
;
}
readyToRun
=
true
;
}
private
File
getParentFile
(
File
file
)
{
String
filename
=
file
.
getAbsolutePath
(
)
;
file
=
new
File
(
filename
)
;
filename
=
file
.
getParent
(
)
;
if
(
filename
!=
null
&&
msgOutputLevel
>=
Project
.
MSG_VERBOSE
)
{
System
.
out
.
println
(
"Searching in "
+
filename
)
;
}
return
(
filename
==
null
)
?
null
:
new
File
(
filename
)
;
}
private
File
findBuildFile
(
String
start
,
String
suffix
)
throws
BuildException
{
if
(
msgOutputLevel
>=
Project
.
MSG_INFO
)
{
System
.
out
.
println
(
"Searching for "
+
suffix
+
" ..."
)
;
}
File
parent
=
new
File
(
new
File
(
start
)
.
getAbsolutePath
(
)
)
;
File
file
=
new
File
(
parent
,
suffix
)
;
while
(
!
file
.
exists
(
)
)
{
parent
=
getParentFile
(
parent
)
;
if
(
parent
==
null
)
{
throw
new
BuildException
(
"Could not locate a build file!"
)
;
}
file
=
new
File
(
parent
,
suffix
)
;
}
return
file
;
}
private
void
runBuild
(
ClassLoader
coreLoader
)
throws
BuildException
{
if
(
!
readyToRun
)
{
return
;
}
final
Project
project
=
new
Project
(
)
;
project
.
setCoreLoader
(
coreLoader
)
;
Throwable
error
=
null
;
try
{
addBuildListeners
(
project
)
;
addInputHandler
(
project
)
;
PrintStream
err
=
System
.
err
;
PrintStream
out
=
System
.
out
;
InputStream
in
=
System
.
in
;
SecurityManager
oldsm
=
null
;
if
(
!
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_0
)
&&
!
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_1
)
)
{
oldsm
=
System
.
getSecurityManager
(
)
;
}
try
{
if
(
allowInput
)
{
project
.
setDefaultInputStream
(
System
.
in
)
;
}
System
.
setIn
(
new
DemuxInputStream
(
project
)
)
;
System
.
setOut
(
new
PrintStream
(
new
DemuxOutputStream
(
project
,
false
)
)
)
;
System
.
setErr
(
new
PrintStream
(
new
DemuxOutputStream
(
project
,
true
)
)
)
;
if
(
!
projectHelp
)
{
project
.
fireBuildStarted
(
)
;
}
project
.
init
(
)
;
project
.
setUserProperty
(
"ant.version"
,
getAntVersion
(
)
)
;
Enumeration
e
=
definedProps
.
keys
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
String
arg
=
(
String
)
e
.
nextElement
(
)
;
String
value
=
(
String
)
definedProps
.
get
(
arg
)
;
project
.
setUserProperty
(
arg
,
value
)
;
}
project
.
setUserProperty
(
"ant.file"
,
buildFile
.
getAbsolutePath
(
)
)
;
project
.
setKeepGoingMode
(
keepGoingMode
)
;
ProjectHelper
.
configureProject
(
project
,
buildFile
)
;
if
(
projectHelp
)
{
printDescription
(
project
)
;
printTargets
(
project
,
msgOutputLevel
>
Project
.
MSG_INFO
)
;
return
;
}
if
(
targets
.
size
(
)
==
0
)
{
if
(
project
.
getDefaultTarget
(
)
!=
null
)
{
targets
.
addElement
(
project
.
getDefaultTarget
(
)
)
;
}
}
project
.
executeTargets
(
targets
)
;
}
finally
{
if
(
oldsm
!=
null
)
{
System
.
setSecurityManager
(
oldsm
)
;
}
System
.
setOut
(
out
)
;
System
.
setErr
(
err
)
;
System
.
setIn
(
in
)
;
}
}
catch
(
RuntimeException
exc
)
{
error
=
exc
;
throw
exc
;
}
catch
(
Error
err
)
{
error
=
err
;
throw
err
;
}
finally
{
if
(
!
projectHelp
)
{
project
.
fireBuildFinished
(
error
)
;
}
}
}
protected
void
addBuildListeners
(
Project
project
)
{
project
.
addBuildListener
(
createLogger
(
)
)
;
for
(
int
i
=
0
;
i
<
listeners
.
size
(
)
;
i
++
)
{
String
className
=
(
String
)
listeners
.
elementAt
(
i
)
;
try
{
BuildListener
listener
=
(
BuildListener
)
Class
.
forName
(
className
)
.
newInstance
(
)
;
if
(
project
!=
null
)
{
project
.
setProjectReference
(
listener
)
;
}
project
.
addBuildListener
(
listener
)
;
}
catch
(
Throwable
exc
)
{
throw
new
BuildException
(
"Unable to instantiate listener "
+
className
,
exc
)
;
}
}
}
private
void
addInputHandler
(
Project
project
)
throws
BuildException
{
InputHandler
handler
=
null
;
if
(
inputHandlerClassname
==
null
)
{
handler
=
new
DefaultInputHandler
(
)
;
}
else
{
try
{
handler
=
(
InputHandler
)
(
Class
.
forName
(
inputHandlerClassname
)
.
newInstance
(
)
)
;
if
(
project
!=
null
)
{
project
.
setProjectReference
(
handler
)
;
}
}
catch
(
ClassCastException
e
)
{
String
msg
=
"The specified input handler class "
+
inputHandlerClassname
+
" does not implement the InputHandler interface"
;
throw
new
BuildException
(
msg
)
;
}
catch
(
Exception
e
)
{
String
msg
=
"Unable to instantiate specified input handler "
+
"class "
+
inputHandlerClassname
+
" : "
+
e
.
getClass
(
)
.
getName
(
)
;
throw
new
BuildException
(
msg
)
;
}
}
project
.
setInputHandler
(
handler
)
;
}
private
BuildLogger
createLogger
(
)
{
BuildLogger
logger
=
null
;
if
(
loggerClassname
!=
null
)
{
try
{
Class
loggerClass
=
Class
.
forName
(
loggerClassname
)
;
logger
=
(
BuildLogger
)
(
loggerClass
.
newInstance
(
)
)
;
}
catch
(
ClassCastException
e
)
{
System
.
err
.
println
(
"The specified logger class "
+
loggerClassname
+
" does not implement the BuildLogger interface"
)
;
throw
new
RuntimeException
(
)
;
}
catch
(
Exception
e
)
{
System
.
err
.
println
(
"Unable to instantiate specified logger "
+
"class "
+
loggerClassname
+
" : "
+
e
.
getClass
(
)
.
getName
(
)
)
;
throw
new
RuntimeException
(
)
;
}
}
else
{
logger
=
new
DefaultLogger
(
)
;
}
logger
.
setMessageOutputLevel
(
msgOutputLevel
)
;
logger
.
setOutputPrintStream
(
out
)
;
logger
.
setErrorPrintStream
(
err
)
;
logger
.
setEmacsMode
(
emacsMode
)
;
return
logger
;
}
private
static
void
printUsage
(
)
{
String
lSep
=
System
.
getProperty
(
"line.separator"
)
;
StringBuffer
msg
=
new
StringBuffer
(
)
;
msg
.
append
(
"ant [options] [target [target2 [target3] ...]]"
+
lSep
)
;
msg
.
append
(
"Options: "
+
lSep
)
;
msg
.
append
(
"  -help, -h              print this message"
+
lSep
)
;
msg
.
append
(
"  -projecthelp, -p       print project help information"
+
lSep
)
;
msg
.
append
(
"  -version               print the version information and exit"
+
lSep
)
;
msg
.
append
(
"  -diagnostics           print information that might be helpful to"
+
lSep
)
;
msg
.
append
(
"                         diagnose or report problems."
+
lSep
)
;
msg
.
append
(
"  -quiet, -q             be extra quiet"
+
lSep
)
;
msg
.
append
(
"  -verbose, -v           be extra verbose"
+
lSep
)
;
msg
.
append
(
"  -debug, -d             print debugging information"
+
lSep
)
;
msg
.
append
(
"  -emacs, -e             produce logging information without adornments"
+
lSep
)
;
msg
.
append
(
"  -lib <path>            specifies a path to search for jars and classes"
+
lSep
)
;
msg
.
append
(
"  -logfile <file>        use given file for log"
+
lSep
)
;
msg
.
append
(
"    -l     <file>                ''"
+
lSep
)
;
msg
.
append
(
"  -logger <classname>    the class which is to perform logging"
+
lSep
)
;
msg
.
append
(
"  -listener <classname>  add an instance of class as a project listener"
+
lSep
)
;
msg
.
append
(
"  -noinput               do not allow interactive input"
+
lSep
)
;
msg
.
append
(
"  -buildfile <file>      use given buildfile"
+
lSep
)
;
msg
.
append
(
"    -file    <file>              ''"
+
lSep
)
;
msg
.
append
(
"    -f       <file>              ''"
+
lSep
)
;
msg
.
append
(
"  -D<property>=<value>   use value for given property"
+
lSep
)
;
msg
.
append
(
"  -keep-going, -k        execute all targets that do not depend"
+
lSep
)
;
msg
.
append
(
"                         on failed target(s)"
+
lSep
)
;
msg
.
append
(
"  -propertyfile <name>   load all properties from file with -D"
+
lSep
)
;
msg
.
append
(
"                         properties taking precedence"
+
lSep
)
;
msg
.
append
(
"  -inputhandler <class>  the class which will handle input requests"
+
lSep
)
;
msg
.
append
(
"  -find <file>           (s)earch for buildfile towards the root of"
+
lSep
)
;
msg
.
append
(
"    -s  <file>           the filesystem and use it"
+
lSep
)
;
System
.
out
.
println
(
msg
.
toString
(
)
)
;
}
private
static
void
printVersion
(
)
throws
BuildException
{
System
.
out
.
println
(
getAntVersion
(
)
)
;
}
private
static
String
antVersion
=
null
;
public
static
synchronized
String
getAntVersion
(
)
throws
BuildException
{
if
(
antVersion
==
null
)
{
try
{
Properties
props
=
new
Properties
(
)
;
InputStream
in
=
Main
.
class
.
getResourceAsStream
(
"/org/apache/tools/ant/version.txt"
)
;
props
.
load
(
in
)
;
in
.
close
(
)
;
StringBuffer
msg
=
new
StringBuffer
(
)
;
msg
.
append
(
"Apache Ant version "
)
;
msg
.
append
(
props
.
getProperty
(
"VERSION"
)
)
;
msg
.
append
(
" compiled on "
)
;
msg
.
append
(
props
.
getProperty
(
"DATE"
)
)
;
antVersion
=
msg
.
toString
(
)
;
}
catch
(
IOException
ioe
)
{
throw
new
BuildException
(
"Could not load the version information:"
+
ioe
.
getMessage
(
)
)
;
}
catch
(
NullPointerException
npe
)
{
throw
new
BuildException
(
"Could not load the version information."
)
;
}
}
return
antVersion
;
}
private
static
void
printDescription
(
Project
project
)
{
if
(
project
.
getDescription
(
)
!=
null
)
{
project
.
log
(
project
.
getDescription
(
)
)
;
}
}
private
static
void
printTargets
(
Project
project
,
boolean
printSubTargets
)
{
int
maxLength
=
0
;
Enumeration
ptargets
=
project
.
getTargets
(
)
.
elements
(
)
;
String
targetName
;
String
targetDescription
;
Target
currentTarget
;
Vector
topNames
=
new
Vector
(
)
;
Vector
topDescriptions
=
new
Vector
(
)
;
Vector
subNames
=
new
Vector
(
)
;
while
(
ptargets
.
hasMoreElements
(
)
)
{
currentTarget
=
(
Target
)
ptargets
.
nextElement
(
)
;
targetName
=
currentTarget
.
getName
(
)
;
if
(
targetName
.
equals
(
""
)
)
{
continue
;
}
targetDescription
=
currentTarget
.
getDescription
(
)
;
if
(
targetDescription
==
null
)
{
int
pos
=
findTargetPosition
(
subNames
,
targetName
)
;
subNames
.
insertElementAt
(
targetName
,
pos
)
;
}
else
{
int
pos
=
findTargetPosition
(
topNames
,
targetName
)
;
topNames
.
insertElementAt
(
targetName
,
pos
)
;
topDescriptions
.
insertElementAt
(
targetDescription
,
pos
)
;
if
(
targetName
.
length
(
)
>
maxLength
)
{
maxLength
=
targetName
.
length
(
)
;
}
}
}
printTargets
(
project
,
topNames
,
topDescriptions
,
"Main targets:"
,
maxLength
)
;
if
(
topNames
.
size
(
)
==
0
)
{
printSubTargets
=
true
;
}
if
(
printSubTargets
)
{
printTargets
(
project
,
subNames
,
null
,
"Other targets:"
,
0
)
;
}
String
defaultTarget
=
project
.
getDefaultTarget
(
)
;
if
(
defaultTarget
!=
null
&&
!
""
.
equals
(
defaultTarget
)
)
{
project
.
log
(
"Default target: "
+
defaultTarget
)
;
}
}
private
static
int
findTargetPosition
(
Vector
names
,
String
name
)
{
int
res
=
names
.
size
(
)
;
for
(
int
i
=
0
;
i
<
names
.
size
(
)
&&
res
==
names
.
size
(
)
;
i
++
)
{
if
(
name
.
compareTo
(
(
String
)
names
.
elementAt
(
i
)
)
<
0
)
{
res
=
i
;
}
}
return
res
;
}
private
static
void
printTargets
(
Project
project
,
Vector
names
,
Vector
descriptions
,
String
heading
,
int
maxlen
)
{
String
lSep
=
System
.
getProperty
(
"line.separator"
)
;
String
spaces
=
"    "
;
while
(
spaces
.
length
(
)
<=
maxlen
)
{
spaces
+=
spaces
;
}
StringBuffer
msg
=
new
StringBuffer
(
)
;
msg
.
append
(
heading
+
lSep
+
lSep
)
;
for
(
int
i
=
0
;
i
<
names
.
size
(
)
;
i
++
)
{
msg
.
append
(
" "
)
;
msg
.
append
(
names
.
elementAt
(
i
)
)
;
if
(
descriptions
!=
null
)
{
msg
.
append
(
spaces
.
substring
(
0
,
maxlen
-
(
(
String
)
names
.
elementAt
(
i
)
)
.
length
(
)
+
2
)
)
;
msg
.
append
(
descriptions
.
elementAt
(
i
)
)
;
}
msg
.
append
(
lSep
)
;
}
project
.
log
(
msg
.
toString
(
)
)
;
}
}
