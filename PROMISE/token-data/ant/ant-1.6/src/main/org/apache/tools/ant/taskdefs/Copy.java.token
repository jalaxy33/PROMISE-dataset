package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
org
.
apache
.
tools
.
ant
.
types
.
FilterChain
;
import
org
.
apache
.
tools
.
ant
.
types
.
FilterSet
;
import
org
.
apache
.
tools
.
ant
.
types
.
FilterSetCollection
;
import
org
.
apache
.
tools
.
ant
.
types
.
Mapper
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileNameMapper
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
import
org
.
apache
.
tools
.
ant
.
util
.
FlatFileNameMapper
;
import
org
.
apache
.
tools
.
ant
.
util
.
IdentityMapper
;
import
org
.
apache
.
tools
.
ant
.
util
.
SourceFileScanner
;
public
class
Copy
extends
Task
{
protected
File
file
=
null
;
protected
File
destFile
=
null
;
protected
File
destDir
=
null
;
protected
Vector
filesets
=
new
Vector
(
)
;
private
boolean
enableMultipleMappings
=
false
;
protected
boolean
filtering
=
false
;
protected
boolean
preserveLastModified
=
false
;
protected
boolean
forceOverwrite
=
false
;
protected
boolean
flatten
=
false
;
protected
int
verbosity
=
Project
.
MSG_VERBOSE
;
protected
boolean
includeEmpty
=
true
;
private
boolean
failonerror
=
true
;
protected
Hashtable
fileCopyMap
=
new
Hashtable
(
)
;
protected
Hashtable
dirCopyMap
=
new
Hashtable
(
)
;
protected
Hashtable
completeDirMap
=
new
Hashtable
(
)
;
protected
Mapper
mapperElement
=
null
;
private
Vector
filterChains
=
new
Vector
(
)
;
private
Vector
filterSets
=
new
Vector
(
)
;
private
FileUtils
fileUtils
;
private
String
inputEncoding
=
null
;
private
String
outputEncoding
=
null
;
public
Copy
(
)
{
fileUtils
=
FileUtils
.
newFileUtils
(
)
;
}
protected
FileUtils
getFileUtils
(
)
{
return
fileUtils
;
}
public
void
setFile
(
File
file
)
{
this
.
file
=
file
;
}
public
void
setTofile
(
File
destFile
)
{
this
.
destFile
=
destFile
;
}
public
void
setTodir
(
File
destDir
)
{
this
.
destDir
=
destDir
;
}
public
FilterChain
createFilterChain
(
)
{
FilterChain
filterChain
=
new
FilterChain
(
)
;
filterChains
.
addElement
(
filterChain
)
;
return
filterChain
;
}
public
FilterSet
createFilterSet
(
)
{
FilterSet
filterSet
=
new
FilterSet
(
)
;
filterSets
.
addElement
(
filterSet
)
;
return
filterSet
;
}
public
void
setPreserveLastModified
(
String
preserve
)
{
setPreserveLastModified
(
Project
.
toBoolean
(
preserve
)
)
;
}
public
void
setPreserveLastModified
(
boolean
preserve
)
{
preserveLastModified
=
preserve
;
}
public
boolean
getPreserveLastModified
(
)
{
return
preserveLastModified
;
}
protected
Vector
getFilterSets
(
)
{
return
filterSets
;
}
protected
Vector
getFilterChains
(
)
{
return
filterChains
;
}
public
void
setFiltering
(
boolean
filtering
)
{
this
.
filtering
=
filtering
;
}
public
void
setOverwrite
(
boolean
overwrite
)
{
this
.
forceOverwrite
=
overwrite
;
}
public
void
setFlatten
(
boolean
flatten
)
{
this
.
flatten
=
flatten
;
}
public
void
setVerbose
(
boolean
verbose
)
{
if
(
verbose
)
{
this
.
verbosity
=
Project
.
MSG_INFO
;
}
else
{
this
.
verbosity
=
Project
.
MSG_VERBOSE
;
}
}
public
void
setIncludeEmptyDirs
(
boolean
includeEmpty
)
{
this
.
includeEmpty
=
includeEmpty
;
}
public
void
setEnableMultipleMappings
(
boolean
enableMultipleMappings
)
{
this
.
enableMultipleMappings
=
enableMultipleMappings
;
}
public
boolean
isEnableMultipleMapping
(
)
{
return
enableMultipleMappings
;
}
public
void
setFailOnError
(
boolean
failonerror
)
{
this
.
failonerror
=
failonerror
;
}
public
void
addFileset
(
FileSet
set
)
{
filesets
.
addElement
(
set
)
;
}
public
Mapper
createMapper
(
)
throws
BuildException
{
if
(
mapperElement
!=
null
)
{
throw
new
BuildException
(
"Cannot define more than one mapper"
,
getLocation
(
)
)
;
}
mapperElement
=
new
Mapper
(
getProject
(
)
)
;
return
mapperElement
;
}
public
void
setEncoding
(
String
encoding
)
{
this
.
inputEncoding
=
encoding
;
if
(
outputEncoding
==
null
)
{
outputEncoding
=
encoding
;
}
}
public
String
getEncoding
(
)
{
return
inputEncoding
;
}
public
void
setOutputEncoding
(
String
encoding
)
{
this
.
outputEncoding
=
encoding
;
}
public
String
getOutputEncoding
(
)
{
return
outputEncoding
;
}
public
void
execute
(
)
throws
BuildException
{
File
savedFile
=
file
;
File
savedDestFile
=
destFile
;
File
savedDestDir
=
destDir
;
FileSet
savedFileSet
=
null
;
if
(
file
==
null
&&
destFile
!=
null
&&
filesets
.
size
(
)
==
1
)
{
savedFileSet
=
(
FileSet
)
filesets
.
elementAt
(
0
)
;
}
validateAttributes
(
)
;
try
{
if
(
file
!=
null
)
{
if
(
file
.
exists
(
)
)
{
if
(
destFile
==
null
)
{
destFile
=
new
File
(
destDir
,
file
.
getName
(
)
)
;
}
if
(
forceOverwrite
||
!
destFile
.
exists
(
)
||
(
file
.
lastModified
(
)
>
destFile
.
lastModified
(
)
)
)
{
fileCopyMap
.
put
(
file
.
getAbsolutePath
(
)
,
new
String
[
]
{
destFile
.
getAbsolutePath
(
)
}
)
;
}
else
{
log
(
file
+
" omitted as "
+
destFile
+
" is up to date."
,
Project
.
MSG_VERBOSE
)
;
}
}
else
{
String
message
=
"Warning: Could not find file "
+
file
.
getAbsolutePath
(
)
+
" to copy."
;
if
(
!
failonerror
)
{
log
(
message
)
;
}
else
{
throw
new
BuildException
(
message
)
;
}
}
}
for
(
int
i
=
0
;
i
<
filesets
.
size
(
)
;
i
++
)
{
FileSet
fs
=
(
FileSet
)
filesets
.
elementAt
(
i
)
;
DirectoryScanner
ds
=
null
;
try
{
ds
=
fs
.
getDirectoryScanner
(
getProject
(
)
)
;
}
catch
(
BuildException
e
)
{
if
(
failonerror
||
!
e
.
getMessage
(
)
.
endsWith
(
" not found."
)
)
{
throw
e
;
}
else
{
log
(
"Warning: "
+
e
.
getMessage
(
)
)
;
continue
;
}
}
File
fromDir
=
fs
.
getDir
(
getProject
(
)
)
;
String
[
]
srcFiles
=
ds
.
getIncludedFiles
(
)
;
String
[
]
srcDirs
=
ds
.
getIncludedDirectories
(
)
;
boolean
isEverythingIncluded
=
ds
.
isEverythingIncluded
(
)
&&
(
!
fs
.
hasSelectors
(
)
&&
!
fs
.
hasPatterns
(
)
)
;
if
(
isEverythingIncluded
&&
!
flatten
&&
mapperElement
==
null
)
{
completeDirMap
.
put
(
fromDir
,
destDir
)
;
}
scan
(
fromDir
,
destDir
,
srcFiles
,
srcDirs
)
;
}
try
{
doFileOperations
(
)
;
}
catch
(
BuildException
e
)
{
if
(
!
failonerror
)
{
log
(
"Warning: "
+
e
.
getMessage
(
)
,
Project
.
MSG_ERR
)
;
}
else
{
throw
e
;
}
}
}
finally
{
file
=
savedFile
;
destFile
=
savedDestFile
;
destDir
=
savedDestDir
;
if
(
savedFileSet
!=
null
)
{
filesets
.
insertElementAt
(
savedFileSet
,
0
)
;
}
fileCopyMap
.
clear
(
)
;
dirCopyMap
.
clear
(
)
;
completeDirMap
.
clear
(
)
;
}
}
protected
void
validateAttributes
(
)
throws
BuildException
{
if
(
file
==
null
&&
filesets
.
size
(
)
==
0
)
{
throw
new
BuildException
(
"Specify at least one source "
+
"- a file or a fileset."
)
;
}
if
(
destFile
!=
null
&&
destDir
!=
null
)
{
throw
new
BuildException
(
"Only one of tofile and todir "
+
"may be set."
)
;
}
if
(
destFile
==
null
&&
destDir
==
null
)
{
throw
new
BuildException
(
"One of tofile or todir must be set."
)
;
}
if
(
file
!=
null
&&
file
.
exists
(
)
&&
file
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"Use a fileset to copy directories."
)
;
}
if
(
destFile
!=
null
&&
filesets
.
size
(
)
>
0
)
{
if
(
filesets
.
size
(
)
>
1
)
{
throw
new
BuildException
(
"Cannot concatenate multiple files into a single file."
)
;
}
else
{
FileSet
fs
=
(
FileSet
)
filesets
.
elementAt
(
0
)
;
DirectoryScanner
ds
=
fs
.
getDirectoryScanner
(
getProject
(
)
)
;
String
[
]
srcFiles
=
ds
.
getIncludedFiles
(
)
;
if
(
srcFiles
.
length
==
0
)
{
throw
new
BuildException
(
"Cannot perform operation from directory to file."
)
;
}
else
if
(
srcFiles
.
length
==
1
)
{
if
(
file
==
null
)
{
file
=
new
File
(
ds
.
getBasedir
(
)
,
srcFiles
[
0
]
)
;
filesets
.
removeElementAt
(
0
)
;
}
else
{
throw
new
BuildException
(
"Cannot concatenate multiple "
+
"files into a single file."
)
;
}
}
else
{
throw
new
BuildException
(
"Cannot concatenate multiple "
+
"files into a single file."
)
;
}
}
}
if
(
destFile
!=
null
)
{
destDir
=
fileUtils
.
getParentFile
(
destFile
)
;
}
}
protected
void
scan
(
File
fromDir
,
File
toDir
,
String
[
]
files
,
String
[
]
dirs
)
{
FileNameMapper
mapper
=
null
;
if
(
mapperElement
!=
null
)
{
mapper
=
mapperElement
.
getImplementation
(
)
;
}
else
if
(
flatten
)
{
mapper
=
new
FlatFileNameMapper
(
)
;
}
else
{
mapper
=
new
IdentityMapper
(
)
;
}
buildMap
(
fromDir
,
toDir
,
files
,
mapper
,
fileCopyMap
)
;
if
(
includeEmpty
)
{
buildMap
(
fromDir
,
toDir
,
dirs
,
mapper
,
dirCopyMap
)
;
}
}
protected
void
buildMap
(
File
fromDir
,
File
toDir
,
String
[
]
names
,
FileNameMapper
mapper
,
Hashtable
map
)
{
String
[
]
toCopy
=
null
;
if
(
forceOverwrite
)
{
Vector
v
=
new
Vector
(
)
;
for
(
int
i
=
0
;
i
<
names
.
length
;
i
++
)
{
if
(
mapper
.
mapFileName
(
names
[
i
]
)
!=
null
)
{
v
.
addElement
(
names
[
i
]
)
;
}
}
toCopy
=
new
String
[
v
.
size
(
)
]
;
v
.
copyInto
(
toCopy
)
;
}
else
{
SourceFileScanner
ds
=
new
SourceFileScanner
(
this
)
;
toCopy
=
ds
.
restrict
(
names
,
fromDir
,
toDir
,
mapper
)
;
}
for
(
int
i
=
0
;
i
<
toCopy
.
length
;
i
++
)
{
File
src
=
new
File
(
fromDir
,
toCopy
[
i
]
)
;
String
[
]
mappedFiles
=
mapper
.
mapFileName
(
toCopy
[
i
]
)
;
if
(
!
enableMultipleMappings
)
{
map
.
put
(
src
.
getAbsolutePath
(
)
,
new
String
[
]
{
new
File
(
toDir
,
mappedFiles
[
0
]
)
.
getAbsolutePath
(
)
}
)
;
}
else
{
for
(
int
k
=
0
;
k
<
mappedFiles
.
length
;
k
++
)
{
mappedFiles
[
k
]
=
new
File
(
toDir
,
mappedFiles
[
k
]
)
.
getAbsolutePath
(
)
;
}
map
.
put
(
src
.
getAbsolutePath
(
)
,
mappedFiles
)
;
}
}
}
protected
void
doFileOperations
(
)
{
if
(
fileCopyMap
.
size
(
)
>
0
)
{
log
(
"Copying "
+
fileCopyMap
.
size
(
)
+
" file"
+
(
fileCopyMap
.
size
(
)
==
1
?
""
:
"s"
)
+
" to "
+
destDir
.
getAbsolutePath
(
)
)
;
Enumeration
e
=
fileCopyMap
.
keys
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
String
fromFile
=
(
String
)
e
.
nextElement
(
)
;
String
[
]
toFiles
=
(
String
[
]
)
fileCopyMap
.
get
(
fromFile
)
;
for
(
int
i
=
0
;
i
<
toFiles
.
length
;
i
++
)
{
String
toFile
=
toFiles
[
i
]
;
if
(
fromFile
.
equals
(
toFile
)
)
{
log
(
"Skipping self-copy of "
+
fromFile
,
verbosity
)
;
continue
;
}
try
{
log
(
"Copying "
+
fromFile
+
" to "
+
toFile
,
verbosity
)
;
FilterSetCollection
executionFilters
=
new
FilterSetCollection
(
)
;
if
(
filtering
)
{
executionFilters
.
addFilterSet
(
getProject
(
)
.
getGlobalFilterSet
(
)
)
;
}
for
(
Enumeration
filterEnum
=
filterSets
.
elements
(
)
;
filterEnum
.
hasMoreElements
(
)
;
)
{
executionFilters
.
addFilterSet
(
(
FilterSet
)
filterEnum
.
nextElement
(
)
)
;
}
fileUtils
.
copyFile
(
fromFile
,
toFile
,
executionFilters
,
filterChains
,
forceOverwrite
,
preserveLastModified
,
inputEncoding
,
outputEncoding
,
getProject
(
)
)
;
}
catch
(
IOException
ioe
)
{
String
msg
=
"Failed to copy "
+
fromFile
+
" to "
+
toFile
+
" due to "
+
ioe
.
getMessage
(
)
;
File
targetFile
=
new
File
(
toFile
)
;
if
(
targetFile
.
exists
(
)
&&
!
targetFile
.
delete
(
)
)
{
msg
+=
" and I couldn't delete the corrupt "
+
toFile
;
}
throw
new
BuildException
(
msg
,
ioe
,
getLocation
(
)
)
;
}
}
}
}
if
(
includeEmpty
)
{
Enumeration
e
=
dirCopyMap
.
elements
(
)
;
int
createCount
=
0
;
while
(
e
.
hasMoreElements
(
)
)
{
String
[
]
dirs
=
(
String
[
]
)
e
.
nextElement
(
)
;
for
(
int
i
=
0
;
i
<
dirs
.
length
;
i
++
)
{
File
d
=
new
File
(
dirs
[
i
]
)
;
if
(
!
d
.
exists
(
)
)
{
if
(
!
d
.
mkdirs
(
)
)
{
log
(
"Unable to create directory "
+
d
.
getAbsolutePath
(
)
,
Project
.
MSG_ERR
)
;
}
else
{
createCount
++
;
}
}
}
}
if
(
createCount
>
0
)
{
log
(
"Copied "
+
dirCopyMap
.
size
(
)
+
" empty director"
+
(
dirCopyMap
.
size
(
)
==
1
?
"y"
:
"ies"
)
+
" to "
+
createCount
+
" empty director"
+
(
createCount
==
1
?
"y"
:
"ies"
)
+
" under "
+
destDir
.
getAbsolutePath
(
)
)
;
}
}
}
}
