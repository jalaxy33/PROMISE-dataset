package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
File
;
import
java
.
util
.
Hashtable
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileNameMapper
;
import
org
.
apache
.
tools
.
ant
.
util
.
IdentityMapper
;
public
class
Sync
extends
Task
{
private
MyCopy
_copy
;
public
void
init
(
)
throws
BuildException
{
_copy
=
new
MyCopy
(
)
;
configureTask
(
_copy
)
;
_copy
.
setFiltering
(
false
)
;
_copy
.
setIncludeEmptyDirs
(
false
)
;
_copy
.
setPreserveLastModified
(
true
)
;
}
private
void
configureTask
(
Task
helper
)
{
helper
.
setProject
(
getProject
(
)
)
;
helper
.
setTaskName
(
getTaskName
(
)
)
;
helper
.
setOwningTarget
(
getOwningTarget
(
)
)
;
helper
.
init
(
)
;
}
public
void
execute
(
)
throws
BuildException
{
File
toDir
=
_copy
.
getToDir
(
)
;
Hashtable
allFiles
=
_copy
.
_dest2src
;
boolean
noRemovalNecessary
=
!
toDir
.
exists
(
)
||
toDir
.
list
(
)
.
length
<
1
;
log
(
"PASS#1: Copying files to "
+
toDir
,
Project
.
MSG_DEBUG
)
;
_copy
.
execute
(
)
;
if
(
noRemovalNecessary
)
{
log
(
"NO removing necessary in "
+
toDir
,
Project
.
MSG_DEBUG
)
;
return
;
}
log
(
"PASS#2: Removing orphan files from "
+
toDir
,
Project
.
MSG_DEBUG
)
;
int
[
]
removedFileCount
=
removeOrphanFiles
(
allFiles
,
toDir
)
;
logRemovedCount
(
removedFileCount
[
0
]
,
"dangling director"
,
"y"
,
"ies"
)
;
logRemovedCount
(
removedFileCount
[
1
]
,
"dangling file"
,
""
,
"s"
)
;
if
(
!
_copy
.
getIncludeEmptyDirs
(
)
)
{
log
(
"PASS#3: Removing empty directories from "
+
toDir
,
Project
.
MSG_DEBUG
)
;
int
removedDirCount
=
removeEmptyDirectories
(
toDir
,
false
)
;
logRemovedCount
(
removedDirCount
,
"empty director"
,
"y"
,
"ies"
)
;
}
}
private
void
logRemovedCount
(
int
count
,
String
prefix
,
String
singularSuffix
,
String
pluralSuffix
)
{
File
toDir
=
_copy
.
getToDir
(
)
;
String
what
=
(
prefix
==
null
)
?
""
:
prefix
;
what
+=
(
count
<
2
)
?
singularSuffix
:
pluralSuffix
;
if
(
count
>
0
)
{
log
(
"Removed "
+
count
+
" "
+
what
+
" from "
+
toDir
,
Project
.
MSG_INFO
)
;
}
else
{
log
(
"NO "
+
what
+
" to remove from "
+
toDir
,
Project
.
MSG_VERBOSE
)
;
}
}
private
int
[
]
removeOrphanFiles
(
Hashtable
nonOrphans
,
File
file
)
{
int
[
]
removedCount
=
new
int
[
]
{
0
,
0
,
0
}
;
if
(
file
.
isDirectory
(
)
)
{
File
[
]
children
=
file
.
listFiles
(
)
;
for
(
int
i
=
0
;
i
<
children
.
length
;
++
i
)
{
int
[
]
temp
=
removeOrphanFiles
(
nonOrphans
,
children
[
i
]
)
;
removedCount
[
0
]
+=
temp
[
0
]
;
removedCount
[
1
]
+=
temp
[
1
]
;
removedCount
[
2
]
+=
temp
[
2
]
;
}
if
(
nonOrphans
.
get
(
file
)
==
null
&&
removedCount
[
2
]
==
0
)
{
log
(
"Removing orphan directory: "
+
file
,
Project
.
MSG_DEBUG
)
;
file
.
delete
(
)
;
++
removedCount
[
0
]
;
}
else
{
removedCount
[
2
]
=
1
;
}
}
else
{
if
(
nonOrphans
.
get
(
file
)
==
null
)
{
log
(
"Removing orphan file: "
+
file
,
Project
.
MSG_DEBUG
)
;
file
.
delete
(
)
;
++
removedCount
[
1
]
;
}
else
{
removedCount
[
2
]
=
1
;
}
}
return
removedCount
;
}
private
int
removeEmptyDirectories
(
File
dir
,
boolean
removeIfEmpty
)
{
int
removedCount
=
0
;
if
(
dir
.
isDirectory
(
)
)
{
File
[
]
children
=
dir
.
listFiles
(
)
;
for
(
int
i
=
0
;
i
<
children
.
length
;
++
i
)
{
File
file
=
children
[
i
]
;
if
(
file
.
isDirectory
(
)
)
{
removedCount
+=
removeEmptyDirectories
(
file
,
true
)
;
}
}
if
(
children
.
length
>
0
)
{
children
=
dir
.
listFiles
(
)
;
}
if
(
children
.
length
<
1
&&
removeIfEmpty
)
{
log
(
"Removing empty directory: "
+
dir
,
Project
.
MSG_DEBUG
)
;
dir
.
delete
(
)
;
++
removedCount
;
}
}
return
removedCount
;
}
public
void
setTodir
(
File
destDir
)
{
_copy
.
setTodir
(
destDir
)
;
}
public
void
setVerbose
(
boolean
verbose
)
{
_copy
.
setVerbose
(
verbose
)
;
}
public
void
setOverwrite
(
boolean
overwrite
)
{
_copy
.
setOverwrite
(
overwrite
)
;
}
public
void
setIncludeEmptyDirs
(
boolean
includeEmpty
)
{
_copy
.
setIncludeEmptyDirs
(
includeEmpty
)
;
}
public
void
setFailOnError
(
boolean
failonerror
)
{
_copy
.
setFailOnError
(
failonerror
)
;
}
public
void
addFileset
(
FileSet
set
)
{
_copy
.
addFileset
(
set
)
;
}
public
static
class
MyCopy
extends
Copy
{
private
Hashtable
_dest2src
=
new
Hashtable
(
)
;
public
MyCopy
(
)
{
}
protected
void
buildMap
(
File
fromDir
,
File
toDir
,
String
[
]
names
,
FileNameMapper
mapper
,
Hashtable
map
)
{
assertTrue
(
"No mapper"
,
mapper
instanceof
IdentityMapper
)
;
super
.
buildMap
(
fromDir
,
toDir
,
names
,
mapper
,
map
)
;
for
(
int
i
=
0
;
i
<
names
.
length
;
++
i
)
{
String
name
=
names
[
i
]
;
File
dest
=
new
File
(
toDir
,
name
)
;
_dest2src
.
put
(
dest
,
fromDir
)
;
}
}
public
File
getToDir
(
)
{
return
destDir
;
}
public
boolean
getIncludeEmptyDirs
(
)
{
return
includeEmpty
;
}
}
private
static
void
assertTrue
(
String
message
,
boolean
condition
)
{
if
(
!
condition
)
{
throw
new
BuildException
(
"Assertion Error: "
+
message
)
;
}
}
}
