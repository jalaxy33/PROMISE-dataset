package
org
.
apache
.
tools
.
ant
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
EOFException
;
import
java
.
io
.
InputStream
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
lang
.
reflect
.
Modifier
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Properties
;
import
java
.
util
.
Stack
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Set
;
import
java
.
util
.
HashSet
;
import
org
.
apache
.
tools
.
ant
.
input
.
DefaultInputHandler
;
import
org
.
apache
.
tools
.
ant
.
input
.
InputHandler
;
import
org
.
apache
.
tools
.
ant
.
types
.
FilterSet
;
import
org
.
apache
.
tools
.
ant
.
types
.
FilterSetCollection
;
import
org
.
apache
.
tools
.
ant
.
types
.
Description
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
import
org
.
apache
.
tools
.
ant
.
util
.
JavaEnvUtils
;
import
org
.
apache
.
tools
.
ant
.
util
.
StringUtils
;
public
class
Project
{
public
static
final
int
MSG_ERR
=
0
;
public
static
final
int
MSG_WARN
=
1
;
public
static
final
int
MSG_INFO
=
2
;
public
static
final
int
MSG_VERBOSE
=
3
;
public
static
final
int
MSG_DEBUG
=
4
;
private
static
final
String
VISITING
=
"VISITING"
;
private
static
final
String
VISITED
=
"VISITED"
;
private
static
final
String
ANTCLASSLOADER_JDK12
=
"org.apache.tools.ant.loader.AntClassLoader2"
;
public
static
final
String
JAVA_1_0
=
JavaEnvUtils
.
JAVA_1_0
;
public
static
final
String
JAVA_1_1
=
JavaEnvUtils
.
JAVA_1_1
;
public
static
final
String
JAVA_1_2
=
JavaEnvUtils
.
JAVA_1_2
;
public
static
final
String
JAVA_1_3
=
JavaEnvUtils
.
JAVA_1_3
;
public
static
final
String
JAVA_1_4
=
JavaEnvUtils
.
JAVA_1_4
;
public
static
final
String
TOKEN_START
=
FilterSet
.
DEFAULT_TOKEN_START
;
public
static
final
String
TOKEN_END
=
FilterSet
.
DEFAULT_TOKEN_END
;
private
String
name
;
private
String
description
;
private
Hashtable
references
=
new
AntRefTable
(
this
)
;
private
String
defaultTarget
;
private
Hashtable
targets
=
new
Hashtable
(
)
;
private
FilterSet
globalFilterSet
=
new
FilterSet
(
)
;
private
FilterSetCollection
globalFilters
=
new
FilterSetCollection
(
globalFilterSet
)
;
private
File
baseDir
;
private
Vector
listeners
=
new
Vector
(
)
;
private
ClassLoader
coreLoader
=
null
;
private
Hashtable
threadTasks
=
new
Hashtable
(
)
;
private
Hashtable
threadGroupTasks
=
new
Hashtable
(
)
;
private
InputHandler
inputHandler
=
null
;
private
InputStream
defaultInputStream
=
null
;
private
boolean
keepGoingMode
=
false
;
public
void
setInputHandler
(
InputHandler
handler
)
{
inputHandler
=
handler
;
}
public
void
setDefaultInputStream
(
InputStream
defaultInputStream
)
{
this
.
defaultInputStream
=
defaultInputStream
;
}
public
InputStream
getDefaultInputStream
(
)
{
return
defaultInputStream
;
}
public
InputHandler
getInputHandler
(
)
{
return
inputHandler
;
}
private
FileUtils
fileUtils
;
private
boolean
loggingMessage
=
false
;
public
Project
(
)
{
fileUtils
=
FileUtils
.
newFileUtils
(
)
;
inputHandler
=
new
DefaultInputHandler
(
)
;
}
public
void
initSubProject
(
Project
subProject
)
{
ComponentHelper
.
getComponentHelper
(
subProject
)
.
initSubProject
(
ComponentHelper
.
getComponentHelper
(
this
)
)
;
subProject
.
setKeepGoingMode
(
this
.
isKeepGoingMode
(
)
)
;
}
public
void
init
(
)
throws
BuildException
{
setJavaVersionProperty
(
)
;
ComponentHelper
.
getComponentHelper
(
this
)
.
initDefaultDefinitions
(
)
;
setSystemProperties
(
)
;
}
private
AntClassLoader
createClassLoader
(
)
{
AntClassLoader
loader
=
null
;
if
(
!
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_1
)
)
{
try
{
Class
loaderClass
=
Class
.
forName
(
ANTCLASSLOADER_JDK12
)
;
loader
=
(
AntClassLoader
)
loaderClass
.
newInstance
(
)
;
}
catch
(
Exception
e
)
{
log
(
"Unable to create Class Loader: "
+
e
.
getMessage
(
)
,
Project
.
MSG_DEBUG
)
;
}
}
if
(
loader
==
null
)
{
loader
=
new
AntClassLoader
(
)
;
}
loader
.
setProject
(
this
)
;
return
loader
;
}
public
AntClassLoader
createClassLoader
(
Path
path
)
{
AntClassLoader
loader
=
createClassLoader
(
)
;
loader
.
setClassPath
(
path
)
;
return
loader
;
}
public
void
setCoreLoader
(
ClassLoader
coreLoader
)
{
this
.
coreLoader
=
coreLoader
;
}
public
ClassLoader
getCoreLoader
(
)
{
return
coreLoader
;
}
public
synchronized
void
addBuildListener
(
BuildListener
listener
)
{
Vector
newListeners
=
getBuildListeners
(
)
;
newListeners
.
addElement
(
listener
)
;
listeners
=
newListeners
;
}
public
synchronized
void
removeBuildListener
(
BuildListener
listener
)
{
Vector
newListeners
=
getBuildListeners
(
)
;
newListeners
.
removeElement
(
listener
)
;
listeners
=
newListeners
;
}
public
Vector
getBuildListeners
(
)
{
return
(
Vector
)
listeners
.
clone
(
)
;
}
public
void
log
(
String
message
)
{
log
(
message
,
MSG_INFO
)
;
}
public
void
log
(
String
message
,
int
msgLevel
)
{
fireMessageLogged
(
this
,
message
,
msgLevel
)
;
}
public
void
log
(
Task
task
,
String
message
,
int
msgLevel
)
{
fireMessageLogged
(
task
,
message
,
msgLevel
)
;
}
public
void
log
(
Target
target
,
String
message
,
int
msgLevel
)
{
fireMessageLogged
(
target
,
message
,
msgLevel
)
;
}
public
FilterSet
getGlobalFilterSet
(
)
{
return
globalFilterSet
;
}
public
void
setProperty
(
String
name
,
String
value
)
{
PropertyHelper
.
getPropertyHelper
(
this
)
.
setProperty
(
null
,
name
,
value
,
true
)
;
}
public
void
setNewProperty
(
String
name
,
String
value
)
{
PropertyHelper
.
getPropertyHelper
(
this
)
.
setNewProperty
(
null
,
name
,
value
)
;
}
public
void
setUserProperty
(
String
name
,
String
value
)
{
PropertyHelper
.
getPropertyHelper
(
this
)
.
setUserProperty
(
null
,
name
,
value
)
;
}
public
void
setInheritedProperty
(
String
name
,
String
value
)
{
PropertyHelper
ph
=
PropertyHelper
.
getPropertyHelper
(
this
)
;
ph
.
setInheritedProperty
(
null
,
name
,
value
)
;
}
private
void
setPropertyInternal
(
String
name
,
String
value
)
{
PropertyHelper
ph
=
PropertyHelper
.
getPropertyHelper
(
this
)
;
ph
.
setProperty
(
null
,
name
,
value
,
false
)
;
}
public
String
getProperty
(
String
name
)
{
PropertyHelper
ph
=
PropertyHelper
.
getPropertyHelper
(
this
)
;
return
(
String
)
ph
.
getProperty
(
null
,
name
)
;
}
public
String
replaceProperties
(
String
value
)
throws
BuildException
{
PropertyHelper
ph
=
PropertyHelper
.
getPropertyHelper
(
this
)
;
return
ph
.
replaceProperties
(
null
,
value
,
null
)
;
}
public
String
getUserProperty
(
String
name
)
{
PropertyHelper
ph
=
PropertyHelper
.
getPropertyHelper
(
this
)
;
return
(
String
)
ph
.
getUserProperty
(
null
,
name
)
;
}
public
Hashtable
getProperties
(
)
{
PropertyHelper
ph
=
PropertyHelper
.
getPropertyHelper
(
this
)
;
return
ph
.
getProperties
(
)
;
}
public
Hashtable
getUserProperties
(
)
{
PropertyHelper
ph
=
PropertyHelper
.
getPropertyHelper
(
this
)
;
return
ph
.
getUserProperties
(
)
;
}
public
void
copyUserProperties
(
Project
other
)
{
PropertyHelper
ph
=
PropertyHelper
.
getPropertyHelper
(
this
)
;
ph
.
copyUserProperties
(
other
)
;
}
public
void
copyInheritedProperties
(
Project
other
)
{
PropertyHelper
ph
=
PropertyHelper
.
getPropertyHelper
(
this
)
;
ph
.
copyInheritedProperties
(
other
)
;
}
public
void
setDefaultTarget
(
String
defaultTarget
)
{
this
.
defaultTarget
=
defaultTarget
;
}
public
String
getDefaultTarget
(
)
{
return
defaultTarget
;
}
public
void
setDefault
(
String
defaultTarget
)
{
this
.
defaultTarget
=
defaultTarget
;
}
public
void
setName
(
String
name
)
{
setUserProperty
(
"ant.project.name"
,
name
)
;
this
.
name
=
name
;
}
public
String
getName
(
)
{
return
name
;
}
public
void
setDescription
(
String
description
)
{
this
.
description
=
description
;
}
public
String
getDescription
(
)
{
if
(
description
==
null
)
{
description
=
Description
.
getDescription
(
this
)
;
}
return
description
;
}
public
void
addFilter
(
String
token
,
String
value
)
{
if
(
token
==
null
)
{
return
;
}
globalFilterSet
.
addFilter
(
new
FilterSet
.
Filter
(
token
,
value
)
)
;
}
public
Hashtable
getFilters
(
)
{
return
globalFilterSet
.
getFilterHash
(
)
;
}
public
void
setBasedir
(
String
baseD
)
throws
BuildException
{
setBaseDir
(
new
File
(
baseD
)
)
;
}
public
void
setBaseDir
(
File
baseDir
)
throws
BuildException
{
baseDir
=
fileUtils
.
normalize
(
baseDir
.
getAbsolutePath
(
)
)
;
if
(
!
baseDir
.
exists
(
)
)
{
throw
new
BuildException
(
"Basedir "
+
baseDir
.
getAbsolutePath
(
)
+
" does not exist"
)
;
}
if
(
!
baseDir
.
isDirectory
(
)
)
{
throw
new
BuildException
(
"Basedir "
+
baseDir
.
getAbsolutePath
(
)
+
" is not a directory"
)
;
}
this
.
baseDir
=
baseDir
;
setPropertyInternal
(
"basedir"
,
this
.
baseDir
.
getPath
(
)
)
;
String
msg
=
"Project base dir set to: "
+
this
.
baseDir
;
log
(
msg
,
MSG_VERBOSE
)
;
}
public
File
getBaseDir
(
)
{
if
(
baseDir
==
null
)
{
try
{
setBasedir
(
"."
)
;
}
catch
(
BuildException
ex
)
{
ex
.
printStackTrace
(
)
;
}
}
return
baseDir
;
}
public
void
setKeepGoingMode
(
boolean
keepGoingMode
)
{
this
.
keepGoingMode
=
keepGoingMode
;
}
public
boolean
isKeepGoingMode
(
)
{
return
this
.
keepGoingMode
;
}
public
static
String
getJavaVersion
(
)
{
return
JavaEnvUtils
.
getJavaVersion
(
)
;
}
public
void
setJavaVersionProperty
(
)
throws
BuildException
{
String
javaVersion
=
JavaEnvUtils
.
getJavaVersion
(
)
;
setPropertyInternal
(
"ant.java.version"
,
javaVersion
)
;
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_0
)
)
{
throw
new
BuildException
(
"Ant cannot work on Java 1.0"
)
;
}
log
(
"Detected Java version: "
+
javaVersion
+
" in: "
+
System
.
getProperty
(
"java.home"
)
,
MSG_VERBOSE
)
;
log
(
"Detected OS: "
+
System
.
getProperty
(
"os.name"
)
,
MSG_VERBOSE
)
;
}
public
void
setSystemProperties
(
)
{
Properties
systemP
=
System
.
getProperties
(
)
;
Enumeration
e
=
systemP
.
keys
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
Object
name
=
e
.
nextElement
(
)
;
String
value
=
systemP
.
get
(
name
)
.
toString
(
)
;
this
.
setPropertyInternal
(
name
.
toString
(
)
,
value
)
;
}
}
public
void
addTaskDefinition
(
String
taskName
,
Class
taskClass
)
throws
BuildException
{
ComponentHelper
.
getComponentHelper
(
this
)
.
addTaskDefinition
(
taskName
,
taskClass
)
;
}
public
void
checkTaskClass
(
final
Class
taskClass
)
throws
BuildException
{
ComponentHelper
.
getComponentHelper
(
this
)
.
checkTaskClass
(
taskClass
)
;
if
(
!
Modifier
.
isPublic
(
taskClass
.
getModifiers
(
)
)
)
{
final
String
message
=
taskClass
+
" is not public"
;
log
(
message
,
Project
.
MSG_ERR
)
;
throw
new
BuildException
(
message
)
;
}
if
(
Modifier
.
isAbstract
(
taskClass
.
getModifiers
(
)
)
)
{
final
String
message
=
taskClass
+
" is abstract"
;
log
(
message
,
Project
.
MSG_ERR
)
;
throw
new
BuildException
(
message
)
;
}
try
{
taskClass
.
getConstructor
(
null
)
;
}
catch
(
NoSuchMethodException
e
)
{
final
String
message
=
"No public no-arg constructor in "
+
taskClass
;
log
(
message
,
Project
.
MSG_ERR
)
;
throw
new
BuildException
(
message
)
;
}
if
(
!
Task
.
class
.
isAssignableFrom
(
taskClass
)
)
{
TaskAdapter
.
checkTaskClass
(
taskClass
,
this
)
;
}
}
public
Hashtable
getTaskDefinitions
(
)
{
return
ComponentHelper
.
getComponentHelper
(
this
)
.
getTaskDefinitions
(
)
;
}
public
void
addDataTypeDefinition
(
String
typeName
,
Class
typeClass
)
{
ComponentHelper
.
getComponentHelper
(
this
)
.
addDataTypeDefinition
(
typeName
,
typeClass
)
;
}
public
Hashtable
getDataTypeDefinitions
(
)
{
return
ComponentHelper
.
getComponentHelper
(
this
)
.
getDataTypeDefinitions
(
)
;
}
public
void
addTarget
(
Target
target
)
throws
BuildException
{
String
name
=
target
.
getName
(
)
;
if
(
targets
.
get
(
name
)
!=
null
)
{
throw
new
BuildException
(
"Duplicate target: `"
+
name
+
"'"
)
;
}
addOrReplaceTarget
(
name
,
target
)
;
}
public
void
addTarget
(
String
targetName
,
Target
target
)
throws
BuildException
{
if
(
targets
.
get
(
targetName
)
!=
null
)
{
throw
new
BuildException
(
"Duplicate target: `"
+
targetName
+
"'"
)
;
}
addOrReplaceTarget
(
targetName
,
target
)
;
}
public
void
addOrReplaceTarget
(
Target
target
)
{
addOrReplaceTarget
(
target
.
getName
(
)
,
target
)
;
}
public
void
addOrReplaceTarget
(
String
targetName
,
Target
target
)
{
String
msg
=
" +Target: "
+
targetName
;
log
(
msg
,
MSG_DEBUG
)
;
target
.
setProject
(
this
)
;
targets
.
put
(
targetName
,
target
)
;
}
public
Hashtable
getTargets
(
)
{
return
targets
;
}
public
Task
createTask
(
String
taskType
)
throws
BuildException
{
return
ComponentHelper
.
getComponentHelper
(
this
)
.
createTask
(
taskType
)
;
}
public
Object
createDataType
(
String
typeName
)
throws
BuildException
{
return
ComponentHelper
.
getComponentHelper
(
this
)
.
createDataType
(
typeName
)
;
}
public
void
executeTargets
(
Vector
targetNames
)
throws
BuildException
{
for
(
int
i
=
0
;
i
<
targetNames
.
size
(
)
;
i
++
)
{
executeTarget
(
(
String
)
targetNames
.
elementAt
(
i
)
)
;
}
}
public
void
demuxOutput
(
String
output
,
boolean
isWarning
)
{
Task
task
=
getThreadTask
(
Thread
.
currentThread
(
)
)
;
if
(
task
==
null
)
{
log
(
output
,
isWarning
?
MSG_WARN
:
MSG_INFO
)
;
}
else
{
if
(
isWarning
)
{
task
.
handleErrorOutput
(
output
)
;
}
else
{
task
.
handleOutput
(
output
)
;
}
}
}
public
int
defaultInput
(
byte
[
]
buffer
,
int
offset
,
int
length
)
throws
IOException
{
if
(
defaultInputStream
!=
null
)
{
System
.
out
.
flush
(
)
;
return
defaultInputStream
.
read
(
buffer
,
offset
,
length
)
;
}
else
{
throw
new
EOFException
(
"No input provided for project"
)
;
}
}
public
int
demuxInput
(
byte
[
]
buffer
,
int
offset
,
int
length
)
throws
IOException
{
Task
task
=
getThreadTask
(
Thread
.
currentThread
(
)
)
;
if
(
task
==
null
)
{
return
defaultInput
(
buffer
,
offset
,
length
)
;
}
else
{
return
task
.
handleInput
(
buffer
,
offset
,
length
)
;
}
}
public
void
demuxFlush
(
String
output
,
boolean
isError
)
{
Task
task
=
getThreadTask
(
Thread
.
currentThread
(
)
)
;
if
(
task
==
null
)
{
fireMessageLogged
(
this
,
output
,
isError
?
MSG_ERR
:
MSG_INFO
)
;
}
else
{
if
(
isError
)
{
task
.
handleErrorFlush
(
output
)
;
}
else
{
task
.
handleFlush
(
output
)
;
}
}
}
public
void
executeTarget
(
String
targetName
)
throws
BuildException
{
if
(
targetName
==
null
)
{
String
msg
=
"No target specified"
;
throw
new
BuildException
(
msg
)
;
}
Vector
sortedTargets
=
topoSort
(
targetName
,
targets
)
;
Set
succeededTargets
=
new
HashSet
(
)
;
BuildException
buildException
=
null
;
for
(
Enumeration
iter
=
sortedTargets
.
elements
(
)
;
iter
.
hasMoreElements
(
)
;
)
{
Target
curtarget
=
(
Target
)
iter
.
nextElement
(
)
;
boolean
canExecute
=
true
;
for
(
Enumeration
depIter
=
curtarget
.
getDependencies
(
)
;
depIter
.
hasMoreElements
(
)
;
)
{
String
dependencyName
=
(
(
String
)
depIter
.
nextElement
(
)
)
;
if
(
!
succeededTargets
.
contains
(
dependencyName
)
)
{
canExecute
=
false
;
log
(
curtarget
,
"Cannot execute '"
+
curtarget
.
getName
(
)
+
"' - '"
+
dependencyName
+
"' failed or was not executed."
,
MSG_ERR
)
;
break
;
}
}
if
(
canExecute
)
{
Throwable
thrownException
=
null
;
try
{
curtarget
.
performTasks
(
)
;
succeededTargets
.
add
(
curtarget
.
getName
(
)
)
;
}
catch
(
RuntimeException
ex
)
{
if
(
!
(
keepGoingMode
)
)
{
throw
ex
;
}
thrownException
=
ex
;
}
catch
(
Throwable
ex
)
{
if
(
!
(
keepGoingMode
)
)
{
throw
new
BuildException
(
ex
)
;
}
thrownException
=
ex
;
}
if
(
thrownException
!=
null
)
{
if
(
thrownException
instanceof
BuildException
)
{
log
(
curtarget
,
"Target '"
+
curtarget
.
getName
(
)
+
"' failed with message '"
+
thrownException
.
getMessage
(
)
+
"'."
,
MSG_ERR
)
;
if
(
buildException
==
null
)
{
buildException
=
(
BuildException
)
thrownException
;
}
}
else
{
log
(
curtarget
,
"Target '"
+
curtarget
.
getName
(
)
+
"' failed with message '"
+
thrownException
.
getMessage
(
)
+
"'."
,
MSG_ERR
)
;
thrownException
.
printStackTrace
(
System
.
err
)
;
if
(
buildException
==
null
)
{
buildException
=
new
BuildException
(
thrownException
)
;
}
}
}
}
if
(
curtarget
.
getName
(
)
.
equals
(
targetName
)
)
{
break
;
}
}
if
(
buildException
!=
null
)
{
throw
buildException
;
}
}
public
File
resolveFile
(
String
fileName
,
File
rootDir
)
{
return
fileUtils
.
resolveFile
(
rootDir
,
fileName
)
;
}
public
File
resolveFile
(
String
fileName
)
{
return
fileUtils
.
resolveFile
(
baseDir
,
fileName
)
;
}
public
static
String
translatePath
(
String
toProcess
)
{
if
(
toProcess
==
null
||
toProcess
.
length
(
)
==
0
)
{
return
""
;
}
StringBuffer
path
=
new
StringBuffer
(
toProcess
.
length
(
)
+
50
)
;
PathTokenizer
tokenizer
=
new
PathTokenizer
(
toProcess
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
String
pathComponent
=
tokenizer
.
nextToken
(
)
;
pathComponent
=
pathComponent
.
replace
(
'/'
,
File
.
separatorChar
)
;
pathComponent
=
pathComponent
.
replace
(
'\\'
,
File
.
separatorChar
)
;
if
(
path
.
length
(
)
!=
0
)
{
path
.
append
(
File
.
pathSeparatorChar
)
;
}
path
.
append
(
pathComponent
)
;
}
return
path
.
toString
(
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
)
throws
IOException
{
fileUtils
.
copyFile
(
sourceFile
,
destFile
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
boolean
filtering
)
throws
IOException
{
fileUtils
.
copyFile
(
sourceFile
,
destFile
,
filtering
?
globalFilters
:
null
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
boolean
filtering
,
boolean
overwrite
)
throws
IOException
{
fileUtils
.
copyFile
(
sourceFile
,
destFile
,
filtering
?
globalFilters
:
null
,
overwrite
)
;
}
public
void
copyFile
(
String
sourceFile
,
String
destFile
,
boolean
filtering
,
boolean
overwrite
,
boolean
preserveLastModified
)
throws
IOException
{
fileUtils
.
copyFile
(
sourceFile
,
destFile
,
filtering
?
globalFilters
:
null
,
overwrite
,
preserveLastModified
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
)
throws
IOException
{
fileUtils
.
copyFile
(
sourceFile
,
destFile
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
boolean
filtering
)
throws
IOException
{
fileUtils
.
copyFile
(
sourceFile
,
destFile
,
filtering
?
globalFilters
:
null
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
boolean
filtering
,
boolean
overwrite
)
throws
IOException
{
fileUtils
.
copyFile
(
sourceFile
,
destFile
,
filtering
?
globalFilters
:
null
,
overwrite
)
;
}
public
void
copyFile
(
File
sourceFile
,
File
destFile
,
boolean
filtering
,
boolean
overwrite
,
boolean
preserveLastModified
)
throws
IOException
{
fileUtils
.
copyFile
(
sourceFile
,
destFile
,
filtering
?
globalFilters
:
null
,
overwrite
,
preserveLastModified
)
;
}
public
void
setFileLastModified
(
File
file
,
long
time
)
throws
BuildException
{
if
(
JavaEnvUtils
.
isJavaVersion
(
JavaEnvUtils
.
JAVA_1_1
)
)
{
log
(
"Cannot change the modification time of "
+
file
+
" in JDK 1.1"
,
Project
.
MSG_WARN
)
;
return
;
}
fileUtils
.
setFileLastModified
(
file
,
time
)
;
log
(
"Setting modification time for "
+
file
,
MSG_VERBOSE
)
;
}
public
static
boolean
toBoolean
(
String
s
)
{
return
(
"on"
.
equalsIgnoreCase
(
s
)
||
"true"
.
equalsIgnoreCase
(
s
)
||
"yes"
.
equalsIgnoreCase
(
s
)
)
;
}
public
final
Vector
topoSort
(
String
root
,
Hashtable
targets
)
throws
BuildException
{
Vector
ret
=
new
Vector
(
)
;
Hashtable
state
=
new
Hashtable
(
)
;
Stack
visiting
=
new
Stack
(
)
;
tsort
(
root
,
targets
,
state
,
visiting
,
ret
)
;
log
(
"Build sequence for target `"
+
root
+
"' is "
+
ret
,
MSG_VERBOSE
)
;
for
(
Enumeration
en
=
targets
.
keys
(
)
;
en
.
hasMoreElements
(
)
;
)
{
String
curTarget
=
(
String
)
en
.
nextElement
(
)
;
String
st
=
(
String
)
state
.
get
(
curTarget
)
;
if
(
st
==
null
)
{
tsort
(
curTarget
,
targets
,
state
,
visiting
,
ret
)
;
}
else
if
(
st
==
VISITING
)
{
throw
new
RuntimeException
(
"Unexpected node in visiting state: "
+
curTarget
)
;
}
}
log
(
"Complete build sequence is "
+
ret
,
MSG_VERBOSE
)
;
return
ret
;
}
private
final
void
tsort
(
String
root
,
Hashtable
targets
,
Hashtable
state
,
Stack
visiting
,
Vector
ret
)
throws
BuildException
{
state
.
put
(
root
,
VISITING
)
;
visiting
.
push
(
root
)
;
Target
target
=
(
Target
)
targets
.
get
(
root
)
;
if
(
target
==
null
)
{
StringBuffer
sb
=
new
StringBuffer
(
"Target `"
)
;
sb
.
append
(
root
)
;
sb
.
append
(
"' does not exist in this project. "
)
;
visiting
.
pop
(
)
;
if
(
!
visiting
.
empty
(
)
)
{
String
parent
=
(
String
)
visiting
.
peek
(
)
;
sb
.
append
(
"It is used from target `"
)
;
sb
.
append
(
parent
)
;
sb
.
append
(
"'."
)
;
}
throw
new
BuildException
(
new
String
(
sb
)
)
;
}
for
(
Enumeration
en
=
target
.
getDependencies
(
)
;
en
.
hasMoreElements
(
)
;
)
{
String
cur
=
(
String
)
en
.
nextElement
(
)
;
String
m
=
(
String
)
state
.
get
(
cur
)
;
if
(
m
==
null
)
{
tsort
(
cur
,
targets
,
state
,
visiting
,
ret
)
;
}
else
if
(
m
==
VISITING
)
{
throw
makeCircularException
(
cur
,
visiting
)
;
}
}
String
p
=
(
String
)
visiting
.
pop
(
)
;
if
(
root
!=
p
)
{
throw
new
RuntimeException
(
"Unexpected internal error: expected to "
+
"pop "
+
root
+
" but got "
+
p
)
;
}
state
.
put
(
root
,
VISITED
)
;
ret
.
addElement
(
target
)
;
}
private
static
BuildException
makeCircularException
(
String
end
,
Stack
stk
)
{
StringBuffer
sb
=
new
StringBuffer
(
"Circular dependency: "
)
;
sb
.
append
(
end
)
;
String
c
;
do
{
c
=
(
String
)
stk
.
pop
(
)
;
sb
.
append
(
" <- "
)
;
sb
.
append
(
c
)
;
}
while
(
!
c
.
equals
(
end
)
)
;
return
new
BuildException
(
new
String
(
sb
)
)
;
}
public
void
addReference
(
String
name
,
Object
value
)
{
synchronized
(
references
)
{
Object
old
=
(
(
AntRefTable
)
references
)
.
getReal
(
name
)
;
if
(
old
==
value
)
{
return
;
}
if
(
old
!=
null
&&
!
(
old
instanceof
UnknownElement
)
)
{
log
(
"Overriding previous definition of reference to "
+
name
,
MSG_WARN
)
;
}
log
(
"Adding reference: "
+
name
,
MSG_DEBUG
)
;
references
.
put
(
name
,
value
)
;
}
}
public
Hashtable
getReferences
(
)
{
return
references
;
}
public
Object
getReference
(
String
key
)
{
return
references
.
get
(
key
)
;
}
public
String
getElementName
(
Object
element
)
{
return
ComponentHelper
.
getComponentHelper
(
this
)
.
getElementName
(
element
)
;
}
public
void
fireBuildStarted
(
)
{
BuildEvent
event
=
new
BuildEvent
(
this
)
;
Iterator
iter
=
listeners
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
BuildListener
listener
=
(
BuildListener
)
iter
.
next
(
)
;
listener
.
buildStarted
(
event
)
;
}
}
public
void
fireBuildFinished
(
Throwable
exception
)
{
BuildEvent
event
=
new
BuildEvent
(
this
)
;
event
.
setException
(
exception
)
;
Iterator
iter
=
listeners
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
BuildListener
listener
=
(
BuildListener
)
iter
.
next
(
)
;
listener
.
buildFinished
(
event
)
;
}
}
protected
void
fireTargetStarted
(
Target
target
)
{
BuildEvent
event
=
new
BuildEvent
(
target
)
;
Iterator
iter
=
listeners
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
BuildListener
listener
=
(
BuildListener
)
iter
.
next
(
)
;
listener
.
targetStarted
(
event
)
;
}
}
protected
void
fireTargetFinished
(
Target
target
,
Throwable
exception
)
{
BuildEvent
event
=
new
BuildEvent
(
target
)
;
event
.
setException
(
exception
)
;
Iterator
iter
=
listeners
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
BuildListener
listener
=
(
BuildListener
)
iter
.
next
(
)
;
listener
.
targetFinished
(
event
)
;
}
}
protected
void
fireTaskStarted
(
Task
task
)
{
registerThreadTask
(
Thread
.
currentThread
(
)
,
task
)
;
BuildEvent
event
=
new
BuildEvent
(
task
)
;
Iterator
iter
=
listeners
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
BuildListener
listener
=
(
BuildListener
)
iter
.
next
(
)
;
listener
.
taskStarted
(
event
)
;
}
}
protected
void
fireTaskFinished
(
Task
task
,
Throwable
exception
)
{
registerThreadTask
(
Thread
.
currentThread
(
)
,
null
)
;
System
.
out
.
flush
(
)
;
System
.
err
.
flush
(
)
;
BuildEvent
event
=
new
BuildEvent
(
task
)
;
event
.
setException
(
exception
)
;
Iterator
iter
=
listeners
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
BuildListener
listener
=
(
BuildListener
)
iter
.
next
(
)
;
listener
.
taskFinished
(
event
)
;
}
}
private
void
fireMessageLoggedEvent
(
BuildEvent
event
,
String
message
,
int
priority
)
{
if
(
message
.
endsWith
(
StringUtils
.
LINE_SEP
)
)
{
int
endIndex
=
message
.
length
(
)
-
StringUtils
.
LINE_SEP
.
length
(
)
;
event
.
setMessage
(
message
.
substring
(
0
,
endIndex
)
,
priority
)
;
}
else
{
event
.
setMessage
(
message
,
priority
)
;
}
synchronized
(
this
)
{
if
(
loggingMessage
)
{
throw
new
BuildException
(
"Listener attempted to access "
+
(
priority
==
MSG_ERR
?
"System.err"
:
"System.out"
)
+
" - infinite loop terminated"
)
;
}
try
{
loggingMessage
=
true
;
Iterator
iter
=
listeners
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
BuildListener
listener
=
(
BuildListener
)
iter
.
next
(
)
;
listener
.
messageLogged
(
event
)
;
}
}
finally
{
loggingMessage
=
false
;
}
}
}
protected
void
fireMessageLogged
(
Project
project
,
String
message
,
int
priority
)
{
BuildEvent
event
=
new
BuildEvent
(
project
)
;
fireMessageLoggedEvent
(
event
,
message
,
priority
)
;
}
protected
void
fireMessageLogged
(
Target
target
,
String
message
,
int
priority
)
{
BuildEvent
event
=
new
BuildEvent
(
target
)
;
fireMessageLoggedEvent
(
event
,
message
,
priority
)
;
}
protected
void
fireMessageLogged
(
Task
task
,
String
message
,
int
priority
)
{
BuildEvent
event
=
new
BuildEvent
(
task
)
;
fireMessageLoggedEvent
(
event
,
message
,
priority
)
;
}
public
synchronized
void
registerThreadTask
(
Thread
thread
,
Task
task
)
{
if
(
task
!=
null
)
{
threadTasks
.
put
(
thread
,
task
)
;
threadGroupTasks
.
put
(
thread
.
getThreadGroup
(
)
,
task
)
;
}
else
{
threadTasks
.
remove
(
thread
)
;
threadGroupTasks
.
remove
(
thread
.
getThreadGroup
(
)
)
;
}
}
public
Task
getThreadTask
(
Thread
thread
)
{
Task
task
=
(
Task
)
threadTasks
.
get
(
thread
)
;
if
(
task
==
null
)
{
ThreadGroup
group
=
thread
.
getThreadGroup
(
)
;
while
(
task
==
null
&&
group
!=
null
)
{
task
=
(
Task
)
threadGroupTasks
.
get
(
group
)
;
group
=
group
.
getParent
(
)
;
}
}
return
task
;
}
private
static
class
AntRefTable
extends
Hashtable
{
private
Project
project
;
public
AntRefTable
(
Project
project
)
{
super
(
)
;
this
.
project
=
project
;
}
public
Object
getReal
(
Object
key
)
{
return
super
.
get
(
key
)
;
}
public
Object
get
(
Object
key
)
{
Object
o
=
super
.
get
(
key
)
;
if
(
o
instanceof
UnknownElement
)
{
UnknownElement
ue
=
(
UnknownElement
)
o
;
ue
.
maybeConfigure
(
)
;
o
=
ue
.
getRealThing
(
)
;
}
return
o
;
}
}
public
final
void
setProjectReference
(
final
Object
obj
)
{
if
(
obj
instanceof
ProjectComponent
)
{
(
(
ProjectComponent
)
obj
)
.
setProject
(
this
)
;
return
;
}
try
{
Method
method
=
obj
.
getClass
(
)
.
getMethod
(
"setProject"
,
new
Class
[
]
{
Project
.
class
}
)
;
if
(
method
!=
null
)
{
method
.
invoke
(
obj
,
new
Object
[
]
{
this
}
)
;
}
}
catch
(
Throwable
e
)
{
}
}
}
