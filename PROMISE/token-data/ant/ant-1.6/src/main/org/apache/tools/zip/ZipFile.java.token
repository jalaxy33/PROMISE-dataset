package
org
.
apache
.
tools
.
zip
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
RandomAccessFile
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
util
.
Calendar
;
import
java
.
util
.
Date
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
zip
.
Inflater
;
import
java
.
util
.
zip
.
InflaterInputStream
;
import
java
.
util
.
zip
.
ZipException
;
public
class
ZipFile
{
private
Hashtable
entries
=
new
Hashtable
(
)
;
private
Hashtable
nameMap
=
new
Hashtable
(
)
;
private
Hashtable
dataOffsets
=
new
Hashtable
(
)
;
private
String
encoding
=
null
;
private
RandomAccessFile
archive
;
public
ZipFile
(
File
f
)
throws
IOException
{
this
(
f
,
null
)
;
}
public
ZipFile
(
String
name
)
throws
IOException
{
this
(
new
File
(
name
)
,
null
)
;
}
public
ZipFile
(
String
name
,
String
encoding
)
throws
IOException
{
this
(
new
File
(
name
)
,
encoding
)
;
}
public
ZipFile
(
File
f
,
String
encoding
)
throws
IOException
{
this
.
encoding
=
encoding
;
archive
=
new
RandomAccessFile
(
f
,
"r"
)
;
populateFromCentralDirectory
(
)
;
resolveLocalFileHeaderData
(
)
;
}
public
String
getEncoding
(
)
{
return
encoding
;
}
public
void
close
(
)
throws
IOException
{
archive
.
close
(
)
;
}
public
Enumeration
getEntries
(
)
{
return
entries
.
keys
(
)
;
}
public
ZipEntry
getEntry
(
String
name
)
{
return
(
ZipEntry
)
nameMap
.
get
(
name
)
;
}
public
InputStream
getInputStream
(
ZipEntry
ze
)
throws
IOException
,
ZipException
{
Long
start
=
(
Long
)
dataOffsets
.
get
(
ze
)
;
if
(
start
==
null
)
{
return
null
;
}
BoundedInputStream
bis
=
new
BoundedInputStream
(
start
.
longValue
(
)
,
ze
.
getCompressedSize
(
)
)
;
switch
(
ze
.
getMethod
(
)
)
{
case
ZipEntry
.
STORED
:
return
bis
;
case
ZipEntry
.
DEFLATED
:
bis
.
addDummy
(
)
;
return
new
InflaterInputStream
(
bis
,
new
Inflater
(
true
)
)
;
default
:
throw
new
ZipException
(
"Found unsupported compression method "
+
ze
.
getMethod
(
)
)
;
}
}
private
static
final
int
CFH_LEN
=
2
+
2
+
2
+
2
+
2
+
2
+
4
+
4
+
4
+
2
+
2
+
2
+
2
+
2
+
4
+
4
;
private
void
populateFromCentralDirectory
(
)
throws
IOException
{
positionAtCentralDirectory
(
)
;
byte
[
]
cfh
=
new
byte
[
CFH_LEN
]
;
byte
[
]
signatureBytes
=
new
byte
[
4
]
;
archive
.
readFully
(
signatureBytes
)
;
ZipLong
sig
=
new
ZipLong
(
signatureBytes
)
;
while
(
sig
.
equals
(
ZipOutputStream
.
CFH_SIG
)
)
{
archive
.
readFully
(
cfh
)
;
int
off
=
0
;
ZipEntry
ze
=
new
ZipEntry
(
)
;
ZipShort
versionMadeBy
=
new
ZipShort
(
cfh
,
off
)
;
off
+=
2
;
ze
.
setPlatform
(
(
versionMadeBy
.
getValue
(
)
>
>
8
)
&
0x0F
)
;
off
+=
4
;
ze
.
setMethod
(
(
new
ZipShort
(
cfh
,
off
)
)
.
getValue
(
)
)
;
off
+=
2
;
ze
.
setTime
(
fromDosTime
(
new
ZipLong
(
cfh
,
off
)
)
.
getTime
(
)
)
;
off
+=
4
;
ze
.
setCrc
(
(
new
ZipLong
(
cfh
,
off
)
)
.
getValue
(
)
)
;
off
+=
4
;
ze
.
setCompressedSize
(
(
new
ZipLong
(
cfh
,
off
)
)
.
getValue
(
)
)
;
off
+=
4
;
ze
.
setSize
(
(
new
ZipLong
(
cfh
,
off
)
)
.
getValue
(
)
)
;
off
+=
4
;
int
fileNameLen
=
(
new
ZipShort
(
cfh
,
off
)
)
.
getValue
(
)
;
off
+=
2
;
int
extraLen
=
(
new
ZipShort
(
cfh
,
off
)
)
.
getValue
(
)
;
off
+=
2
;
int
commentLen
=
(
new
ZipShort
(
cfh
,
off
)
)
.
getValue
(
)
;
off
+=
2
;
off
+=
2
;
ze
.
setInternalAttributes
(
(
new
ZipShort
(
cfh
,
off
)
)
.
getValue
(
)
)
;
off
+=
2
;
ze
.
setExternalAttributes
(
(
new
ZipLong
(
cfh
,
off
)
)
.
getValue
(
)
)
;
off
+=
4
;
entries
.
put
(
ze
,
new
Long
(
(
new
ZipLong
(
cfh
,
off
)
)
.
getValue
(
)
)
)
;
byte
[
]
fileName
=
new
byte
[
fileNameLen
]
;
archive
.
readFully
(
fileName
)
;
ze
.
setName
(
getString
(
fileName
)
)
;
nameMap
.
put
(
ze
.
getName
(
)
,
ze
)
;
archive
.
skipBytes
(
extraLen
)
;
byte
[
]
comment
=
new
byte
[
commentLen
]
;
archive
.
readFully
(
comment
)
;
ze
.
setComment
(
getString
(
comment
)
)
;
archive
.
readFully
(
signatureBytes
)
;
sig
=
new
ZipLong
(
signatureBytes
)
;
}
}
private
static
final
int
MIN_EOCD_SIZE
=
4
+
2
+
+
2
+
+
2
+
+
2
+
4
+
+
+
4
+
2
;
private
static
final
int
CFD_LOCATOR_OFFSET
=
4
+
2
+
+
2
+
+
2
+
+
2
+
4
;
private
void
positionAtCentralDirectory
(
)
throws
IOException
{
long
off
=
archive
.
length
(
)
-
MIN_EOCD_SIZE
;
archive
.
seek
(
off
)
;
byte
[
]
sig
=
ZipOutputStream
.
EOCD_SIG
.
getBytes
(
)
;
int
curr
=
archive
.
read
(
)
;
boolean
found
=
false
;
while
(
curr
!=
-
1
)
{
if
(
curr
==
sig
[
0
]
)
{
curr
=
archive
.
read
(
)
;
if
(
curr
==
sig
[
1
]
)
{
curr
=
archive
.
read
(
)
;
if
(
curr
==
sig
[
2
]
)
{
curr
=
archive
.
read
(
)
;
if
(
curr
==
sig
[
3
]
)
{
found
=
true
;
break
;
}
}
}
}
archive
.
seek
(
--
off
)
;
curr
=
archive
.
read
(
)
;
}
if
(
!
found
)
{
throw
new
ZipException
(
"archive is not a ZIP archive"
)
;
}
archive
.
seek
(
off
+
CFD_LOCATOR_OFFSET
)
;
byte
[
]
cfdOffset
=
new
byte
[
4
]
;
archive
.
readFully
(
cfdOffset
)
;
archive
.
seek
(
(
new
ZipLong
(
cfdOffset
)
)
.
getValue
(
)
)
;
}
private
static
final
long
LFH_OFFSET_FOR_FILENAME_LENGTH
=
4
+
2
+
2
+
2
+
2
+
2
+
4
+
4
+
4
;
private
void
resolveLocalFileHeaderData
(
)
throws
IOException
{
Enumeration
e
=
getEntries
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
ZipEntry
ze
=
(
ZipEntry
)
e
.
nextElement
(
)
;
long
offset
=
(
(
Long
)
entries
.
get
(
ze
)
)
.
longValue
(
)
;
archive
.
seek
(
offset
+
LFH_OFFSET_FOR_FILENAME_LENGTH
)
;
byte
[
]
b
=
new
byte
[
2
]
;
archive
.
readFully
(
b
)
;
int
fileNameLen
=
(
new
ZipShort
(
b
)
)
.
getValue
(
)
;
archive
.
readFully
(
b
)
;
int
extraFieldLen
=
(
new
ZipShort
(
b
)
)
.
getValue
(
)
;
archive
.
skipBytes
(
fileNameLen
)
;
byte
[
]
localExtraData
=
new
byte
[
extraFieldLen
]
;
archive
.
readFully
(
localExtraData
)
;
ze
.
setExtra
(
localExtraData
)
;
dataOffsets
.
put
(
ze
,
new
Long
(
offset
+
LFH_OFFSET_FOR_FILENAME_LENGTH
+
2
+
2
+
fileNameLen
+
extraFieldLen
)
)
;
}
}
protected
static
Date
fromDosTime
(
ZipLong
l
)
{
long
dosTime
=
l
.
getValue
(
)
;
Calendar
cal
=
Calendar
.
getInstance
(
)
;
cal
.
set
(
Calendar
.
YEAR
,
(
int
)
(
(
dosTime
>
>
25
)
&
0x7f
)
+
1980
)
;
cal
.
set
(
Calendar
.
MONTH
,
(
int
)
(
(
dosTime
>
>
21
)
&
0x0f
)
-
1
)
;
cal
.
set
(
Calendar
.
DATE
,
(
int
)
(
dosTime
>
>
16
)
&
0x1f
)
;
cal
.
set
(
Calendar
.
HOUR_OF_DAY
,
(
int
)
(
dosTime
>
>
11
)
&
0x1f
)
;
cal
.
set
(
Calendar
.
MINUTE
,
(
int
)
(
dosTime
>
>
5
)
&
0x3f
)
;
cal
.
set
(
Calendar
.
SECOND
,
(
int
)
(
dosTime
<<
1
)
&
0x3e
)
;
return
cal
.
getTime
(
)
;
}
protected
String
getString
(
byte
[
]
bytes
)
throws
ZipException
{
if
(
encoding
==
null
)
{
return
new
String
(
bytes
)
;
}
else
{
try
{
return
new
String
(
bytes
,
encoding
)
;
}
catch
(
UnsupportedEncodingException
uee
)
{
throw
new
ZipException
(
uee
.
getMessage
(
)
)
;
}
}
}
private
class
BoundedInputStream
extends
InputStream
{
private
long
remaining
;
private
long
loc
;
private
boolean
addDummyByte
=
false
;
BoundedInputStream
(
long
start
,
long
remaining
)
{
this
.
remaining
=
remaining
;
loc
=
start
;
}
public
int
read
(
)
throws
IOException
{
if
(
remaining
--
<=
0
)
{
if
(
addDummyByte
)
{
addDummyByte
=
false
;
return
0
;
}
return
-
1
;
}
synchronized
(
archive
)
{
archive
.
seek
(
loc
++
)
;
return
archive
.
read
(
)
;
}
}
public
int
read
(
byte
[
]
b
,
int
off
,
int
len
)
throws
IOException
{
if
(
remaining
<=
0
)
{
if
(
addDummyByte
)
{
addDummyByte
=
false
;
b
[
off
]
=
0
;
return
1
;
}
return
-
1
;
}
if
(
len
<=
0
)
{
return
0
;
}
if
(
len
>
remaining
)
{
len
=
(
int
)
remaining
;
}
int
ret
=
-
1
;
synchronized
(
archive
)
{
archive
.
seek
(
loc
)
;
ret
=
archive
.
read
(
b
,
off
,
len
)
;
}
if
(
ret
>
0
)
{
loc
+=
ret
;
remaining
-=
ret
;
}
return
ret
;
}
void
addDummy
(
)
{
addDummyByte
=
true
;
}
}
}
