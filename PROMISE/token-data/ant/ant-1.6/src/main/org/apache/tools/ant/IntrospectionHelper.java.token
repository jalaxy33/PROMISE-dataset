package
org
.
apache
.
tools
.
ant
;
import
java
.
io
.
File
;
import
java
.
lang
.
reflect
.
Constructor
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
List
;
import
java
.
util
.
Locale
;
import
org
.
apache
.
tools
.
ant
.
types
.
EnumeratedAttribute
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
PreSetDef
;
public
final
class
IntrospectionHelper
implements
BuildListener
{
private
Hashtable
attributeTypes
;
private
Hashtable
attributeSetters
;
private
Hashtable
nestedTypes
;
private
Hashtable
nestedCreators
;
private
List
addTypeMethods
;
private
Method
addText
=
null
;
private
Class
bean
;
private
static
Hashtable
helpers
=
new
Hashtable
(
)
;
private
static
final
Hashtable
PRIMITIVE_TYPE_MAP
=
new
Hashtable
(
8
)
;
static
{
Class
[
]
primitives
=
{
Boolean
.
TYPE
,
Byte
.
TYPE
,
Character
.
TYPE
,
Short
.
TYPE
,
Integer
.
TYPE
,
Long
.
TYPE
,
Float
.
TYPE
,
Double
.
TYPE
}
;
Class
[
]
wrappers
=
{
Boolean
.
class
,
Byte
.
class
,
Character
.
class
,
Short
.
class
,
Integer
.
class
,
Long
.
class
,
Float
.
class
,
Double
.
class
}
;
for
(
int
i
=
0
;
i
<
primitives
.
length
;
i
++
)
{
PRIMITIVE_TYPE_MAP
.
put
(
primitives
[
i
]
,
wrappers
[
i
]
)
;
}
}
private
IntrospectionHelper
(
final
Class
bean
)
{
attributeTypes
=
new
Hashtable
(
)
;
attributeSetters
=
new
Hashtable
(
)
;
nestedTypes
=
new
Hashtable
(
)
;
nestedCreators
=
new
Hashtable
(
)
;
addTypeMethods
=
new
ArrayList
(
)
;
this
.
bean
=
bean
;
Method
[
]
methods
=
bean
.
getMethods
(
)
;
for
(
int
i
=
0
;
i
<
methods
.
length
;
i
++
)
{
final
Method
m
=
methods
[
i
]
;
final
String
name
=
m
.
getName
(
)
;
Class
returnType
=
m
.
getReturnType
(
)
;
Class
[
]
args
=
m
.
getParameterTypes
(
)
;
if
(
args
.
length
==
1
&&
java
.
lang
.
Void
.
TYPE
.
equals
(
returnType
)
&&
(
name
.
equals
(
"add"
)
||
name
.
equals
(
"addConfigured"
)
)
)
{
insertAddTypeMethod
(
m
)
;
continue
;
}
if
(
org
.
apache
.
tools
.
ant
.
Task
.
class
.
isAssignableFrom
(
bean
)
&&
args
.
length
==
1
&&
isHiddenSetMethod
(
name
,
args
[
0
]
)
)
{
continue
;
}
if
(
org
.
apache
.
tools
.
ant
.
TaskContainer
.
class
.
isAssignableFrom
(
bean
)
&&
args
.
length
==
1
&&
"addTask"
.
equals
(
name
)
&&
org
.
apache
.
tools
.
ant
.
Task
.
class
.
equals
(
args
[
0
]
)
)
{
continue
;
}
if
(
"addText"
.
equals
(
name
)
&&
java
.
lang
.
Void
.
TYPE
.
equals
(
returnType
)
&&
args
.
length
==
1
&&
java
.
lang
.
String
.
class
.
equals
(
args
[
0
]
)
)
{
addText
=
methods
[
i
]
;
}
else
if
(
name
.
startsWith
(
"set"
)
&&
java
.
lang
.
Void
.
TYPE
.
equals
(
returnType
)
&&
args
.
length
==
1
&&
!
args
[
0
]
.
isArray
(
)
)
{
String
propName
=
getPropertyName
(
name
,
"set"
)
;
if
(
attributeSetters
.
get
(
propName
)
!=
null
)
{
if
(
java
.
lang
.
String
.
class
.
equals
(
args
[
0
]
)
)
{
continue
;
}
}
AttributeSetter
as
=
createAttributeSetter
(
m
,
args
[
0
]
,
propName
)
;
if
(
as
!=
null
)
{
attributeTypes
.
put
(
propName
,
args
[
0
]
)
;
attributeSetters
.
put
(
propName
,
as
)
;
}
}
else
if
(
name
.
startsWith
(
"create"
)
&&
!
returnType
.
isArray
(
)
&&
!
returnType
.
isPrimitive
(
)
&&
args
.
length
==
0
)
{
String
propName
=
getPropertyName
(
name
,
"create"
)
;
if
(
nestedCreators
.
get
(
propName
)
==
null
)
{
nestedTypes
.
put
(
propName
,
returnType
)
;
nestedCreators
.
put
(
propName
,
new
NestedCreator
(
)
{
public
boolean
isPolyMorphic
(
)
{
return
false
;
}
public
Object
getRealObject
(
)
{
return
null
;
}
public
Class
getElementClass
(
)
{
return
null
;
}
public
Object
create
(
Project
project
,
Object
parent
,
Object
ignore
)
throws
InvocationTargetException
,
IllegalAccessException
{
return
m
.
invoke
(
parent
,
new
Object
[
]
{
}
)
;
}
public
void
store
(
Object
parent
,
Object
child
)
{
}
}
)
;
}
}
else
if
(
name
.
startsWith
(
"addConfigured"
)
&&
java
.
lang
.
Void
.
TYPE
.
equals
(
returnType
)
&&
args
.
length
==
1
&&
!
java
.
lang
.
String
.
class
.
equals
(
args
[
0
]
)
&&
!
args
[
0
]
.
isArray
(
)
&&
!
args
[
0
]
.
isPrimitive
(
)
)
{
try
{
Constructor
constructor
=
null
;
try
{
constructor
=
args
[
0
]
.
getConstructor
(
new
Class
[
]
{
}
)
;
}
catch
(
NoSuchMethodException
ex
)
{
constructor
=
args
[
0
]
.
getConstructor
(
new
Class
[
]
{
Project
.
class
}
)
;
}
final
Constructor
c
=
constructor
;
String
propName
=
getPropertyName
(
name
,
"addConfigured"
)
;
nestedTypes
.
put
(
propName
,
args
[
0
]
)
;
nestedCreators
.
put
(
propName
,
new
NestedCreator
(
)
{
public
boolean
isPolyMorphic
(
)
{
return
true
;
}
public
Object
getRealObject
(
)
{
return
null
;
}
public
Class
getElementClass
(
)
{
return
c
.
getDeclaringClass
(
)
;
}
public
Object
create
(
Project
project
,
Object
parent
,
Object
child
)
throws
InvocationTargetException
,
IllegalAccessException
,
InstantiationException
{
if
(
child
!=
null
)
{
return
child
;
}
else
if
(
c
.
getParameterTypes
(
)
.
length
==
0
)
{
return
c
.
newInstance
(
new
Object
[
]
{
}
)
;
}
else
{
return
c
.
newInstance
(
new
Object
[
]
{
project
}
)
;
}
}
public
void
store
(
Object
parent
,
Object
child
)
throws
InvocationTargetException
,
IllegalAccessException
,
InstantiationException
{
m
.
invoke
(
parent
,
new
Object
[
]
{
child
}
)
;
}
}
)
;
}
catch
(
NoSuchMethodException
nse
)
{
}
}
else
if
(
name
.
startsWith
(
"add"
)
&&
java
.
lang
.
Void
.
TYPE
.
equals
(
returnType
)
&&
args
.
length
==
1
&&
!
java
.
lang
.
String
.
class
.
equals
(
args
[
0
]
)
&&
!
args
[
0
]
.
isArray
(
)
&&
!
args
[
0
]
.
isPrimitive
(
)
)
{
try
{
Constructor
constructor
=
null
;
try
{
constructor
=
args
[
0
]
.
getConstructor
(
new
Class
[
]
{
}
)
;
}
catch
(
NoSuchMethodException
ex
)
{
constructor
=
args
[
0
]
.
getConstructor
(
new
Class
[
]
{
Project
.
class
}
)
;
}
final
Constructor
c
=
constructor
;
String
propName
=
getPropertyName
(
name
,
"add"
)
;
nestedTypes
.
put
(
propName
,
args
[
0
]
)
;
nestedCreators
.
put
(
propName
,
new
NestedCreator
(
)
{
public
boolean
isPolyMorphic
(
)
{
return
true
;
}
public
Object
getRealObject
(
)
{
return
null
;
}
public
Class
getElementClass
(
)
{
return
c
.
getDeclaringClass
(
)
;
}
public
Object
create
(
Project
project
,
Object
parent
,
Object
child
)
throws
InvocationTargetException
,
IllegalAccessException
,
InstantiationException
{
if
(
child
!=
null
)
{
}
else
if
(
c
.
getParameterTypes
(
)
.
length
==
0
)
{
child
=
c
.
newInstance
(
new
Object
[
]
{
}
)
;
}
else
{
child
=
c
.
newInstance
(
new
Object
[
]
{
project
}
)
;
}
m
.
invoke
(
parent
,
new
Object
[
]
{
child
}
)
;
return
child
;
}
public
void
store
(
Object
parent
,
Object
child
)
throws
InvocationTargetException
,
IllegalAccessException
,
InstantiationException
{
}
}
)
;
}
catch
(
NoSuchMethodException
nse
)
{
}
}
}
}
private
boolean
isHiddenSetMethod
(
String
name
,
Class
type
)
{
if
(
"setLocation"
.
equals
(
name
)
&&
org
.
apache
.
tools
.
ant
.
Location
.
class
.
equals
(
type
)
)
{
return
true
;
}
if
(
"setTaskType"
.
equals
(
name
)
&&
java
.
lang
.
String
.
class
.
equals
(
type
)
)
{
return
true
;
}
return
false
;
}
public
static
synchronized
IntrospectionHelper
getHelper
(
Class
c
)
{
IntrospectionHelper
ih
=
(
IntrospectionHelper
)
helpers
.
get
(
c
)
;
if
(
ih
==
null
)
{
ih
=
new
IntrospectionHelper
(
c
)
;
helpers
.
put
(
c
,
ih
)
;
}
return
ih
;
}
public
static
synchronized
IntrospectionHelper
getHelper
(
Project
p
,
Class
c
)
{
IntrospectionHelper
ih
=
(
IntrospectionHelper
)
helpers
.
get
(
c
)
;
if
(
ih
==
null
)
{
ih
=
new
IntrospectionHelper
(
c
)
;
helpers
.
put
(
c
,
ih
)
;
p
.
addBuildListener
(
ih
)
;
}
return
ih
;
}
public
void
setAttribute
(
Project
p
,
Object
element
,
String
attributeName
,
String
value
)
throws
BuildException
{
AttributeSetter
as
=
(
AttributeSetter
)
attributeSetters
.
get
(
attributeName
)
;
if
(
as
==
null
)
{
if
(
element
instanceof
DynamicConfigurator
)
{
DynamicConfigurator
dc
=
(
DynamicConfigurator
)
element
;
dc
.
setDynamicAttribute
(
attributeName
,
value
)
;
return
;
}
else
{
String
msg
=
getElementName
(
p
,
element
)
+
" doesn't support the \""
+
attributeName
+
"\" attribute."
;
throw
new
BuildException
(
msg
)
;
}
}
try
{
as
.
set
(
p
,
element
,
value
)
;
}
catch
(
IllegalAccessException
ie
)
{
throw
new
BuildException
(
ie
)
;
}
catch
(
InvocationTargetException
ite
)
{
Throwable
t
=
ite
.
getTargetException
(
)
;
if
(
t
instanceof
BuildException
)
{
throw
(
BuildException
)
t
;
}
throw
new
BuildException
(
t
)
;
}
}
public
void
addText
(
Project
project
,
Object
element
,
String
text
)
throws
BuildException
{
if
(
addText
==
null
)
{
if
(
text
.
trim
(
)
.
length
(
)
==
0
)
{
return
;
}
else
{
String
msg
=
project
.
getElementName
(
element
)
+
" doesn't support nested text data."
;
throw
new
BuildException
(
msg
)
;
}
}
try
{
addText
.
invoke
(
element
,
new
String
[
]
{
text
}
)
;
}
catch
(
IllegalAccessException
ie
)
{
throw
new
BuildException
(
ie
)
;
}
catch
(
InvocationTargetException
ite
)
{
Throwable
t
=
ite
.
getTargetException
(
)
;
if
(
t
instanceof
BuildException
)
{
throw
(
BuildException
)
t
;
}
throw
new
BuildException
(
t
)
;
}
}
public
void
throwNotSupported
(
Project
project
,
Object
parent
,
String
elementName
)
{
String
msg
=
project
.
getElementName
(
parent
)
+
" doesn't support the nested \""
+
elementName
+
"\" element."
;
throw
new
BuildException
(
msg
)
;
}
private
NestedCreator
getNestedCreator
(
Project
project
,
String
parentUri
,
Object
parent
,
String
elementName
)
throws
BuildException
{
String
uri
=
ProjectHelper
.
extractUriFromComponentName
(
elementName
)
;
String
name
=
ProjectHelper
.
extractNameFromComponentName
(
elementName
)
;
NestedCreator
nc
=
null
;
if
(
uri
.
equals
(
parentUri
)
)
{
nc
=
(
NestedCreator
)
nestedCreators
.
get
(
name
.
toLowerCase
(
Locale
.
US
)
)
;
}
if
(
nc
==
null
)
{
nc
=
createAddTypeCreator
(
project
,
parent
,
elementName
)
;
}
if
(
nc
==
null
&&
parent
instanceof
DynamicConfigurator
)
{
DynamicConfigurator
dc
=
(
DynamicConfigurator
)
parent
;
final
Object
nestedElement
=
dc
.
createDynamicElement
(
name
.
toLowerCase
(
Locale
.
US
)
)
;
if
(
nestedElement
!=
null
)
{
nc
=
new
NestedCreator
(
)
{
public
boolean
isPolyMorphic
(
)
{
return
false
;
}
public
Class
getElementClass
(
)
{
return
null
;
}
public
Object
getRealObject
(
)
{
return
null
;
}
public
Object
create
(
Project
project
,
Object
parent
,
Object
ignore
)
{
return
nestedElement
;
}
public
void
store
(
Object
parent
,
Object
child
)
{
}
}
;
}
}
if
(
nc
==
null
)
{
throwNotSupported
(
project
,
parent
,
elementName
)
;
}
return
nc
;
}
public
Object
createElement
(
Project
project
,
Object
parent
,
String
elementName
)
throws
BuildException
{
NestedCreator
nc
=
getNestedCreator
(
project
,
""
,
parent
,
elementName
)
;
try
{
Object
nestedElement
=
nc
.
create
(
project
,
parent
,
null
)
;
if
(
project
!=
null
)
{
project
.
setProjectReference
(
nestedElement
)
;
}
return
nestedElement
;
}
catch
(
IllegalAccessException
ie
)
{
throw
new
BuildException
(
ie
)
;
}
catch
(
InstantiationException
ine
)
{
throw
new
BuildException
(
ine
)
;
}
catch
(
InvocationTargetException
ite
)
{
Throwable
t
=
ite
.
getTargetException
(
)
;
if
(
t
instanceof
BuildException
)
{
throw
(
BuildException
)
t
;
}
throw
new
BuildException
(
t
)
;
}
}
public
Creator
getElementCreator
(
Project
project
,
String
parentUri
,
Object
parent
,
String
elementName
,
UnknownElement
ue
)
{
NestedCreator
nc
=
getNestedCreator
(
project
,
parentUri
,
parent
,
elementName
)
;
return
new
Creator
(
project
,
parent
,
nc
)
;
}
public
boolean
supportsNestedElement
(
String
elementName
)
{
return
nestedCreators
.
containsKey
(
elementName
.
toLowerCase
(
Locale
.
US
)
)
||
DynamicConfigurator
.
class
.
isAssignableFrom
(
bean
)
||
addTypeMethods
.
size
(
)
!=
0
;
}
public
boolean
supportsNestedElement
(
String
parentUri
,
String
elementName
)
{
String
uri
=
ProjectHelper
.
extractUriFromComponentName
(
elementName
)
;
String
name
=
ProjectHelper
.
extractNameFromComponentName
(
elementName
)
;
return
(
nestedCreators
.
containsKey
(
name
.
toLowerCase
(
Locale
.
US
)
)
&&
(
uri
.
equals
(
parentUri
)
)
)
||
DynamicConfigurator
.
class
.
isAssignableFrom
(
bean
)
||
addTypeMethods
.
size
(
)
!=
0
;
}
public
void
storeElement
(
Project
project
,
Object
parent
,
Object
child
,
String
elementName
)
throws
BuildException
{
if
(
elementName
==
null
)
{
return
;
}
NestedCreator
ns
=
(
NestedCreator
)
nestedCreators
.
get
(
elementName
.
toLowerCase
(
Locale
.
US
)
)
;
if
(
ns
==
null
)
{
return
;
}
try
{
ns
.
store
(
parent
,
child
)
;
}
catch
(
IllegalAccessException
ie
)
{
throw
new
BuildException
(
ie
)
;
}
catch
(
InstantiationException
ine
)
{
throw
new
BuildException
(
ine
)
;
}
catch
(
InvocationTargetException
ite
)
{
Throwable
t
=
ite
.
getTargetException
(
)
;
if
(
t
instanceof
BuildException
)
{
throw
(
BuildException
)
t
;
}
throw
new
BuildException
(
t
)
;
}
}
public
Class
getElementType
(
String
elementName
)
throws
BuildException
{
Class
nt
=
(
Class
)
nestedTypes
.
get
(
elementName
)
;
if
(
nt
==
null
)
{
String
msg
=
"Class "
+
bean
.
getName
(
)
+
" doesn't support the nested \""
+
elementName
+
"\" element."
;
throw
new
BuildException
(
msg
)
;
}
return
nt
;
}
public
Class
getAttributeType
(
String
attributeName
)
throws
BuildException
{
Class
at
=
(
Class
)
attributeTypes
.
get
(
attributeName
)
;
if
(
at
==
null
)
{
String
msg
=
"Class "
+
bean
.
getName
(
)
+
" doesn't support the \""
+
attributeName
+
"\" attribute."
;
throw
new
BuildException
(
msg
)
;
}
return
at
;
}
public
boolean
supportsCharacters
(
)
{
return
addText
!=
null
;
}
public
Enumeration
getAttributes
(
)
{
return
attributeSetters
.
keys
(
)
;
}
public
Enumeration
getNestedElements
(
)
{
return
nestedTypes
.
keys
(
)
;
}
private
AttributeSetter
createAttributeSetter
(
final
Method
m
,
Class
arg
,
final
String
attrName
)
{
final
Class
reflectedArg
=
PRIMITIVE_TYPE_MAP
.
containsKey
(
arg
)
?
(
Class
)
PRIMITIVE_TYPE_MAP
.
get
(
arg
)
:
arg
;
if
(
java
.
lang
.
String
.
class
.
equals
(
reflectedArg
)
)
{
return
new
AttributeSetter
(
)
{
public
void
set
(
Project
p
,
Object
parent
,
String
value
)
throws
InvocationTargetException
,
IllegalAccessException
{
m
.
invoke
(
parent
,
new
String
[
]
{
value
}
)
;
}
}
;
}
else
if
(
java
.
lang
.
Character
.
class
.
equals
(
reflectedArg
)
)
{
return
new
AttributeSetter
(
)
{
public
void
set
(
Project
p
,
Object
parent
,
String
value
)
throws
InvocationTargetException
,
IllegalAccessException
{
if
(
value
.
length
(
)
==
0
)
{
throw
new
BuildException
(
"The value \"\" is not a "
+
"legal value for attribute \""
+
attrName
+
"\""
)
;
}
m
.
invoke
(
parent
,
new
Character
[
]
{
new
Character
(
value
.
charAt
(
0
)
)
}
)
;
}
}
;
}
else
if
(
java
.
lang
.
Boolean
.
class
.
equals
(
reflectedArg
)
)
{
return
new
AttributeSetter
(
)
{
public
void
set
(
Project
p
,
Object
parent
,
String
value
)
throws
InvocationTargetException
,
IllegalAccessException
{
m
.
invoke
(
parent
,
new
Boolean
[
]
{
new
Boolean
(
Project
.
toBoolean
(
value
)
)
}
)
;
}
}
;
}
else
if
(
java
.
lang
.
Class
.
class
.
equals
(
reflectedArg
)
)
{
return
new
AttributeSetter
(
)
{
public
void
set
(
Project
p
,
Object
parent
,
String
value
)
throws
InvocationTargetException
,
IllegalAccessException
,
BuildException
{
try
{
m
.
invoke
(
parent
,
new
Class
[
]
{
Class
.
forName
(
value
)
}
)
;
}
catch
(
ClassNotFoundException
ce
)
{
throw
new
BuildException
(
ce
)
;
}
}
}
;
}
else
if
(
java
.
io
.
File
.
class
.
equals
(
reflectedArg
)
)
{
return
new
AttributeSetter
(
)
{
public
void
set
(
Project
p
,
Object
parent
,
String
value
)
throws
InvocationTargetException
,
IllegalAccessException
{
m
.
invoke
(
parent
,
new
File
[
]
{
p
.
resolveFile
(
value
)
}
)
;
}
}
;
}
else
if
(
org
.
apache
.
tools
.
ant
.
types
.
Path
.
class
.
equals
(
reflectedArg
)
)
{
return
new
AttributeSetter
(
)
{
public
void
set
(
Project
p
,
Object
parent
,
String
value
)
throws
InvocationTargetException
,
IllegalAccessException
{
m
.
invoke
(
parent
,
new
Path
[
]
{
new
Path
(
p
,
value
)
}
)
;
}
}
;
}
else
if
(
EnumeratedAttribute
.
class
.
isAssignableFrom
(
reflectedArg
)
)
{
return
new
AttributeSetter
(
)
{
public
void
set
(
Project
p
,
Object
parent
,
String
value
)
throws
InvocationTargetException
,
IllegalAccessException
,
BuildException
{
try
{
EnumeratedAttribute
ea
=
(
EnumeratedAttribute
)
reflectedArg
.
newInstance
(
)
;
ea
.
setValue
(
value
)
;
m
.
invoke
(
parent
,
new
EnumeratedAttribute
[
]
{
ea
}
)
;
}
catch
(
InstantiationException
ie
)
{
throw
new
BuildException
(
ie
)
;
}
}
}
;
}
else
{
try
{
final
Constructor
c
=
reflectedArg
.
getConstructor
(
new
Class
[
]
{
java
.
lang
.
String
.
class
}
)
;
return
new
AttributeSetter
(
)
{
public
void
set
(
Project
p
,
Object
parent
,
String
value
)
throws
InvocationTargetException
,
IllegalAccessException
,
BuildException
{
try
{
Object
attribute
=
c
.
newInstance
(
new
String
[
]
{
value
}
)
;
if
(
p
!=
null
)
{
p
.
setProjectReference
(
attribute
)
;
}
m
.
invoke
(
parent
,
new
Object
[
]
{
attribute
}
)
;
}
catch
(
InstantiationException
ie
)
{
throw
new
BuildException
(
ie
)
;
}
}
}
;
}
catch
(
NoSuchMethodException
nme
)
{
}
}
return
null
;
}
protected
String
getElementName
(
Project
project
,
Object
element
)
{
return
project
.
getElementName
(
element
)
;
}
private
String
getPropertyName
(
String
methodName
,
String
prefix
)
{
int
start
=
prefix
.
length
(
)
;
return
methodName
.
substring
(
start
)
.
toLowerCase
(
Locale
.
US
)
;
}
public
static
final
class
Creator
{
private
NestedCreator
nestedCreator
;
private
Object
parent
;
private
Project
project
;
private
Object
nestedObject
;
private
String
polyType
;
private
Creator
(
Project
project
,
Object
parent
,
NestedCreator
nestedCreator
)
{
this
.
project
=
project
;
this
.
parent
=
parent
;
this
.
nestedCreator
=
nestedCreator
;
}
public
void
setPolyType
(
String
polyType
)
{
this
.
polyType
=
polyType
;
}
public
Object
create
(
)
{
if
(
polyType
!=
null
)
{
if
(
!
nestedCreator
.
isPolyMorphic
(
)
)
{
throw
new
BuildException
(
"Not allowed to use the polymorphic form"
+
" for this element"
)
;
}
Class
elementClass
=
nestedCreator
.
getElementClass
(
)
;
ComponentHelper
helper
=
ComponentHelper
.
getComponentHelper
(
project
)
;
nestedObject
=
ComponentHelper
.
getComponentHelper
(
project
)
.
createComponent
(
polyType
)
;
if
(
nestedObject
==
null
)
{
throw
new
BuildException
(
"Unable to create object of type "
+
polyType
)
;
}
}
try
{
nestedObject
=
nestedCreator
.
create
(
project
,
parent
,
nestedObject
)
;
if
(
project
!=
null
)
{
project
.
setProjectReference
(
nestedObject
)
;
}
return
nestedObject
;
}
catch
(
IllegalAccessException
ex
)
{
throw
new
BuildException
(
ex
)
;
}
catch
(
InstantiationException
ex
)
{
throw
new
BuildException
(
ex
)
;
}
catch
(
IllegalArgumentException
ex
)
{
if
(
polyType
!=
null
)
{
throw
new
BuildException
(
"Invalid type used "
+
polyType
)
;
}
throw
ex
;
}
catch
(
InvocationTargetException
ex
)
{
Throwable
t
=
ex
.
getTargetException
(
)
;
if
(
t
instanceof
BuildException
)
{
throw
(
BuildException
)
t
;
}
throw
new
BuildException
(
t
)
;
}
}
public
Object
getRealObject
(
)
{
return
nestedCreator
.
getRealObject
(
)
;
}
public
void
store
(
)
{
try
{
nestedCreator
.
store
(
parent
,
nestedObject
)
;
}
catch
(
IllegalAccessException
ex
)
{
throw
new
BuildException
(
ex
)
;
}
catch
(
InstantiationException
ex
)
{
throw
new
BuildException
(
ex
)
;
}
catch
(
IllegalArgumentException
ex
)
{
if
(
polyType
!=
null
)
{
throw
new
BuildException
(
"Invalid type used "
+
polyType
)
;
}
throw
ex
;
}
catch
(
InvocationTargetException
ex
)
{
Throwable
t
=
ex
.
getTargetException
(
)
;
if
(
t
instanceof
BuildException
)
{
throw
(
BuildException
)
t
;
}
throw
new
BuildException
(
t
)
;
}
}
}
private
interface
NestedCreator
{
boolean
isPolyMorphic
(
)
;
Class
getElementClass
(
)
;
Object
getRealObject
(
)
;
Object
create
(
Project
project
,
Object
parent
,
Object
child
)
throws
InvocationTargetException
,
IllegalAccessException
,
InstantiationException
;
void
store
(
Object
parent
,
Object
child
)
throws
InvocationTargetException
,
IllegalAccessException
,
InstantiationException
;
}
private
interface
AttributeSetter
{
void
set
(
Project
p
,
Object
parent
,
String
value
)
throws
InvocationTargetException
,
IllegalAccessException
,
BuildException
;
}
public
void
buildFinished
(
BuildEvent
event
)
{
attributeTypes
.
clear
(
)
;
attributeSetters
.
clear
(
)
;
nestedTypes
.
clear
(
)
;
nestedCreators
.
clear
(
)
;
addText
=
null
;
helpers
.
clear
(
)
;
}
public
void
buildStarted
(
BuildEvent
event
)
{
}
public
void
targetStarted
(
BuildEvent
event
)
{
}
public
void
targetFinished
(
BuildEvent
event
)
{
}
public
void
taskStarted
(
BuildEvent
event
)
{
}
public
void
taskFinished
(
BuildEvent
event
)
{
}
public
void
messageLogged
(
BuildEvent
event
)
{
}
private
NestedCreator
createAddTypeCreator
(
Project
project
,
Object
parent
,
String
elementName
)
throws
BuildException
{
if
(
addTypeMethods
.
size
(
)
==
0
)
{
return
null
;
}
ComponentHelper
helper
=
ComponentHelper
.
getComponentHelper
(
project
)
;
Object
addedObject
=
null
;
Method
addMethod
=
null
;
Class
clazz
=
helper
.
getComponentClass
(
elementName
)
;
if
(
clazz
==
null
)
{
return
null
;
}
addMethod
=
findMatchingMethod
(
clazz
,
addTypeMethods
)
;
if
(
addMethod
==
null
)
{
return
null
;
}
addedObject
=
helper
.
createComponent
(
elementName
)
;
if
(
addedObject
==
null
)
{
return
null
;
}
Object
rObject
=
addedObject
;
if
(
addedObject
instanceof
PreSetDef
.
PreSetDefinition
)
{
rObject
=
(
(
PreSetDef
.
PreSetDefinition
)
addedObject
)
.
createObject
(
project
)
;
}
final
Method
method
=
addMethod
;
final
Object
nestedObject
=
addedObject
;
final
Object
realObject
=
rObject
;
return
new
NestedCreator
(
)
{
public
boolean
isPolyMorphic
(
)
{
return
false
;
}
public
Class
getElementClass
(
)
{
return
null
;
}
public
Object
create
(
Project
project
,
Object
parent
,
Object
ignore
)
throws
InvocationTargetException
,
IllegalAccessException
{
if
(
!
method
.
getName
(
)
.
endsWith
(
"Configured"
)
)
{
method
.
invoke
(
parent
,
new
Object
[
]
{
realObject
}
)
;
}
return
nestedObject
;
}
public
Object
getRealObject
(
)
{
return
realObject
;
}
public
void
store
(
Object
parent
,
Object
child
)
throws
InvocationTargetException
,
IllegalAccessException
,
InstantiationException
{
if
(
method
.
getName
(
)
.
endsWith
(
"Configured"
)
)
{
method
.
invoke
(
parent
,
new
Object
[
]
{
realObject
}
)
;
}
}
}
;
}
private
void
insertAddTypeMethod
(
Method
method
)
{
Class
argClass
=
method
.
getParameterTypes
(
)
[
0
]
;
for
(
int
c
=
0
;
c
<
addTypeMethods
.
size
(
)
;
++
c
)
{
Method
current
=
(
Method
)
addTypeMethods
.
get
(
c
)
;
if
(
current
.
getParameterTypes
(
)
[
0
]
.
equals
(
argClass
)
)
{
return
;
}
if
(
current
.
getParameterTypes
(
)
[
0
]
.
isAssignableFrom
(
argClass
)
)
{
addTypeMethods
.
add
(
c
,
method
)
;
return
;
}
}
addTypeMethods
.
add
(
method
)
;
}
private
Method
findMatchingMethod
(
Class
paramClass
,
List
methods
)
{
Class
matchedClass
=
null
;
Method
matchedMethod
=
null
;
for
(
int
i
=
0
;
i
<
methods
.
size
(
)
;
++
i
)
{
Method
method
=
(
Method
)
methods
.
get
(
i
)
;
Class
methodClass
=
method
.
getParameterTypes
(
)
[
0
]
;
if
(
methodClass
.
isAssignableFrom
(
paramClass
)
)
{
if
(
matchedClass
==
null
)
{
matchedClass
=
methodClass
;
matchedMethod
=
method
;
}
else
{
if
(
!
methodClass
.
isAssignableFrom
(
matchedClass
)
)
{
throw
new
BuildException
(
"ambiguous: types "
+
matchedClass
.
getName
(
)
+
" and "
+
methodClass
.
getName
(
)
+
" match "
+
paramClass
.
getName
(
)
)
;
}
}
}
}
return
matchedMethod
;
}
}
