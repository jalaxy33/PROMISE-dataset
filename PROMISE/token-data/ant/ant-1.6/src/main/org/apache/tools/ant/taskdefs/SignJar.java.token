package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Vector
;
import
java
.
util
.
zip
.
ZipEntry
;
import
java
.
util
.
zip
.
ZipFile
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
org
.
apache
.
tools
.
ant
.
util
.
JavaEnvUtils
;
public
class
SignJar
extends
Task
{
protected
File
jar
;
protected
String
alias
;
private
String
keystore
;
protected
String
storepass
;
protected
String
storetype
;
protected
String
keypass
;
protected
String
sigfile
;
protected
File
signedjar
;
protected
boolean
verbose
;
protected
boolean
internalsf
;
protected
boolean
sectionsonly
;
private
String
maxMemory
;
protected
Vector
filesets
=
new
Vector
(
)
;
protected
boolean
lazy
;
public
void
setMaxmemory
(
String
max
)
{
maxMemory
=
max
;
}
public
void
setJar
(
final
File
jar
)
{
this
.
jar
=
jar
;
}
public
void
setAlias
(
final
String
alias
)
{
this
.
alias
=
alias
;
}
public
void
setKeystore
(
final
String
keystore
)
{
this
.
keystore
=
keystore
;
}
public
void
setStorepass
(
final
String
storepass
)
{
this
.
storepass
=
storepass
;
}
public
void
setStoretype
(
final
String
storetype
)
{
this
.
storetype
=
storetype
;
}
public
void
setKeypass
(
final
String
keypass
)
{
this
.
keypass
=
keypass
;
}
public
void
setSigfile
(
final
String
sigfile
)
{
this
.
sigfile
=
sigfile
;
}
public
void
setSignedjar
(
final
File
signedjar
)
{
this
.
signedjar
=
signedjar
;
}
public
void
setVerbose
(
final
boolean
verbose
)
{
this
.
verbose
=
verbose
;
}
public
void
setInternalsf
(
final
boolean
internalsf
)
{
this
.
internalsf
=
internalsf
;
}
public
void
setSectionsonly
(
final
boolean
sectionsonly
)
{
this
.
sectionsonly
=
sectionsonly
;
}
public
void
setLazy
(
final
boolean
lazy
)
{
this
.
lazy
=
lazy
;
}
public
void
addFileset
(
final
FileSet
set
)
{
filesets
.
addElement
(
set
)
;
}
public
void
execute
(
)
throws
BuildException
{
if
(
null
==
jar
&&
filesets
.
size
(
)
==
0
)
{
throw
new
BuildException
(
"jar must be set through jar attribute "
+
"or nested filesets"
)
;
}
if
(
null
!=
jar
)
{
if
(
filesets
.
size
(
)
!=
0
)
{
log
(
"nested filesets will be ignored if the jar attribute has"
+
" been specified."
,
Project
.
MSG_WARN
)
;
}
doOneJar
(
jar
,
signedjar
)
;
return
;
}
else
{
for
(
int
i
=
0
;
i
<
filesets
.
size
(
)
;
i
++
)
{
FileSet
fs
=
(
FileSet
)
filesets
.
elementAt
(
i
)
;
DirectoryScanner
ds
=
fs
.
getDirectoryScanner
(
getProject
(
)
)
;
String
[
]
jarFiles
=
ds
.
getIncludedFiles
(
)
;
for
(
int
j
=
0
;
j
<
jarFiles
.
length
;
j
++
)
{
doOneJar
(
new
File
(
fs
.
getDir
(
getProject
(
)
)
,
jarFiles
[
j
]
)
,
null
)
;
}
}
}
}
private
void
doOneJar
(
File
jarSource
,
File
jarTarget
)
throws
BuildException
{
if
(
null
==
alias
)
{
throw
new
BuildException
(
"alias attribute must be set"
)
;
}
if
(
null
==
storepass
)
{
throw
new
BuildException
(
"storepass attribute must be set"
)
;
}
if
(
isUpToDate
(
jarSource
,
jarTarget
)
)
{
return
;
}
final
ExecTask
cmd
=
(
ExecTask
)
getProject
(
)
.
createTask
(
"exec"
)
;
cmd
.
setExecutable
(
JavaEnvUtils
.
getJdkExecutable
(
"jarsigner"
)
)
;
if
(
maxMemory
!=
null
)
{
cmd
.
createArg
(
)
.
setValue
(
"-J-Xmx"
+
maxMemory
)
;
}
if
(
null
!=
keystore
)
{
File
keystoreFile
=
getProject
(
)
.
resolveFile
(
keystore
)
;
if
(
keystoreFile
.
exists
(
)
)
{
cmd
.
createArg
(
)
.
setValue
(
"-keystore"
)
;
cmd
.
createArg
(
)
.
setValue
(
keystoreFile
.
getPath
(
)
)
;
}
else
{
cmd
.
createArg
(
)
.
setValue
(
"-keystore"
)
;
cmd
.
createArg
(
)
.
setValue
(
keystore
)
;
}
}
if
(
null
!=
storepass
)
{
cmd
.
createArg
(
)
.
setValue
(
"-storepass"
)
;
cmd
.
createArg
(
)
.
setValue
(
storepass
)
;
}
if
(
null
!=
storetype
)
{
cmd
.
createArg
(
)
.
setValue
(
"-storetype"
)
;
cmd
.
createArg
(
)
.
setValue
(
storetype
)
;
}
if
(
null
!=
keypass
)
{
cmd
.
createArg
(
)
.
setValue
(
"-keypass"
)
;
cmd
.
createArg
(
)
.
setValue
(
keypass
)
;
}
if
(
null
!=
sigfile
)
{
cmd
.
createArg
(
)
.
setValue
(
"-sigfile"
)
;
cmd
.
createArg
(
)
.
setValue
(
sigfile
)
;
}
if
(
null
!=
jarTarget
)
{
cmd
.
createArg
(
)
.
setValue
(
"-signedjar"
)
;
cmd
.
createArg
(
)
.
setValue
(
jarTarget
.
toString
(
)
)
;
}
if
(
verbose
)
{
cmd
.
createArg
(
)
.
setValue
(
"-verbose"
)
;
}
if
(
internalsf
)
{
cmd
.
createArg
(
)
.
setValue
(
"-internalsf"
)
;
}
if
(
sectionsonly
)
{
cmd
.
createArg
(
)
.
setValue
(
"-sectionsonly"
)
;
}
cmd
.
createArg
(
)
.
setValue
(
jarSource
.
toString
(
)
)
;
cmd
.
createArg
(
)
.
setValue
(
alias
)
;
log
(
"Signing Jar : "
+
jarSource
.
getAbsolutePath
(
)
)
;
cmd
.
setFailonerror
(
true
)
;
cmd
.
setTaskName
(
getTaskName
(
)
)
;
cmd
.
execute
(
)
;
}
protected
boolean
isUpToDate
(
File
jarFile
,
File
signedjarFile
)
{
if
(
null
==
jarFile
)
{
return
false
;
}
if
(
null
!=
signedjarFile
)
{
if
(
!
jarFile
.
exists
(
)
)
{
return
false
;
}
if
(
!
signedjarFile
.
exists
(
)
)
{
return
false
;
}
if
(
jarFile
.
equals
(
signedjarFile
)
)
{
return
false
;
}
if
(
signedjarFile
.
lastModified
(
)
>
jarFile
.
lastModified
(
)
)
{
return
true
;
}
}
else
{
if
(
lazy
)
{
return
isSigned
(
jarFile
)
;
}
}
return
false
;
}
protected
boolean
isSigned
(
File
file
)
{
final
String
SIG_START
=
"META-INF/"
;
final
String
SIG_END
=
".SF"
;
if
(
!
file
.
exists
(
)
)
{
return
false
;
}
ZipFile
jarFile
=
null
;
try
{
jarFile
=
new
ZipFile
(
file
)
;
if
(
null
==
alias
)
{
Enumeration
entries
=
jarFile
.
entries
(
)
;
while
(
entries
.
hasMoreElements
(
)
)
{
String
name
=
(
(
ZipEntry
)
entries
.
nextElement
(
)
)
.
getName
(
)
;
if
(
name
.
startsWith
(
SIG_START
)
&&
name
.
endsWith
(
SIG_END
)
)
{
return
true
;
}
}
return
false
;
}
else
{
return
jarFile
.
getEntry
(
SIG_START
+
alias
.
toUpperCase
(
)
+
SIG_END
)
!=
null
;
}
}
catch
(
IOException
e
)
{
return
false
;
}
finally
{
if
(
jarFile
!=
null
)
{
try
{
jarFile
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
}
}
}
