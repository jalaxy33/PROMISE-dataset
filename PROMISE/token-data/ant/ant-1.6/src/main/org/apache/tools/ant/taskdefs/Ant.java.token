package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
PrintStream
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Set
;
import
java
.
util
.
HashSet
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
BuildListener
;
import
org
.
apache
.
tools
.
ant
.
DefaultLogger
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
ProjectComponent
;
import
org
.
apache
.
tools
.
ant
.
ProjectHelper
;
import
org
.
apache
.
tools
.
ant
.
Target
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
types
.
PropertySet
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
public
class
Ant
extends
Task
{
private
File
dir
=
null
;
private
String
antFile
=
null
;
private
String
target
=
null
;
private
String
output
=
null
;
private
boolean
inheritAll
=
true
;
private
boolean
inheritRefs
=
false
;
private
Vector
properties
=
new
Vector
(
)
;
private
Vector
references
=
new
Vector
(
)
;
private
Project
newProject
;
private
PrintStream
out
=
null
;
private
Vector
propertySets
=
new
Vector
(
)
;
public
void
setInheritAll
(
boolean
value
)
{
inheritAll
=
value
;
}
public
void
setInheritRefs
(
boolean
value
)
{
inheritRefs
=
value
;
}
public
void
init
(
)
{
newProject
=
new
Project
(
)
;
newProject
.
setDefaultInputStream
(
getProject
(
)
.
getDefaultInputStream
(
)
)
;
newProject
.
setJavaVersionProperty
(
)
;
}
private
void
reinit
(
)
{
init
(
)
;
}
private
void
initializeProject
(
)
{
newProject
.
setInputHandler
(
getProject
(
)
.
getInputHandler
(
)
)
;
Vector
listeners
=
getProject
(
)
.
getBuildListeners
(
)
;
final
int
count
=
listeners
.
size
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
newProject
.
addBuildListener
(
(
BuildListener
)
listeners
.
elementAt
(
i
)
)
;
}
if
(
output
!=
null
)
{
File
outfile
=
null
;
if
(
dir
!=
null
)
{
outfile
=
FileUtils
.
newFileUtils
(
)
.
resolveFile
(
dir
,
output
)
;
}
else
{
outfile
=
getProject
(
)
.
resolveFile
(
output
)
;
}
try
{
out
=
new
PrintStream
(
new
FileOutputStream
(
outfile
)
)
;
DefaultLogger
logger
=
new
DefaultLogger
(
)
;
logger
.
setMessageOutputLevel
(
Project
.
MSG_INFO
)
;
logger
.
setOutputPrintStream
(
out
)
;
logger
.
setErrorPrintStream
(
out
)
;
newProject
.
addBuildListener
(
logger
)
;
}
catch
(
IOException
ex
)
{
log
(
"Ant: Can't set output to "
+
output
)
;
}
}
getProject
(
)
.
initSubProject
(
newProject
)
;
getProject
(
)
.
copyUserProperties
(
newProject
)
;
if
(
!
inheritAll
)
{
newProject
.
setSystemProperties
(
)
;
}
else
{
addAlmostAll
(
getProject
(
)
.
getProperties
(
)
)
;
}
Enumeration
e
=
propertySets
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
PropertySet
ps
=
(
PropertySet
)
e
.
nextElement
(
)
;
addAlmostAll
(
ps
.
getProperties
(
)
)
;
}
}
public
void
handleOutput
(
String
output
)
{
if
(
newProject
!=
null
)
{
newProject
.
demuxOutput
(
output
,
false
)
;
}
else
{
super
.
handleOutput
(
output
)
;
}
}
public
int
handleInput
(
byte
[
]
buffer
,
int
offset
,
int
length
)
throws
IOException
{
if
(
newProject
!=
null
)
{
return
newProject
.
demuxInput
(
buffer
,
offset
,
length
)
;
}
else
{
return
super
.
handleInput
(
buffer
,
offset
,
length
)
;
}
}
public
void
handleFlush
(
String
output
)
{
if
(
newProject
!=
null
)
{
newProject
.
demuxFlush
(
output
,
false
)
;
}
else
{
super
.
handleFlush
(
output
)
;
}
}
public
void
handleErrorOutput
(
String
output
)
{
if
(
newProject
!=
null
)
{
newProject
.
demuxOutput
(
output
,
true
)
;
}
else
{
super
.
handleErrorOutput
(
output
)
;
}
}
public
void
handleErrorFlush
(
String
output
)
{
if
(
newProject
!=
null
)
{
newProject
.
demuxFlush
(
output
,
true
)
;
}
else
{
super
.
handleErrorFlush
(
output
)
;
}
}
public
void
execute
(
)
throws
BuildException
{
File
savedDir
=
dir
;
String
savedAntFile
=
antFile
;
String
savedTarget
=
target
;
try
{
if
(
newProject
==
null
)
{
reinit
(
)
;
}
if
(
(
dir
==
null
)
&&
(
inheritAll
)
)
{
dir
=
getProject
(
)
.
getBaseDir
(
)
;
}
initializeProject
(
)
;
if
(
dir
!=
null
)
{
newProject
.
setBaseDir
(
dir
)
;
if
(
savedDir
!=
null
)
{
newProject
.
setInheritedProperty
(
"basedir"
,
dir
.
getAbsolutePath
(
)
)
;
}
}
else
{
dir
=
getProject
(
)
.
getBaseDir
(
)
;
}
overrideProperties
(
)
;
if
(
antFile
==
null
)
{
antFile
=
"build.xml"
;
}
File
file
=
FileUtils
.
newFileUtils
(
)
.
resolveFile
(
dir
,
antFile
)
;
antFile
=
file
.
getAbsolutePath
(
)
;
log
(
"calling target "
+
(
target
!=
null
?
target
:
"[default]"
)
+
" in build file "
+
antFile
,
Project
.
MSG_VERBOSE
)
;
newProject
.
setUserProperty
(
"ant.file"
,
antFile
)
;
if
(
newProject
.
getProperty
(
"ant.file"
)
.
equals
(
getProject
(
)
.
getProperty
(
"ant.file"
)
)
&&
getOwningTarget
(
)
!=
null
)
{
if
(
getOwningTarget
(
)
.
getName
(
)
.
equals
(
""
)
)
{
if
(
getTaskName
(
)
.
equals
(
"antcall"
)
)
{
throw
new
BuildException
(
"antcall must not be used at"
+
" the top level."
)
;
}
else
{
throw
new
BuildException
(
getTaskName
(
)
+
" task at the"
+
" top level must not invoke"
+
" its own build file."
)
;
}
}
}
try
{
ProjectHelper
.
configureProject
(
newProject
,
new
File
(
antFile
)
)
;
}
catch
(
BuildException
ex
)
{
throw
ProjectHelper
.
addLocationToBuildException
(
ex
,
getLocation
(
)
)
;
}
if
(
target
==
null
)
{
target
=
newProject
.
getDefaultTarget
(
)
;
}
if
(
newProject
.
getProperty
(
"ant.file"
)
.
equals
(
getProject
(
)
.
getProperty
(
"ant.file"
)
)
&&
getOwningTarget
(
)
!=
null
)
{
String
owningTargetName
=
getOwningTarget
(
)
.
getName
(
)
;
if
(
owningTargetName
.
equals
(
target
)
)
{
throw
new
BuildException
(
getTaskName
(
)
+
" task calling "
+
"its own parent target."
)
;
}
else
{
Target
other
=
(
Target
)
getProject
(
)
.
getTargets
(
)
.
get
(
target
)
;
if
(
other
!=
null
&&
other
.
dependsOn
(
owningTargetName
)
)
{
throw
new
BuildException
(
getTaskName
(
)
+
" task calling a target"
+
" that depends on"
+
" its parent target \'"
+
owningTargetName
+
"\'."
)
;
}
}
}
addReferences
(
)
;
if
(
target
!=
null
&&
!
""
.
equals
(
target
)
)
{
try
{
log
(
"Entering "
+
antFile
+
"..."
,
Project
.
MSG_VERBOSE
)
;
newProject
.
executeTarget
(
target
)
;
}
catch
(
BuildException
ex
)
{
throw
ProjectHelper
.
addLocationToBuildException
(
ex
,
getLocation
(
)
)
;
}
finally
{
log
(
"Exiting "
+
antFile
+
"."
,
Project
.
MSG_VERBOSE
)
;
}
}
}
finally
{
newProject
=
null
;
Enumeration
e
=
properties
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
Property
p
=
(
Property
)
e
.
nextElement
(
)
;
p
.
setProject
(
null
)
;
}
if
(
output
!=
null
&&
out
!=
null
)
{
try
{
out
.
close
(
)
;
}
catch
(
final
Exception
ex
)
{
}
}
dir
=
savedDir
;
antFile
=
savedAntFile
;
target
=
savedTarget
;
}
}
private
void
overrideProperties
(
)
throws
BuildException
{
Set
set
=
new
HashSet
(
)
;
for
(
int
i
=
properties
.
size
(
)
-
1
;
i
>=
0
;
--
i
)
{
Property
p
=
(
Property
)
properties
.
get
(
i
)
;
if
(
p
.
getName
(
)
!=
null
&&
!
p
.
getName
(
)
.
equals
(
""
)
)
{
if
(
set
.
contains
(
p
.
getName
(
)
)
)
{
properties
.
remove
(
i
)
;
}
else
{
set
.
add
(
p
.
getName
(
)
)
;
}
}
}
Enumeration
e
=
properties
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
Property
p
=
(
Property
)
e
.
nextElement
(
)
;
p
.
setProject
(
newProject
)
;
p
.
execute
(
)
;
}
getProject
(
)
.
copyInheritedProperties
(
newProject
)
;
}
private
void
addReferences
(
)
throws
BuildException
{
Hashtable
thisReferences
=
(
Hashtable
)
getProject
(
)
.
getReferences
(
)
.
clone
(
)
;
Hashtable
newReferences
=
newProject
.
getReferences
(
)
;
Enumeration
e
;
if
(
references
.
size
(
)
>
0
)
{
for
(
e
=
references
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
Reference
ref
=
(
Reference
)
e
.
nextElement
(
)
;
String
refid
=
ref
.
getRefId
(
)
;
if
(
refid
==
null
)
{
throw
new
BuildException
(
"the refid attribute is required"
+
" for reference elements"
)
;
}
if
(
!
thisReferences
.
containsKey
(
refid
)
)
{
log
(
"Parent project doesn't contain any reference '"
+
refid
+
"'"
,
Project
.
MSG_WARN
)
;
continue
;
}
thisReferences
.
remove
(
refid
)
;
String
toRefid
=
ref
.
getToRefid
(
)
;
if
(
toRefid
==
null
)
{
toRefid
=
refid
;
}
copyReference
(
refid
,
toRefid
)
;
}
}
if
(
inheritRefs
)
{
for
(
e
=
thisReferences
.
keys
(
)
;
e
.
hasMoreElements
(
)
;
)
{
String
key
=
(
String
)
e
.
nextElement
(
)
;
if
(
newReferences
.
containsKey
(
key
)
)
{
continue
;
}
copyReference
(
key
,
key
)
;
}
}
}
private
void
copyReference
(
String
oldKey
,
String
newKey
)
{
Object
orig
=
getProject
(
)
.
getReference
(
oldKey
)
;
if
(
orig
==
null
)
{
log
(
"No object referenced by "
+
oldKey
+
". Can't copy to "
+
newKey
,
Project
.
MSG_WARN
)
;
return
;
}
Class
c
=
orig
.
getClass
(
)
;
Object
copy
=
orig
;
try
{
Method
cloneM
=
c
.
getMethod
(
"clone"
,
new
Class
[
0
]
)
;
if
(
cloneM
!=
null
)
{
copy
=
cloneM
.
invoke
(
orig
,
new
Object
[
0
]
)
;
log
(
"Adding clone of reference "
+
oldKey
,
Project
.
MSG_DEBUG
)
;
}
}
catch
(
Exception
e
)
{
}
if
(
copy
instanceof
ProjectComponent
)
{
(
(
ProjectComponent
)
copy
)
.
setProject
(
newProject
)
;
}
else
{
try
{
Method
setProjectM
=
c
.
getMethod
(
"setProject"
,
new
Class
[
]
{
Project
.
class
}
)
;
if
(
setProjectM
!=
null
)
{
setProjectM
.
invoke
(
copy
,
new
Object
[
]
{
newProject
}
)
;
}
}
catch
(
NoSuchMethodException
e
)
{
}
catch
(
Exception
e2
)
{
String
msg
=
"Error setting new project instance for "
+
"reference with id "
+
oldKey
;
throw
new
BuildException
(
msg
,
e2
,
getLocation
(
)
)
;
}
}
newProject
.
addReference
(
newKey
,
copy
)
;
}
private
void
addAlmostAll
(
Hashtable
props
)
{
Enumeration
e
=
props
.
keys
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
String
key
=
e
.
nextElement
(
)
.
toString
(
)
;
if
(
"basedir"
.
equals
(
key
)
||
"ant.file"
.
equals
(
key
)
)
{
continue
;
}
String
value
=
props
.
get
(
key
)
.
toString
(
)
;
if
(
newProject
.
getProperty
(
key
)
==
null
)
{
newProject
.
setNewProperty
(
key
,
value
)
;
}
}
}
public
void
setDir
(
File
d
)
{
this
.
dir
=
d
;
}
public
void
setAntfile
(
String
s
)
{
this
.
antFile
=
s
;
}
public
void
setTarget
(
String
s
)
{
if
(
s
.
equals
(
""
)
)
{
throw
new
BuildException
(
"target attribute must not be empty"
)
;
}
this
.
target
=
s
;
}
public
void
setOutput
(
String
s
)
{
this
.
output
=
s
;
}
public
Property
createProperty
(
)
{
if
(
newProject
==
null
)
{
reinit
(
)
;
}
Property
p
=
new
Property
(
true
,
getProject
(
)
)
;
p
.
setProject
(
newProject
)
;
p
.
setTaskName
(
"property"
)
;
properties
.
addElement
(
p
)
;
return
p
;
}
public
void
addReference
(
Reference
r
)
{
references
.
addElement
(
r
)
;
}
public
void
addPropertyset
(
PropertySet
ps
)
{
propertySets
.
addElement
(
ps
)
;
}
public
static
class
Reference
extends
org
.
apache
.
tools
.
ant
.
types
.
Reference
{
public
Reference
(
)
{
super
(
)
;
}
private
String
targetid
=
null
;
public
void
setToRefid
(
String
targetid
)
{
this
.
targetid
=
targetid
;
}
public
String
getToRefid
(
)
{
return
targetid
;
}
}
}
