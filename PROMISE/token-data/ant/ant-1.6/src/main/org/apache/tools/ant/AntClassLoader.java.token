package
org
.
apache
.
tools
.
ant
;
import
java
.
io
.
ByteArrayOutputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
lang
.
reflect
.
Constructor
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
net
.
MalformedURLException
;
import
java
.
net
.
URL
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Vector
;
import
java
.
util
.
zip
.
ZipEntry
;
import
java
.
util
.
zip
.
ZipFile
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
util
.
JavaEnvUtils
;
import
org
.
apache
.
tools
.
ant
.
util
.
LoaderUtils
;
public
class
AntClassLoader
extends
ClassLoader
implements
BuildListener
{
private
class
ResourceEnumeration
implements
Enumeration
{
private
String
resourceName
;
private
int
pathElementsIndex
;
private
URL
nextResource
;
ResourceEnumeration
(
String
name
)
{
this
.
resourceName
=
name
;
this
.
pathElementsIndex
=
0
;
findNextResource
(
)
;
}
public
boolean
hasMoreElements
(
)
{
return
(
this
.
nextResource
!=
null
)
;
}
public
Object
nextElement
(
)
{
URL
ret
=
this
.
nextResource
;
findNextResource
(
)
;
return
ret
;
}
private
void
findNextResource
(
)
{
URL
url
=
null
;
while
(
(
pathElementsIndex
<
pathComponents
.
size
(
)
)
&&
(
url
==
null
)
)
{
try
{
File
pathComponent
=
(
File
)
pathComponents
.
elementAt
(
pathElementsIndex
)
;
url
=
getResourceURL
(
pathComponent
,
this
.
resourceName
)
;
pathElementsIndex
++
;
}
catch
(
BuildException
e
)
{
}
}
this
.
nextResource
=
url
;
}
}
private
static
final
int
BUFFER_SIZE
=
8192
;
private
static
final
int
NUMBER_OF_STRINGS
=
256
;
private
Vector
pathComponents
=
new
Vector
(
)
;
private
Project
project
;
private
boolean
parentFirst
=
true
;
private
Vector
systemPackages
=
new
Vector
(
)
;
private
Vector
loaderPackages
=
new
Vector
(
)
;
private
boolean
ignoreBase
=
false
;
private
ClassLoader
parent
=
null
;
private
Hashtable
zipFiles
=
new
Hashtable
(
)
;
private
ClassLoader
savedContextLoader
=
null
;
private
boolean
isContextLoaderSaved
=
false
;
private
static
Method
getProtectionDomain
=
null
;
private
static
Method
defineClassProtectionDomain
=
null
;
static
{
try
{
getProtectionDomain
=
Class
.
class
.
getMethod
(
"getProtectionDomain"
,
new
Class
[
0
]
)
;
Class
protectionDomain
=
Class
.
forName
(
"java.security.ProtectionDomain"
)
;
Class
[
]
args
=
new
Class
[
]
{
String
.
class
,
byte
[
]
.
class
,
Integer
.
TYPE
,
Integer
.
TYPE
,
protectionDomain
}
;
defineClassProtectionDomain
=
ClassLoader
.
class
.
getDeclaredMethod
(
"defineClass"
,
args
)
;
}
catch
(
Exception
e
)
{
}
}
public
AntClassLoader
(
)
{
setParent
(
null
)
;
}
public
AntClassLoader
(
Project
project
,
Path
classpath
)
{
setParent
(
null
)
;
setProject
(
project
)
;
setClassPath
(
classpath
)
;
}
public
AntClassLoader
(
ClassLoader
parent
,
Project
project
,
Path
classpath
,
boolean
parentFirst
)
{
this
(
project
,
classpath
)
;
if
(
parent
!=
null
)
{
setParent
(
parent
)
;
}
setParentFirst
(
parentFirst
)
;
addJavaLibraries
(
)
;
}
public
AntClassLoader
(
Project
project
,
Path
classpath
,
boolean
parentFirst
)
{
this
(
null
,
project
,
classpath
,
parentFirst
)
;
}
public
AntClassLoader
(
ClassLoader
parent
,
boolean
parentFirst
)
{
setParent
(
parent
)
;
project
=
null
;
this
.
parentFirst
=
parentFirst
;
}
public
void
setProject
(
Project
project
)
{
this
.
project
=
project
;
if
(
project
!=
null
)
{
project
.
addBuildListener
(
this
)
;
}
}
public
void
setClassPath
(
Path
classpath
)
{
pathComponents
.
removeAllElements
(
)
;
if
(
classpath
!=
null
)
{
Path
actualClasspath
=
classpath
.
concatSystemClasspath
(
"ignore"
)
;
String
[
]
pathElements
=
actualClasspath
.
list
(
)
;
for
(
int
i
=
0
;
i
<
pathElements
.
length
;
++
i
)
{
try
{
addPathElement
(
pathElements
[
i
]
)
;
}
catch
(
BuildException
e
)
{
}
}
}
}
public
void
setParent
(
ClassLoader
parent
)
{
if
(
parent
==
null
)
{
this
.
parent
=
AntClassLoader
.
class
.
getClassLoader
(
)
;
}
else
{
this
.
parent
=
parent
;
}
}
public
void
setParentFirst
(
boolean
parentFirst
)
{
this
.
parentFirst
=
parentFirst
;
}
protected
void
log
(
String
message
,
int
priority
)
{
if
(
project
!=
null
)
{
project
.
log
(
message
,
priority
)
;
}
}
public
void
setThreadContextLoader
(
)
{
if
(
isContextLoaderSaved
)
{
throw
new
BuildException
(
"Context loader has not been reset"
)
;
}
if
(
LoaderUtils
.
isContextLoaderAvailable
(
)
)
{
savedContextLoader
=
LoaderUtils
.
getContextClassLoader
(
)
;
ClassLoader
loader
=
this
;
if
(
project
!=
null
&&
"only"
.
equals
(
project
.
getProperty
(
"build.sysclasspath"
)
)
)
{
loader
=
this
.
getClass
(
)
.
getClassLoader
(
)
;
}
LoaderUtils
.
setContextClassLoader
(
loader
)
;
isContextLoaderSaved
=
true
;
}
}
public
void
resetThreadContextLoader
(
)
{
if
(
LoaderUtils
.
isContextLoaderAvailable
(
)
&&
isContextLoaderSaved
)
{
LoaderUtils
.
setContextClassLoader
(
savedContextLoader
)
;
savedContextLoader
=
null
;
isContextLoaderSaved
=
false
;
}
}
public
void
addPathElement
(
String
pathElement
)
throws
BuildException
{
File
pathComponent
=
project
!=
null
?
project
.
resolveFile
(
pathElement
)
:
new
File
(
pathElement
)
;
try
{
addPathFile
(
pathComponent
)
;
}
catch
(
IOException
e
)
{
throw
new
BuildException
(
e
)
;
}
}
protected
void
addPathFile
(
File
pathComponent
)
throws
IOException
{
pathComponents
.
addElement
(
pathComponent
)
;
}
public
String
getClasspath
(
)
{
StringBuffer
sb
=
new
StringBuffer
(
)
;
boolean
firstPass
=
true
;
Enumeration
componentEnum
=
pathComponents
.
elements
(
)
;
while
(
componentEnum
.
hasMoreElements
(
)
)
{
if
(
!
firstPass
)
{
sb
.
append
(
System
.
getProperty
(
"path.separator"
)
)
;
}
else
{
firstPass
=
false
;
}
sb
.
append
(
(
(
File
)
componentEnum
.
nextElement
(
)
)
.
getAbsolutePath
(
)
)
;
}
return
sb
.
toString
(
)
;
}
public
synchronized
void
setIsolated
(
boolean
isolated
)
{
ignoreBase
=
isolated
;
}
public
static
void
initializeClass
(
Class
theClass
)
{
final
Constructor
[
]
cons
=
theClass
.
getDeclaredConstructors
(
)
;
if
(
cons
!=
null
)
{
if
(
cons
.
length
>
0
&&
cons
[
0
]
!=
null
)
{
final
String
[
]
strs
=
new
String
[
NUMBER_OF_STRINGS
]
;
try
{
cons
[
0
]
.
newInstance
(
strs
)
;
}
catch
(
Throwable
t
)
{
}
}
}
}
public
void
addSystemPackageRoot
(
String
packageRoot
)
{
systemPackages
.
addElement
(
packageRoot
+
(
packageRoot
.
endsWith
(
"."
)
?
""
:
"."
)
)
;
}
public
void
addLoaderPackageRoot
(
String
packageRoot
)
{
loaderPackages
.
addElement
(
packageRoot
+
(
packageRoot
.
endsWith
(
"."
)
?
""
:
"."
)
)
;
}
public
Class
forceLoadClass
(
String
classname
)
throws
ClassNotFoundException
{
log
(
"force loading "
+
classname
,
Project
.
MSG_DEBUG
)
;
Class
theClass
=
findLoadedClass
(
classname
)
;
if
(
theClass
==
null
)
{
theClass
=
findClass
(
classname
)
;
}
return
theClass
;
}
public
Class
forceLoadSystemClass
(
String
classname
)
throws
ClassNotFoundException
{
log
(
"force system loading "
+
classname
,
Project
.
MSG_DEBUG
)
;
Class
theClass
=
findLoadedClass
(
classname
)
;
if
(
theClass
==
null
)
{
theClass
=
findBaseClass
(
classname
)
;
}
return
theClass
;
}
public
InputStream
getResourceAsStream
(
String
name
)
{
InputStream
resourceStream
=
null
;
if
(
isParentFirst
(
name
)
)
{
resourceStream
=
loadBaseResource
(
name
)
;
if
(
resourceStream
!=
null
)
{
log
(
"ResourceStream for "
+
name
+
" loaded from parent loader"
,
Project
.
MSG_DEBUG
)
;
}
else
{
resourceStream
=
loadResource
(
name
)
;
if
(
resourceStream
!=
null
)
{
log
(
"ResourceStream for "
+
name
+
" loaded from ant loader"
,
Project
.
MSG_DEBUG
)
;
}
}
}
else
{
resourceStream
=
loadResource
(
name
)
;
if
(
resourceStream
!=
null
)
{
log
(
"ResourceStream for "
+
name
+
" loaded from ant loader"
,
Project
.
MSG_DEBUG
)
;
}
else
{
resourceStream
=
loadBaseResource
(
name
)
;
if
(
resourceStream
!=
null
)
{
log
(
"ResourceStream for "
+
name
+
" loaded from parent loader"
,
Project
.
MSG_DEBUG
)
;
}
}
}
if
(
resourceStream
==
null
)
{
log
(
"Couldn't load ResourceStream for "
+
name
,
Project
.
MSG_DEBUG
)
;
}
return
resourceStream
;
}
private
InputStream
loadResource
(
String
name
)
{
InputStream
stream
=
null
;
Enumeration
e
=
pathComponents
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
&&
stream
==
null
)
{
File
pathComponent
=
(
File
)
e
.
nextElement
(
)
;
stream
=
getResourceStream
(
pathComponent
,
name
)
;
}
return
stream
;
}
private
InputStream
loadBaseResource
(
String
name
)
{
if
(
parent
==
null
)
{
return
getSystemResourceAsStream
(
name
)
;
}
else
{
return
parent
.
getResourceAsStream
(
name
)
;
}
}
private
InputStream
getResourceStream
(
File
file
,
String
resourceName
)
{
try
{
if
(
!
file
.
exists
(
)
)
{
return
null
;
}
if
(
file
.
isDirectory
(
)
)
{
File
resource
=
new
File
(
file
,
resourceName
)
;
if
(
resource
.
exists
(
)
)
{
return
new
FileInputStream
(
resource
)
;
}
}
else
{
ZipFile
zipFile
=
(
ZipFile
)
zipFiles
.
get
(
file
)
;
if
(
zipFile
==
null
)
{
zipFile
=
new
ZipFile
(
file
)
;
zipFiles
.
put
(
file
,
zipFile
)
;
}
ZipEntry
entry
=
zipFile
.
getEntry
(
resourceName
)
;
if
(
entry
!=
null
)
{
return
zipFile
.
getInputStream
(
entry
)
;
}
}
}
catch
(
Exception
e
)
{
log
(
"Ignoring Exception "
+
e
.
getClass
(
)
.
getName
(
)
+
": "
+
e
.
getMessage
(
)
+
" reading resource "
+
resourceName
+
" from "
+
file
,
Project
.
MSG_VERBOSE
)
;
}
return
null
;
}
private
boolean
isParentFirst
(
String
resourceName
)
{
boolean
useParentFirst
=
parentFirst
;
for
(
Enumeration
e
=
systemPackages
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
String
packageName
=
(
String
)
e
.
nextElement
(
)
;
if
(
resourceName
.
startsWith
(
packageName
)
)
{
useParentFirst
=
true
;
break
;
}
}
for
(
Enumeration
e
=
loaderPackages
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
String
packageName
=
(
String
)
e
.
nextElement
(
)
;
if
(
resourceName
.
startsWith
(
packageName
)
)
{
useParentFirst
=
false
;
break
;
}
}
return
useParentFirst
;
}
public
URL
getResource
(
String
name
)
{
URL
url
=
null
;
if
(
isParentFirst
(
name
)
)
{
url
=
(
parent
==
null
)
?
super
.
getResource
(
name
)
:
parent
.
getResource
(
name
)
;
}
if
(
url
!=
null
)
{
log
(
"Resource "
+
name
+
" loaded from parent loader"
,
Project
.
MSG_DEBUG
)
;
}
else
{
Enumeration
e
=
pathComponents
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
&&
url
==
null
)
{
File
pathComponent
=
(
File
)
e
.
nextElement
(
)
;
url
=
getResourceURL
(
pathComponent
,
name
)
;
if
(
url
!=
null
)
{
log
(
"Resource "
+
name
+
" loaded from ant loader"
,
Project
.
MSG_DEBUG
)
;
}
}
}
if
(
url
==
null
&&
!
isParentFirst
(
name
)
)
{
url
=
(
parent
==
null
)
?
super
.
getResource
(
name
)
:
parent
.
getResource
(
name
)
;
if
(
url
!=
null
)
{
log
(
"Resource "
+
name
+
" loaded from parent loader"
,
Project
.
MSG_DEBUG
)
;
}
}
if
(
url
==
null
)
{
log
(
"Couldn't load Resource "
+
name
,
Project
.
MSG_DEBUG
)
;
}
return
url
;
}
protected
Enumeration
findResources
(
String
name
)
throws
IOException
{
return
new
ResourceEnumeration
(
name
)
;
}
protected
URL
getResourceURL
(
File
file
,
String
resourceName
)
{
try
{
if
(
!
file
.
exists
(
)
)
{
return
null
;
}
if
(
file
.
isDirectory
(
)
)
{
File
resource
=
new
File
(
file
,
resourceName
)
;
if
(
resource
.
exists
(
)
)
{
try
{
return
new
URL
(
"file:"
+
resource
.
toString
(
)
)
;
}
catch
(
MalformedURLException
ex
)
{
return
null
;
}
}
}
else
{
ZipFile
zipFile
=
(
ZipFile
)
zipFiles
.
get
(
file
)
;
if
(
zipFile
==
null
)
{
zipFile
=
new
ZipFile
(
file
)
;
zipFiles
.
put
(
file
,
zipFile
)
;
}
ZipEntry
entry
=
zipFile
.
getEntry
(
resourceName
)
;
if
(
entry
!=
null
)
{
try
{
return
new
URL
(
"jar:file:"
+
file
.
toString
(
)
+
"!/"
+
entry
)
;
}
catch
(
MalformedURLException
ex
)
{
return
null
;
}
}
}
}
catch
(
Exception
e
)
{
e
.
printStackTrace
(
)
;
}
return
null
;
}
protected
synchronized
Class
loadClass
(
String
classname
,
boolean
resolve
)
throws
ClassNotFoundException
{
Class
theClass
=
findLoadedClass
(
classname
)
;
if
(
theClass
!=
null
)
{
return
theClass
;
}
if
(
isParentFirst
(
classname
)
)
{
try
{
theClass
=
findBaseClass
(
classname
)
;
log
(
"Class "
+
classname
+
" loaded from parent loader "
+
"(parentFirst)"
,
Project
.
MSG_DEBUG
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
theClass
=
findClass
(
classname
)
;
log
(
"Class "
+
classname
+
" loaded from ant loader "
+
"(parentFirst)"
,
Project
.
MSG_DEBUG
)
;
}
}
else
{
try
{
theClass
=
findClass
(
classname
)
;
log
(
"Class "
+
classname
+
" loaded from ant loader"
,
Project
.
MSG_DEBUG
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
if
(
ignoreBase
)
{
throw
cnfe
;
}
theClass
=
findBaseClass
(
classname
)
;
log
(
"Class "
+
classname
+
" loaded from parent loader"
,
Project
.
MSG_DEBUG
)
;
}
}
if
(
resolve
)
{
resolveClass
(
theClass
)
;
}
return
theClass
;
}
private
String
getClassFilename
(
String
classname
)
{
return
classname
.
replace
(
'.'
,
'/'
)
+
".class"
;
}
protected
Class
defineClassFromData
(
File
container
,
byte
[
]
classData
,
String
classname
)
throws
IOException
{
if
(
defineClassProtectionDomain
!=
null
)
{
try
{
Object
domain
=
getProtectionDomain
.
invoke
(
Project
.
class
,
new
Object
[
0
]
)
;
Object
[
]
args
=
new
Object
[
]
{
classname
,
classData
,
new
Integer
(
0
)
,
new
Integer
(
classData
.
length
)
,
domain
}
;
return
(
Class
)
defineClassProtectionDomain
.
invoke
(
this
,
args
)
;
}
catch
(
InvocationTargetException
ite
)
{
Throwable
t
=
ite
.
getTargetException
(
)
;
if
(
t
instanceof
ClassFormatError
)
{
throw
(
ClassFormatError
)
t
;
}
else
if
(
t
instanceof
NoClassDefFoundError
)
{
throw
(
NoClassDefFoundError
)
t
;
}
else
if
(
t
instanceof
SecurityException
)
{
throw
(
SecurityException
)
t
;
}
else
{
throw
new
IOException
(
t
.
toString
(
)
)
;
}
}
catch
(
Exception
e
)
{
throw
new
IOException
(
e
.
toString
(
)
)
;
}
}
else
{
return
defineClass
(
classname
,
classData
,
0
,
classData
.
length
)
;
}
}
private
Class
getClassFromStream
(
InputStream
stream
,
String
classname
,
File
container
)
throws
IOException
,
SecurityException
{
ByteArrayOutputStream
baos
=
new
ByteArrayOutputStream
(
)
;
int
bytesRead
=
-
1
;
byte
[
]
buffer
=
new
byte
[
BUFFER_SIZE
]
;
while
(
(
bytesRead
=
stream
.
read
(
buffer
,
0
,
BUFFER_SIZE
)
)
!=
-
1
)
{
baos
.
write
(
buffer
,
0
,
bytesRead
)
;
}
byte
[
]
classData
=
baos
.
toByteArray
(
)
;
return
defineClassFromData
(
container
,
classData
,
classname
)
;
}
public
Class
findClass
(
String
name
)
throws
ClassNotFoundException
{
log
(
"Finding class "
+
name
,
Project
.
MSG_DEBUG
)
;
return
findClassInComponents
(
name
)
;
}
protected
boolean
isInPath
(
File
component
)
{
for
(
Enumeration
e
=
pathComponents
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
File
pathComponent
=
(
File
)
e
.
nextElement
(
)
;
if
(
pathComponent
.
equals
(
component
)
)
{
return
true
;
}
}
return
false
;
}
private
Class
findClassInComponents
(
String
name
)
throws
ClassNotFoundException
{
InputStream
stream
=
null
;
String
classFilename
=
getClassFilename
(
name
)
;
try
{
Enumeration
e
=
pathComponents
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
File
pathComponent
=
(
File
)
e
.
nextElement
(
)
;
try
{
stream
=
getResourceStream
(
pathComponent
,
classFilename
)
;
if
(
stream
!=
null
)
{
log
(
"Loaded from "
+
pathComponent
+
" "
+
classFilename
,
Project
.
MSG_DEBUG
)
;
return
getClassFromStream
(
stream
,
name
,
pathComponent
)
;
}
}
catch
(
SecurityException
se
)
{
throw
se
;
}
catch
(
IOException
ioe
)
{
log
(
"Exception reading component "
+
pathComponent
+
" (reason: "
+
ioe
.
getMessage
(
)
+
")"
,
Project
.
MSG_VERBOSE
)
;
}
}
throw
new
ClassNotFoundException
(
name
)
;
}
finally
{
try
{
if
(
stream
!=
null
)
{
stream
.
close
(
)
;
}
}
catch
(
IOException
e
)
{
}
}
}
private
Class
findBaseClass
(
String
name
)
throws
ClassNotFoundException
{
if
(
parent
==
null
)
{
return
findSystemClass
(
name
)
;
}
else
{
return
parent
.
loadClass
(
name
)
;
}
}
public
synchronized
void
cleanup
(
)
{
for
(
Enumeration
e
=
zipFiles
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
ZipFile
zipFile
=
(
ZipFile
)
e
.
nextElement
(
)
;
try
{
zipFile
.
close
(
)
;
}
catch
(
IOException
ioe
)
{
}
}
zipFiles
=
new
Hashtable
(
)
;
if
(
project
!=
null
)
{
project
.
removeBuildListener
(
this
)
;
}
project
=
null
;
}
public
void
buildStarted
(
BuildEvent
event
)
{
}
public
void
buildFinished
(
BuildEvent
event
)
{
cleanup
(
)
;
}
public
void
targetStarted
(
BuildEvent
event
)
{
}
public
void
targetFinished
(
BuildEvent
event
)
{
}
public
void
taskStarted
(
BuildEvent
event
)
{
}
public
void
taskFinished
(
BuildEvent
event
)
{
}
public
void
messageLogged
(
BuildEvent
event
)
{
}
public
void
addJavaLibraries
(
)
{
Vector
packages
=
JavaEnvUtils
.
getJrePackages
(
)
;
Enumeration
e
=
packages
.
elements
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
String
packageName
=
(
String
)
e
.
nextElement
(
)
;
addSystemPackageRoot
(
packageName
)
;
}
}
}
