package
org
.
apache
.
tools
.
ant
.
taskdefs
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
FileReader
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
PrintWriter
;
import
java
.
io
.
Reader
;
import
java
.
io
.
StringReader
;
import
java
.
io
.
Writer
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
ProjectComponent
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
tools
.
ant
.
filters
.
util
.
ChainReaderHelper
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileList
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
org
.
apache
.
tools
.
ant
.
types
.
FilterChain
;
import
org
.
apache
.
tools
.
ant
.
types
.
Path
;
import
org
.
apache
.
tools
.
ant
.
util
.
FileUtils
;
public
class
Concat
extends
Task
{
private
static
final
int
BUFFER_SIZE
=
8192
;
private
File
destinationFile
=
null
;
private
boolean
append
=
false
;
private
String
encoding
=
null
;
private
String
outputEncoding
=
null
;
private
StringBuffer
textBuffer
;
private
Vector
sources
=
new
Vector
(
)
;
private
Vector
filterChains
=
null
;
private
boolean
forceOverwrite
=
true
;
private
TextElement
footer
;
private
TextElement
header
;
private
boolean
fixLastLine
=
false
;
private
String
eolString
=
System
.
getProperty
(
"line.separator"
)
;
private
Writer
outputWriter
=
null
;
private
Vector
sourceFiles
=
new
Vector
(
)
;
private
static
FileUtils
fileUtils
=
FileUtils
.
newFileUtils
(
)
;
public
void
setDestfile
(
File
destinationFile
)
{
this
.
destinationFile
=
destinationFile
;
}
public
void
setAppend
(
boolean
append
)
{
this
.
append
=
append
;
}
public
void
setEncoding
(
String
encoding
)
{
this
.
encoding
=
encoding
;
if
(
outputEncoding
==
null
)
{
outputEncoding
=
encoding
;
}
}
public
void
setOutputEncoding
(
String
outputEncoding
)
{
this
.
outputEncoding
=
outputEncoding
;
}
public
void
setForce
(
boolean
force
)
{
this
.
forceOverwrite
=
force
;
}
public
Path
createPath
(
)
{
Path
path
=
new
Path
(
getProject
(
)
)
;
sources
.
addElement
(
path
)
;
return
path
;
}
public
void
addFileset
(
FileSet
set
)
{
sources
.
addElement
(
set
)
;
}
public
void
addFilelist
(
FileList
list
)
{
sources
.
addElement
(
list
)
;
}
public
void
addFilterChain
(
FilterChain
filterChain
)
{
if
(
filterChains
==
null
)
{
filterChains
=
new
Vector
(
)
;
}
filterChains
.
addElement
(
filterChain
)
;
}
public
void
addText
(
String
text
)
{
if
(
textBuffer
==
null
)
{
textBuffer
=
new
StringBuffer
(
text
.
length
(
)
)
;
}
textBuffer
.
append
(
text
)
;
}
public
void
addHeader
(
TextElement
header
)
{
this
.
header
=
header
;
}
public
void
addFooter
(
TextElement
footer
)
{
this
.
footer
=
footer
;
}
public
void
setFixLastLine
(
boolean
fixLastLine
)
{
this
.
fixLastLine
=
fixLastLine
;
}
public
void
setEol
(
FixCRLF
.
CrLf
crlf
)
{
String
s
=
crlf
.
getValue
(
)
;
if
(
s
.
equals
(
"cr"
)
||
s
.
equals
(
"mac"
)
)
{
eolString
=
"\r"
;
}
else
if
(
s
.
equals
(
"lf"
)
||
s
.
equals
(
"unix"
)
)
{
eolString
=
"\n"
;
}
else
if
(
s
.
equals
(
"crlf"
)
||
s
.
equals
(
"dos"
)
)
{
eolString
=
"\r\n"
;
}
}
public
void
setWriter
(
Writer
outputWriter
)
{
this
.
outputWriter
=
outputWriter
;
}
public
void
execute
(
)
{
sanitizeText
(
)
;
if
(
destinationFile
!=
null
&&
outputWriter
!=
null
)
{
throw
new
BuildException
(
"Cannot specify both a destination file and an output writer"
)
;
}
if
(
sources
.
size
(
)
==
0
&&
textBuffer
==
null
)
{
throw
new
BuildException
(
"At least one file must be provided, or some text."
)
;
}
if
(
sources
.
size
(
)
>
0
&&
textBuffer
!=
null
)
{
throw
new
BuildException
(
"Cannot include inline text when using filesets."
)
;
}
for
(
Enumeration
e
=
sources
.
elements
(
)
;
e
.
hasMoreElements
(
)
;
)
{
Object
o
=
e
.
nextElement
(
)
;
if
(
o
instanceof
Path
)
{
Path
path
=
(
Path
)
o
;
checkAddFiles
(
null
,
path
.
list
(
)
)
;
}
else
if
(
o
instanceof
FileSet
)
{
FileSet
fileSet
=
(
FileSet
)
o
;
DirectoryScanner
scanner
=
fileSet
.
getDirectoryScanner
(
getProject
(
)
)
;
checkAddFiles
(
fileSet
.
getDir
(
getProject
(
)
)
,
scanner
.
getIncludedFiles
(
)
)
;
}
else
if
(
o
instanceof
FileList
)
{
FileList
fileList
=
(
FileList
)
o
;
checkAddFiles
(
fileList
.
getDir
(
getProject
(
)
)
,
fileList
.
getFiles
(
getProject
(
)
)
)
;
}
}
if
(
destinationFile
!=
null
&&
!
forceOverwrite
&&
(
sourceFiles
.
size
(
)
>
0
)
&&
destinationFile
.
exists
(
)
)
{
boolean
outofdate
=
false
;
for
(
int
i
=
0
;
i
<
sourceFiles
.
size
(
)
;
++
i
)
{
File
file
=
(
File
)
sourceFiles
.
elementAt
(
i
)
;
if
(
file
.
lastModified
(
)
>
destinationFile
.
lastModified
(
)
)
{
outofdate
=
true
;
break
;
}
}
if
(
!
outofdate
)
{
log
(
destinationFile
+
" is up-to-date."
,
Project
.
MSG_VERBOSE
)
;
return
;
}
}
if
(
textBuffer
==
null
&&
sourceFiles
.
size
(
)
==
0
&&
header
==
null
&&
footer
==
null
)
{
log
(
"No existing files and no nested text, doing nothing"
,
Project
.
MSG_INFO
)
;
return
;
}
cat
(
)
;
}
public
void
reset
(
)
{
append
=
false
;
forceOverwrite
=
true
;
destinationFile
=
null
;
encoding
=
null
;
outputEncoding
=
null
;
fixLastLine
=
false
;
sources
.
removeAllElements
(
)
;
sourceFiles
.
removeAllElements
(
)
;
filterChains
=
null
;
footer
=
null
;
header
=
null
;
}
private
void
checkAddFiles
(
File
base
,
String
[
]
filenames
)
{
for
(
int
i
=
0
;
i
<
filenames
.
length
;
++
i
)
{
File
file
=
new
File
(
base
,
filenames
[
i
]
)
;
if
(
!
file
.
exists
(
)
)
{
log
(
"File "
+
file
+
" does not exist."
,
Project
.
MSG_ERR
)
;
continue
;
}
if
(
destinationFile
!=
null
&&
fileUtils
.
fileNameEquals
(
destinationFile
,
file
)
)
{
throw
new
BuildException
(
"Input file \""
+
file
+
"\" "
+
"is the same as the output file."
)
;
}
sourceFiles
.
addElement
(
file
)
;
}
}
private
void
cat
(
)
{
OutputStream
os
=
null
;
Reader
reader
=
null
;
char
[
]
buffer
=
new
char
[
BUFFER_SIZE
]
;
try
{
PrintWriter
writer
=
null
;
if
(
outputWriter
!=
null
)
{
writer
=
new
PrintWriter
(
outputWriter
)
;
}
else
{
if
(
destinationFile
==
null
)
{
os
=
new
LogOutputStream
(
this
,
Project
.
MSG_WARN
)
;
}
else
{
File
parent
=
fileUtils
.
getParentFile
(
destinationFile
)
;
if
(
!
parent
.
exists
(
)
)
{
parent
.
mkdirs
(
)
;
}
os
=
new
FileOutputStream
(
destinationFile
.
getAbsolutePath
(
)
,
append
)
;
}
if
(
outputEncoding
==
null
)
{
writer
=
new
PrintWriter
(
new
BufferedWriter
(
new
OutputStreamWriter
(
os
)
)
)
;
}
else
{
writer
=
new
PrintWriter
(
new
BufferedWriter
(
new
OutputStreamWriter
(
os
,
outputEncoding
)
)
)
;
}
}
if
(
header
!=
null
)
{
if
(
header
.
getFiltering
(
)
)
{
concatenate
(
buffer
,
writer
,
new
StringReader
(
header
.
getValue
(
)
)
)
;
}
else
{
writer
.
print
(
header
.
getValue
(
)
)
;
}
}
if
(
textBuffer
!=
null
)
{
reader
=
new
StringReader
(
getProject
(
)
.
replaceProperties
(
textBuffer
.
substring
(
0
)
)
)
;
}
else
{
reader
=
new
MultiReader
(
)
;
}
concatenate
(
buffer
,
writer
,
reader
)
;
if
(
footer
!=
null
)
{
if
(
footer
.
getFiltering
(
)
)
{
concatenate
(
buffer
,
writer
,
new
StringReader
(
footer
.
getValue
(
)
)
)
;
}
else
{
writer
.
print
(
footer
.
getValue
(
)
)
;
}
}
writer
.
flush
(
)
;
if
(
os
!=
null
)
{
os
.
flush
(
)
;
}
}
catch
(
IOException
ioex
)
{
throw
new
BuildException
(
"Error while concatenating: "
+
ioex
.
getMessage
(
)
,
ioex
)
;
}
finally
{
if
(
reader
!=
null
)
{
try
{
reader
.
close
(
)
;
}
catch
(
IOException
ignore
)
{
}
}
if
(
os
!=
null
)
{
try
{
os
.
close
(
)
;
}
catch
(
IOException
ignore
)
{
}
}
}
}
private
void
concatenate
(
char
[
]
buffer
,
Writer
writer
,
Reader
in
)
throws
IOException
{
if
(
filterChains
!=
null
)
{
ChainReaderHelper
helper
=
new
ChainReaderHelper
(
)
;
helper
.
setBufferSize
(
BUFFER_SIZE
)
;
helper
.
setPrimaryReader
(
in
)
;
helper
.
setFilterChains
(
filterChains
)
;
helper
.
setProject
(
getProject
(
)
)
;
in
=
new
BufferedReader
(
helper
.
getAssembledReader
(
)
)
;
}
while
(
true
)
{
int
nRead
=
in
.
read
(
buffer
,
0
,
buffer
.
length
)
;
if
(
nRead
==
-
1
)
{
break
;
}
writer
.
write
(
buffer
,
0
,
nRead
)
;
}
writer
.
flush
(
)
;
}
private
void
sanitizeText
(
)
{
if
(
textBuffer
!=
null
)
{
if
(
textBuffer
.
substring
(
0
)
.
trim
(
)
.
length
(
)
==
0
)
{
textBuffer
=
null
;
}
}
}
public
static
class
TextElement
extends
ProjectComponent
{
private
String
value
=
""
;
private
boolean
trimLeading
=
false
;
private
boolean
trim
=
false
;
private
boolean
filtering
=
true
;
private
String
encoding
=
null
;
public
void
setFiltering
(
boolean
filtering
)
{
this
.
filtering
=
filtering
;
}
private
boolean
getFiltering
(
)
{
return
filtering
;
}
public
void
setEncoding
(
String
encoding
)
{
this
.
encoding
=
encoding
;
}
public
void
setFile
(
File
file
)
{
if
(
!
file
.
exists
(
)
)
{
throw
new
BuildException
(
"File "
+
file
+
" does not exist."
)
;
}
BufferedReader
reader
=
null
;
try
{
if
(
this
.
encoding
==
null
)
{
reader
=
new
BufferedReader
(
new
FileReader
(
file
)
)
;
}
else
{
reader
=
new
BufferedReader
(
new
InputStreamReader
(
new
FileInputStream
(
file
)
,
this
.
encoding
)
)
;
}
value
=
fileUtils
.
readFully
(
reader
)
;
}
catch
(
IOException
ex
)
{
throw
new
BuildException
(
ex
)
;
}
finally
{
if
(
reader
!=
null
)
{
try
{
reader
.
close
(
)
;
}
catch
(
Throwable
t
)
{
}
}
}
}
public
void
addText
(
String
value
)
{
this
.
value
+=
getProject
(
)
.
replaceProperties
(
value
)
;
}
public
void
setTrimLeading
(
boolean
strip
)
{
this
.
trimLeading
=
strip
;
}
public
void
setTrim
(
boolean
trim
)
{
this
.
trim
=
trim
;
}
public
String
getValue
(
)
{
if
(
value
==
null
)
{
value
=
""
;
}
if
(
value
.
trim
(
)
.
length
(
)
==
0
)
{
value
=
""
;
}
if
(
trimLeading
)
{
char
[
]
current
=
value
.
toCharArray
(
)
;
StringBuffer
b
=
new
StringBuffer
(
current
.
length
)
;
boolean
startOfLine
=
true
;
int
pos
=
0
;
while
(
pos
<
current
.
length
)
{
char
ch
=
current
[
pos
++
]
;
if
(
startOfLine
)
{
if
(
ch
==
' '
||
ch
==
'\t'
)
{
continue
;
}
startOfLine
=
false
;
}
b
.
append
(
ch
)
;
if
(
ch
==
'\n'
||
ch
==
'\r'
)
{
startOfLine
=
true
;
}
}
value
=
b
.
toString
(
)
;
}
if
(
trim
)
{
value
=
value
.
trim
(
)
;
}
return
value
;
}
}
private
class
MultiReader
extends
Reader
{
private
int
pos
=
0
;
private
Reader
reader
=
null
;
private
int
lastPos
=
0
;
private
char
[
]
lastChars
=
new
char
[
eolString
.
length
(
)
]
;
private
boolean
needAddSeparator
=
false
;
private
Reader
getReader
(
)
throws
IOException
{
if
(
reader
==
null
)
{
if
(
encoding
==
null
)
{
reader
=
new
BufferedReader
(
new
FileReader
(
(
File
)
sourceFiles
.
elementAt
(
pos
)
)
)
;
}
else
{
reader
=
new
BufferedReader
(
new
InputStreamReader
(
new
FileInputStream
(
(
File
)
sourceFiles
.
elementAt
(
pos
)
)
,
encoding
)
)
;
}
for
(
int
i
=
0
;
i
<
lastChars
.
length
;
++
i
)
{
lastChars
[
i
]
=
0
;
}
}
return
reader
;
}
public
int
read
(
)
throws
IOException
{
if
(
needAddSeparator
)
{
int
ret
=
eolString
.
charAt
(
lastPos
++
)
;
if
(
lastPos
>=
eolString
.
length
(
)
)
{
lastPos
=
0
;
needAddSeparator
=
false
;
}
return
ret
;
}
while
(
pos
<
sourceFiles
.
size
(
)
)
{
int
ch
=
getReader
(
)
.
read
(
)
;
if
(
ch
==
-
1
)
{
reader
.
close
(
)
;
reader
=
null
;
if
(
fixLastLine
&&
isMissingEndOfLine
(
)
)
{
needAddSeparator
=
true
;
lastPos
=
0
;
}
}
else
{
addLastChar
(
(
char
)
ch
)
;
return
ch
;
}
pos
++
;
}
return
-
1
;
}
public
int
read
(
char
[
]
cbuf
,
int
off
,
int
len
)
throws
IOException
{
int
amountRead
=
0
;
while
(
pos
<
sourceFiles
.
size
(
)
||
(
needAddSeparator
)
)
{
if
(
needAddSeparator
)
{
cbuf
[
off
]
=
eolString
.
charAt
(
lastPos
++
)
;
if
(
lastPos
>=
eolString
.
length
(
)
)
{
lastPos
=
0
;
needAddSeparator
=
false
;
pos
++
;
}
len
--
;
off
++
;
amountRead
++
;
if
(
len
==
0
)
{
return
amountRead
;
}
continue
;
}
int
nRead
=
getReader
(
)
.
read
(
cbuf
,
off
,
len
)
;
if
(
nRead
==
-
1
||
nRead
==
0
)
{
reader
.
close
(
)
;
reader
=
null
;
if
(
fixLastLine
&&
isMissingEndOfLine
(
)
)
{
needAddSeparator
=
true
;
lastPos
=
0
;
}
else
{
pos
++
;
}
}
else
{
if
(
fixLastLine
)
{
for
(
int
i
=
nRead
;
i
>
(
nRead
-
lastChars
.
length
)
;
--
i
)
{
if
(
i
<
0
)
{
break
;
}
addLastChar
(
cbuf
[
off
+
i
-
1
]
)
;
}
}
len
-=
nRead
;
off
+=
nRead
;
amountRead
+=
nRead
;
if
(
len
==
0
)
{
return
amountRead
;
}
}
}
if
(
amountRead
==
0
)
{
return
-
1
;
}
else
{
return
amountRead
;
}
}
public
void
close
(
)
throws
IOException
{
if
(
reader
!=
null
)
{
reader
.
close
(
)
;
}
}
private
void
addLastChar
(
char
ch
)
{
for
(
int
i
=
lastChars
.
length
-
2
;
i
>=
0
;
--
i
)
{
lastChars
[
i
]
=
lastChars
[
i
+
1
]
;
}
lastChars
[
lastChars
.
length
-
1
]
=
ch
;
}
private
boolean
isMissingEndOfLine
(
)
{
for
(
int
i
=
0
;
i
<
lastChars
.
length
;
++
i
)
{
if
(
lastChars
[
i
]
!=
eolString
.
charAt
(
i
)
)
{
return
true
;
}
}
return
false
;
}
}
}
