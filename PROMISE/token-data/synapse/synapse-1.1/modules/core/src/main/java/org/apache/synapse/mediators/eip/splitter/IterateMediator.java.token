package
org
.
apache
.
synapse
.
mediators
.
eip
.
splitter
;
import
org
.
apache
.
axiom
.
om
.
OMElement
;
import
org
.
apache
.
axiom
.
om
.
OMNode
;
import
org
.
apache
.
axiom
.
soap
.
SOAPEnvelope
;
import
org
.
apache
.
axis2
.
AxisFault
;
import
org
.
apache
.
axis2
.
Constants
;
import
org
.
apache
.
axis2
.
context
.
OperationContext
;
import
org
.
apache
.
synapse
.
ManagedLifecycle
;
import
org
.
apache
.
synapse
.
MessageContext
;
import
org
.
apache
.
synapse
.
SynapseLog
;
import
org
.
apache
.
synapse
.
endpoints
.
Endpoint
;
import
org
.
apache
.
synapse
.
core
.
SynapseEnvironment
;
import
org
.
apache
.
synapse
.
core
.
axis2
.
Axis2MessageContext
;
import
org
.
apache
.
synapse
.
mediators
.
AbstractMediator
;
import
org
.
apache
.
synapse
.
mediators
.
eip
.
EIPConstants
;
import
org
.
apache
.
synapse
.
mediators
.
eip
.
EIPUtils
;
import
org
.
apache
.
synapse
.
mediators
.
eip
.
Target
;
import
org
.
apache
.
synapse
.
util
.
MessageHelper
;
import
org
.
apache
.
synapse
.
util
.
xpath
.
SynapseXPath
;
import
org
.
jaxen
.
JaxenException
;
import
java
.
util
.
List
;
public
class
IterateMediator
extends
AbstractMediator
implements
ManagedLifecycle
{
private
boolean
continueParent
=
false
;
private
boolean
preservePayload
=
false
;
private
SynapseXPath
expression
=
null
;
private
SynapseXPath
attachPath
=
null
;
private
Target
target
=
null
;
private
String
id
=
null
;
public
boolean
mediate
(
MessageContext
synCtx
)
{
SynapseLog
synLog
=
getLog
(
synCtx
)
;
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebug
(
"Start : Iterate mediator"
)
;
if
(
synLog
.
isTraceTraceEnabled
(
)
)
{
synLog
.
traceTrace
(
"Message : "
+
synCtx
.
getEnvelope
(
)
)
;
}
}
try
{
SOAPEnvelope
envelope
=
MessageHelper
.
cloneSOAPEnvelope
(
synCtx
.
getEnvelope
(
)
)
;
List
splitElements
=
EIPUtils
.
getDetachedMatchingElements
(
envelope
,
synCtx
,
expression
)
;
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebug
(
"Splitting with XPath : "
+
expression
+
" resulted in "
+
splitElements
.
size
(
)
+
" elements"
)
;
}
if
(
!
preservePayload
&&
envelope
.
getBody
(
)
!=
null
)
{
envelope
.
getBody
(
)
.
removeChildren
(
)
;
}
int
msgCount
=
splitElements
.
size
(
)
;
int
msgNumber
=
0
;
for
(
Object
o
:
splitElements
)
{
if
(
!
(
o
instanceof
OMNode
)
)
{
handleException
(
"Error splitting message with XPath : "
+
expression
+
" - result not an OMNode"
,
synCtx
)
;
}
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebug
(
"Submitting "
+
(
msgNumber
+
1
)
+
" of "
+
msgNumber
+
(
target
.
isAsynchronous
(
)
?
" messages for processing in parallel"
:
" messages for processing sequentially"
)
)
;
}
target
.
mediate
(
getIteratedMessage
(
synCtx
,
msgNumber
++
,
msgCount
,
envelope
,
(
OMNode
)
o
)
)
;
}
}
catch
(
JaxenException
e
)
{
handleException
(
"Error evaluating split XPath expression : "
+
expression
,
e
,
synCtx
)
;
}
catch
(
AxisFault
af
)
{
handleException
(
"Error creating an iterated copy of the message"
,
af
,
synCtx
)
;
}
OperationContext
opCtx
=
(
(
Axis2MessageContext
)
synCtx
)
.
getAxis2MessageContext
(
)
.
getOperationContext
(
)
;
if
(
!
continueParent
&&
opCtx
!=
null
)
{
opCtx
.
setProperty
(
Constants
.
RESPONSE_WRITTEN
,
"SKIP"
)
;
}
synLog
.
traceOrDebug
(
"End : Iterate mediator"
)
;
return
continueParent
;
}
private
MessageContext
getIteratedMessage
(
MessageContext
synCtx
,
int
msgNumber
,
int
msgCount
,
SOAPEnvelope
envelope
,
OMNode
o
)
throws
AxisFault
,
JaxenException
{
MessageContext
newCtx
=
MessageHelper
.
cloneMessageContext
(
synCtx
)
;
if
(
id
!=
null
)
{
newCtx
.
setProperty
(
EIPConstants
.
AGGREGATE_CORRELATION
+
"."
+
id
,
synCtx
.
getMessageID
(
)
)
;
newCtx
.
setProperty
(
EIPConstants
.
MESSAGE_SEQUENCE
+
"."
+
id
,
msgNumber
+
EIPConstants
.
MESSAGE_SEQUENCE_DELEMITER
+
msgCount
)
;
}
else
{
newCtx
.
setProperty
(
EIPConstants
.
MESSAGE_SEQUENCE
,
msgNumber
+
EIPConstants
.
MESSAGE_SEQUENCE_DELEMITER
+
msgCount
)
;
}
SOAPEnvelope
newEnvelope
=
MessageHelper
.
cloneSOAPEnvelope
(
envelope
)
;
if
(
preservePayload
)
{
Object
attachElem
=
attachPath
.
evaluate
(
newEnvelope
,
synCtx
)
;
if
(
attachElem
!=
null
&&
attachElem
instanceof
List
&&
!
(
(
List
)
attachElem
)
.
isEmpty
(
)
)
{
attachElem
=
(
(
List
)
attachElem
)
.
get
(
0
)
;
}
if
(
attachElem
!=
null
&&
attachElem
instanceof
OMElement
)
{
(
(
OMElement
)
attachElem
)
.
addChild
(
o
)
;
}
else
{
handleException
(
"Error in attaching the splitted elements :: "
+
"Unable to get the attach path specified by the expression "
+
attachPath
,
synCtx
)
;
}
}
else
if
(
newEnvelope
.
getBody
(
)
!=
null
)
{
newEnvelope
.
getBody
(
)
.
addChild
(
o
)
;
}
newCtx
.
setEnvelope
(
newEnvelope
)
;
return
newCtx
;
}
public
boolean
isContinueParent
(
)
{
return
continueParent
;
}
public
void
setContinueParent
(
boolean
continueParent
)
{
this
.
continueParent
=
continueParent
;
}
public
boolean
isPreservePayload
(
)
{
return
preservePayload
;
}
public
void
setPreservePayload
(
boolean
preservePayload
)
{
this
.
preservePayload
=
preservePayload
;
}
public
SynapseXPath
getExpression
(
)
{
return
expression
;
}
public
void
setExpression
(
SynapseXPath
expression
)
{
this
.
expression
=
expression
;
}
public
SynapseXPath
getAttachPath
(
)
{
return
attachPath
;
}
public
void
setAttachPath
(
SynapseXPath
attachPath
)
{
this
.
attachPath
=
attachPath
;
}
public
Target
getTarget
(
)
{
return
target
;
}
public
void
setTarget
(
Target
target
)
{
this
.
target
=
target
;
}
public
String
getId
(
)
{
return
id
;
}
public
void
setId
(
String
id
)
{
this
.
id
=
id
;
}
public
void
init
(
SynapseEnvironment
se
)
{
if
(
target
!=
null
)
{
Endpoint
endpoint
=
target
.
getEndpoint
(
)
;
if
(
endpoint
!=
null
)
{
endpoint
.
init
(
se
)
;
}
ManagedLifecycle
seq
=
target
.
getSequence
(
)
;
if
(
seq
!=
null
)
{
seq
.
init
(
se
)
;
}
}
}
public
void
destroy
(
)
{
if
(
target
!=
null
)
{
Endpoint
endpoint
=
target
.
getEndpoint
(
)
;
if
(
endpoint
!=
null
&&
endpoint
.
isInitialized
(
)
)
{
endpoint
.
destroy
(
)
;
}
ManagedLifecycle
seq
=
target
.
getSequence
(
)
;
if
(
seq
!=
null
)
{
seq
.
destroy
(
)
;
}
}
}
}
