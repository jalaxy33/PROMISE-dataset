package
org
.
apache
.
synapse
.
endpoints
;
import
org
.
apache
.
axis2
.
context
.
ConfigurationContext
;
import
org
.
apache
.
axis2
.
addressing
.
EndpointReference
;
import
org
.
apache
.
axis2
.
clustering
.
Member
;
import
org
.
apache
.
synapse
.
*
;
import
org
.
apache
.
synapse
.
core
.
axis2
.
Axis2SynapseEnvironment
;
import
org
.
apache
.
synapse
.
core
.
axis2
.
Axis2MessageContext
;
import
org
.
apache
.
synapse
.
core
.
SynapseEnvironment
;
import
org
.
apache
.
synapse
.
endpoints
.
algorithms
.
AlgorithmContext
;
import
org
.
apache
.
synapse
.
endpoints
.
algorithms
.
LoadbalanceAlgorithm
;
import
org
.
apache
.
synapse
.
mediators
.
MediatorProperty
;
import
java
.
net
.
*
;
import
java
.
util
.
*
;
import
java
.
io
.
IOException
;
public
class
LoadbalanceEndpoint
extends
AbstractEndpoint
{
private
boolean
failover
=
true
;
private
LoadbalanceAlgorithm
algorithm
=
null
;
private
AlgorithmContext
algorithmContext
=
null
;
private
List
<
Member
>
activeMembers
=
null
;
private
List
<
Member
>
inactiveMembers
=
null
;
@
Override
public
void
init
(
SynapseEnvironment
synapseEnvironment
)
{
ConfigurationContext
cc
=
(
(
Axis2SynapseEnvironment
)
synapseEnvironment
)
.
getAxis2ConfigurationContext
(
)
;
if
(
!
initialized
)
{
super
.
init
(
synapseEnvironment
)
;
if
(
algorithmContext
==
null
)
{
algorithmContext
=
new
AlgorithmContext
(
isClusteringEnabled
,
cc
,
getName
(
)
)
;
}
if
(
algorithm
!=
null
&&
algorithm
instanceof
ManagedLifecycle
)
{
ManagedLifecycle
lifecycle
=
(
ManagedLifecycle
)
algorithm
;
lifecycle
.
init
(
synapseEnvironment
)
;
}
}
}
@
Override
public
void
destroy
(
)
{
super
.
destroy
(
)
;
if
(
algorithm
!=
null
&&
algorithm
instanceof
ManagedLifecycle
)
{
ManagedLifecycle
lifecycle
=
(
ManagedLifecycle
)
algorithm
;
lifecycle
.
destroy
(
)
;
}
}
public
void
send
(
MessageContext
synCtx
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Sending using Load-balance "
+
toString
(
)
)
;
}
Endpoint
endpoint
=
null
;
if
(
activeMembers
==
null
)
{
endpoint
=
getNextChild
(
synCtx
)
;
}
evaluateProperties
(
synCtx
)
;
if
(
endpoint
!=
null
)
{
if
(
synCtx
.
getProperty
(
SynapseConstants
.
LAST_ENDPOINT
)
==
null
)
{
if
(
failover
)
{
synCtx
.
getEnvelope
(
)
.
build
(
)
;
}
}
else
{
if
(
metricsMBean
!=
null
)
{
metricsMBean
.
reportSendingFault
(
SynapseConstants
.
ENDPOINT_LB_FAIL_OVER
)
;
}
}
synCtx
.
pushFaultHandler
(
this
)
;
endpoint
.
send
(
synCtx
)
;
}
else
if
(
activeMembers
!=
null
&&
!
activeMembers
.
isEmpty
(
)
)
{
EndpointReference
to
=
synCtx
.
getTo
(
)
;
LoadbalanceFaultHandler
faultHandler
=
new
LoadbalanceFaultHandler
(
to
)
;
if
(
failover
)
{
synCtx
.
pushFaultHandler
(
faultHandler
)
;
}
sendToApplicationMember
(
synCtx
,
to
,
faultHandler
)
;
}
else
{
String
msg
=
"Loadbalance endpoint : "
+
(
getName
(
)
!=
null
?
getName
(
)
:
SynapseConstants
.
ANONYMOUS_ENDPOINT
)
+
" - no ready child endpoints"
;
log
.
warn
(
msg
)
;
informFailure
(
synCtx
,
SynapseConstants
.
ENDPOINT_LB_NONE_READY
,
msg
)
;
}
}
private
void
sendToApplicationMember
(
MessageContext
synCtx
,
EndpointReference
to
,
LoadbalanceFaultHandler
faultHandler
)
{
org
.
apache
.
axis2
.
context
.
MessageContext
axis2MsgCtx
=
(
(
Axis2MessageContext
)
synCtx
)
.
getAxis2MessageContext
(
)
;
String
transport
=
axis2MsgCtx
.
getTransportIn
(
)
.
getName
(
)
;
algorithm
.
setApplicationMembers
(
activeMembers
)
;
Member
currentMember
=
algorithm
.
getNextApplicationMember
(
algorithmContext
)
;
faultHandler
.
setCurrentMember
(
currentMember
)
;
if
(
currentMember
!=
null
)
{
if
(
transport
.
equals
(
"http"
)
||
transport
.
equals
(
"https"
)
)
{
String
address
=
to
.
getAddress
(
)
;
if
(
address
.
indexOf
(
":"
)
!=
-
1
)
{
try
{
address
=
new
URL
(
address
)
.
getPath
(
)
;
}
catch
(
MalformedURLException
e
)
{
String
msg
=
"URL "
+
address
+
" is malformed"
;
log
.
error
(
msg
,
e
)
;
throw
new
SynapseException
(
msg
,
e
)
;
}
}
EndpointReference
epr
=
new
EndpointReference
(
transport
+
"://"
+
currentMember
.
getHostName
(
)
+
":"
+
(
"http"
.
equals
(
transport
)
?
currentMember
.
getHttpPort
(
)
:
currentMember
.
getHttpsPort
(
)
)
+
address
)
;
synCtx
.
setTo
(
epr
)
;
if
(
failover
)
{
synCtx
.
getEnvelope
(
)
.
build
(
)
;
}
AddressEndpoint
endpoint
=
new
AddressEndpoint
(
)
;
EndpointDefinition
definition
=
new
EndpointDefinition
(
)
;
endpoint
.
setDefinition
(
definition
)
;
endpoint
.
init
(
synCtx
.
getEnvironment
(
)
)
;
endpoint
.
send
(
synCtx
)
;
}
else
{
log
.
error
(
"Cannot load balance for non-HTTP/S transport "
+
transport
)
;
}
}
else
{
synCtx
.
getFaultStack
(
)
.
pop
(
)
;
String
msg
=
"No application members available"
;
log
.
error
(
msg
)
;
throw
new
SynapseException
(
msg
)
;
}
}
public
boolean
readyToSend
(
)
{
for
(
Endpoint
endpoint
:
getChildren
(
)
)
{
if
(
endpoint
.
readyToSend
(
)
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Load-balance "
+
this
.
toString
(
)
+
" has at least one endpoint at ready state"
)
;
}
return
true
;
}
}
log
.
warn
(
"Load-balance "
+
this
.
toString
(
)
+
" has no endpoints at ready state to process message"
)
;
return
false
;
}
@
Override
public
void
onChildEndpointFail
(
Endpoint
endpoint
,
MessageContext
synMessageContext
)
{
logOnChildEndpointFail
(
endpoint
,
synMessageContext
)
;
if
(
failover
)
{
if
(
!
(
(
AbstractEndpoint
)
endpoint
)
.
isRetryDisabled
(
synMessageContext
)
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
this
+
" Retry Attempt for Request with [Message ID : "
+
synMessageContext
.
getMessageID
(
)
+
"], [To : "
+
synMessageContext
.
getTo
(
)
+
"]"
)
;
}
send
(
synMessageContext
)
;
}
else
{
String
msg
=
"Loadbalance endpoint : "
+
(
getName
(
)
!=
null
?
getName
(
)
:
SynapseConstants
.
ANONYMOUS_ENDPOINT
)
+
" - one of the child endpoints encounterd a non-retry error, "
+
"not sending message to another endpoint"
;
log
.
warn
(
msg
)
;
informFailure
(
synMessageContext
,
SynapseConstants
.
ENDPOINT_LB_NONE_READY
,
msg
)
;
}
}
else
{
Object
o
=
synMessageContext
.
getFaultStack
(
)
.
pop
(
)
;
if
(
o
!=
null
)
{
(
(
FaultHandler
)
o
)
.
handleFault
(
synMessageContext
)
;
}
}
}
public
boolean
isFailover
(
)
{
return
failover
;
}
public
void
setFailover
(
boolean
failover
)
{
this
.
failover
=
failover
;
}
public
LoadbalanceAlgorithm
getAlgorithm
(
)
{
return
algorithm
;
}
public
void
setAlgorithm
(
LoadbalanceAlgorithm
algorithm
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Load-balance "
+
this
.
toString
(
)
+
" will be using the algorithm "
+
algorithm
.
getName
(
)
+
" for load distribution"
)
;
}
this
.
algorithm
=
algorithm
;
}
protected
Endpoint
getNextChild
(
MessageContext
synCtx
)
{
return
algorithm
.
getNextEndpoint
(
synCtx
,
algorithmContext
)
;
}
private
class
LoadbalanceFaultHandler
extends
FaultHandler
{
private
EndpointReference
to
;
private
Member
currentMember
;
public
void
setCurrentMember
(
Member
currentMember
)
{
this
.
currentMember
=
currentMember
;
}
private
LoadbalanceFaultHandler
(
EndpointReference
to
)
{
this
.
to
=
to
;
}
public
void
onFault
(
MessageContext
synCtx
)
{
if
(
currentMember
==
null
)
{
return
;
}
synCtx
.
pushFaultHandler
(
this
)
;
activeMembers
.
remove
(
currentMember
)
;
inactiveMembers
.
add
(
currentMember
)
;
sendToApplicationMember
(
synCtx
,
to
,
this
)
;
}
}
public
void
setMembers
(
List
<
Member
>
members
)
{
this
.
activeMembers
=
members
;
this
.
inactiveMembers
=
new
ArrayList
<
Member
>
(
)
;
}
public
List
<
Member
>
getMembers
(
)
{
return
this
.
activeMembers
;
}
public
void
startApplicationMembershipTimer
(
)
{
Timer
timer
=
new
Timer
(
)
;
timer
.
scheduleAtFixedRate
(
new
MemberActivatorTask
(
)
,
1000
,
500
)
;
}
private
class
MemberActivatorTask
extends
TimerTask
{
public
void
run
(
)
{
try
{
for
(
Member
member
:
inactiveMembers
)
{
if
(
canConnect
(
member
)
)
{
inactiveMembers
.
remove
(
member
)
;
activeMembers
.
add
(
member
)
;
}
}
}
catch
(
Exception
ignored
)
{
}
}
private
boolean
canConnect
(
Member
member
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Trying to connect to member "
+
member
.
getHostName
(
)
+
"..."
)
;
}
for
(
int
retries
=
30
;
retries
>
0
;
retries
--
)
{
try
{
InetAddress
addr
=
InetAddress
.
getByName
(
member
.
getHostName
(
)
)
;
int
httpPort
=
member
.
getHttpPort
(
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"HTTP Port="
+
httpPort
)
;
}
if
(
httpPort
!=
-
1
)
{
SocketAddress
httpSockaddr
=
new
InetSocketAddress
(
addr
,
httpPort
)
;
new
Socket
(
)
.
connect
(
httpSockaddr
,
10000
)
;
}
int
httpsPort
=
member
.
getHttpsPort
(
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"HTTPS Port="
+
httpPort
)
;
}
if
(
httpsPort
!=
-
1
)
{
SocketAddress
httpsSockaddr
=
new
InetSocketAddress
(
addr
,
httpsPort
)
;
new
Socket
(
)
.
connect
(
httpsSockaddr
,
10000
)
;
}
return
true
;
}
catch
(
IOException
e
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
""
,
e
)
;
}
String
msg
=
e
.
getMessage
(
)
;
if
(
msg
.
indexOf
(
"Connection refused"
)
==
-
1
&&
msg
.
indexOf
(
"connect timed out"
)
==
-
1
)
{
log
.
error
(
"Cannot connect to member "
+
member
,
e
)
;
}
}
}
return
false
;
}
}
}
