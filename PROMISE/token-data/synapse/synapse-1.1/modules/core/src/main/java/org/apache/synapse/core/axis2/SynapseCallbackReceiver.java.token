package
org
.
apache
.
synapse
.
core
.
axis2
;
import
org
.
apache
.
axiom
.
om
.
OMException
;
import
org
.
apache
.
axis2
.
AxisFault
;
import
org
.
apache
.
axis2
.
Constants
;
import
org
.
apache
.
axis2
.
addressing
.
AddressingConstants
;
import
org
.
apache
.
axis2
.
addressing
.
EndpointReference
;
import
org
.
apache
.
axis2
.
addressing
.
RelatesTo
;
import
org
.
apache
.
axis2
.
client
.
Options
;
import
org
.
apache
.
axis2
.
client
.
async
.
AxisCallback
;
import
org
.
apache
.
axis2
.
context
.
MessageContext
;
import
org
.
apache
.
axis2
.
engine
.
MessageReceiver
;
import
org
.
apache
.
axis2
.
transport
.
http
.
HTTPConstants
;
import
org
.
apache
.
axis2
.
wsdl
.
WSDLConstants
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
org
.
apache
.
http
.
nio
.
NHttpServerConnection
;
import
org
.
apache
.
synapse
.
FaultHandler
;
import
org
.
apache
.
synapse
.
SynapseConstants
;
import
org
.
apache
.
synapse
.
SynapseException
;
import
org
.
apache
.
synapse
.
ServerContextInformation
;
import
org
.
apache
.
synapse
.
aspects
.
statistics
.
ErrorLogFactory
;
import
org
.
apache
.
synapse
.
aspects
.
statistics
.
StatisticsReporter
;
import
org
.
apache
.
synapse
.
commons
.
jmx
.
MBeanRegistrar
;
import
org
.
apache
.
synapse
.
config
.
SynapseConfigUtils
;
import
org
.
apache
.
synapse
.
config
.
SynapseConfiguration
;
import
org
.
apache
.
synapse
.
endpoints
.
Endpoint
;
import
org
.
apache
.
synapse
.
endpoints
.
dispatch
.
Dispatcher
;
import
org
.
apache
.
synapse
.
transport
.
nhttp
.
NhttpConstants
;
import
org
.
apache
.
synapse
.
transport
.
passthru
.
PassThroughConstants
;
import
org
.
apache
.
synapse
.
transport
.
passthru
.
Pipe
;
import
org
.
apache
.
synapse
.
transport
.
passthru
.
config
.
SourceConfiguration
;
import
org
.
apache
.
synapse
.
util
.
ResponseAcceptEncodingProcessor
;
import
java
.
util
.
*
;
public
class
SynapseCallbackReceiver
implements
MessageReceiver
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
SynapseCallbackReceiver
.
class
)
;
private
static
final
String
CALLBACK_STORE_CATEGORY
=
"SynapseCallbackStore"
;
private
static
final
String
CALLBACK_STORE_NAME
=
"SynapseCallbackStore"
;
private
static
final
SynapseCallbackReceiver
instance
=
new
SynapseCallbackReceiver
(
)
;
private
final
Map
<
String
,
AxisCallback
>
callbackStore
;
private
boolean
initialized
=
false
;
private
SynapseCallbackReceiver
(
)
{
callbackStore
=
Collections
.
synchronizedMap
(
new
HashMap
<
String
,
AxisCallback
>
(
)
)
;
}
public
static
SynapseCallbackReceiver
getInstance
(
)
{
return
instance
;
}
public
void
init
(
SynapseConfiguration
synCfg
,
ServerContextInformation
contextInformation
)
{
if
(
initialized
)
{
log
.
warn
(
"Attempted to re-initialize SynapseCallbackReceiver"
)
;
return
;
}
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Initializing SynapseCallbackReceiver"
)
;
}
TimeoutHandler
timeoutHandler
=
new
TimeoutHandler
(
callbackStore
,
contextInformation
)
;
Timer
timeOutTimer
=
synCfg
.
getSynapseTimer
(
)
;
long
timeoutHandlerInterval
=
SynapseConfigUtils
.
getTimeoutHandlerInterval
(
)
;
timeOutTimer
.
schedule
(
timeoutHandler
,
0
,
timeoutHandlerInterval
)
;
MBeanRegistrar
.
getInstance
(
)
.
registerMBean
(
new
SynapseCallbackStoreView
(
this
)
,
CALLBACK_STORE_CATEGORY
,
CALLBACK_STORE_NAME
)
;
initialized
=
true
;
}
public
void
destroy
(
)
{
if
(
!
initialized
)
{
log
.
warn
(
"Attempted to destroy uninitialized SynapseCallbackReceiver"
)
;
return
;
}
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Destroying SynapseCallbackReceiver"
)
;
}
MBeanRegistrar
.
getInstance
(
)
.
unRegisterMBean
(
CALLBACK_STORE_CATEGORY
,
CALLBACK_STORE_NAME
)
;
initialized
=
false
;
}
public
int
getCallbackCount
(
)
{
return
callbackStore
.
size
(
)
;
}
public
String
[
]
getPendingCallbacks
(
)
{
Set
<
String
>
keys
=
callbackStore
.
keySet
(
)
;
List
<
String
>
list
=
new
ArrayList
<
String
>
(
)
;
synchronized
(
callbackStore
)
{
Iterator
<
String
>
iterator
=
keys
.
iterator
(
)
;
while
(
iterator
.
hasNext
(
)
)
{
list
.
add
(
iterator
.
next
(
)
)
;
}
}
return
list
.
toArray
(
new
String
[
list
.
size
(
)
]
)
;
}
public
void
addCallback
(
String
MsgID
,
AxisCallback
callback
)
{
callbackStore
.
put
(
MsgID
,
callback
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Callback added. Total callbacks waiting for : "
+
callbackStore
.
size
(
)
)
;
}
}
public
void
receive
(
MessageContext
messageCtx
)
throws
AxisFault
{
String
messageID
=
null
;
if
(
messageCtx
.
getProperty
(
NhttpConstants
.
HTTP_202_RECEIVED
)
!=
null
&&
"true"
.
equals
(
messageCtx
.
getProperty
(
NhttpConstants
.
HTTP_202_RECEIVED
)
)
)
{
if
(
callbackStore
.
containsKey
(
messageCtx
.
getMessageID
(
)
)
)
{
callbackStore
.
remove
(
messageCtx
.
getMessageID
(
)
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"CallBack registered with Message id : "
+
messageCtx
.
getMessageID
(
)
+
" removed from the "
+
"callback store since we got an accepted Notification"
)
;
}
}
return
;
}
if
(
messageCtx
.
getOptions
(
)
!=
null
&&
messageCtx
.
getOptions
(
)
.
getRelatesTo
(
)
!=
null
)
{
Options
options
=
messageCtx
.
getOptions
(
)
;
if
(
options
!=
null
)
{
RelatesTo
relatesTo
=
options
.
getRelatesTo
(
)
;
if
(
relatesTo
!=
null
)
{
messageID
=
relatesTo
.
getValue
(
)
;
}
}
}
else
{
messageID
=
(
String
)
messageCtx
.
getProperty
(
SynapseConstants
.
RELATES_TO_FOR_POX
)
;
}
if
(
messageID
!=
null
)
{
AxisCallback
callback
=
callbackStore
.
remove
(
messageID
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Callback removed for request message id : "
+
messageID
+
". Pending callbacks count : "
+
callbackStore
.
size
(
)
)
;
}
RelatesTo
[
]
relates
=
messageCtx
.
getRelationships
(
)
;
if
(
relates
!=
null
&&
relates
.
length
>
1
)
{
removeDuplicateRelatesTo
(
messageCtx
,
relates
)
;
}
if
(
callback
!=
null
)
{
handleMessage
(
messageID
,
messageCtx
,
(
(
AsyncCallback
)
callback
)
.
getSynapseOutMsgCtx
(
)
,
(
AsyncCallback
)
callback
)
;
}
else
{
log
.
warn
(
"Synapse received a response for the request with message Id : "
+
messageID
+
" But a callback is not registered (anymore) to process this response"
)
;
}
}
else
if
(
!
messageCtx
.
isPropertyTrue
(
NhttpConstants
.
SC_ACCEPTED
)
)
{
log
.
warn
(
"Synapse received a response message without a message Id"
)
;
}
}
private
void
handleMessage
(
String
messageID
,
MessageContext
response
,
org
.
apache
.
synapse
.
MessageContext
synapseOutMsgCtx
,
AsyncCallback
callback
)
throws
AxisFault
{
Object
o
=
response
.
getProperty
(
SynapseConstants
.
SENDING_FAULT
)
;
if
(
o
!=
null
&&
Boolean
.
TRUE
.
equals
(
o
)
)
{
Pipe
pipe
=
(
Pipe
)
(
(
Axis2MessageContext
)
synapseOutMsgCtx
)
.
getAxis2MessageContext
(
)
.
getProperty
(
PassThroughConstants
.
PASS_THROUGH_PIPE
)
;
if
(
pipe
!=
null
&&
pipe
.
isSerializationComplete
(
)
)
{
NHttpServerConnection
conn
=
(
NHttpServerConnection
)
(
(
Axis2MessageContext
)
synapseOutMsgCtx
)
.
getAxis2MessageContext
(
)
.
getProperty
(
PassThroughConstants
.
PASS_THROUGH_SOURCE_CONNECTION
)
;
SourceConfiguration
sourceConfiguration
=
(
SourceConfiguration
)
(
(
Axis2MessageContext
)
synapseOutMsgCtx
)
.
getAxis2MessageContext
(
)
.
getProperty
(
PassThroughConstants
.
PASS_THROUGH_SOURCE_CONFIGURATION
)
;
Pipe
newPipe
=
new
Pipe
(
conn
,
sourceConfiguration
.
getBufferFactory
(
)
.
getBuffer
(
)
,
PassThroughConstants
.
SOURCE
,
sourceConfiguration
)
;
(
(
Axis2MessageContext
)
synapseOutMsgCtx
)
.
getAxis2MessageContext
(
)
.
setProperty
(
PassThroughConstants
.
PASS_THROUGH_PIPE
,
newPipe
)
;
}
StatisticsReporter
.
reportFaultForAll
(
synapseOutMsgCtx
,
ErrorLogFactory
.
createErrorLog
(
response
)
)
;
Stack
faultStack
=
synapseOutMsgCtx
.
getFaultStack
(
)
;
if
(
faultStack
!=
null
&&
!
faultStack
.
isEmpty
(
)
)
{
try
{
synapseOutMsgCtx
.
getEnvelope
(
)
.
build
(
)
;
}
catch
(
OMException
x
)
{
synapseOutMsgCtx
.
setEnvelope
(
response
.
getEnvelope
(
)
)
;
}
Exception
e
=
(
Exception
)
response
.
getProperty
(
SynapseConstants
.
ERROR_EXCEPTION
)
;
synapseOutMsgCtx
.
setProperty
(
SynapseConstants
.
SENDING_FAULT
,
Boolean
.
TRUE
)
;
synapseOutMsgCtx
.
setProperty
(
SynapseConstants
.
ERROR_CODE
,
response
.
getProperty
(
SynapseConstants
.
ERROR_CODE
)
)
;
synapseOutMsgCtx
.
setProperty
(
SynapseConstants
.
ERROR_MESSAGE
,
response
.
getProperty
(
SynapseConstants
.
ERROR_MESSAGE
)
)
;
synapseOutMsgCtx
.
setProperty
(
SynapseConstants
.
ERROR_DETAIL
,
response
.
getProperty
(
SynapseConstants
.
ERROR_DETAIL
)
)
;
synapseOutMsgCtx
.
setProperty
(
SynapseConstants
.
ERROR_EXCEPTION
,
e
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"[Failed Request Message ID : "
+
messageID
+
"]"
+
" [New to be Retried Request Message ID : "
+
synapseOutMsgCtx
.
getMessageID
(
)
+
"]"
)
;
}
int
errorCode
=
(
Integer
)
response
.
getProperty
(
SynapseConstants
.
ERROR_CODE
)
;
if
(
errorCode
==
SynapseConstants
.
NHTTP_CONNECTION_TIMEOUT
&&
callback
.
getTimeOutAction
(
)
==
SynapseConstants
.
DISCARD
)
{
log
.
warn
(
"Synapse timed out for the request with Message ID : "
+
messageID
+
". Ignoring fault handlers since the timeout action is DISCARD."
)
;
faultStack
.
removeAllElements
(
)
;
}
else
{
(
(
FaultHandler
)
faultStack
.
pop
(
)
)
.
handleFault
(
synapseOutMsgCtx
,
null
)
;
}
}
}
else
{
Stack
faultStack
=
synapseOutMsgCtx
.
getFaultStack
(
)
;
if
(
faultStack
!=
null
&&
!
faultStack
.
isEmpty
(
)
&&
faultStack
.
peek
(
)
instanceof
Endpoint
)
{
Endpoint
successfulEndpoint
=
(
Endpoint
)
faultStack
.
pop
(
)
;
successfulEndpoint
.
onSuccess
(
)
;
}
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Synapse received an asynchronous response message"
)
;
log
.
debug
(
"Received To: "
+
(
response
.
getTo
(
)
!=
null
?
response
.
getTo
(
)
.
getAddress
(
)
:
"null"
)
)
;
log
.
debug
(
"SOAPAction: "
+
(
response
.
getSoapAction
(
)
!=
null
?
response
.
getSoapAction
(
)
:
"null"
)
)
;
log
.
debug
(
"WSA-Action: "
+
(
response
.
getWSAAction
(
)
!=
null
?
response
.
getWSAAction
(
)
:
"null"
)
)
;
String
[
]
cids
=
response
.
getAttachmentMap
(
)
.
getAllContentIDs
(
)
;
if
(
cids
!=
null
&&
cids
.
length
>
0
)
{
for
(
String
cid
:
cids
)
{
log
.
debug
(
"Attachment : "
+
cid
)
;
}
}
log
.
debug
(
"Body : \n"
+
response
.
getEnvelope
(
)
)
;
}
MessageContext
axisOutMsgCtx
=
(
(
Axis2MessageContext
)
synapseOutMsgCtx
)
.
getAxis2MessageContext
(
)
;
ResponseAcceptEncodingProcessor
.
process
(
response
,
axisOutMsgCtx
)
;
response
.
setServiceContext
(
null
)
;
response
.
setOperationContext
(
axisOutMsgCtx
.
getOperationContext
(
)
)
;
response
.
setAxisMessage
(
axisOutMsgCtx
.
getAxisOperation
(
)
.
getMessage
(
WSDLConstants
.
MESSAGE_LABEL_OUT_VALUE
)
)
;
response
.
setServerSide
(
true
)
;
response
.
setProperty
(
SynapseConstants
.
ISRESPONSE_PROPERTY
,
Boolean
.
TRUE
)
;
response
.
setProperty
(
MessageContext
.
TRANSPORT_OUT
,
axisOutMsgCtx
.
getProperty
(
MessageContext
.
TRANSPORT_OUT
)
)
;
response
.
setProperty
(
org
.
apache
.
axis2
.
Constants
.
OUT_TRANSPORT_INFO
,
axisOutMsgCtx
.
getProperty
(
org
.
apache
.
axis2
.
Constants
.
OUT_TRANSPORT_INFO
)
)
;
response
.
setTransportIn
(
axisOutMsgCtx
.
getTransportIn
(
)
)
;
response
.
setTransportOut
(
axisOutMsgCtx
.
getTransportOut
(
)
)
;
response
.
setDoingREST
(
axisOutMsgCtx
.
isDoingREST
(
)
)
;
if
(
axisOutMsgCtx
.
isDoingMTOM
(
)
)
{
response
.
setDoingMTOM
(
true
)
;
response
.
setProperty
(
org
.
apache
.
axis2
.
Constants
.
Configuration
.
ENABLE_MTOM
,
org
.
apache
.
axis2
.
Constants
.
VALUE_TRUE
)
;
}
if
(
axisOutMsgCtx
.
isDoingSwA
(
)
)
{
response
.
setDoingSwA
(
true
)
;
response
.
setProperty
(
org
.
apache
.
axis2
.
Constants
.
Configuration
.
ENABLE_SWA
,
org
.
apache
.
axis2
.
Constants
.
VALUE_TRUE
)
;
}
if
(
axisOutMsgCtx
.
getProperty
(
AddressingConstants
.
DISABLE_ADDRESSING_FOR_OUT_MESSAGES
)
!=
null
)
{
response
.
setProperty
(
AddressingConstants
.
DISABLE_ADDRESSING_FOR_OUT_MESSAGES
,
axisOutMsgCtx
.
getProperty
(
AddressingConstants
.
DISABLE_ADDRESSING_FOR_OUT_MESSAGES
)
)
;
}
else
{
response
.
removeProperty
(
AddressingConstants
.
DISABLE_ADDRESSING_FOR_OUT_MESSAGES
)
;
}
Object
messageType
=
axisOutMsgCtx
.
getProperty
(
org
.
apache
.
axis2
.
Constants
.
Configuration
.
MESSAGE_TYPE
)
;
if
(
!
HTTPConstants
.
MEDIA_TYPE_X_WWW_FORM
.
equals
(
messageType
)
)
{
response
.
setProperty
(
org
.
apache
.
axis2
.
Constants
.
Configuration
.
MESSAGE_TYPE
,
messageType
)
;
}
if
(
axisOutMsgCtx
.
isSOAP11
(
)
!=
response
.
isSOAP11
(
)
)
{
if
(
axisOutMsgCtx
.
isSOAP11
(
)
)
{
SOAPUtils
.
convertSOAP12toSOAP11
(
response
)
;
}
else
{
SOAPUtils
.
convertSOAP11toSOAP12
(
response
)
;
}
}
if
(
axisOutMsgCtx
.
getMessageID
(
)
!=
null
)
{
response
.
setRelationships
(
new
RelatesTo
[
]
{
new
RelatesTo
(
axisOutMsgCtx
.
getMessageID
(
)
)
}
)
;
}
response
.
setReplyTo
(
axisOutMsgCtx
.
getReplyTo
(
)
)
;
response
.
setFaultTo
(
axisOutMsgCtx
.
getFaultTo
(
)
)
;
if
(
axisOutMsgCtx
.
isPropertyTrue
(
NhttpConstants
.
IGNORE_SC_ACCEPTED
)
)
{
response
.
setProperty
(
NhttpConstants
.
FORCE_SC_ACCEPTED
,
Constants
.
VALUE_TRUE
)
;
}
Axis2MessageContext
synapseInMessageContext
=
new
Axis2MessageContext
(
response
,
synapseOutMsgCtx
.
getConfiguration
(
)
,
synapseOutMsgCtx
.
getEnvironment
(
)
)
;
synapseInMessageContext
.
setResponse
(
true
)
;
synapseInMessageContext
.
setTo
(
new
EndpointReference
(
AddressingConstants
.
Final
.
WSA_ANONYMOUS_URL
)
)
;
synapseInMessageContext
.
setTracingState
(
synapseOutMsgCtx
.
getTracingState
(
)
)
;
for
(
Object
key
:
synapseOutMsgCtx
.
getPropertyKeySet
(
)
)
{
synapseInMessageContext
.
setProperty
(
(
String
)
key
,
synapseOutMsgCtx
.
getProperty
(
(
String
)
key
)
)
;
}
Dispatcher
dispatcher
=
(
Dispatcher
)
synapseOutMsgCtx
.
getProperty
(
SynapseConstants
.
PROP_SAL_ENDPOINT_CURRENT_DISPATCHER
)
;
if
(
dispatcher
!=
null
&&
dispatcher
.
isServerInitiatedSession
(
)
)
{
dispatcher
.
updateSession
(
synapseInMessageContext
)
;
}
StatisticsReporter
.
reportForAllOnResponseReceived
(
synapseInMessageContext
)
;
try
{
synapseOutMsgCtx
.
getEnvironment
(
)
.
injectMessage
(
synapseInMessageContext
)
;
}
catch
(
SynapseException
syne
)
{
Stack
stack
=
synapseInMessageContext
.
getFaultStack
(
)
;
if
(
stack
!=
null
&&
!
stack
.
isEmpty
(
)
)
{
(
(
FaultHandler
)
stack
.
pop
(
)
)
.
handleFault
(
synapseInMessageContext
,
syne
)
;
}
else
{
log
.
error
(
"Synapse encountered an exception, "
+
"No error handlers found - [Message Dropped]\n"
+
syne
.
getMessage
(
)
)
;
}
}
}
}
private
void
removeDuplicateRelatesTo
(
MessageContext
mc
,
RelatesTo
[
]
relates
)
{
int
insertPos
=
0
;
RelatesTo
[
]
newRelates
=
new
RelatesTo
[
relates
.
length
]
;
for
(
RelatesTo
current
:
relates
)
{
boolean
found
=
false
;
for
(
int
j
=
0
;
j
<
newRelates
.
length
&&
j
<
insertPos
;
j
++
)
{
if
(
newRelates
[
j
]
.
equals
(
current
)
||
newRelates
[
j
]
.
getValue
(
)
.
equals
(
current
.
getValue
(
)
)
)
{
found
=
true
;
break
;
}
}
if
(
!
found
)
{
newRelates
[
insertPos
++
]
=
current
;
}
}
RelatesTo
[
]
trimmedRelates
=
new
RelatesTo
[
insertPos
]
;
System
.
arraycopy
(
newRelates
,
0
,
trimmedRelates
,
0
,
insertPos
)
;
mc
.
setRelationships
(
trimmedRelates
)
;
}
}
