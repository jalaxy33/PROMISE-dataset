package
org
.
apache
.
synapse
.
mediators
.
eip
.
aggregator
;
import
org
.
apache
.
synapse
.
MessageContext
;
import
org
.
apache
.
synapse
.
SynapseLog
;
import
org
.
apache
.
synapse
.
core
.
SynapseEnvironment
;
import
org
.
apache
.
synapse
.
mediators
.
eip
.
EIPConstants
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
java
.
util
.
List
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
TimerTask
;
public
class
Aggregate
extends
TimerTask
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
Aggregate
.
class
)
;
private
long
timeoutMillis
=
0
;
private
long
expiryTimeMillis
=
0
;
private
int
minCount
=
-
1
;
private
int
maxCount
=
-
1
;
private
String
correlation
=
null
;
private
AggregateMediator
aggregateMediator
=
null
;
private
List
<
MessageContext
>
messages
=
new
ArrayList
<
MessageContext
>
(
)
;
private
boolean
locked
=
false
;
private
boolean
completed
=
false
;
private
SynapseEnvironment
synEnv
=
null
;
public
Aggregate
(
SynapseEnvironment
synEnv
,
String
corelation
,
long
timeoutMillis
,
int
min
,
int
max
,
AggregateMediator
mediator
)
{
this
.
synEnv
=
synEnv
;
this
.
correlation
=
corelation
;
if
(
timeoutMillis
>
0
)
{
expiryTimeMillis
=
System
.
currentTimeMillis
(
)
+
timeoutMillis
;
}
if
(
min
>
0
)
{
minCount
=
min
;
}
if
(
max
>
0
)
{
maxCount
=
max
;
}
this
.
aggregateMediator
=
mediator
;
}
public
synchronized
boolean
addMessage
(
MessageContext
synCtx
)
{
if
(
maxCount
<=
0
||
(
maxCount
>
0
&&
messages
.
size
(
)
<
maxCount
)
)
{
messages
.
add
(
synCtx
)
;
return
true
;
}
else
{
return
false
;
}
}
public
synchronized
boolean
isComplete
(
SynapseLog
synLog
)
{
if
(
!
completed
)
{
if
(
!
messages
.
isEmpty
(
)
)
{
MessageContext
mc
=
messages
.
get
(
0
)
;
Object
prop
=
mc
.
getProperty
(
EIPConstants
.
MESSAGE_SEQUENCE
+
(
aggregateMediator
.
getId
(
)
!=
null
?
"."
+
aggregateMediator
.
getId
(
)
:
""
)
)
;
if
(
prop
!=
null
&&
prop
instanceof
String
)
{
String
[
]
msgSequence
=
prop
.
toString
(
)
.
split
(
EIPConstants
.
MESSAGE_SEQUENCE_DELEMITER
)
;
int
total
=
Integer
.
parseInt
(
msgSequence
[
1
]
)
;
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebug
(
messages
.
size
(
)
+
" messages of "
+
total
+
" collected in current aggregation"
)
;
}
if
(
messages
.
size
(
)
>=
total
)
{
synLog
.
traceOrDebug
(
"Aggregation complete"
)
;
return
true
;
}
}
}
else
{
synLog
.
traceOrDebug
(
"No messages collected in current aggregation"
)
;
}
if
(
minCount
>
0
&&
messages
.
size
(
)
>=
minCount
)
{
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebug
(
"Aggregation complete - the minimum : "
+
minCount
+
" messages has been reached"
)
;
}
return
true
;
}
if
(
maxCount
>
0
&&
messages
.
size
(
)
>=
maxCount
)
{
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebug
(
"Aggregation complete - the maximum : "
+
maxCount
+
" messages has been reached"
)
;
}
return
true
;
}
if
(
expiryTimeMillis
>
0
&&
System
.
currentTimeMillis
(
)
>=
expiryTimeMillis
)
{
synLog
.
traceOrDebug
(
"Aggregation complete - the aggregation has timed out"
)
;
return
true
;
}
}
else
{
synLog
.
traceOrDebug
(
"Aggregation already completed - this message will not be processed in aggregation"
)
;
}
return
false
;
}
public
long
getTimeoutMillis
(
)
{
return
timeoutMillis
;
}
public
void
setTimeoutMillis
(
long
timeoutMillis
)
{
this
.
timeoutMillis
=
timeoutMillis
;
}
public
int
getMinCount
(
)
{
return
minCount
;
}
public
void
setMinCount
(
int
minCount
)
{
this
.
minCount
=
minCount
;
}
public
int
getMaxCount
(
)
{
return
maxCount
;
}
public
void
setMaxCount
(
int
maxCount
)
{
this
.
maxCount
=
maxCount
;
}
public
String
getCorrelation
(
)
{
return
correlation
;
}
public
void
setCorrelation
(
String
correlation
)
{
this
.
correlation
=
correlation
;
}
public
synchronized
List
<
MessageContext
>
getMessages
(
)
{
return
new
ArrayList
<
MessageContext
>
(
messages
)
;
}
public
void
setMessages
(
List
<
MessageContext
>
messages
)
{
this
.
messages
=
messages
;
}
public
long
getExpiryTimeMillis
(
)
{
return
expiryTimeMillis
;
}
public
void
setExpiryTimeMillis
(
long
expiryTimeMillis
)
{
this
.
expiryTimeMillis
=
expiryTimeMillis
;
}
public
void
run
(
)
{
while
(
true
)
{
if
(
completed
)
{
break
;
}
if
(
getLock
(
)
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Time : "
+
System
.
currentTimeMillis
(
)
+
" and this aggregator "
+
"expired at : "
+
expiryTimeMillis
)
;
}
synEnv
.
getExecutorService
(
)
.
execute
(
new
AggregateTimeout
(
this
)
)
;
break
;
}
}
}
private
class
AggregateTimeout
implements
Runnable
{
private
Aggregate
aggregate
=
null
;
AggregateTimeout
(
Aggregate
aggregate
)
{
this
.
aggregate
=
aggregate
;
}
public
void
run
(
)
{
aggregateMediator
.
completeAggregate
(
aggregate
)
;
}
}
public
synchronized
boolean
getLock
(
)
{
return
!
locked
;
}
public
void
releaseLock
(
)
{
locked
=
false
;
}
public
boolean
isCompleted
(
)
{
return
completed
;
}
public
void
setCompleted
(
boolean
completed
)
{
this
.
completed
=
completed
;
}
}
