package
org
.
apache
.
synapse
.
core
.
axis2
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
org
.
apache
.
synapse
.
FaultHandler
;
import
org
.
apache
.
synapse
.
MessageContext
;
import
org
.
apache
.
synapse
.
SynapseConstants
;
import
org
.
apache
.
synapse
.
ServerContextInformation
;
import
org
.
apache
.
synapse
.
aspects
.
statistics
.
StatisticsCleaner
;
import
org
.
apache
.
synapse
.
aspects
.
statistics
.
StatisticsCollector
;
import
org
.
apache
.
synapse
.
config
.
SynapseConfigUtils
;
import
org
.
apache
.
synapse
.
endpoints
.
dispatch
.
SALSessions
;
import
java
.
util
.
Map
;
import
java
.
util
.
Stack
;
import
java
.
util
.
TimerTask
;
public
class
TimeoutHandler
extends
TimerTask
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
TimeoutHandler
.
class
)
;
private
final
Map
callbackStore
;
private
final
Object
lock
=
new
Object
(
)
;
private
boolean
alreadyExecuting
=
false
;
private
long
globalTimeout
=
SynapseConstants
.
DEFAULT_GLOBAL_TIMEOUT
;
private
static
final
String
SEND_TIMEOUT_MESSAGE
=
"Send timeout"
;
private
StatisticsCleaner
statisticsCleaner
;
private
ServerContextInformation
contextInfo
=
null
;
public
TimeoutHandler
(
Map
callbacks
,
ServerContextInformation
contextInfo
)
{
this
.
callbackStore
=
callbacks
;
this
.
contextInfo
=
contextInfo
;
this
.
globalTimeout
=
SynapseConfigUtils
.
getGlobalTimeoutInterval
(
)
;
log
.
info
(
"This engine will expire all callbacks after : "
+
(
globalTimeout
/
1000
)
+
" seconds, irrespective of the timeout action,"
+
" after the specified or optional timeout"
)
;
}
public
void
run
(
)
{
if
(
alreadyExecuting
)
return
;
synchronized
(
lock
)
{
alreadyExecuting
=
true
;
try
{
processCallbacks
(
)
;
}
catch
(
Exception
ignore
)
{
}
alreadyExecuting
=
false
;
}
}
private
void
processCallbacks
(
)
{
if
(
statisticsCleaner
==
null
)
{
StatisticsCollector
collector
=
SynapseConfigUtils
.
getStatisticsCollector
(
contextInfo
)
;
if
(
collector
!=
null
)
{
statisticsCleaner
=
new
StatisticsCleaner
(
collector
)
;
}
}
if
(
statisticsCleaner
!=
null
)
{
statisticsCleaner
.
clean
(
)
;
}
SALSessions
.
getInstance
(
)
.
clearSessions
(
)
;
synchronized
(
callbackStore
)
{
if
(
callbackStore
.
size
(
)
>
0
)
{
long
currentTime
=
currentTime
(
)
;
for
(
Object
key
:
callbackStore
.
keySet
(
)
)
{
AsyncCallback
callback
=
(
AsyncCallback
)
callbackStore
.
get
(
key
)
;
if
(
callback
==
null
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"There is no callback for key :"
+
key
)
;
}
continue
;
}
if
(
callback
.
getTimeOutAction
(
)
!=
SynapseConstants
.
NONE
)
{
if
(
callback
.
getTimeOutOn
(
)
<=
currentTime
)
{
callbackStore
.
remove
(
key
)
;
if
(
callback
.
getTimeOutAction
(
)
==
SynapseConstants
.
DISCARD_AND_FAULT
)
{
MessageContext
msgContext
=
callback
.
getSynapseOutMsgCtx
(
)
;
msgContext
.
setProperty
(
SynapseConstants
.
ERROR_CODE
,
SynapseConstants
.
HANDLER_TIME_OUT
)
;
msgContext
.
setProperty
(
SynapseConstants
.
ERROR_MESSAGE
,
SEND_TIMEOUT_MESSAGE
)
;
Stack
faultStack
=
msgContext
.
getFaultStack
(
)
;
for
(
int
j
=
0
;
j
<
faultStack
.
size
(
)
;
j
++
)
{
Object
o
=
faultStack
.
pop
(
)
;
if
(
o
instanceof
FaultHandler
)
{
(
(
FaultHandler
)
o
)
.
handleFault
(
msgContext
)
;
}
}
}
}
}
else
if
(
currentTime
>
globalTimeout
+
callback
.
getTimeOutOn
(
)
)
{
log
.
warn
(
"Expiring message ID : "
+
key
+
"; dropping message after "
+
"global timeout of : "
+
(
globalTimeout
/
1000
)
+
" seconds"
)
;
callbackStore
.
remove
(
key
)
;
}
}
}
}
}
private
long
currentTime
(
)
{
return
System
.
currentTimeMillis
(
)
;
}
}
