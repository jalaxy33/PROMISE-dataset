package
org
.
apache
.
synapse
.
config
;
import
org
.
apache
.
axiom
.
om
.
OMElement
;
import
org
.
apache
.
axis2
.
AxisFault
;
import
org
.
apache
.
axis2
.
engine
.
AxisConfiguration
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
org
.
apache
.
synapse
.
*
;
import
org
.
apache
.
synapse
.
config
.
xml
.
TemplateMediatorFactory
;
import
org
.
apache
.
synapse
.
config
.
xml
.
XMLToTemplateMapper
;
import
org
.
apache
.
synapse
.
config
.
xml
.
endpoints
.
TemplateFactory
;
import
org
.
apache
.
synapse
.
libraries
.
imports
.
SynapseImport
;
import
org
.
apache
.
synapse
.
libraries
.
model
.
Library
;
import
org
.
apache
.
synapse
.
endpoints
.
Template
;
import
org
.
apache
.
synapse
.
libraries
.
util
.
LibDeployerUtils
;
import
org
.
apache
.
synapse
.
mediators
.
template
.
TemplateMediator
;
import
org
.
apache
.
synapse
.
message
.
processors
.
MessageProcessor
;
import
org
.
apache
.
synapse
.
message
.
store
.
MessageStore
;
import
org
.
apache
.
synapse
.
deployers
.
SynapseArtifactDeploymentStore
;
import
org
.
apache
.
synapse
.
commons
.
datasource
.
DataSourceRepositoryHolder
;
import
org
.
apache
.
synapse
.
eventing
.
SynapseEventSource
;
import
org
.
apache
.
synapse
.
commons
.
executors
.
PriorityExecutor
;
import
org
.
apache
.
synapse
.
config
.
xml
.
MediatorFactoryFinder
;
import
org
.
apache
.
synapse
.
config
.
xml
.
endpoints
.
XMLToEndpointMapper
;
import
org
.
apache
.
synapse
.
core
.
SynapseEnvironment
;
import
org
.
apache
.
synapse
.
core
.
axis2
.
ProxyService
;
import
org
.
apache
.
synapse
.
endpoints
.
Endpoint
;
import
org
.
apache
.
synapse
.
endpoints
.
dispatch
.
SALSessions
;
import
org
.
apache
.
synapse
.
mediators
.
base
.
SequenceMediator
;
import
org
.
apache
.
synapse
.
registry
.
Registry
;
import
org
.
apache
.
axiom
.
om
.
OMNode
;
import
org
.
apache
.
synapse
.
rest
.
API
;
import
javax
.
xml
.
namespace
.
QName
;
import
java
.
io
.
IOException
;
import
java
.
util
.
*
;
import
java
.
util
.
concurrent
.
ConcurrentHashMap
;
@
SuppressWarnings
(
{
"UnusedDeclaration"
}
)
public
class
SynapseConfiguration
implements
ManagedLifecycle
,
SynapseArtifact
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
SynapseConfiguration
.
class
)
;
private
static
final
String
ENTRY
=
"entry"
;
private
static
final
String
ENDPOINT
=
"endpoint"
;
private
static
final
String
SEQUENCE
=
"sequence"
;
private
static
final
String
TEMPLATE
=
"sequence-template"
;
private
Registry
registry
=
null
;
private
QName
defaultQName
=
null
;
private
Mediator
mandatorySequence
=
null
;
private
final
Map
<
String
,
ProxyService
>
proxyServices
=
new
ConcurrentHashMap
<
String
,
ProxyService
>
(
)
;
private
final
Map
<
String
,
Startup
>
startups
=
new
ConcurrentHashMap
<
String
,
Startup
>
(
)
;
private
final
Map
<
String
,
Object
>
localRegistry
=
new
ConcurrentHashMap
<
String
,
Object
>
(
)
;
private
Properties
properties
=
new
Properties
(
)
;
private
Timer
synapseTimer
;
private
AxisConfiguration
axisConfiguration
=
null
;
private
String
pathToConfigFile
=
null
;
private
Map
<
String
,
SynapseEventSource
>
eventSources
=
new
ConcurrentHashMap
<
String
,
SynapseEventSource
>
(
)
;
private
List
<
SynapseObserver
>
observers
=
new
ArrayList
<
SynapseObserver
>
(
)
;
private
Map
<
String
,
PriorityExecutor
>
executors
=
new
ConcurrentHashMap
<
String
,
PriorityExecutor
>
(
)
;
private
Map
<
String
,
MessageStore
>
messageStores
=
new
ConcurrentHashMap
<
String
,
MessageStore
>
(
)
;
private
Map
<
String
,
MessageProcessor
>
messageProcessors
=
new
ConcurrentHashMap
<
String
,
MessageProcessor
>
(
)
;
private
Map
<
String
,
Template
>
endpointTemplates
=
new
ConcurrentHashMap
<
String
,
Template
>
(
)
;
private
Map
<
String
,
API
>
apiTable
=
new
ConcurrentHashMap
<
String
,
API
>
(
)
;
private
String
description
=
null
;
private
SynapseArtifactDeploymentStore
artifactDeploymentStore
=
new
SynapseArtifactDeploymentStore
(
)
;
private
Map
<
String
,
Library
>
synapseLibraries
=
new
ConcurrentHashMap
<
String
,
Library
>
(
)
;
private
Map
<
String
,
SynapseImport
>
synapseImports
=
new
ConcurrentHashMap
<
String
,
SynapseImport
>
(
)
;
private
boolean
allowHotUpdate
=
true
;
private
boolean
initialized
=
false
;
public
synchronized
void
addSequence
(
String
key
,
Mediator
mediator
)
{
assertAlreadyExists
(
key
,
SEQUENCE
)
;
localRegistry
.
put
(
key
,
mediator
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
sequenceAdded
(
mediator
)
;
}
}
public
synchronized
void
addSequenceTemplate
(
String
key
,
TemplateMediator
mediator
)
{
assertAlreadyExists
(
key
,
TEMPLATE
)
;
localRegistry
.
put
(
key
,
mediator
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
sequenceTemplateAdded
(
mediator
)
;
}
}
public
synchronized
void
updateSequenceTemplate
(
String
key
,
TemplateMediator
mediator
)
{
localRegistry
.
put
(
key
,
mediator
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
sequenceTemplateAdded
(
mediator
)
;
}
}
public
synchronized
void
updateSequence
(
String
key
,
Mediator
mediator
)
{
localRegistry
.
put
(
key
,
mediator
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
sequenceAdded
(
mediator
)
;
}
}
public
void
addSequence
(
String
key
,
Entry
entry
)
{
assertAlreadyExists
(
key
,
ENTRY
)
;
localRegistry
.
put
(
key
,
entry
)
;
}
public
Map
<
String
,
SequenceMediator
>
getDefinedSequences
(
)
{
Map
<
String
,
SequenceMediator
>
definedSequences
=
new
HashMap
<
String
,
SequenceMediator
>
(
)
;
synchronized
(
this
)
{
for
(
Object
o
:
localRegistry
.
values
(
)
)
{
if
(
o
instanceof
SequenceMediator
)
{
SequenceMediator
seq
=
(
SequenceMediator
)
o
;
definedSequences
.
put
(
seq
.
getName
(
)
,
seq
)
;
}
}
}
return
definedSequences
;
}
public
Map
<
String
,
TemplateMediator
>
getSequenceTemplates
(
)
{
Map
<
String
,
TemplateMediator
>
definedTemplates
=
new
HashMap
<
String
,
TemplateMediator
>
(
)
;
synchronized
(
this
)
{
for
(
Object
o
:
localRegistry
.
values
(
)
)
{
if
(
o
instanceof
TemplateMediator
)
{
TemplateMediator
template
=
(
TemplateMediator
)
o
;
definedTemplates
.
put
(
template
.
getName
(
)
,
template
)
;
}
}
}
return
definedTemplates
;
}
public
Map
<
String
,
Template
>
getEndpointTemplates
(
)
{
Map
<
String
,
Template
>
definedTemplates
=
new
HashMap
<
String
,
Template
>
(
)
;
synchronized
(
this
)
{
for
(
Object
o
:
localRegistry
.
values
(
)
)
{
if
(
o
instanceof
Template
)
{
Template
template
=
(
Template
)
o
;
definedTemplates
.
put
(
template
.
getName
(
)
,
template
)
;
}
}
}
return
definedTemplates
;
}
public
void
addAPI
(
String
name
,
API
api
)
{
if
(
!
apiTable
.
containsKey
(
name
)
)
{
for
(
API
existingAPI
:
apiTable
.
values
(
)
)
{
if
(
api
.
getVersion
(
)
.
equals
(
existingAPI
.
getVersion
(
)
)
&&
existingAPI
.
getContext
(
)
.
equals
(
api
.
getContext
(
)
)
)
{
handleException
(
"URL context: "
+
api
.
getContext
(
)
+
" is already registered"
+
" with the API: "
+
existingAPI
.
getName
(
)
)
;
}
}
apiTable
.
put
(
name
,
api
)
;
}
else
{
handleException
(
"Duplicate resource definition by the name: "
+
name
)
;
}
}
public
void
updateAPI
(
String
name
,
API
api
)
{
if
(
!
apiTable
.
containsKey
(
name
)
)
{
handleException
(
"No API exists by the name: "
+
name
)
;
}
else
{
for
(
API
existingAPI
:
apiTable
.
values
(
)
)
{
if
(
api
.
getVersion
(
)
.
equals
(
existingAPI
.
getVersion
(
)
)
&&
existingAPI
.
getContext
(
)
.
equals
(
api
.
getContext
(
)
)
&&
!
name
.
equals
(
api
.
getName
(
)
)
)
{
handleException
(
"URL context: "
+
api
.
getContext
(
)
+
" is already registered"
+
" with the API: "
+
existingAPI
.
getName
(
)
)
;
}
}
apiTable
.
put
(
name
,
api
)
;
}
}
public
Collection
<
API
>
getAPIs
(
)
{
return
Collections
.
unmodifiableCollection
(
apiTable
.
values
(
)
)
;
}
public
API
getAPI
(
String
name
)
{
return
apiTable
.
get
(
name
)
;
}
public
void
removeAPI
(
String
name
)
{
API
api
=
apiTable
.
get
(
name
)
;
if
(
api
!=
null
)
{
apiTable
.
remove
(
name
)
;
}
else
{
handleException
(
"No API exists by the name: "
+
name
)
;
}
}
public
TemplateMediator
getSequenceTemplate
(
String
key
)
{
Object
o
=
getEntry
(
key
)
;
if
(
o
instanceof
TemplateMediator
)
{
return
(
TemplateMediator
)
o
;
}
Entry
entry
=
null
;
if
(
o
==
null
)
{
entry
=
new
Entry
(
key
)
;
entry
.
setType
(
Entry
.
REMOTE_ENTRY
)
;
}
else
{
Object
object
=
localRegistry
.
get
(
key
)
;
if
(
object
instanceof
Entry
)
{
entry
=
(
Entry
)
object
;
}
}
assertEntryNull
(
entry
,
key
)
;
if
(
entry
.
getMapper
(
)
==
null
)
{
entry
.
setMapper
(
new
XMLToTemplateMapper
(
)
)
;
}
if
(
entry
.
getType
(
)
==
Entry
.
REMOTE_ENTRY
)
{
if
(
registry
!=
null
)
{
o
=
registry
.
getResource
(
entry
,
getProperties
(
)
)
;
if
(
o
!=
null
&&
o
instanceof
TemplateMediator
)
{
localRegistry
.
put
(
key
,
entry
)
;
return
(
TemplateMediator
)
o
;
}
else
if
(
o
instanceof
OMNode
)
{
TemplateMediator
m
=
(
TemplateMediator
)
new
TemplateMediatorFactory
(
)
.
createMediator
(
(
OMElement
)
o
,
properties
)
;
if
(
m
!=
null
)
{
entry
.
setValue
(
m
)
;
return
m
;
}
}
}
}
else
{
Object
value
=
entry
.
getValue
(
)
;
if
(
value
instanceof
OMNode
)
{
Object
object
=
entry
.
getMapper
(
)
.
getObjectFromOMNode
(
(
OMNode
)
value
,
getProperties
(
)
)
;
if
(
object
instanceof
TemplateMediator
)
{
entry
.
setValue
(
object
)
;
return
(
TemplateMediator
)
object
;
}
}
}
TemplateMediator
templateFromLib
=
LibDeployerUtils
.
getLibArtifact
(
synapseLibraries
,
key
,
TemplateMediator
.
class
)
;
if
(
templateFromLib
!=
null
)
{
return
templateFromLib
;
}
return
null
;
}
public
Mediator
getMandatorySequence
(
)
{
return
mandatorySequence
;
}
public
void
setMandatorySequence
(
Mediator
mandatorySequence
)
{
this
.
mandatorySequence
=
mandatorySequence
;
}
public
Mediator
getSequence
(
String
key
)
{
Object
o
=
getEntry
(
key
)
;
if
(
o
instanceof
Mediator
)
{
return
(
Mediator
)
o
;
}
Entry
entry
=
null
;
if
(
o
==
null
)
{
entry
=
new
Entry
(
key
)
;
entry
.
setType
(
Entry
.
REMOTE_ENTRY
)
;
}
else
{
Object
object
=
localRegistry
.
get
(
key
)
;
if
(
object
instanceof
Entry
)
{
entry
=
(
Entry
)
object
;
}
}
assertEntryNull
(
entry
,
key
)
;
if
(
entry
.
getMapper
(
)
==
null
)
{
entry
.
setMapper
(
MediatorFactoryFinder
.
getInstance
(
)
)
;
}
if
(
entry
.
getType
(
)
==
Entry
.
REMOTE_ENTRY
)
{
if
(
registry
!=
null
)
{
o
=
registry
.
getResource
(
entry
,
getProperties
(
)
)
;
if
(
o
!=
null
&&
o
instanceof
Mediator
)
{
localRegistry
.
put
(
key
,
entry
)
;
return
(
Mediator
)
o
;
}
else
if
(
o
instanceof
OMNode
)
{
Mediator
m
=
(
Mediator
)
MediatorFactoryFinder
.
getInstance
(
)
.
getObjectFromOMNode
(
(
OMNode
)
o
,
properties
)
;
if
(
m
!=
null
)
{
entry
.
setValue
(
m
)
;
return
m
;
}
}
}
}
else
{
Object
value
=
entry
.
getValue
(
)
;
if
(
value
instanceof
OMNode
)
{
Object
object
=
entry
.
getMapper
(
)
.
getObjectFromOMNode
(
(
OMNode
)
value
,
getProperties
(
)
)
;
if
(
object
instanceof
Mediator
)
{
entry
.
setValue
(
object
)
;
return
(
Mediator
)
object
;
}
}
}
return
null
;
}
public
synchronized
void
removeSequence
(
String
key
)
{
Object
sequence
=
localRegistry
.
get
(
key
)
;
if
(
sequence
instanceof
Mediator
)
{
localRegistry
.
remove
(
key
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
sequenceRemoved
(
(
Mediator
)
sequence
)
;
}
}
else
{
handleException
(
"No sequence exists by the key/name : "
+
key
)
;
}
}
public
synchronized
void
removeSequenceTemplate
(
String
name
)
{
Object
sequence
=
localRegistry
.
get
(
name
)
;
if
(
sequence
instanceof
TemplateMediator
)
{
localRegistry
.
remove
(
name
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
sequenceTemplateRemoved
(
(
Mediator
)
sequence
)
;
}
}
else
{
handleException
(
"No template exists by the key/name : "
+
name
)
;
}
}
public
Mediator
getMainSequence
(
)
{
return
getSequence
(
SynapseConstants
.
MAIN_SEQUENCE_KEY
)
;
}
public
Mediator
getFaultSequence
(
)
{
return
getSequence
(
SynapseConstants
.
FAULT_SEQUENCE_KEY
)
;
}
public
synchronized
void
addEntry
(
String
key
,
Entry
entry
)
{
assertAlreadyExists
(
key
,
ENTRY
)
;
if
(
entry
.
getType
(
)
==
Entry
.
URL_SRC
&&
entry
.
getValue
(
)
==
null
)
{
try
{
SynapseEnvironment
synEnv
=
SynapseConfigUtils
.
getSynapseEnvironment
(
axisConfiguration
)
;
entry
.
setValue
(
SynapseConfigUtils
.
getOMElementFromURL
(
entry
.
getSrc
(
)
.
toString
(
)
,
synEnv
!=
null
?
synEnv
.
getServerContextInformation
(
)
.
getServerConfigurationInformation
(
)
.
getSynapseHome
(
)
:
""
)
)
;
localRegistry
.
put
(
key
,
entry
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
entryAdded
(
entry
)
;
}
}
catch
(
IOException
e
)
{
handleException
(
"Can not read from source URL : "
+
entry
.
getSrc
(
)
)
;
}
}
else
{
localRegistry
.
put
(
key
,
entry
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
entryAdded
(
entry
)
;
}
}
}
public
synchronized
void
updateEntry
(
String
key
,
Entry
entry
)
{
if
(
entry
.
getType
(
)
==
Entry
.
URL_SRC
&&
entry
.
getValue
(
)
==
null
)
{
try
{
SynapseEnvironment
synEnv
=
SynapseConfigUtils
.
getSynapseEnvironment
(
axisConfiguration
)
;
entry
.
setValue
(
SynapseConfigUtils
.
getOMElementFromURL
(
entry
.
getSrc
(
)
.
toString
(
)
,
synEnv
!=
null
?
synEnv
.
getServerContextInformation
(
)
.
getServerConfigurationInformation
(
)
.
getSynapseHome
(
)
:
""
)
)
;
localRegistry
.
put
(
key
,
entry
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
entryAdded
(
entry
)
;
}
}
catch
(
IOException
e
)
{
handleException
(
"Can not read from source URL : "
+
entry
.
getSrc
(
)
)
;
}
}
else
{
localRegistry
.
put
(
key
,
entry
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
entryAdded
(
entry
)
;
}
}
}
public
Map
<
String
,
Entry
>
getCachedEntries
(
)
{
Map
<
String
,
Entry
>
cachedEntries
=
new
HashMap
<
String
,
Entry
>
(
)
;
synchronized
(
this
)
{
for
(
Object
o
:
localRegistry
.
values
(
)
)
{
if
(
o
!=
null
&&
o
instanceof
Entry
)
{
Entry
entry
=
(
Entry
)
o
;
if
(
entry
.
isDynamic
(
)
&&
entry
.
isCached
(
)
)
{
cachedEntries
.
put
(
entry
.
getKey
(
)
,
entry
)
;
}
}
}
}
return
cachedEntries
;
}
public
Map
<
String
,
Entry
>
getDefinedEntries
(
)
{
Map
<
String
,
Entry
>
definedEntries
=
new
HashMap
<
String
,
Entry
>
(
)
;
synchronized
(
this
)
{
for
(
Object
o
:
localRegistry
.
values
(
)
)
{
if
(
o
instanceof
Entry
&&
(
(
Entry
)
o
)
.
getType
(
)
!=
Entry
.
REMOTE_ENTRY
)
{
Entry
entry
=
(
Entry
)
o
;
definedEntries
.
put
(
entry
.
getKey
(
)
,
entry
)
;
}
}
}
return
definedEntries
;
}
public
Object
getLocalRegistryEntry
(
String
key
)
{
Object
o
=
localRegistry
.
get
(
key
)
;
if
(
o
!=
null
&&
o
instanceof
Entry
)
{
Entry
entry
=
(
Entry
)
o
;
if
(
!
entry
.
isDynamic
(
)
)
{
return
entry
.
getValue
(
)
;
}
}
return
null
;
}
public
Object
getEntry
(
String
key
)
{
Object
o
=
localRegistry
.
get
(
key
)
;
if
(
o
!=
null
&&
o
instanceof
Entry
)
{
Entry
entry
=
(
Entry
)
o
;
if
(
!
entry
.
isDynamic
(
)
||
(
entry
.
isCached
(
)
&&
!
entry
.
isExpired
(
)
)
)
{
return
entry
.
getValue
(
)
;
}
if
(
registry
!=
null
)
{
if
(
entry
.
isCached
(
)
)
{
try
{
o
=
registry
.
getResource
(
entry
,
getProperties
(
)
)
;
}
catch
(
Exception
e
)
{
log
.
warn
(
"Error while loading the resource "
+
key
+
" from the remote "
+
"registry. Previously cached value will be used. Check the "
+
"registry accessibility."
)
;
return
entry
.
getValue
(
)
;
}
}
else
{
o
=
registry
.
getResource
(
entry
,
getProperties
(
)
)
;
}
}
else
{
if
(
entry
.
isCached
(
)
)
{
log
.
warn
(
"The registry is no longer available in the Synapse configuration. "
+
"Using the previously cached value for the resource : "
+
key
)
;
return
entry
.
getValue
(
)
;
}
else
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Will not  evaluate the value of the remote entry with a key "
+
key
+
",  because the registry is not available"
)
;
}
return
null
;
}
}
}
return
o
;
}
public
Entry
getEntryDefinition
(
String
key
)
{
Object
o
=
localRegistry
.
get
(
key
)
;
if
(
o
==
null
||
o
instanceof
Entry
)
{
if
(
o
==
null
)
{
synchronized
(
this
)
{
o
=
localRegistry
.
get
(
key
)
;
if
(
o
==
null
)
{
Entry
entry
=
new
Entry
(
key
)
;
entry
.
setType
(
Entry
.
REMOTE_ENTRY
)
;
addEntry
(
key
,
entry
)
;
return
entry
;
}
}
}
return
(
Entry
)
o
;
}
else
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"There is no local registry entry for key : "
+
key
)
;
}
return
null
;
}
}
public
synchronized
void
removeEntry
(
String
key
)
{
Object
entry
=
localRegistry
.
get
(
key
)
;
if
(
entry
instanceof
Entry
)
{
localRegistry
.
remove
(
key
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
entryRemoved
(
(
Entry
)
entry
)
;
}
}
else
{
handleException
(
"No entry exists by the key : "
+
key
)
;
}
}
public
void
clearCachedEntry
(
String
key
)
{
Entry
entry
=
getEntryDefinition
(
key
)
;
if
(
entry
!=
null
&&
entry
.
isDynamic
(
)
&&
entry
.
isCached
(
)
)
{
entry
.
clearCache
(
)
;
}
}
public
synchronized
void
clearCache
(
)
{
for
(
Object
o
:
localRegistry
.
values
(
)
)
{
if
(
o
!=
null
&&
o
instanceof
Entry
)
{
Entry
entry
=
(
Entry
)
o
;
if
(
entry
.
isDynamic
(
)
&&
entry
.
isCached
(
)
)
{
entry
.
clearCache
(
)
;
}
}
}
}
public
synchronized
void
addEndpoint
(
String
key
,
Endpoint
endpoint
)
{
assertAlreadyExists
(
key
,
ENDPOINT
)
;
localRegistry
.
put
(
key
,
endpoint
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
endpointAdded
(
endpoint
)
;
}
}
public
synchronized
void
updateEndpoint
(
String
key
,
Endpoint
endpoint
)
{
localRegistry
.
put
(
key
,
endpoint
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
endpointAdded
(
endpoint
)
;
}
}
public
void
addEndpoint
(
String
key
,
Entry
entry
)
{
assertAlreadyExists
(
key
,
ENTRY
)
;
localRegistry
.
put
(
key
,
entry
)
;
}
public
Map
<
String
,
Endpoint
>
getDefinedEndpoints
(
)
{
Map
<
String
,
Endpoint
>
definedEndpoints
=
new
HashMap
<
String
,
Endpoint
>
(
)
;
synchronized
(
this
)
{
for
(
Object
o
:
localRegistry
.
values
(
)
)
{
if
(
o
instanceof
Endpoint
)
{
Endpoint
ep
=
(
Endpoint
)
o
;
definedEndpoints
.
put
(
ep
.
getName
(
)
,
ep
)
;
}
}
}
return
definedEndpoints
;
}
public
Endpoint
getEndpoint
(
String
key
)
{
Object
o
=
getEntry
(
key
)
;
if
(
o
!=
null
&&
o
instanceof
Endpoint
)
{
return
(
Endpoint
)
o
;
}
Entry
entry
=
null
;
if
(
o
==
null
)
{
entry
=
new
Entry
(
key
)
;
entry
.
setType
(
Entry
.
REMOTE_ENTRY
)
;
}
else
{
Object
object
=
localRegistry
.
get
(
key
)
;
if
(
object
instanceof
Entry
)
{
entry
=
(
Entry
)
object
;
}
}
assertEntryNull
(
entry
,
key
)
;
if
(
entry
.
getMapper
(
)
==
null
)
{
entry
.
setMapper
(
XMLToEndpointMapper
.
getInstance
(
)
)
;
}
if
(
entry
.
getType
(
)
==
Entry
.
REMOTE_ENTRY
)
{
if
(
registry
!=
null
)
{
o
=
registry
.
getResource
(
entry
,
getProperties
(
)
)
;
if
(
o
!=
null
&&
o
instanceof
Endpoint
)
{
localRegistry
.
put
(
key
,
entry
)
;
return
(
Endpoint
)
o
;
}
else
if
(
o
instanceof
OMNode
)
{
Endpoint
e
=
(
Endpoint
)
XMLToEndpointMapper
.
getInstance
(
)
.
getObjectFromOMNode
(
(
OMNode
)
o
,
properties
)
;
if
(
e
!=
null
)
{
entry
.
setValue
(
e
)
;
return
e
;
}
}
}
}
else
{
Object
value
=
entry
.
getValue
(
)
;
if
(
value
instanceof
OMNode
)
{
Object
object
=
entry
.
getMapper
(
)
.
getObjectFromOMNode
(
(
OMNode
)
value
,
getProperties
(
)
)
;
if
(
object
instanceof
Endpoint
)
{
entry
.
setValue
(
object
)
;
return
(
Endpoint
)
object
;
}
}
}
return
null
;
}
public
synchronized
void
removeEndpoint
(
String
key
)
{
Object
endpoint
=
localRegistry
.
get
(
key
)
;
if
(
endpoint
instanceof
Endpoint
)
{
localRegistry
.
remove
(
key
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
endpointRemoved
(
(
Endpoint
)
endpoint
)
;
}
}
else
{
handleException
(
"No endpoint exists by the key/name : "
+
key
)
;
}
}
public
synchronized
void
addProxyService
(
String
name
,
ProxyService
proxy
)
{
if
(
!
proxyServices
.
containsKey
(
name
)
)
{
proxyServices
.
put
(
name
,
proxy
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
proxyServiceAdded
(
proxy
)
;
}
}
else
{
handleException
(
"Duplicate proxy service by the name : "
+
name
)
;
}
}
public
ProxyService
getProxyService
(
String
name
)
{
return
proxyServices
.
get
(
name
)
;
}
public
synchronized
void
removeProxyService
(
String
name
)
{
ProxyService
proxy
=
proxyServices
.
get
(
name
)
;
if
(
proxy
==
null
)
{
handleException
(
"Unknown proxy service for name : "
+
name
)
;
}
else
{
try
{
if
(
getAxisConfiguration
(
)
.
getServiceForActivation
(
name
)
!=
null
)
{
if
(
getAxisConfiguration
(
)
.
getServiceForActivation
(
name
)
.
isActive
(
)
)
{
getAxisConfiguration
(
)
.
getService
(
name
)
.
setActive
(
false
)
;
}
getAxisConfiguration
(
)
.
removeService
(
name
)
;
}
proxyServices
.
remove
(
name
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
proxyServiceRemoved
(
proxy
)
;
}
}
catch
(
AxisFault
axisFault
)
{
handleException
(
axisFault
.
getMessage
(
)
)
;
}
}
}
public
Collection
<
ProxyService
>
getProxyServices
(
)
{
return
Collections
.
unmodifiableCollection
(
proxyServices
.
values
(
)
)
;
}
public
Map
getLocalRegistry
(
)
{
return
Collections
.
unmodifiableMap
(
localRegistry
)
;
}
public
Registry
getRegistry
(
)
{
return
registry
;
}
public
void
setRegistry
(
Registry
registry
)
{
this
.
registry
=
registry
;
}
public
void
setAxisConfiguration
(
AxisConfiguration
axisConfig
)
{
this
.
axisConfiguration
=
axisConfig
;
}
public
AxisConfiguration
getAxisConfiguration
(
)
{
return
axisConfiguration
;
}
public
String
getPathToConfigFile
(
)
{
return
pathToConfigFile
;
}
public
void
setPathToConfigFile
(
String
pathToConfigFile
)
{
this
.
pathToConfigFile
=
pathToConfigFile
;
}
public
void
setDefaultQName
(
QName
defaultQName
)
{
this
.
defaultQName
=
defaultQName
;
}
public
QName
getDefaultQName
(
)
{
return
defaultQName
;
}
public
Timer
getSynapseTimer
(
)
{
if
(
synapseTimer
==
null
)
{
handleException
(
"Attempted to access the Synapse timer "
+
"before initializing SynapseConfiguration"
)
;
}
return
synapseTimer
;
}
public
Collection
<
Startup
>
getStartups
(
)
{
return
startups
.
values
(
)
;
}
public
Startup
getStartup
(
String
id
)
{
return
startups
.
get
(
id
)
;
}
public
synchronized
void
addStartup
(
Startup
startup
)
{
if
(
!
startups
.
containsKey
(
startup
.
getName
(
)
)
)
{
startups
.
put
(
startup
.
getName
(
)
,
startup
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
startupAdded
(
startup
)
;
}
}
else
{
handleException
(
"Duplicate startup by the name : "
+
startup
.
getName
(
)
)
;
}
}
public
synchronized
void
updateStartup
(
Startup
startup
)
{
startups
.
put
(
startup
.
getName
(
)
,
startup
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
startupAdded
(
startup
)
;
}
}
public
synchronized
void
removeStartup
(
String
name
)
{
Startup
startup
=
startups
.
get
(
name
)
;
if
(
startup
!=
null
)
{
startups
.
remove
(
name
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
startupRemoved
(
startup
)
;
}
}
else
{
handleException
(
"No startup exists by the name : "
+
name
)
;
}
}
public
Properties
getProperties
(
)
{
return
properties
;
}
public
void
setProperty
(
String
key
,
String
value
)
{
properties
.
setProperty
(
key
,
value
)
;
}
public
void
setProperties
(
Properties
properties
)
{
this
.
properties
=
properties
;
}
public
String
getProperty
(
String
propKey
,
String
def
)
{
String
val
=
System
.
getProperty
(
propKey
)
;
if
(
val
==
null
)
{
val
=
properties
.
getProperty
(
propKey
)
;
}
if
(
val
!=
null
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Using synapse tuning parameter : "
+
propKey
+
" = "
+
val
)
;
}
return
val
;
}
return
def
;
}
public
long
getProperty
(
String
propKey
,
long
def
)
{
String
val
=
System
.
getProperty
(
propKey
)
;
if
(
val
==
null
)
{
val
=
properties
.
getProperty
(
propKey
)
;
}
if
(
val
!=
null
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Using synapse tuning parameter : "
+
propKey
+
" = "
+
val
)
;
}
return
Long
.
valueOf
(
val
)
;
}
return
def
;
}
public
String
getProperty
(
String
propKey
)
{
String
val
=
System
.
getProperty
(
propKey
)
;
if
(
val
==
null
)
{
val
=
properties
.
getProperty
(
propKey
)
;
}
if
(
val
!=
null
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Using synapse tuning parameter : "
+
propKey
+
" = "
+
val
)
;
}
return
val
;
}
return
null
;
}
public
synchronized
void
init
(
SynapseEnvironment
se
)
{
if
(
initialized
)
{
log
.
warn
(
"Attempted to re-initialize SynapseConfiguration"
)
;
return
;
}
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Initializing the Synapse Configuration using the SynapseEnvironment"
)
;
}
try
{
doInit
(
se
)
;
}
finally
{
initialized
=
true
;
}
}
public
synchronized
void
destroy
(
)
{
if
(
!
initialized
)
{
log
.
warn
(
"Attempted to destroy uninitialized SynapseConfiguration"
)
;
return
;
}
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Destroying the Synapse Configuration"
)
;
}
try
{
doDestroy
(
)
;
}
finally
{
initialized
=
false
;
}
}
private
void
doInit
(
SynapseEnvironment
se
)
{
synapseTimer
=
new
Timer
(
true
)
;
if
(
registry
!=
null
&&
registry
instanceof
ManagedLifecycle
)
{
(
(
ManagedLifecycle
)
registry
)
.
init
(
se
)
;
}
for
(
Endpoint
endpoint
:
getDefinedEndpoints
(
)
.
values
(
)
)
{
endpoint
.
init
(
se
)
;
}
for
(
TemplateMediator
seqTemplate
:
getSequenceTemplates
(
)
.
values
(
)
)
{
seqTemplate
.
init
(
se
)
;
}
for
(
ManagedLifecycle
seq
:
getDefinedSequences
(
)
.
values
(
)
)
{
if
(
seq
!=
null
)
{
seq
.
init
(
se
)
;
}
}
for
(
ProxyService
proxy
:
getProxyServices
(
)
)
{
if
(
proxy
.
getTargetInLineEndpoint
(
)
!=
null
)
{
proxy
.
getTargetInLineEndpoint
(
)
.
init
(
se
)
;
}
if
(
proxy
.
getTargetInLineInSequence
(
)
!=
null
)
{
proxy
.
getTargetInLineInSequence
(
)
.
init
(
se
)
;
}
if
(
proxy
.
getTargetInLineOutSequence
(
)
!=
null
)
{
proxy
.
getTargetInLineOutSequence
(
)
.
init
(
se
)
;
}
if
(
proxy
.
getTargetInLineFaultSequence
(
)
!=
null
)
{
proxy
.
getTargetInLineFaultSequence
(
)
.
init
(
se
)
;
}
}
for
(
ManagedLifecycle
stp
:
getStartups
(
)
)
{
if
(
stp
!=
null
)
{
stp
.
init
(
se
)
;
}
}
for
(
PriorityExecutor
executor
:
getPriorityExecutors
(
)
.
values
(
)
)
{
executor
.
init
(
)
;
}
for
(
MessageStore
messageStore
:
messageStores
.
values
(
)
)
{
messageStore
.
init
(
se
)
;
}
for
(
MessageProcessor
messageProcessor
:
messageProcessors
.
values
(
)
)
{
messageProcessor
.
init
(
se
)
;
}
for
(
API
api
:
apiTable
.
values
(
)
)
{
api
.
init
(
se
)
;
}
}
private
void
doDestroy
(
)
{
synapseTimer
.
cancel
(
)
;
synapseTimer
=
null
;
for
(
ProxyService
p
:
getProxyServices
(
)
)
{
if
(
p
.
getTargetInLineInSequence
(
)
!=
null
)
{
p
.
getTargetInLineInSequence
(
)
.
destroy
(
)
;
}
if
(
p
.
getTargetInLineOutSequence
(
)
!=
null
)
{
p
.
getTargetInLineOutSequence
(
)
.
destroy
(
)
;
}
}
for
(
ManagedLifecycle
seq
:
getDefinedSequences
(
)
.
values
(
)
)
{
seq
.
destroy
(
)
;
}
for
(
TemplateMediator
seqTemplate
:
getSequenceTemplates
(
)
.
values
(
)
)
{
seqTemplate
.
destroy
(
)
;
}
for
(
Endpoint
endpoint
:
getDefinedEndpoints
(
)
.
values
(
)
)
{
endpoint
.
destroy
(
)
;
}
for
(
ManagedLifecycle
stp
:
startups
.
values
(
)
)
{
stp
.
destroy
(
)
;
}
try
{
SALSessions
.
getInstance
(
)
.
reset
(
)
;
DataSourceRepositoryHolder
.
getInstance
(
)
.
getDataSourceRepositoryManager
(
)
.
clear
(
)
;
}
catch
(
Throwable
ignored
)
{
}
for
(
PriorityExecutor
pe
:
executors
.
values
(
)
)
{
pe
.
destroy
(
)
;
}
for
(
MessageStore
ms
:
messageStores
.
values
(
)
)
{
ms
.
destroy
(
)
;
}
for
(
MessageProcessor
mp
:
messageProcessors
.
values
(
)
)
{
mp
.
destroy
(
)
;
}
for
(
API
api
:
apiTable
.
values
(
)
)
{
api
.
destroy
(
)
;
}
}
private
void
handleException
(
String
msg
)
{
log
.
error
(
msg
)
;
throw
new
SynapseException
(
msg
)
;
}
public
synchronized
void
addEventSource
(
String
name
,
SynapseEventSource
eventSource
)
{
if
(
!
eventSources
.
containsKey
(
name
)
)
{
eventSources
.
put
(
name
,
eventSource
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
eventSourceAdded
(
eventSource
)
;
}
}
else
{
handleException
(
"Duplicate event source by the name : "
+
name
)
;
}
}
public
SynapseEventSource
getEventSource
(
String
name
)
{
return
eventSources
.
get
(
name
)
;
}
public
synchronized
void
removeEventSource
(
String
name
)
{
SynapseEventSource
eventSource
=
eventSources
.
get
(
name
)
;
if
(
eventSource
==
null
)
{
handleException
(
"No event source exists by the name : "
+
name
)
;
}
else
{
try
{
if
(
getAxisConfiguration
(
)
.
getServiceForActivation
(
name
)
!=
null
)
{
if
(
getAxisConfiguration
(
)
.
getServiceForActivation
(
name
)
.
isActive
(
)
)
{
getAxisConfiguration
(
)
.
getService
(
name
)
.
setActive
(
false
)
;
}
getAxisConfiguration
(
)
.
removeService
(
name
)
;
}
eventSources
.
remove
(
name
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
eventSourceRemoved
(
eventSource
)
;
}
}
catch
(
AxisFault
axisFault
)
{
handleException
(
axisFault
.
getMessage
(
)
)
;
}
}
}
public
Collection
<
SynapseEventSource
>
getEventSources
(
)
{
return
eventSources
.
values
(
)
;
}
public
void
setEventSources
(
Map
<
String
,
SynapseEventSource
>
eventSources
)
{
this
.
eventSources
=
eventSources
;
}
public
void
registerObserver
(
SynapseObserver
o
)
{
if
(
!
observers
.
contains
(
o
)
)
{
observers
.
add
(
o
)
;
}
}
public
List
<
SynapseObserver
>
getObservers
(
)
{
return
Collections
.
unmodifiableList
(
observers
)
;
}
public
synchronized
void
addPriorityExecutor
(
String
name
,
PriorityExecutor
executor
)
{
if
(
!
executors
.
containsKey
(
name
)
)
{
executors
.
put
(
name
,
executor
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
priorityExecutorAdded
(
executor
)
;
}
}
else
{
handleException
(
"Duplicate priority executor by the name: "
+
name
)
;
}
}
public
synchronized
void
updatePriorityExecutor
(
String
name
,
PriorityExecutor
executor
)
{
executors
.
put
(
name
,
executor
)
;
for
(
SynapseObserver
o
:
observers
)
{
o
.
priorityExecutorAdded
(
executor
)
;
}
}
public
Map
<
String
,
PriorityExecutor
>
getPriorityExecutors
(
)
{
return
executors
;
}
public
synchronized
PriorityExecutor
removeExecutor
(
String
name
)
{
PriorityExecutor
executor
=
executors
.
remove
(
name
)
;
if
(
executor
!=
null
)
{
for
(
SynapseObserver
o
:
observers
)
{
o
.
priorityExecutorRemoved
(
executor
)
;
}
}
return
executor
;
}
public
MessageStore
getMessageStore
(
String
name
)
{
return
messageStores
.
get
(
name
)
;
}
public
void
addMessageStore
(
String
name
,
MessageStore
messageStore
)
{
if
(
!
messageStores
.
containsKey
(
name
)
)
{
messageStores
.
put
(
name
,
messageStore
)
;
}
else
{
handleException
(
"Duplicate message store : "
+
name
)
;
}
}
public
Map
<
String
,
MessageStore
>
getMessageStores
(
)
{
return
messageStores
;
}
public
MessageStore
removeMessageStore
(
String
name
)
{
return
messageStores
.
remove
(
name
)
;
}
public
void
addMessageProcessor
(
String
name
,
MessageProcessor
processor
)
{
if
(
!
(
messageProcessors
.
containsKey
(
name
)
)
)
{
messageProcessors
.
put
(
name
,
processor
)
;
}
else
{
handleException
(
"Duplicate Message Processor "
+
name
)
;
}
}
public
Map
<
String
,
MessageProcessor
>
getMessageProcessors
(
)
{
return
messageProcessors
;
}
public
MessageProcessor
removeMessageProcessor
(
String
name
)
{
return
messageProcessors
.
remove
(
name
)
;
}
public
void
addSynapseLibrary
(
String
name
,
Library
library
)
{
if
(
!
(
synapseLibraries
.
containsKey
(
name
)
)
)
{
synapseLibraries
.
put
(
name
,
library
)
;
}
else
{
handleException
(
"Duplicate Synapse Library "
+
name
)
;
}
}
public
Map
<
String
,
Library
>
getSynapseLibraries
(
)
{
return
synapseLibraries
;
}
public
Library
removeSynapseLibrary
(
String
name
)
{
return
synapseLibraries
.
remove
(
name
)
;
}
public
void
addSynapseImport
(
String
name
,
SynapseImport
synImport
)
{
if
(
!
(
synapseImports
.
containsKey
(
name
)
)
)
{
synapseImports
.
put
(
name
,
synImport
)
;
}
else
{
handleException
(
"Duplicate Synapse Library "
+
name
)
;
}
}
public
Map
<
String
,
SynapseImport
>
getSynapseImports
(
)
{
return
synapseImports
;
}
public
SynapseImport
removeSynapseImport
(
String
name
)
{
return
synapseImports
.
remove
(
name
)
;
}
public
void
setDescription
(
String
description
)
{
this
.
description
=
description
;
}
public
String
getDescription
(
)
{
return
description
;
}
public
SynapseArtifactDeploymentStore
getArtifactDeploymentStore
(
)
{
return
artifactDeploymentStore
;
}
private
void
assertAlreadyExists
(
String
key
,
String
type
)
{
if
(
key
==
null
||
""
.
equals
(
key
)
)
{
handleException
(
"Given entry key is empty or null."
)
;
}
if
(
localRegistry
.
containsKey
(
key
.
trim
(
)
)
)
{
handleException
(
"Duplicate "
+
type
+
" definition for key : "
+
key
)
;
}
}
private
void
assertEntryNull
(
Entry
entry
,
String
key
)
{
if
(
entry
==
null
)
{
handleException
(
"Cannot locate an either local or remote entry for key : "
+
key
)
;
}
}
public
void
addEndpointTemplate
(
String
name
,
Template
template
)
{
assertAlreadyExists
(
name
,
"template"
)
;
localRegistry
.
put
(
name
,
template
)
;
}
public
void
updateEndpointTemplate
(
String
name
,
Template
template
)
{
localRegistry
.
put
(
name
,
template
)
;
}
public
void
removeEndpointTemplate
(
String
name
)
{
Object
sequence
=
localRegistry
.
get
(
name
)
;
if
(
sequence
instanceof
Template
)
{
localRegistry
.
remove
(
name
)
;
}
else
{
handleException
(
"No template exists by the key/name : "
+
name
)
;
}
}
public
Template
getEndpointTemplate
(
String
key
)
{
Object
o
=
getEntry
(
key
)
;
if
(
o
instanceof
Template
)
{
return
(
Template
)
o
;
}
Entry
entry
=
null
;
if
(
o
==
null
)
{
entry
=
new
Entry
(
key
)
;
entry
.
setType
(
Entry
.
REMOTE_ENTRY
)
;
}
else
{
Object
object
=
localRegistry
.
get
(
key
)
;
if
(
object
instanceof
Entry
)
{
entry
=
(
Entry
)
object
;
}
}
assertEntryNull
(
entry
,
key
)
;
if
(
entry
.
getMapper
(
)
==
null
)
{
entry
.
setMapper
(
new
XMLToTemplateMapper
(
)
)
;
}
if
(
entry
.
getType
(
)
==
Entry
.
REMOTE_ENTRY
)
{
if
(
registry
!=
null
)
{
o
=
registry
.
getResource
(
entry
,
getProperties
(
)
)
;
if
(
o
!=
null
&&
o
instanceof
Template
)
{
localRegistry
.
put
(
key
,
entry
)
;
return
(
Template
)
o
;
}
else
if
(
o
instanceof
OMNode
)
{
Template
m
=
new
TemplateFactory
(
)
.
createEndpointTemplate
(
(
OMElement
)
o
,
properties
)
;
if
(
m
!=
null
)
{
entry
.
setValue
(
m
)
;
return
m
;
}
}
}
}
else
{
Object
value
=
entry
.
getValue
(
)
;
if
(
value
instanceof
OMNode
)
{
Object
object
=
entry
.
getMapper
(
)
.
getObjectFromOMNode
(
(
OMNode
)
value
,
getProperties
(
)
)
;
if
(
object
instanceof
Template
)
{
entry
.
setValue
(
object
)
;
return
(
Template
)
object
;
}
}
}
Template
templateFromLib
=
LibDeployerUtils
.
getLibArtifact
(
synapseLibraries
,
key
,
Template
.
class
)
;
if
(
templateFromLib
!=
null
)
{
return
templateFromLib
;
}
return
null
;
}
public
boolean
isAllowHotUpdate
(
)
{
return
allowHotUpdate
;
}
public
void
setAllowHotUpdate
(
boolean
allowHotUpdate
)
{
this
.
allowHotUpdate
=
allowHotUpdate
;
}
}
