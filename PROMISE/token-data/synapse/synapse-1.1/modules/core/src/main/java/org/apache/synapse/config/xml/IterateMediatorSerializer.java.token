package
org
.
apache
.
synapse
.
config
.
xml
;
import
org
.
apache
.
axiom
.
om
.
OMElement
;
import
org
.
apache
.
synapse
.
Mediator
;
import
org
.
apache
.
synapse
.
mediators
.
eip
.
splitter
.
IterateMediator
;
public
class
IterateMediatorSerializer
extends
AbstractMediatorSerializer
{
public
OMElement
serializeSpecificMediator
(
Mediator
m
)
{
if
(
!
(
m
instanceof
IterateMediator
)
)
{
handleException
(
"Unsupported mediator passed in for serialization : "
+
m
.
getType
(
)
)
;
}
OMElement
itrElem
=
fac
.
createOMElement
(
"iterate"
,
synNS
)
;
saveTracingState
(
itrElem
,
m
)
;
IterateMediator
itrMed
=
(
IterateMediator
)
m
;
if
(
itrMed
.
isContinueParent
(
)
)
{
itrElem
.
addAttribute
(
"continueParent"
,
Boolean
.
toString
(
true
)
,
nullNS
)
;
}
if
(
itrMed
.
getId
(
)
!=
null
)
{
itrElem
.
addAttribute
(
"id"
,
itrMed
.
getId
(
)
,
nullNS
)
;
}
if
(
itrMed
.
isPreservePayload
(
)
)
{
itrElem
.
addAttribute
(
"preservePayload"
,
Boolean
.
toString
(
true
)
,
nullNS
)
;
}
if
(
itrMed
.
getAttachPath
(
)
!=
null
&&
!
"."
.
equals
(
itrMed
.
getAttachPath
(
)
.
toString
(
)
)
)
{
SynapseXPathSerializer
.
serializeXPath
(
itrMed
.
getAttachPath
(
)
,
itrElem
,
"attachPath"
)
;
}
if
(
itrMed
.
getExpression
(
)
!=
null
)
{
SynapseXPathSerializer
.
serializeXPath
(
itrMed
.
getExpression
(
)
,
itrElem
,
"expression"
)
;
}
else
{
handleException
(
"Missing expression of the IterateMediator which is required."
)
;
}
if
(
itrMed
.
getTarget
(
)
!=
null
&&
!
itrMed
.
getTarget
(
)
.
isAsynchronous
(
)
)
{
itrElem
.
addAttribute
(
"sequential"
,
"true"
,
nullNS
)
;
}
itrElem
.
addChild
(
TargetSerializer
.
serializeTarget
(
itrMed
.
getTarget
(
)
)
)
;
return
itrElem
;
}
public
String
getMediatorClassName
(
)
{
return
IterateMediator
.
class
.
getName
(
)
;
}
}
