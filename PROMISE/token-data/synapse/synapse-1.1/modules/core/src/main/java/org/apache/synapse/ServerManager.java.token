package
org
.
apache
.
synapse
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
org
.
apache
.
synapse
.
commons
.
jmx
.
MBeanRegistrar
;
import
org
.
apache
.
synapse
.
config
.
SynapsePropertiesLoader
;
import
org
.
apache
.
synapse
.
securevault
.
PasswordManager
;
import
org
.
apache
.
synapse
.
securevault
.
SecurityConstants
;
import
javax
.
management
.
NotCompliantMBeanException
;
import
java
.
util
.
Date
;
@
SuppressWarnings
(
{
"UnusedDeclaration"
}
)
public
class
ServerManager
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
ServerManager
.
class
)
;
private
SynapseController
synapseController
;
private
ServerConfigurationInformation
serverConfigurationInformation
;
private
ServerContextInformation
serverContextInformation
;
private
boolean
initialized
=
false
;
private
ClassLoader
classLoader
;
public
ServerManager
(
)
{
}
public
synchronized
ServerState
init
(
ServerConfigurationInformation
serverConfigurationInformation
,
ServerContextInformation
serverContextInformation
)
{
classLoader
=
Thread
.
currentThread
(
)
.
getContextClassLoader
(
)
;
this
.
serverConfigurationInformation
=
serverConfigurationInformation
;
if
(
serverContextInformation
==
null
)
{
this
.
serverContextInformation
=
new
ServerContextInformation
(
serverConfigurationInformation
)
;
}
else
{
this
.
serverContextInformation
=
serverContextInformation
;
}
synapseController
=
SynapseControllerFactory
.
createSynapseController
(
serverConfigurationInformation
)
;
doInit
(
)
;
initialized
=
true
;
return
this
.
serverContextInformation
.
getServerState
(
)
;
}
public
synchronized
ServerState
shutdown
(
)
{
ServerState
serverState
=
ServerStateDetectionStrategy
.
currentState
(
serverContextInformation
,
serverConfigurationInformation
)
;
switch
(
serverState
)
{
case
INITIALIZED
:
{
doShutdown
(
)
;
break
;
}
case
STOPPED
:
{
doShutdown
(
)
;
break
;
}
case
STARTED
:
{
stop
(
)
;
doShutdown
(
)
;
break
;
}
case
MAINTENANCE
:
{
stop
(
)
;
doShutdown
(
)
;
break
;
}
}
this
.
synapseController
=
null
;
this
.
serverContextInformation
=
null
;
this
.
serverConfigurationInformation
=
null
;
this
.
initialized
=
false
;
return
ServerState
.
UNDETERMINED
;
}
public
synchronized
ServerState
start
(
)
{
assertInitialized
(
)
;
ServerState
serverState
=
ServerStateDetectionStrategy
.
currentState
(
serverContextInformation
,
serverConfigurationInformation
)
;
if
(
serverState
==
ServerState
.
INITIALIZED
||
serverState
==
ServerState
.
STOPPED
)
{
serverContextInformation
.
setSynapseConfiguration
(
synapseController
.
createSynapseConfiguration
(
)
)
;
serverContextInformation
.
setSynapseEnvironment
(
synapseController
.
createSynapseEnvironment
(
)
)
;
synapseController
.
start
(
)
;
changeState
(
ServerState
.
STARTED
)
;
log
.
info
(
"Server ready for processing..."
)
;
}
else
if
(
serverState
==
ServerState
.
STARTED
)
{
String
message
=
"The server has already been started."
;
handleException
(
message
)
;
}
else
if
(
serverState
==
ServerState
.
MAINTENANCE
)
{
endMaintenance
(
)
;
}
else
{
changeState
(
serverState
)
;
}
return
this
.
serverContextInformation
.
getServerState
(
)
;
}
public
synchronized
ServerState
startMaintenance
(
)
{
assertInitialized
(
)
;
ServerState
serverState
=
ServerStateDetectionStrategy
.
currentState
(
serverContextInformation
,
serverConfigurationInformation
)
;
if
(
serverState
==
ServerState
.
STARTED
)
{
synapseController
.
startMaintenance
(
)
;
changeState
(
ServerState
.
MAINTENANCE
)
;
}
else
if
(
serverState
==
ServerState
.
MAINTENANCE
)
{
String
message
=
"The server is already in maintenance mode."
;
handleException
(
message
)
;
}
else
{
String
message
=
"Couldn't enter maintenance mode, the server has not been started."
;
handleException
(
message
)
;
}
return
serverContextInformation
.
getServerState
(
)
;
}
public
synchronized
ServerState
endMaintenance
(
)
{
assertInitialized
(
)
;
ServerState
serverState
=
ServerStateDetectionStrategy
.
currentState
(
serverContextInformation
,
serverConfigurationInformation
)
;
if
(
serverState
==
ServerState
.
MAINTENANCE
)
{
synapseController
.
endMaintenance
(
)
;
changeState
(
ServerState
.
STARTED
)
;
}
else
{
String
message
=
"Couldn't leave maintenance mode."
+
" The server has not been in maintenance."
;
handleException
(
message
)
;
}
return
serverContextInformation
.
getServerState
(
)
;
}
public
synchronized
ServerState
stop
(
)
{
assertInitialized
(
)
;
ServerState
serverState
=
ServerStateDetectionStrategy
.
currentState
(
serverContextInformation
,
serverConfigurationInformation
)
;
if
(
serverState
==
ServerState
.
STARTED
||
serverState
==
ServerState
.
MAINTENANCE
)
{
synapseController
.
stop
(
)
;
synapseController
.
destroySynapseEnvironment
(
)
;
serverContextInformation
.
setSynapseEnvironment
(
null
)
;
synapseController
.
destroySynapseConfiguration
(
)
;
serverContextInformation
.
setSynapseConfiguration
(
null
)
;
changeState
(
ServerState
.
STOPPED
)
;
}
else
{
changeState
(
serverState
)
;
String
message
=
"Couldn't stop the ServerManager, it has not been started yet"
;
handleException
(
message
)
;
}
return
this
.
serverContextInformation
.
getServerState
(
)
;
}
public
synchronized
ServerState
stopGracefully
(
long
maxWaitMillis
)
{
final
long
startTime
=
System
.
currentTimeMillis
(
)
;
final
long
endTime
=
startTime
+
maxWaitMillis
;
final
long
waitIntervalMillis
=
2000
;
log
.
info
(
new
StringBuilder
(
"Requesting a graceful shutdown at: "
)
.
append
(
new
Date
(
)
)
.
append
(
" in a maximum of "
)
.
append
(
maxWaitMillis
/
1000
)
.
append
(
" seconds."
)
.
toString
(
)
)
;
startMaintenance
(
)
;
if
(
synapseController
.
waitUntilSafeToStop
(
waitIntervalMillis
,
endTime
)
)
{
log
.
info
(
new
StringBuilder
(
"The instance could not be gracefully stopped in: "
)
.
append
(
maxWaitMillis
/
1000
)
.
append
(
" seconds. Performing an immediate stop..."
)
.
toString
(
)
)
;
}
stop
(
)
;
log
.
info
(
new
StringBuilder
(
"Graceful stop request completed in "
)
.
append
(
(
System
.
currentTimeMillis
(
)
-
startTime
)
)
.
append
(
" milliseconds."
)
.
toString
(
)
)
;
return
this
.
serverContextInformation
.
getServerState
(
)
;
}
public
ServerConfigurationInformation
getServerConfigurationInformation
(
)
{
assertInitialized
(
)
;
return
serverConfigurationInformation
;
}
public
ServerContextInformation
getServerContextInformation
(
)
{
assertInitialized
(
)
;
return
serverContextInformation
;
}
public
ClassLoader
getClassLoader
(
)
{
return
classLoader
;
}
public
boolean
isInitialized
(
)
{
return
initialized
;
}
public
ServerState
getServerState
(
)
{
if
(
serverContextInformation
!=
null
)
{
return
serverContextInformation
.
getServerState
(
)
;
}
return
ServerState
.
UNDETERMINED
;
}
private
void
doInit
(
)
{
ServerState
serverState
=
ServerStateDetectionStrategy
.
currentState
(
serverContextInformation
,
serverConfigurationInformation
)
;
if
(
serverState
==
ServerState
.
INITIALIZABLE
)
{
registerMBean
(
)
;
PasswordManager
.
getInstance
(
)
.
init
(
SynapsePropertiesLoader
.
loadSynapseProperties
(
)
,
SynapseConstants
.
SYNAPSE
)
;
this
.
synapseController
.
init
(
serverConfigurationInformation
,
serverContextInformation
)
;
changeState
(
ServerState
.
INITIALIZED
)
;
}
else
{
changeState
(
serverState
)
;
}
}
private
void
doShutdown
(
)
{
ServerState
serverState
=
ServerStateDetectionStrategy
.
currentState
(
serverContextInformation
,
serverConfigurationInformation
)
;
if
(
serverState
==
ServerState
.
INITIALIZED
||
serverState
==
ServerState
.
STOPPED
)
{
PasswordManager
passwordManager
=
PasswordManager
.
getInstance
(
)
;
if
(
passwordManager
.
isInitialized
(
)
)
{
PasswordManager
.
getInstance
(
)
.
shutDown
(
)
;
}
unRegisterMBean
(
)
;
synapseController
.
destroy
(
)
;
changeState
(
ServerState
.
UNDETERMINED
)
;
}
else
{
changeState
(
serverState
)
;
}
}
private
void
changeState
(
ServerState
serverState
)
{
this
.
serverContextInformation
.
setServerState
(
serverState
)
;
}
private
void
assertInitialized
(
)
{
if
(
!
initialized
)
{
String
msg
=
"Server manager has not been initialized, it requires to be "
+
"initialized, with the required configurations before starting"
;
handleException
(
msg
)
;
}
}
private
void
handleException
(
String
msg
)
{
log
.
error
(
msg
)
;
throw
new
SynapseException
(
msg
)
;
}
private
void
handleException
(
String
msg
,
Exception
e
)
{
log
.
error
(
msg
,
e
)
;
throw
new
SynapseException
(
msg
,
e
)
;
}
private
void
registerMBean
(
)
{
MBeanRegistrar
.
getInstance
(
)
.
registerMBean
(
new
ServerManagerView
(
this
)
,
SynapseConstants
.
SERVER_MANAGER_MBEAN
,
SynapseConstants
.
SERVER_MANAGER_MBEAN
)
;
try
{
MBeanRegistrar
.
getInstance
(
)
.
registerMBean
(
new
SecretManagerAdminMBeanImpl
(
)
,
SecurityConstants
.
PROP_SECURITY_ADMIN_SERVICES
,
SecurityConstants
.
PROP_SECRET_MANAGER_ADMIN_MBEAN
)
;
}
catch
(
NotCompliantMBeanException
e
)
{
handleException
(
"Error registering SecretManagerAdminMBeanImpl"
,
e
)
;
}
}
private
void
unRegisterMBean
(
)
{
MBeanRegistrar
.
getInstance
(
)
.
unRegisterMBean
(
SynapseConstants
.
SERVER_MANAGER_MBEAN
,
SynapseConstants
.
SERVER_MANAGER_MBEAN
)
;
MBeanRegistrar
.
getInstance
(
)
.
unRegisterMBean
(
SecurityConstants
.
PROP_SECURITY_ADMIN_SERVICES
,
SecurityConstants
.
PROP_SECRET_MANAGER_ADMIN_MBEAN
)
;
}
}
