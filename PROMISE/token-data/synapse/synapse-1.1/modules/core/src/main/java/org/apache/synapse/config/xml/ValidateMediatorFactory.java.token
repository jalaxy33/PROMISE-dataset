package
org
.
apache
.
synapse
.
config
.
xml
;
import
org
.
apache
.
axiom
.
om
.
OMAttribute
;
import
org
.
apache
.
axiom
.
om
.
OMElement
;
import
org
.
apache
.
synapse
.
Mediator
;
import
org
.
apache
.
synapse
.
mediators
.
Value
;
import
org
.
apache
.
synapse
.
mediators
.
builtin
.
ValidateMediator
;
import
org
.
jaxen
.
JaxenException
;
import
org
.
xml
.
sax
.
SAXException
;
import
javax
.
xml
.
namespace
.
QName
;
import
java
.
util
.
*
;
public
class
ValidateMediatorFactory
extends
AbstractListMediatorFactory
{
private
static
final
QName
VALIDATE_Q
=
new
QName
(
XMLConfigConstants
.
SYNAPSE_NAMESPACE
,
"validate"
)
;
private
static
final
QName
ON_FAIL_Q
=
new
QName
(
XMLConfigConstants
.
SYNAPSE_NAMESPACE
,
"on-fail"
)
;
private
static
final
QName
SCHEMA_Q
=
new
QName
(
XMLConfigConstants
.
SYNAPSE_NAMESPACE
,
"schema"
)
;
public
Mediator
createSpecificMediator
(
OMElement
elem
,
Properties
properties
)
{
ValidateMediator
validateMediator
=
new
ValidateMediator
(
)
;
List
<
Value
>
schemaKeys
=
new
ArrayList
<
Value
>
(
)
;
Iterator
schemas
=
elem
.
getChildrenWithName
(
SCHEMA_Q
)
;
while
(
schemas
.
hasNext
(
)
)
{
Object
o
=
schemas
.
next
(
)
;
if
(
o
instanceof
OMElement
)
{
OMElement
omElem
=
(
OMElement
)
o
;
OMAttribute
keyAtt
=
omElem
.
getAttribute
(
ATT_KEY
)
;
if
(
keyAtt
!=
null
)
{
ValueFactory
keyFac
=
new
ValueFactory
(
)
;
Value
generatedKey
=
keyFac
.
createValue
(
XMLConfigConstants
.
KEY
,
omElem
)
;
schemaKeys
.
add
(
generatedKey
)
;
}
else
{
handleException
(
"A 'schema' definition must contain a local property 'key'"
)
;
}
}
else
{
handleException
(
"Invalid 'schema' declaration for validate mediator"
)
;
}
}
if
(
schemaKeys
.
size
(
)
==
0
)
{
handleException
(
"No schema specified for the validate mediator"
)
;
}
else
{
validateMediator
.
setSchemaKeys
(
schemaKeys
)
;
}
OMAttribute
attSource
=
elem
.
getAttribute
(
ATT_SOURCE
)
;
if
(
attSource
!=
null
)
{
try
{
validateMediator
.
setSource
(
SynapseXPathFactory
.
getSynapseXPath
(
elem
,
ATT_SOURCE
)
)
;
}
catch
(
JaxenException
e
)
{
handleException
(
"Invalid XPath expression specified for attribute 'source'"
,
e
)
;
}
}
validateMediator
.
setResourceMap
(
ResourceMapFactory
.
createResourceMap
(
elem
)
)
;
OMElement
onFail
=
null
;
Iterator
iterator
=
elem
.
getChildrenWithName
(
ON_FAIL_Q
)
;
if
(
iterator
.
hasNext
(
)
)
{
onFail
=
(
OMElement
)
iterator
.
next
(
)
;
}
if
(
onFail
!=
null
&&
onFail
.
getChildElements
(
)
.
hasNext
(
)
)
{
addChildren
(
onFail
,
validateMediator
,
properties
)
;
}
else
{
handleException
(
"A non-empty <on-fail> child element is required for "
+
"the <validate> mediator"
)
;
}
processAuditStatus
(
validateMediator
,
elem
)
;
for
(
Map
.
Entry
<
String
,
String
>
entry
:
collectNameValuePairs
(
elem
,
FEATURE_Q
)
.
entrySet
(
)
)
{
String
value
=
entry
.
getValue
(
)
;
boolean
isFeatureEnabled
;
if
(
"true"
.
equals
(
value
)
)
{
isFeatureEnabled
=
true
;
}
else
if
(
"false"
.
equals
(
value
)
)
{
isFeatureEnabled
=
false
;
}
else
{
handleException
(
"The feature must have value true or false"
)
;
break
;
}
try
{
validateMediator
.
addFeature
(
entry
.
getKey
(
)
,
isFeatureEnabled
)
;
}
catch
(
SAXException
e
)
{
handleException
(
"Error setting validation feature : "
+
entry
.
getKey
(
)
+
" to : "
+
value
,
e
)
;
}
}
return
validateMediator
;
}
public
QName
getTagQName
(
)
{
return
VALIDATE_Q
;
}
}
