package
org
.
apache
.
synapse
.
mediators
.
transform
;
import
org
.
apache
.
axiom
.
om
.
OMElement
;
import
org
.
apache
.
axiom
.
om
.
OMNode
;
import
org
.
apache
.
axiom
.
soap
.
SOAPEnvelope
;
import
org
.
apache
.
axis2
.
AxisFault
;
import
org
.
apache
.
synapse
.
MessageContext
;
import
org
.
apache
.
synapse
.
SynapseException
;
import
org
.
apache
.
synapse
.
SynapseLog
;
import
org
.
apache
.
synapse
.
config
.
Entry
;
import
org
.
apache
.
synapse
.
config
.
SynapseConfigUtils
;
import
org
.
apache
.
synapse
.
core
.
SynapseEnvironment
;
import
org
.
apache
.
synapse
.
mediators
.
AbstractMediator
;
import
org
.
apache
.
synapse
.
mediators
.
Value
;
import
org
.
apache
.
synapse
.
mediators
.
MediatorProperty
;
import
org
.
apache
.
synapse
.
util
.
jaxp
.
*
;
import
org
.
apache
.
synapse
.
util
.
resolver
.
CustomJAXPURIResolver
;
import
org
.
apache
.
synapse
.
util
.
resolver
.
ResourceMap
;
import
org
.
apache
.
synapse
.
util
.
xpath
.
SourceXPathSupport
;
import
org
.
apache
.
synapse
.
util
.
xpath
.
SynapseXPath
;
import
javax
.
xml
.
transform
.
*
;
import
java
.
nio
.
charset
.
Charset
;
import
java
.
util
.
*
;
public
class
XSLTMediator
extends
AbstractMediator
{
private
static
class
ErrorListenerImpl
implements
ErrorListener
{
private
final
SynapseLog
synLog
;
private
final
String
activity
;
public
ErrorListenerImpl
(
SynapseLog
synLog
,
String
activity
)
{
this
.
synLog
=
synLog
;
this
.
activity
=
activity
;
}
public
void
warning
(
TransformerException
e
)
throws
TransformerException
{
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebugWarn
(
"Warning encountered during "
+
activity
+
" : "
+
e
)
;
}
}
public
void
error
(
TransformerException
e
)
throws
TransformerException
{
synLog
.
error
(
"Error occurred in "
+
activity
+
" : "
+
e
)
;
throw
e
;
}
public
void
fatalError
(
TransformerException
e
)
throws
TransformerException
{
synLog
.
error
(
"Fatal error occurred in "
+
activity
+
" : "
+
e
)
;
throw
e
;
}
}
public
static
final
String
USE_DOM_SOURCE_AND_RESULTS
=
"http://ws.apache.org/ns/synapse/transform/feature/dom"
;
public
static
final
String
SOURCE_BUILDER_FACTORY
=
"http://ws.apache.org/ns/synapse/transform/attribute/sbf"
;
public
static
final
String
RESULT_BUILDER_FACTORY
=
"http://ws.apache.org/ns/synapse/transform/attribute/rbf"
;
private
Value
xsltKey
=
null
;
private
final
SourceXPathSupport
source
=
new
SourceXPathSupport
(
)
;
private
String
targetPropertyName
=
null
;
private
final
List
<
MediatorProperty
>
properties
=
new
ArrayList
<
MediatorProperty
>
(
)
;
private
final
List
<
MediatorProperty
>
transformerFactoryFeatures
=
new
ArrayList
<
MediatorProperty
>
(
)
;
private
final
List
<
MediatorProperty
>
transformerFactoryAttributes
=
new
ArrayList
<
MediatorProperty
>
(
)
;
private
ResourceMap
resourceMap
;
private
Map
<
String
,
Templates
>
cachedTemplatesMap
=
new
Hashtable
<
String
,
Templates
>
(
)
;
private
final
TransformerFactory
transFact
=
TransformerFactory
.
newInstance
(
)
;
private
final
Object
transformerLock
=
new
Object
(
)
;
private
SourceBuilderFactory
sourceBuilderFactory
=
new
StreamSourceBuilderFactory
(
)
;
private
ResultBuilderFactory
resultBuilderFactory
=
new
StreamResultBuilderFactory
(
)
;
public
boolean
mediate
(
MessageContext
synCtx
)
{
SynapseLog
synLog
=
getLog
(
synCtx
)
;
synLog
.
traceOrDebug
(
"Start : XSLT mediator"
)
;
if
(
synLog
.
isTraceTraceEnabled
(
)
)
{
synLog
.
traceTrace
(
"Message : "
+
synCtx
.
getEnvelope
(
)
)
;
}
try
{
performXSLT
(
synCtx
,
synLog
)
;
}
catch
(
Exception
e
)
{
handleException
(
"Unable to perform XSLT transformation using : "
+
xsltKey
+
" against source XPath : "
+
source
,
e
,
synCtx
)
;
}
synLog
.
traceOrDebug
(
"End : XSLT mediator"
)
;
return
true
;
}
private
void
performXSLT
(
MessageContext
synCtx
,
SynapseLog
synLog
)
{
OMNode
sourceNode
=
source
.
selectOMNode
(
synCtx
,
synLog
)
;
boolean
isSoapEnvelope
=
(
sourceNode
==
synCtx
.
getEnvelope
(
)
)
;
boolean
isSoapBody
=
(
sourceNode
==
synCtx
.
getEnvelope
(
)
.
getBody
(
)
)
;
boolean
isSoapHeader
=
(
sourceNode
==
synCtx
.
getEnvelope
(
)
.
getHeader
(
)
)
;
String
generatedXsltKey
=
xsltKey
.
evaluateValue
(
synCtx
)
;
Templates
cachedTemplates
=
null
;
if
(
synLog
.
isTraceTraceEnabled
(
)
)
{
synLog
.
traceTrace
(
"Transformation source : "
+
sourceNode
.
toString
(
)
)
;
}
if
(
isCreationOrRecreationRequired
(
synCtx
)
)
{
synchronized
(
transformerLock
)
{
if
(
isCreationOrRecreationRequired
(
synCtx
)
)
{
cachedTemplates
=
createTemplate
(
synCtx
,
synLog
,
generatedXsltKey
)
;
}
else
{
cachedTemplates
=
cachedTemplatesMap
.
get
(
generatedXsltKey
)
;
}
}
}
else
{
synchronized
(
transformerLock
)
{
cachedTemplates
=
cachedTemplatesMap
.
get
(
generatedXsltKey
)
;
}
}
try
{
Transformer
transformer
=
null
;
try
{
transformer
=
cachedTemplates
.
newTransformer
(
)
;
}
catch
(
NullPointerException
ex
)
{
handleException
(
"Unable to create Transformer using cached template"
,
ex
,
synCtx
)
;
}
if
(
!
properties
.
isEmpty
(
)
)
{
applyProperties
(
transformer
,
synCtx
,
synLog
)
;
}
transformer
.
setErrorListener
(
new
ErrorListenerImpl
(
synLog
,
"XSLT transformation"
)
)
;
String
outputMethod
=
transformer
.
getOutputProperty
(
OutputKeys
.
METHOD
)
;
String
encoding
=
transformer
.
getOutputProperty
(
OutputKeys
.
ENCODING
)
;
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebug
(
"output method: "
+
outputMethod
+
"; encoding: "
+
encoding
)
;
}
ResultBuilderFactory
.
Output
output
;
if
(
"text"
.
equals
(
outputMethod
)
)
{
synLog
.
traceOrDebug
(
"Processing non SOAP/XML (text) transformation result"
)
;
output
=
ResultBuilderFactory
.
Output
.
TEXT
;
}
else
if
(
isSoapEnvelope
)
{
output
=
ResultBuilderFactory
.
Output
.
SOAP_ENVELOPE
;
}
else
{
output
=
ResultBuilderFactory
.
Output
.
ELEMENT
;
}
SynapseEnvironment
synEnv
=
synCtx
.
getEnvironment
(
)
;
ResultBuilder
resultBuilder
=
resultBuilderFactory
.
createResultBuilder
(
synEnv
,
output
)
;
SourceBuilder
sourceBuilder
=
sourceBuilderFactory
.
createSourceBuilder
(
synEnv
)
;
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebug
(
"Using "
+
sourceBuilder
.
getClass
(
)
.
getName
(
)
)
;
synLog
.
traceOrDebug
(
"Using "
+
resultBuilder
.
getClass
(
)
.
getName
(
)
)
;
}
try
{
transformer
.
transform
(
sourceBuilder
.
getSource
(
(
OMElement
)
sourceNode
)
,
resultBuilder
.
getResult
(
)
)
;
}
finally
{
sourceBuilder
.
release
(
)
;
}
synLog
.
traceOrDebug
(
"Transformation completed - processing result"
)
;
OMElement
result
=
resultBuilder
.
getNode
(
encoding
==
null
?
null
:
Charset
.
forName
(
encoding
)
)
;
if
(
synLog
.
isTraceTraceEnabled
(
)
)
{
synLog
.
traceTrace
(
"Transformation result : "
+
result
.
toString
(
)
)
;
}
if
(
targetPropertyName
!=
null
)
{
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebug
(
"Adding result as message context property : "
+
targetPropertyName
)
;
}
synCtx
.
setProperty
(
targetPropertyName
,
result
)
;
}
else
{
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
synLog
.
traceOrDebug
(
"Replace "
+
(
isSoapEnvelope
?
"SOAP envelope"
:
isSoapBody
?
"SOAP body"
:
"node"
)
+
" with result"
)
;
}
if
(
isSoapEnvelope
)
{
try
{
synCtx
.
setEnvelope
(
(
SOAPEnvelope
)
result
)
;
}
catch
(
AxisFault
ex
)
{
handleException
(
"Unable to replace SOAP envelope with result"
,
ex
,
synCtx
)
;
}
}
else
if
(
isSoapBody
)
{
for
(
Iterator
itr
=
synCtx
.
getEnvelope
(
)
.
getBody
(
)
.
getChildElements
(
)
;
itr
.
hasNext
(
)
;
)
{
OMElement
child
=
(
OMElement
)
itr
.
next
(
)
;
child
.
detach
(
)
;
}
for
(
Iterator
itr
=
result
.
getChildElements
(
)
;
itr
.
hasNext
(
)
;
)
{
OMElement
child
=
(
OMElement
)
itr
.
next
(
)
;
synCtx
.
getEnvelope
(
)
.
getBody
(
)
.
addChild
(
child
)
;
}
}
else
if
(
isSoapHeader
)
{
for
(
Iterator
itr
=
synCtx
.
getEnvelope
(
)
.
getHeader
(
)
.
getChildElements
(
)
;
itr
.
hasNext
(
)
;
)
{
OMElement
child
=
(
OMElement
)
itr
.
next
(
)
;
child
.
detach
(
)
;
}
for
(
Iterator
itr
=
result
.
getChildElements
(
)
;
itr
.
hasNext
(
)
;
)
{
OMElement
child
=
(
OMElement
)
itr
.
next
(
)
;
synCtx
.
getEnvelope
(
)
.
getHeader
(
)
.
addChild
(
child
)
;
}
}
else
{
sourceNode
.
insertSiblingAfter
(
result
)
;
sourceNode
.
detach
(
)
;
}
}
}
catch
(
TransformerException
e
)
{
handleException
(
"Error performing XSLT transformation using : "
+
xsltKey
,
e
,
synCtx
)
;
}
}
private
Templates
createTemplate
(
MessageContext
synCtx
,
SynapseLog
synLog
,
String
generatedXsltKey
)
{
Templates
cachedTemplates
=
null
;
transFact
.
setErrorListener
(
new
ErrorListenerImpl
(
synLog
,
"stylesheet parsing"
)
)
;
transFact
.
setURIResolver
(
new
CustomJAXPURIResolver
(
resourceMap
,
synCtx
.
getConfiguration
(
)
)
)
;
try
{
cachedTemplates
=
transFact
.
newTemplates
(
SynapseConfigUtils
.
getStreamSource
(
synCtx
.
getEntry
(
generatedXsltKey
)
)
)
;
if
(
cachedTemplates
==
null
)
{
handleException
(
"Error compiling the XSLT with key : "
+
xsltKey
,
synCtx
)
;
}
else
{
cachedTemplatesMap
.
put
(
generatedXsltKey
,
cachedTemplates
)
;
}
}
catch
(
Exception
e
)
{
handleException
(
"Error creating XSLT transformer using : "
+
xsltKey
,
e
,
synCtx
)
;
}
return
cachedTemplates
;
}
private
boolean
isCreationOrRecreationRequired
(
MessageContext
synCtx
)
{
String
generatedXsltKey
=
xsltKey
.
evaluateValue
(
synCtx
)
;
if
(
cachedTemplatesMap
.
isEmpty
(
)
||
!
cachedTemplatesMap
.
containsKey
(
generatedXsltKey
)
)
{
return
true
;
}
else
{
Entry
dp
=
synCtx
.
getConfiguration
(
)
.
getEntryDefinition
(
generatedXsltKey
)
;
return
dp
!=
null
&&
dp
.
isDynamic
(
)
&&
(
!
dp
.
isCached
(
)
||
dp
.
isExpired
(
)
)
;
}
}
public
SynapseXPath
getSource
(
)
{
return
source
.
getXPath
(
)
;
}
public
void
setSource
(
SynapseXPath
source
)
{
this
.
source
.
setXPath
(
source
)
;
}
public
Value
getXsltKey
(
)
{
return
xsltKey
;
}
public
void
setXsltKey
(
Value
xsltKey
)
{
this
.
xsltKey
=
xsltKey
;
}
public
void
addProperty
(
MediatorProperty
p
)
{
properties
.
add
(
p
)
;
}
private
void
applyProperties
(
Transformer
transformer
,
MessageContext
synCtx
,
SynapseLog
synLog
)
{
for
(
MediatorProperty
prop
:
properties
)
{
if
(
prop
!=
null
)
{
String
value
;
if
(
prop
.
getValue
(
)
!=
null
)
{
value
=
prop
.
getValue
(
)
;
}
else
{
value
=
prop
.
getExpression
(
)
.
stringValueOf
(
synCtx
)
;
}
if
(
synLog
.
isTraceOrDebugEnabled
(
)
)
{
if
(
value
==
null
)
{
synLog
.
traceOrDebug
(
"Not setting parameter '"
+
prop
.
getName
(
)
+
"'"
)
;
}
else
{
synLog
.
traceOrDebug
(
"Setting parameter '"
+
prop
.
getName
(
)
+
"' to '"
+
value
+
"'"
)
;
}
}
if
(
value
!=
null
)
{
transformer
.
setParameter
(
prop
.
getName
(
)
,
value
)
;
}
}
}
}
public
void
addFeature
(
String
featureName
,
boolean
isFeatureEnable
)
{
MediatorProperty
mp
=
new
MediatorProperty
(
)
;
mp
.
setName
(
featureName
)
;
if
(
isFeatureEnable
)
{
mp
.
setValue
(
"true"
)
;
}
else
{
mp
.
setValue
(
"false"
)
;
}
transformerFactoryFeatures
.
add
(
mp
)
;
if
(
USE_DOM_SOURCE_AND_RESULTS
.
equals
(
featureName
)
)
{
if
(
isFeatureEnable
)
{
sourceBuilderFactory
=
new
DOOMSourceBuilderFactory
(
)
;
resultBuilderFactory
=
new
DOOMResultBuilderFactory
(
)
;
}
}
else
{
try
{
transFact
.
setFeature
(
featureName
,
isFeatureEnable
)
;
}
catch
(
TransformerConfigurationException
e
)
{
String
msg
=
"Error occurred when setting features to the TransformerFactory"
;
log
.
error
(
msg
,
e
)
;
throw
new
SynapseException
(
msg
,
e
)
;
}
}
}
public
void
addAttribute
(
String
name
,
String
value
)
{
MediatorProperty
mp
=
new
MediatorProperty
(
)
;
mp
.
setName
(
name
)
;
mp
.
setValue
(
value
)
;
transformerFactoryAttributes
.
add
(
mp
)
;
if
(
SOURCE_BUILDER_FACTORY
.
equals
(
name
)
||
RESULT_BUILDER_FACTORY
.
equals
(
name
)
)
{
Object
instance
;
try
{
instance
=
Class
.
forName
(
value
)
.
newInstance
(
)
;
}
catch
(
ClassNotFoundException
e
)
{
String
msg
=
"The class specified by the "
+
name
+
" attribute was not found"
;
log
.
error
(
msg
,
e
)
;
throw
new
SynapseException
(
msg
,
e
)
;
}
catch
(
Exception
e
)
{
String
msg
=
"The class "
+
value
+
" could not be instantiated"
;
log
.
error
(
msg
,
e
)
;
throw
new
SynapseException
(
msg
,
e
)
;
}
if
(
SOURCE_BUILDER_FACTORY
.
equals
(
name
)
)
{
sourceBuilderFactory
=
(
SourceBuilderFactory
)
instance
;
}
else
{
resultBuilderFactory
=
(
ResultBuilderFactory
)
instance
;
}
}
else
{
try
{
transFact
.
setAttribute
(
name
,
value
)
;
}
catch
(
IllegalArgumentException
e
)
{
String
msg
=
"Error occurred when setting attribute to the TransformerFactory"
;
log
.
error
(
msg
,
e
)
;
throw
new
SynapseException
(
msg
,
e
)
;
}
}
}
public
List
<
MediatorProperty
>
getFeatures
(
)
{
return
transformerFactoryFeatures
;
}
public
List
<
MediatorProperty
>
getAttributes
(
)
{
return
transformerFactoryAttributes
;
}
public
void
addAllProperties
(
List
<
MediatorProperty
>
list
)
{
properties
.
addAll
(
list
)
;
}
public
List
<
MediatorProperty
>
getProperties
(
)
{
return
properties
;
}
public
void
setSourceXPathString
(
String
sourceXPathString
)
{
this
.
source
.
setXPathString
(
sourceXPathString
)
;
}
public
String
getTargetPropertyName
(
)
{
return
targetPropertyName
;
}
public
void
setTargetPropertyName
(
String
targetPropertyName
)
{
this
.
targetPropertyName
=
targetPropertyName
;
}
public
ResourceMap
getResourceMap
(
)
{
return
resourceMap
;
}
public
void
setResourceMap
(
ResourceMap
resourceMap
)
{
this
.
resourceMap
=
resourceMap
;
}
}
