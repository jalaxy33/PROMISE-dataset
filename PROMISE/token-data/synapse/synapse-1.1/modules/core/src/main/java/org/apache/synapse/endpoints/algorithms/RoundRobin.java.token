package
org
.
apache
.
synapse
.
endpoints
.
algorithms
;
import
org
.
apache
.
axis2
.
clustering
.
Member
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
org
.
apache
.
synapse
.
MessageContext
;
import
org
.
apache
.
synapse
.
endpoints
.
Endpoint
;
import
java
.
util
.
List
;
import
java
.
util
.
concurrent
.
locks
.
Lock
;
import
java
.
util
.
concurrent
.
locks
.
ReentrantLock
;
public
class
RoundRobin
implements
LoadbalanceAlgorithm
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
RoundRobin
.
class
)
;
private
List
endpoints
=
null
;
private
List
<
Member
>
members
;
private
final
Lock
lock
=
new
ReentrantLock
(
)
;
public
RoundRobin
(
)
{
}
public
RoundRobin
(
List
endpoints
)
{
this
.
endpoints
=
endpoints
;
}
public
void
setApplicationMembers
(
List
<
Member
>
members
)
{
this
.
members
=
members
;
}
public
void
setEndpoints
(
List
<
Endpoint
>
endpoints
)
{
this
.
endpoints
=
endpoints
;
}
public
void
setLoadBalanceEndpoint
(
Endpoint
endpoint
)
{
}
public
Endpoint
getNextEndpoint
(
MessageContext
synCtx
,
AlgorithmContext
algorithmContext
)
{
Endpoint
nextEndpoint
;
int
attempts
=
0
;
synchronized
(
algorithmContext
)
{
int
currentEPR
=
algorithmContext
.
getCurrentEndpointIndex
(
)
;
do
{
nextEndpoint
=
(
Endpoint
)
endpoints
.
get
(
currentEPR
)
;
if
(
currentEPR
==
endpoints
.
size
(
)
-
1
)
{
currentEPR
=
0
;
}
else
{
currentEPR
++
;
}
algorithmContext
.
setCurrentEndpointIndex
(
currentEPR
)
;
attempts
++
;
if
(
attempts
>
endpoints
.
size
(
)
)
{
return
null
;
}
}
while
(
!
nextEndpoint
.
readyToSend
(
)
)
;
}
return
nextEndpoint
;
}
public
Member
getNextApplicationMember
(
AlgorithmContext
algorithmContext
)
{
if
(
members
.
size
(
)
==
0
)
{
return
null
;
}
Member
current
=
null
;
lock
.
lock
(
)
;
try
{
int
currentMemberIndex
=
algorithmContext
.
getCurrentEndpointIndex
(
)
;
if
(
currentMemberIndex
>=
members
.
size
(
)
)
{
currentMemberIndex
=
0
;
}
int
index
=
members
.
size
(
)
;
do
{
current
=
members
.
get
(
currentMemberIndex
)
;
if
(
currentMemberIndex
==
members
.
size
(
)
-
1
)
{
currentMemberIndex
=
0
;
}
else
{
currentMemberIndex
++
;
}
index
--
;
}
while
(
current
.
isSuspended
(
)
&&
index
>
0
)
;
algorithmContext
.
setCurrentEndpointIndex
(
currentMemberIndex
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Members       : "
+
members
.
size
(
)
)
;
log
.
debug
(
"Current member: "
+
current
)
;
}
}
finally
{
lock
.
unlock
(
)
;
}
return
current
;
}
@
Override
public
LoadbalanceAlgorithm
clone
(
)
{
return
new
RoundRobin
(
)
;
}
public
void
reset
(
AlgorithmContext
algorithmContext
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Resetting the Round Robin loadbalancing algorithm ..."
)
;
}
synchronized
(
algorithmContext
)
{
algorithmContext
.
setCurrentEndpointIndex
(
0
)
;
}
}
public
String
getName
(
)
{
return
"RoundRobin"
;
}
}
