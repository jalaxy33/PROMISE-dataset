package
org
.
apache
.
synapse
.
endpoints
.
dispatch
;
import
org
.
apache
.
axis2
.
clustering
.
ClusteringFault
;
import
org
.
apache
.
axis2
.
clustering
.
context
.
Replicator
;
import
org
.
apache
.
axis2
.
context
.
ConfigurationContext
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
org
.
apache
.
synapse
.
SynapseConstants
;
import
org
.
apache
.
synapse
.
SynapseException
;
import
org
.
apache
.
synapse
.
endpoints
.
Endpoint
;
import
org
.
apache
.
synapse
.
endpoints
.
IndirectEndpoint
;
import
org
.
apache
.
synapse
.
endpoints
.
SALoadbalanceEndpoint
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
public
class
DispatcherContext
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
DispatcherContext
.
class
)
;
private
static
final
String
SESSION
=
"session"
;
private
static
final
String
UNDERSCORE_STRING
=
"_"
;
private
final
Map
<
String
,
Endpoint
>
sessionMap
=
Collections
.
synchronizedMap
(
new
HashMap
<
String
,
Endpoint
>
(
)
)
;
private
ConfigurationContext
configCtx
;
private
boolean
isClusteringEnable
=
false
;
private
String
keyPrefix
;
private
final
Map
<
String
,
Endpoint
>
endpointsMap
=
new
HashMap
<
String
,
Endpoint
>
(
)
;
public
Endpoint
getEndpoint
(
String
sessionID
)
{
if
(
isClusteringEnable
)
{
if
(
keyPrefix
==
null
||
""
.
equals
(
keyPrefix
)
)
{
handleException
(
"Cannot find the required key prefix to find the "
+
"shared state of one of  'session'"
)
;
}
Object
value
=
this
.
configCtx
.
getPropertyNonReplicable
(
this
.
keyPrefix
+
sessionID
)
;
if
(
value
!=
null
&&
value
instanceof
String
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Retrieving the endpoint from the session id "
+
value
)
;
}
return
endpointsMap
.
get
(
value
.
toString
(
)
)
;
}
}
else
{
synchronized
(
sessionMap
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Retrieving the endpoint from the session id "
+
sessionID
)
;
}
return
sessionMap
.
get
(
sessionID
)
;
}
}
return
null
;
}
public
void
setEndpoint
(
String
sessionID
,
Endpoint
endpoint
)
{
if
(
isClusteringEnable
)
{
String
endpointName
;
if
(
endpoint
instanceof
IndirectEndpoint
)
{
endpointName
=
(
(
IndirectEndpoint
)
endpoint
)
.
getKey
(
)
;
}
else
{
endpointName
=
endpoint
.
getName
(
)
;
}
if
(
endpointName
==
null
)
{
if
(
log
.
isDebugEnabled
(
)
&&
isClusteringEnable
(
)
)
{
log
.
warn
(
SALoadbalanceEndpoint
.
WARN_MESSAGE
)
;
}
endpointName
=
SynapseConstants
.
ANONYMOUS_ENDPOINT
;
}
if
(
keyPrefix
!=
null
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Adding the enpoint "
+
endpointName
+
" with the session id "
+
keyPrefix
+
sessionID
+
" for replication to the session"
)
;
}
setAndReplicateState
(
keyPrefix
+
sessionID
,
endpointName
)
;
}
}
else
{
synchronized
(
sessionMap
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Adding the endpoint "
+
endpoint
+
" with the session id "
+
sessionID
+
" to the session"
)
;
}
sessionMap
.
put
(
sessionID
,
endpoint
)
;
}
}
}
public
void
removeSession
(
String
id
)
{
if
(
isClusteringEnable
)
{
if
(
keyPrefix
!=
null
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Removing and replicating "
+
"the session with the session id "
+
keyPrefix
+
id
)
;
}
removeAndReplicateState
(
keyPrefix
+
id
)
;
}
}
else
{
synchronized
(
sessionMap
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Removing the session with the session id "
+
id
)
;
}
sessionMap
.
remove
(
id
)
;
}
}
}
public
ConfigurationContext
getConfigurationContext
(
)
{
return
configCtx
;
}
public
void
setConfigurationContext
(
ConfigurationContext
configCtx
)
{
if
(
configCtx
==
null
)
{
handleException
(
"The ConfigurationContext cannot be null"
+
" when system in a cluster environment"
)
;
}
this
.
configCtx
=
configCtx
;
this
.
isClusteringEnable
=
true
;
}
public
void
setContextID
(
String
contextID
)
{
if
(
contextID
==
null
||
""
.
equals
(
contextID
)
)
{
handleException
(
"The Context ID cannot be null when system in a cluster environment"
)
;
}
StringBuffer
buffer
=
new
StringBuffer
(
)
;
buffer
.
append
(
contextID
)
;
buffer
.
append
(
UNDERSCORE_STRING
)
;
buffer
.
append
(
SESSION
)
;
buffer
.
append
(
UNDERSCORE_STRING
)
;
keyPrefix
=
buffer
.
toString
(
)
;
}
protected
void
handleException
(
String
msg
)
{
log
.
error
(
msg
)
;
throw
new
SynapseException
(
msg
)
;
}
protected
void
handleException
(
String
msg
,
Exception
e
)
{
log
.
error
(
msg
,
e
)
;
throw
new
SynapseException
(
msg
,
e
)
;
}
private
void
setAndReplicateState
(
String
key
,
Object
value
)
{
if
(
configCtx
!=
null
&&
key
!=
null
&&
value
!=
null
)
{
try
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Start replicating the property with key : "
+
key
+
" value : "
+
value
)
;
}
Object
prop
=
configCtx
.
getPropertyNonReplicable
(
key
)
;
if
(
prop
==
null
)
{
configCtx
.
setProperty
(
key
,
value
)
;
Replicator
.
replicate
(
configCtx
,
new
String
[
]
{
key
}
)
;
}
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Completed replication of the property with key: "
+
key
)
;
}
}
catch
(
ClusteringFault
clusteringFault
)
{
handleException
(
"Error during the replicating states "
,
clusteringFault
)
;
}
}
}
private
void
removeAndReplicateState
(
String
key
)
{
if
(
configCtx
!=
null
&&
key
!=
null
)
{
try
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Start replicating the property removal with key : "
+
key
)
;
}
configCtx
.
removeProperty
(
key
)
;
Replicator
.
replicate
(
configCtx
,
new
String
[
]
{
key
}
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Completed replication of the property removal with key : "
+
key
)
;
}
}
catch
(
ClusteringFault
clusteringFault
)
{
handleException
(
"Error during the replicating states "
,
clusteringFault
)
;
}
}
}
public
boolean
isClusteringEnable
(
)
{
return
isClusteringEnable
;
}
public
void
setEndpoints
(
List
<
Endpoint
>
endpoints
)
{
if
(
endpoints
!=
null
)
{
for
(
Endpoint
endpoint
:
endpoints
)
{
String
endpointName
;
if
(
endpoint
instanceof
IndirectEndpoint
)
{
endpointName
=
(
(
IndirectEndpoint
)
endpoint
)
.
getKey
(
)
;
}
else
{
endpointName
=
endpoint
.
getName
(
)
;
}
if
(
endpointName
==
null
)
{
if
(
log
.
isDebugEnabled
(
)
&&
isClusteringEnable
(
)
)
{
log
.
warn
(
SALoadbalanceEndpoint
.
WARN_MESSAGE
)
;
}
endpointName
=
SynapseConstants
.
ANONYMOUS_ENDPOINT
;
}
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Adding an endpoint with the name/key "
+
endpointName
+
" to the endpoints map"
)
;
}
endpointsMap
.
put
(
endpointName
,
endpoint
)
;
}
}
}
}
