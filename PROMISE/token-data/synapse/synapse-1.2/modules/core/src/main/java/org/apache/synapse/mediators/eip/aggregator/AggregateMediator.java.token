package
org
.
apache
.
synapse
.
mediators
.
eip
.
aggregator
;
import
org
.
apache
.
axiom
.
soap
.
SOAP11Constants
;
import
org
.
apache
.
axiom
.
soap
.
SOAP12Constants
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
org
.
apache
.
synapse
.
MessageContext
;
import
org
.
apache
.
synapse
.
SynapseConstants
;
import
org
.
apache
.
synapse
.
mediators
.
AbstractMediator
;
import
org
.
apache
.
synapse
.
mediators
.
base
.
SequenceMediator
;
import
org
.
apache
.
synapse
.
mediators
.
eip
.
EIPConstants
;
import
org
.
apache
.
synapse
.
mediators
.
eip
.
EIPUtils
;
import
org
.
apache
.
synapse
.
util
.
xpath
.
SynapseXPath
;
import
org
.
jaxen
.
JaxenException
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Map
;
public
class
AggregateMediator
extends
AbstractMediator
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
AggregateMediator
.
class
)
;
private
static
final
Log
trace
=
LogFactory
.
getLog
(
SynapseConstants
.
TRACE_LOGGER
)
;
private
long
completionTimeoutMillis
=
0
;
private
int
minMessagesToComplete
=
-
1
;
private
int
maxMessagesToComplete
=
-
1
;
private
SynapseXPath
correlateExpression
=
null
;
private
SynapseXPath
aggregationExpression
=
null
;
private
String
onCompleteSequenceRef
=
null
;
private
SequenceMediator
onCompleteSequence
=
null
;
private
Map
<
String
,
Aggregate
>
activeAggregates
=
Collections
.
synchronizedMap
(
new
HashMap
<
String
,
Aggregate
>
(
)
)
;
private
final
Object
lock
=
new
Object
(
)
;
public
AggregateMediator
(
)
{
try
{
aggregationExpression
=
new
SynapseXPath
(
"s11:Body/child::*[position()=1] | "
+
"s12:Body/child::*[position()=1]"
)
;
aggregationExpression
.
addNamespace
(
"s11"
,
SOAP11Constants
.
SOAP_ENVELOPE_NAMESPACE_URI
)
;
aggregationExpression
.
addNamespace
(
"s12"
,
SOAP12Constants
.
SOAP_ENVELOPE_NAMESPACE_URI
)
;
}
catch
(
JaxenException
e
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
handleException
(
"Unable to set the default "
+
"aggregationExpression for the aggregation"
,
e
,
null
)
;
}
}
}
public
boolean
mediate
(
MessageContext
synCtx
)
{
boolean
traceOn
=
isTraceOn
(
synCtx
)
;
boolean
traceOrDebugOn
=
isTraceOrDebugOn
(
traceOn
)
;
if
(
traceOrDebugOn
)
{
traceOrDebug
(
traceOn
,
"Start : Aggregate mediator"
)
;
if
(
traceOn
&&
trace
.
isTraceEnabled
(
)
)
{
trace
.
trace
(
"Message : "
+
synCtx
.
getEnvelope
(
)
)
;
}
}
try
{
Aggregate
aggregate
=
null
;
if
(
correlateExpression
!=
null
&&
correlateExpression
.
evaluate
(
synCtx
)
!=
null
)
{
while
(
aggregate
==
null
)
{
synchronized
(
lock
)
{
if
(
activeAggregates
.
containsKey
(
correlateExpression
.
toString
(
)
)
)
{
aggregate
=
activeAggregates
.
get
(
correlateExpression
.
toString
(
)
)
;
if
(
aggregate
!=
null
)
{
if
(
!
aggregate
.
getLock
(
)
)
{
aggregate
=
null
;
}
}
}
else
{
if
(
traceOrDebugOn
)
{
traceOrDebug
(
traceOn
,
"Creating new Aggregator - "
+
(
completionTimeoutMillis
>
0
?
"expires in : "
+
(
completionTimeoutMillis
/
1000
)
+
"secs"
:
"without expiry time"
)
)
;
}
aggregate
=
new
Aggregate
(
correlateExpression
.
toString
(
)
,
completionTimeoutMillis
,
minMessagesToComplete
,
maxMessagesToComplete
,
this
)
;
if
(
completionTimeoutMillis
>
0
)
{
synCtx
.
getConfiguration
(
)
.
getSynapseTimer
(
)
.
schedule
(
aggregate
,
completionTimeoutMillis
)
;
}
aggregate
.
getLock
(
)
;
activeAggregates
.
put
(
correlateExpression
.
toString
(
)
,
aggregate
)
;
}
}
}
}
else
if
(
synCtx
.
getProperty
(
EIPConstants
.
AGGREGATE_CORRELATION
)
!=
null
)
{
Object
o
=
synCtx
.
getProperty
(
EIPConstants
.
AGGREGATE_CORRELATION
)
;
String
correlation
;
if
(
o
!=
null
&&
o
instanceof
String
)
{
correlation
=
(
String
)
o
;
while
(
aggregate
==
null
)
{
synchronized
(
lock
)
{
if
(
activeAggregates
.
containsKey
(
correlation
)
)
{
aggregate
=
activeAggregates
.
get
(
correlation
)
;
if
(
aggregate
!=
null
)
{
if
(
!
aggregate
.
getLock
(
)
)
{
aggregate
=
null
;
}
}
else
{
break
;
}
}
else
{
if
(
traceOrDebugOn
)
{
traceOrDebug
(
traceOn
,
"Creating new Aggregator - "
+
(
completionTimeoutMillis
>
0
?
"expires in : "
+
(
completionTimeoutMillis
/
1000
)
+
"secs"
:
"without expiry time"
)
)
;
}
aggregate
=
new
Aggregate
(
correlation
,
completionTimeoutMillis
,
minMessagesToComplete
,
maxMessagesToComplete
,
this
)
;
if
(
completionTimeoutMillis
>
0
)
{
synCtx
.
getConfiguration
(
)
.
getSynapseTimer
(
)
.
schedule
(
aggregate
,
completionTimeoutMillis
)
;
}
aggregate
.
getLock
(
)
;
activeAggregates
.
put
(
correlation
,
aggregate
)
;
}
}
}
}
else
{
if
(
traceOrDebugOn
)
{
traceOrDebug
(
traceOn
,
"Unable to find aggrgation correlation property"
)
;
}
return
true
;
}
}
else
{
if
(
traceOrDebugOn
)
{
traceOrDebug
(
traceOn
,
"Unable to find aggrgation correlation XPath or property"
)
;
}
return
true
;
}
if
(
aggregate
!=
null
)
{
boolean
collected
=
aggregate
.
addMessage
(
synCtx
)
;
if
(
traceOrDebugOn
)
{
if
(
collected
)
{
traceOrDebug
(
traceOn
,
"Collected a message during aggregation"
)
;
if
(
traceOn
&&
trace
.
isTraceEnabled
(
)
)
{
trace
.
trace
(
"Collected message : "
+
synCtx
)
;
}
}
}
if
(
aggregate
.
isComplete
(
traceOn
,
traceOrDebugOn
,
trace
,
log
)
)
{
if
(
traceOrDebugOn
)
{
traceOrDebug
(
traceOn
,
"Aggregation completed - invoking onComplete"
)
;
}
completeAggregate
(
aggregate
)
;
if
(
traceOrDebugOn
)
{
traceOrDebug
(
traceOn
,
"End : Aggregate mediator"
)
;
}
return
true
;
}
else
{
aggregate
.
releaseLock
(
)
;
}
}
else
{
if
(
traceOrDebugOn
)
{
traceOrDebug
(
traceOn
,
"Unable to find an aggregate for this message - skip"
)
;
}
return
true
;
}
}
catch
(
JaxenException
e
)
{
handleException
(
"Unable to execute the XPATH over the message"
,
e
,
synCtx
)
;
}
if
(
traceOrDebugOn
)
{
traceOrDebug
(
traceOn
,
"End : Aggregate mediator"
)
;
}
return
false
;
}
public
synchronized
void
completeAggregate
(
Aggregate
aggregate
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Aggregation completed or timed out"
)
;
}
aggregate
.
cancel
(
)
;
aggregate
.
setCompleted
(
true
)
;
MessageContext
newSynCtx
=
getAggregatedMessage
(
aggregate
)
;
if
(
newSynCtx
==
null
)
{
log
.
warn
(
"An aggregation of messages timed out with no aggregated messages"
,
null
)
;
return
;
}
activeAggregates
.
remove
(
aggregate
.
getCorrelation
(
)
)
;
if
(
(
correlateExpression
!=
null
&&
!
correlateExpression
.
toString
(
)
.
equals
(
aggregate
.
getCorrelation
(
)
)
)
||
correlateExpression
==
null
)
{
if
(
onCompleteSequence
!=
null
)
{
onCompleteSequence
.
mediate
(
newSynCtx
)
;
}
else
if
(
onCompleteSequenceRef
!=
null
&&
newSynCtx
.
getSequence
(
onCompleteSequenceRef
)
!=
null
)
{
newSynCtx
.
getSequence
(
onCompleteSequenceRef
)
.
mediate
(
newSynCtx
)
;
}
else
{
handleException
(
"Unable to find the sequence for the mediation "
+
"of the aggregated message"
,
newSynCtx
)
;
}
}
}
private
MessageContext
getAggregatedMessage
(
Aggregate
aggregate
)
{
MessageContext
newCtx
=
null
;
for
(
MessageContext
synCtx
:
aggregate
.
getMessages
(
)
)
{
if
(
newCtx
==
null
)
{
newCtx
=
synCtx
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Generating Aggregated message from : "
+
newCtx
.
getEnvelope
(
)
)
;
}
}
else
{
try
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Merging message : "
+
synCtx
.
getEnvelope
(
)
+
" using XPath : "
+
aggregationExpression
)
;
}
EIPUtils
.
enrichEnvelope
(
newCtx
.
getEnvelope
(
)
,
synCtx
.
getEnvelope
(
)
,
aggregationExpression
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Merged result : "
+
newCtx
.
getEnvelope
(
)
)
;
}
}
catch
(
JaxenException
e
)
{
handleException
(
"Error merging aggregation results using XPath : "
+
aggregationExpression
.
toString
(
)
,
e
,
synCtx
)
;
}
}
}
return
newCtx
;
}
public
SynapseXPath
getCorrelateExpression
(
)
{
return
correlateExpression
;
}
public
void
setCorrelateExpression
(
SynapseXPath
correlateExpression
)
{
this
.
correlateExpression
=
correlateExpression
;
}
public
long
getCompletionTimeoutMillis
(
)
{
return
completionTimeoutMillis
;
}
public
void
setCompletionTimeoutMillis
(
long
completionTimeoutMillis
)
{
this
.
completionTimeoutMillis
=
completionTimeoutMillis
;
}
public
int
getMinMessagesToComplete
(
)
{
return
minMessagesToComplete
;
}
public
void
setMinMessagesToComplete
(
int
minMessagesToComplete
)
{
this
.
minMessagesToComplete
=
minMessagesToComplete
;
}
public
int
getMaxMessagesToComplete
(
)
{
return
maxMessagesToComplete
;
}
public
void
setMaxMessagesToComplete
(
int
maxMessagesToComplete
)
{
this
.
maxMessagesToComplete
=
maxMessagesToComplete
;
}
public
SynapseXPath
getAggregationExpression
(
)
{
return
aggregationExpression
;
}
public
void
setAggregationExpression
(
SynapseXPath
aggregationExpression
)
{
this
.
aggregationExpression
=
aggregationExpression
;
}
public
String
getOnCompleteSequenceRef
(
)
{
return
onCompleteSequenceRef
;
}
public
void
setOnCompleteSequenceRef
(
String
onCompleteSequenceRef
)
{
this
.
onCompleteSequenceRef
=
onCompleteSequenceRef
;
}
public
SequenceMediator
getOnCompleteSequence
(
)
{
return
onCompleteSequence
;
}
public
void
setOnCompleteSequence
(
SequenceMediator
onCompleteSequence
)
{
this
.
onCompleteSequence
=
onCompleteSequence
;
}
public
Map
getActiveAggregates
(
)
{
return
activeAggregates
;
}
}
