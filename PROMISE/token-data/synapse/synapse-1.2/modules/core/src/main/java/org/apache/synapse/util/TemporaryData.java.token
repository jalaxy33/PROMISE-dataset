package
org
.
apache
.
synapse
.
util
;
import
org
.
apache
.
commons
.
io
.
IOUtils
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
java
.
io
.
*
;
public
class
TemporaryData
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
TemporaryData
.
class
)
;
class
OutputStreamImpl
extends
OutputStream
{
private
FileOutputStream
fileOutputStream
;
public
void
write
(
byte
[
]
b
,
int
off
,
int
len
)
throws
IOException
{
if
(
fileOutputStream
!=
null
)
{
fileOutputStream
.
write
(
b
,
off
,
len
)
;
}
else
if
(
len
>
(
chunks
.
length
-
chunkIndex
)
*
chunkSize
-
chunkOffset
)
{
fileOutputStream
=
switchToTempFile
(
)
;
fileOutputStream
.
write
(
b
,
off
,
len
)
;
}
else
{
while
(
len
>
0
)
{
byte
[
]
chunk
=
getCurrentChunk
(
)
;
int
c
=
Math
.
min
(
len
,
chunkSize
-
chunkOffset
)
;
System
.
arraycopy
(
b
,
off
,
chunk
,
chunkOffset
,
c
)
;
len
-=
c
;
off
+=
c
;
chunkOffset
+=
c
;
if
(
chunkOffset
==
chunkSize
)
{
chunkIndex
++
;
chunkOffset
=
0
;
}
}
}
}
public
void
write
(
byte
[
]
b
)
throws
IOException
{
write
(
b
,
0
,
b
.
length
)
;
}
public
void
write
(
int
b
)
throws
IOException
{
write
(
new
byte
[
]
{
(
byte
)
b
}
,
0
,
1
)
;
}
public
void
flush
(
)
throws
IOException
{
if
(
fileOutputStream
!=
null
)
{
fileOutputStream
.
flush
(
)
;
}
}
public
void
close
(
)
throws
IOException
{
if
(
fileOutputStream
!=
null
)
{
fileOutputStream
.
close
(
)
;
}
}
}
class
InputStreamImpl
extends
InputStream
{
private
int
currentChunkIndex
;
private
int
currentChunkOffset
;
private
int
markChunkIndex
;
private
int
markChunkOffset
;
public
int
available
(
)
throws
IOException
{
return
(
chunkIndex
-
currentChunkIndex
)
*
chunkSize
+
chunkOffset
-
currentChunkOffset
;
}
public
int
read
(
byte
[
]
b
,
int
off
,
int
len
)
throws
IOException
{
if
(
len
==
0
)
{
return
0
;
}
int
read
=
0
;
while
(
len
>
0
&&
!
(
currentChunkIndex
==
chunkIndex
&&
currentChunkOffset
==
chunkOffset
)
)
{
int
c
;
if
(
currentChunkIndex
==
chunkIndex
)
{
c
=
Math
.
min
(
len
,
chunkOffset
-
currentChunkOffset
)
;
}
else
{
c
=
Math
.
min
(
len
,
chunkSize
-
currentChunkOffset
)
;
}
System
.
arraycopy
(
chunks
[
currentChunkIndex
]
,
currentChunkOffset
,
b
,
off
,
c
)
;
len
-=
c
;
off
+=
c
;
currentChunkOffset
+=
c
;
read
+=
c
;
if
(
currentChunkOffset
==
chunkSize
)
{
currentChunkIndex
++
;
currentChunkOffset
=
0
;
}
}
if
(
read
==
0
)
{
return
-
1
;
}
else
{
return
read
;
}
}
public
int
read
(
byte
[
]
b
)
throws
IOException
{
return
read
(
b
,
0
,
b
.
length
)
;
}
public
int
read
(
)
throws
IOException
{
byte
[
]
b
=
new
byte
[
1
]
;
return
read
(
b
)
==
-
1
?
-
1
:
(
int
)
b
[
0
]
&
0xFF
;
}
public
boolean
markSupported
(
)
{
return
true
;
}
public
void
mark
(
int
readlimit
)
{
markChunkIndex
=
currentChunkIndex
;
markChunkOffset
=
currentChunkOffset
;
}
public
void
reset
(
)
throws
IOException
{
currentChunkIndex
=
markChunkIndex
;
currentChunkOffset
=
markChunkOffset
;
}
public
long
skip
(
long
n
)
throws
IOException
{
int
available
=
available
(
)
;
int
c
=
n
<
available
?
(
int
)
n
:
available
;
int
newOffset
=
currentChunkOffset
+
c
;
int
chunkDelta
=
newOffset
/
chunkSize
;
currentChunkIndex
+=
chunkDelta
;
currentChunkOffset
=
newOffset
-
(
chunkDelta
*
chunkSize
)
;
return
c
;
}
public
void
close
(
)
throws
IOException
{
}
}
final
int
chunkSize
;
final
String
tempPrefix
;
final
String
tempSuffix
;
byte
[
]
[
]
chunks
;
int
chunkIndex
;
int
chunkOffset
;
File
temporaryFile
;
public
TemporaryData
(
int
numberOfChunks
,
int
chunkSize
,
String
tempPrefix
,
String
tempSuffix
)
{
this
.
chunkSize
=
chunkSize
;
this
.
tempPrefix
=
tempPrefix
;
this
.
tempSuffix
=
tempSuffix
;
chunks
=
new
byte
[
numberOfChunks
]
[
]
;
}
byte
[
]
getCurrentChunk
(
)
{
if
(
chunkOffset
==
0
)
{
byte
[
]
chunk
=
new
byte
[
chunkSize
]
;
chunks
[
chunkIndex
]
=
chunk
;
return
chunk
;
}
else
{
return
chunks
[
chunkIndex
]
;
}
}
FileOutputStream
switchToTempFile
(
)
throws
IOException
{
temporaryFile
=
File
.
createTempFile
(
tempPrefix
,
tempSuffix
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Using temporary file "
+
temporaryFile
)
;
}
temporaryFile
.
deleteOnExit
(
)
;
FileOutputStream
fileOutputStream
=
new
FileOutputStream
(
temporaryFile
)
;
for
(
int
i
=
0
;
i
<
chunkIndex
;
i
++
)
{
fileOutputStream
.
write
(
chunks
[
i
]
)
;
}
if
(
chunkOffset
>
0
)
{
fileOutputStream
.
write
(
chunks
[
chunkIndex
]
,
0
,
chunkOffset
)
;
}
chunks
=
null
;
return
fileOutputStream
;
}
public
OutputStream
getOutputStream
(
)
{
return
new
OutputStreamImpl
(
)
;
}
public
void
readFrom
(
InputStream
in
)
throws
IOException
{
while
(
true
)
{
int
c
=
in
.
read
(
getCurrentChunk
(
)
,
chunkOffset
,
chunkSize
-
chunkOffset
)
;
if
(
c
==
-
1
)
{
break
;
}
chunkOffset
+=
c
;
if
(
chunkOffset
==
chunkSize
)
{
chunkIndex
++
;
chunkOffset
=
0
;
if
(
chunkIndex
==
chunks
.
length
)
{
FileOutputStream
fileOutputStream
=
switchToTempFile
(
)
;
IOUtils
.
copy
(
in
,
fileOutputStream
)
;
fileOutputStream
.
close
(
)
;
break
;
}
}
}
}
public
InputStream
getInputStream
(
)
throws
IOException
{
if
(
temporaryFile
!=
null
)
{
return
new
FileInputStream
(
temporaryFile
)
;
}
else
{
return
new
InputStreamImpl
(
)
;
}
}
public
void
release
(
)
{
if
(
temporaryFile
!=
null
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Deleting temporary file "
+
temporaryFile
)
;
}
temporaryFile
.
delete
(
)
;
}
}
protected
void
finalize
(
)
throws
Throwable
{
if
(
temporaryFile
!=
null
)
{
log
.
warn
(
"Cleaning up unreleased temporary file "
+
temporaryFile
)
;
temporaryFile
.
delete
(
)
;
}
}
}
