package
org
.
apache
.
synapse
.
core
.
axis2
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
org
.
apache
.
synapse
.
FaultHandler
;
import
org
.
apache
.
synapse
.
MessageContext
;
import
org
.
apache
.
synapse
.
SynapseConstants
;
import
org
.
apache
.
synapse
.
ServerManager
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Map
;
import
java
.
util
.
Stack
;
import
java
.
util
.
TimerTask
;
public
class
TimeoutHandler
extends
TimerTask
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
TimeoutHandler
.
class
)
;
private
Map
callbackStore
=
null
;
private
Object
lock
=
new
Object
(
)
;
private
boolean
alreadyExecuting
=
false
;
private
long
globalTimeout
=
SynapseConstants
.
DEFAULT_GLOBAL_TIMEOUT
;
public
TimeoutHandler
(
Map
callbacks
)
{
this
.
callbackStore
=
callbacks
;
globalTimeout
=
ServerManager
.
getInstance
(
)
.
getGlobalTimeoutInterval
(
)
;
log
.
info
(
"This engine will expire all callbacks after : "
+
(
globalTimeout
/
1000
)
+
" seconds, irrespective of the timeout action, after the specified or optional timeout"
)
;
}
public
void
run
(
)
{
if
(
alreadyExecuting
)
return
;
synchronized
(
lock
)
{
alreadyExecuting
=
true
;
try
{
processCallbacks
(
)
;
}
catch
(
Exception
ignore
)
{
}
alreadyExecuting
=
false
;
}
}
private
void
processCallbacks
(
)
{
synchronized
(
callbackStore
)
{
if
(
callbackStore
.
size
(
)
>
0
)
{
long
currentTime
=
currentTime
(
)
;
Iterator
i
=
callbackStore
.
keySet
(
)
.
iterator
(
)
;
while
(
i
.
hasNext
(
)
)
{
Object
key
=
i
.
next
(
)
;
AsyncCallback
callback
=
(
AsyncCallback
)
callbackStore
.
get
(
key
)
;
if
(
callback
.
getTimeOutAction
(
)
!=
SynapseConstants
.
NONE
)
{
if
(
callback
.
getTimeOutOn
(
)
<=
currentTime
)
{
callbackStore
.
remove
(
key
)
;
if
(
callback
.
getTimeOutAction
(
)
==
SynapseConstants
.
DISCARD_AND_FAULT
)
{
MessageContext
msgContext
=
callback
.
getSynapseOutMsgCtx
(
)
;
msgContext
.
setProperty
(
SynapseConstants
.
ERROR_CODE
,
SynapseConstants
.
TIME_OUT
)
;
msgContext
.
setProperty
(
SynapseConstants
.
ERROR_MESSAGE
,
"Send timeout"
)
;
Stack
faultStack
=
msgContext
.
getFaultStack
(
)
;
for
(
int
j
=
0
;
j
<
faultStack
.
size
(
)
;
j
++
)
{
Object
o
=
faultStack
.
pop
(
)
;
if
(
o
instanceof
FaultHandler
)
{
(
(
FaultHandler
)
o
)
.
handleFault
(
msgContext
)
;
}
}
}
}
}
else
if
(
currentTime
>
globalTimeout
+
callback
.
getTimeOutOn
(
)
)
{
log
.
warn
(
"Expiring message ID : "
+
key
+
"; dropping message after "
+
"global timeout of : "
+
(
globalTimeout
/
1000
)
+
" seconds"
)
;
callbackStore
.
remove
(
key
)
;
}
}
}
}
}
private
long
currentTime
(
)
{
return
System
.
currentTimeMillis
(
)
;
}
}
