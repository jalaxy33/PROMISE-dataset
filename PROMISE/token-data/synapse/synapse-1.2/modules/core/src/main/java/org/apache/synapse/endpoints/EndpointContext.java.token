package
org
.
apache
.
synapse
.
endpoints
;
import
org
.
apache
.
axis2
.
clustering
.
ClusteringFault
;
import
org
.
apache
.
axis2
.
clustering
.
context
.
Replicator
;
import
org
.
apache
.
axis2
.
context
.
ConfigurationContext
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
org
.
apache
.
synapse
.
SynapseException
;
public
class
EndpointContext
{
private
static
final
Log
log
=
LogFactory
.
getLog
(
EndpointContext
.
class
)
;
private
static
final
String
ACTIVE
=
"active"
;
private
static
final
String
RECOVER_ON
=
"recover_on"
;
private
static
final
String
UNDERSCORE_STRING
=
"_"
;
private
boolean
active
=
true
;
private
long
recoverOn
=
Long
.
MAX_VALUE
;
private
ConfigurationContext
configCtx
;
private
String
activePropertyKey
;
private
String
recoverOnPropertyKey
;
private
boolean
isClusteringEnable
=
false
;
public
boolean
isActive
(
)
{
if
(
this
.
isClusteringEnable
)
{
if
(
this
.
activePropertyKey
==
null
||
""
.
equals
(
this
.
activePropertyKey
)
)
{
handleException
(
"Cannot find the required key to find the "
+
"shared state of 'active' attribute"
)
;
}
Object
value
=
this
.
configCtx
.
getPropertyNonReplicable
(
this
.
activePropertyKey
)
;
if
(
value
==
null
)
{
return
true
;
}
if
(
value
instanceof
Boolean
)
{
return
(
(
Boolean
)
value
)
.
booleanValue
(
)
;
}
else
if
(
value
instanceof
String
)
{
return
Boolean
.
parseBoolean
(
(
String
)
value
)
;
}
else
{
handleException
(
"Unsupported object type for value"
+
value
)
;
}
}
else
{
return
active
;
}
throw
new
SynapseException
(
"Invalid states in endpoint context"
)
;
}
public
synchronized
void
setActive
(
boolean
active
)
{
if
(
this
.
isClusteringEnable
)
{
setAndReplicateState
(
this
.
activePropertyKey
,
active
)
;
}
else
{
this
.
active
=
active
;
}
}
public
long
getRecoverOn
(
)
{
if
(
this
.
isClusteringEnable
)
{
if
(
this
.
recoverOnPropertyKey
==
null
||
""
.
equals
(
this
.
recoverOnPropertyKey
)
)
{
handleException
(
"Cannot find the required key to find the "
+
"shared state of 'recoveOn' attribute"
)
;
}
Object
value
=
this
.
configCtx
.
getPropertyNonReplicable
(
this
.
recoverOnPropertyKey
)
;
if
(
value
==
null
)
{
return
Long
.
MAX_VALUE
;
}
if
(
value
instanceof
Long
)
{
return
(
(
Long
)
value
)
.
longValue
(
)
;
}
else
if
(
value
instanceof
String
)
{
try
{
return
Long
.
parseLong
(
(
String
)
value
)
;
}
catch
(
NumberFormatException
e
)
{
return
Long
.
MAX_VALUE
;
}
}
else
{
handleException
(
"Unsupported object type for value"
+
value
)
;
}
}
else
{
return
recoverOn
;
}
throw
new
SynapseException
(
"Invalid states in endpoint context"
)
;
}
public
void
setRecoverOn
(
long
recoverOn
)
{
if
(
this
.
isClusteringEnable
)
{
setAndReplicateState
(
this
.
recoverOnPropertyKey
,
recoverOn
)
;
}
else
{
this
.
recoverOn
=
recoverOn
;
}
}
public
ConfigurationContext
getConfigurationContext
(
)
{
return
configCtx
;
}
public
void
setConfigurationContext
(
ConfigurationContext
configCtx
)
{
if
(
configCtx
==
null
)
{
handleException
(
"The ConfigurationContext cannot be null"
+
" when system in a cluster environment"
)
;
}
this
.
configCtx
=
configCtx
;
this
.
isClusteringEnable
=
true
;
}
public
void
setContextID
(
String
contextID
)
{
if
(
contextID
==
null
||
""
.
equals
(
contextID
)
)
{
handleException
(
"The Context ID cannot be null when system in a cluster environment"
)
;
}
StringBuffer
buffer
=
new
StringBuffer
(
)
;
buffer
.
append
(
contextID
)
;
buffer
.
append
(
UNDERSCORE_STRING
)
;
String
prefix
=
buffer
.
toString
(
)
;
this
.
recoverOnPropertyKey
=
prefix
+
RECOVER_ON
;
this
.
activePropertyKey
=
prefix
+
ACTIVE
;
}
private
void
setAndReplicateState
(
String
key
,
Object
value
)
{
if
(
configCtx
!=
null
&&
key
!=
null
&&
value
!=
null
)
{
try
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Start replicating the property with key : "
+
key
+
" value : "
+
value
)
;
}
configCtx
.
setProperty
(
key
,
value
)
;
Replicator
.
replicate
(
configCtx
,
new
String
[
]
{
key
}
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Completed replication of the property with key : "
+
key
)
;
}
}
catch
(
ClusteringFault
clusteringFault
)
{
handleException
(
"Error during the replicating states "
,
clusteringFault
)
;
}
}
}
protected
void
handleException
(
String
msg
)
{
log
.
error
(
msg
)
;
throw
new
SynapseException
(
msg
)
;
}
protected
void
handleException
(
String
msg
,
Exception
e
)
{
log
.
error
(
msg
,
e
)
;
throw
new
SynapseException
(
msg
,
e
)
;
}
}
