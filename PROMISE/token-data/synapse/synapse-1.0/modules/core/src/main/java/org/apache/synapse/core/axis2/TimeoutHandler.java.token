package
org
.
apache
.
synapse
.
core
.
axis2
;
import
org
.
apache
.
synapse
.
MessageContext
;
import
org
.
apache
.
synapse
.
Constants
;
import
org
.
apache
.
synapse
.
FaultHandler
;
import
org
.
apache
.
synapse
.
mediators
.
transform
.
FaultMediator
;
import
org
.
apache
.
synapse
.
mediators
.
MediatorFaultHandler
;
import
java
.
util
.
TimerTask
;
import
java
.
util
.
Map
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Stack
;
public
class
TimeoutHandler
extends
TimerTask
{
private
Map
callbackStore
=
null
;
private
Object
lock
=
new
Object
(
)
;
private
boolean
alreadyExecuting
=
false
;
public
TimeoutHandler
(
Map
callbacks
)
{
this
.
callbackStore
=
callbacks
;
}
public
void
run
(
)
{
if
(
alreadyExecuting
)
return
;
synchronized
(
lock
)
{
alreadyExecuting
=
true
;
try
{
processCallbacks
(
)
;
}
catch
(
Exception
ignore
)
{
}
alreadyExecuting
=
false
;
}
}
private
void
processCallbacks
(
)
{
synchronized
(
callbackStore
)
{
if
(
callbackStore
.
size
(
)
>
0
)
{
long
currentTime
=
currentTime
(
)
;
Iterator
i
=
callbackStore
.
keySet
(
)
.
iterator
(
)
;
while
(
i
.
hasNext
(
)
)
{
Object
key
=
i
.
next
(
)
;
AsyncCallback
callback
=
(
AsyncCallback
)
callbackStore
.
get
(
key
)
;
if
(
callback
.
getTimeOutAction
(
)
!=
Constants
.
NONE
)
{
if
(
callback
.
getTimeOutOn
(
)
<=
currentTime
)
{
callbackStore
.
remove
(
key
)
;
if
(
callback
.
getTimeOutAction
(
)
==
Constants
.
DISCARD_AND_FAULT
)
{
MessageContext
msgContext
=
callback
.
getSynapseOutMsgCtx
(
)
;
msgContext
.
setProperty
(
Constants
.
ERROR_CODE
,
Constants
.
TIME_OUT
)
;
Stack
faultStack
=
msgContext
.
getFaultStack
(
)
;
for
(
int
j
=
0
;
j
<
faultStack
.
size
(
)
;
j
++
)
{
Object
o
=
faultStack
.
pop
(
)
;
if
(
o
instanceof
MediatorFaultHandler
)
{
(
(
MediatorFaultHandler
)
o
)
.
handleFault
(
msgContext
)
;
}
}
}
}
}
}
}
}
}
private
long
currentTime
(
)
{
return
System
.
currentTimeMillis
(
)
;
}
}
