package
org
.
apache
.
ivy
.
ant
;
import
java
.
io
.
File
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
import
org
.
apache
.
ivy
.
core
.
report
.
ArtifactDownloadReport
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
types
.
FileSet
;
import
org
.
apache
.
tools
.
ant
.
types
.
PatternSet
.
NameEntry
;
public
class
IvyCacheFileset
extends
IvyCacheTask
{
private
String
setid
;
public
String
getSetid
(
)
{
return
setid
;
}
public
void
setSetid
(
String
id
)
{
setid
=
id
;
}
public
void
setUseOrigin
(
boolean
useOrigin
)
{
if
(
useOrigin
)
{
throw
new
UnsupportedOperationException
(
"the cachefileset task does not support the useOrigin mode, since filesets "
+
"require to have only one root directory. Please use the the cachepath "
+
"task instead"
)
;
}
}
public
void
doExecute
(
)
throws
BuildException
{
prepareAndCheck
(
)
;
if
(
setid
==
null
)
{
throw
new
BuildException
(
"setid is required in ivy cachefileset"
)
;
}
try
{
FileSet
fileset
=
new
FileSet
(
)
;
fileset
.
setProject
(
getProject
(
)
)
;
getProject
(
)
.
addReference
(
setid
,
fileset
)
;
List
paths
=
getArtifactReports
(
)
;
File
base
=
null
;
for
(
Iterator
iter
=
paths
.
iterator
(
)
;
iter
.
hasNext
(
)
;
)
{
ArtifactDownloadReport
a
=
(
ArtifactDownloadReport
)
iter
.
next
(
)
;
if
(
a
.
getLocalFile
(
)
!=
null
)
{
base
=
getBaseDir
(
base
,
a
.
getLocalFile
(
)
)
;
}
}
if
(
base
==
null
)
{
fileset
.
setDir
(
new
File
(
"."
)
)
;
NameEntry
ne
=
fileset
.
createExclude
(
)
;
ne
.
setName
(
"**/*"
)
;
}
else
{
fileset
.
setDir
(
base
)
;
for
(
Iterator
iter
=
paths
.
iterator
(
)
;
iter
.
hasNext
(
)
;
)
{
ArtifactDownloadReport
a
=
(
ArtifactDownloadReport
)
iter
.
next
(
)
;
if
(
a
.
getLocalFile
(
)
!=
null
)
{
NameEntry
ne
=
fileset
.
createInclude
(
)
;
ne
.
setName
(
getPath
(
base
,
a
.
getLocalFile
(
)
)
)
;
}
}
}
}
catch
(
Exception
ex
)
{
throw
new
BuildException
(
"impossible to build ivy cache fileset: "
+
ex
,
ex
)
;
}
}
private
String
getPath
(
File
base
,
File
file
)
{
String
absoluteBasePath
=
base
.
getAbsolutePath
(
)
;
int
beginIndex
=
absoluteBasePath
.
length
(
)
;
if
(
!
absoluteBasePath
.
endsWith
(
File
.
separator
)
)
{
beginIndex
++
;
}
return
file
.
getAbsolutePath
(
)
.
substring
(
beginIndex
)
;
}
File
getBaseDir
(
File
base
,
File
file
)
{
if
(
base
==
null
)
{
return
file
.
getParentFile
(
)
.
getAbsoluteFile
(
)
;
}
else
{
Iterator
bases
=
getParents
(
base
)
.
iterator
(
)
;
Iterator
fileParents
=
getParents
(
file
.
getAbsoluteFile
(
)
)
.
iterator
(
)
;
File
result
=
null
;
while
(
bases
.
hasNext
(
)
&&
fileParents
.
hasNext
(
)
)
{
File
next
=
(
File
)
bases
.
next
(
)
;
if
(
next
.
equals
(
fileParents
.
next
(
)
)
)
{
result
=
next
;
}
else
{
break
;
}
}
return
result
;
}
}
private
LinkedList
getParents
(
File
file
)
{
LinkedList
r
=
new
LinkedList
(
)
;
while
(
file
!=
null
)
{
r
.
addFirst
(
file
)
;
file
=
file
.
getParentFile
(
)
;
}
return
r
;
}
}
