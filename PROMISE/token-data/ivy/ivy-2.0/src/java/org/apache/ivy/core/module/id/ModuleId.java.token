package
org
.
apache
.
ivy
.
core
.
module
.
id
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Map
;
import
java
.
util
.
WeakHashMap
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
import
org
.
apache
.
ivy
.
core
.
IvyPatternHelper
;
public
class
ModuleId
implements
Comparable
{
static
final
String
ENCODE_SEPARATOR
=
":#@#:"
;
private
static
final
Map
CACHE
=
new
WeakHashMap
(
)
;
public
static
ModuleId
newInstance
(
String
org
,
String
name
)
{
return
intern
(
new
ModuleId
(
org
,
name
)
)
;
}
public
static
ModuleId
intern
(
ModuleId
moduleId
)
{
ModuleId
r
=
(
ModuleId
)
CACHE
.
get
(
moduleId
)
;
if
(
r
==
null
)
{
r
=
moduleId
;
CACHE
.
put
(
r
,
r
)
;
}
return
r
;
}
private
String
organisation
;
private
String
name
;
private
int
hash
;
private
Map
attributes
=
new
HashMap
(
)
;
public
ModuleId
(
String
organisation
,
String
name
)
{
if
(
name
==
null
)
{
throw
new
IllegalArgumentException
(
"null name not allowed"
)
;
}
this
.
organisation
=
organisation
;
this
.
name
=
name
;
attributes
.
put
(
IvyPatternHelper
.
ORGANISATION_KEY
,
organisation
)
;
attributes
.
put
(
IvyPatternHelper
.
MODULE_KEY
,
name
)
;
}
public
String
getName
(
)
{
return
name
;
}
public
String
getOrganisation
(
)
{
return
organisation
;
}
public
boolean
equals
(
Object
obj
)
{
if
(
!
(
obj
instanceof
ModuleId
)
)
{
return
false
;
}
ModuleId
other
=
(
ModuleId
)
obj
;
if
(
other
.
organisation
==
null
)
{
return
organisation
==
null
&&
other
.
name
.
equals
(
name
)
;
}
else
{
return
other
.
organisation
.
equals
(
organisation
)
&&
other
.
name
.
equals
(
name
)
;
}
}
public
int
hashCode
(
)
{
if
(
hash
==
0
)
{
hash
=
31
;
hash
=
hash
*
13
+
(
organisation
==
null
?
0
:
organisation
.
hashCode
(
)
)
;
hash
=
hash
*
13
+
name
.
hashCode
(
)
;
}
return
hash
;
}
public
String
toString
(
)
{
return
organisation
+
"#"
+
name
;
}
public
int
compareTo
(
Object
obj
)
{
ModuleId
that
=
(
ModuleId
)
obj
;
int
result
=
organisation
.
compareTo
(
that
.
organisation
)
;
if
(
result
==
0
)
{
result
=
name
.
compareTo
(
that
.
name
)
;
}
return
result
;
}
public
String
encodeToString
(
)
{
return
getOrganisation
(
)
+
ENCODE_SEPARATOR
+
getName
(
)
;
}
public
Map
getAttributes
(
)
{
return
attributes
;
}
public
static
ModuleId
decode
(
String
encoded
)
{
String
[
]
parts
=
encoded
.
split
(
ENCODE_SEPARATOR
)
;
if
(
parts
.
length
!=
2
)
{
throw
new
IllegalArgumentException
(
"badly encoded module id: '"
+
encoded
+
"'"
)
;
}
return
new
ModuleId
(
parts
[
0
]
,
parts
[
1
]
)
;
}
public
static
final
Pattern
MID_PATTERN
=
Pattern
.
compile
(
"("
+
ModuleRevisionId
.
STRICT_CHARS_PATTERN
+
"*)"
+
"#("
+
ModuleRevisionId
.
STRICT_CHARS_PATTERN
+
"+)"
)
;
public
static
ModuleId
parse
(
String
mid
)
{
Matcher
m
=
MID_PATTERN
.
matcher
(
mid
)
;
if
(
!
m
.
matches
(
)
)
{
throw
new
IllegalArgumentException
(
"module text representation do not match expected pattern."
+
" given mid='"
+
mid
+
"' expected form="
+
MID_PATTERN
.
pattern
(
)
)
;
}
return
newInstance
(
m
.
group
(
1
)
,
m
.
group
(
2
)
)
;
}
}
