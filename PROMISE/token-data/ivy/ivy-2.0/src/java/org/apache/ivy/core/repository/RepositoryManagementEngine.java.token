package
org
.
apache
.
ivy
.
core
.
repository
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Comparator
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Map
;
import
java
.
util
.
TreeSet
;
import
org
.
apache
.
ivy
.
core
.
module
.
descriptor
.
DefaultDependencyDescriptor
;
import
org
.
apache
.
ivy
.
core
.
module
.
descriptor
.
DependencyDescriptor
;
import
org
.
apache
.
ivy
.
core
.
module
.
descriptor
.
ModuleDescriptor
;
import
org
.
apache
.
ivy
.
core
.
module
.
id
.
ModuleRevisionId
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
ResolveData
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
ResolveEngine
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
ResolveOptions
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
ResolvedModuleRevision
;
import
org
.
apache
.
ivy
.
core
.
search
.
SearchEngine
;
import
org
.
apache
.
ivy
.
plugins
.
latest
.
ArtifactInfo
;
import
org
.
apache
.
ivy
.
plugins
.
matcher
.
PatternMatcher
;
import
org
.
apache
.
ivy
.
plugins
.
matcher
.
RegexpPatternMatcher
;
import
org
.
apache
.
ivy
.
plugins
.
version
.
VersionMatcher
;
import
org
.
apache
.
ivy
.
util
.
MemoryUtil
;
import
org
.
apache
.
ivy
.
util
.
Message
;
public
class
RepositoryManagementEngine
{
private
static
final
double
THOUSAND
=
1000.0
;
private
static
final
int
KILO
=
1024
;
private
boolean
loaded
;
private
Map
revisions
=
new
HashMap
(
)
;
private
Map
errors
=
new
HashMap
(
)
;
private
Map
modules
=
new
HashMap
(
)
;
private
boolean
analyzed
;
private
Map
cache
=
new
HashMap
(
)
;
private
Map
dependers
=
new
HashMap
(
)
;
private
SearchEngine
searchEngine
;
private
ResolveEngine
resolveEngine
;
private
RepositoryManagementEngineSettings
settings
;
public
RepositoryManagementEngine
(
RepositoryManagementEngineSettings
settings
,
SearchEngine
searchEngine
,
ResolveEngine
resolveEngine
)
{
this
.
settings
=
settings
;
this
.
searchEngine
=
searchEngine
;
this
.
resolveEngine
=
resolveEngine
;
}
public
void
load
(
)
{
long
startingMemoryUse
=
0
;
if
(
settings
.
dumpMemoryUsage
(
)
)
{
startingMemoryUse
=
MemoryUtil
.
getUsedMemory
(
)
;
}
long
startTime
=
System
.
currentTimeMillis
(
)
;
Message
.
rawinfo
(
"searching modules... "
)
;
ModuleRevisionId
[
]
mrids
=
searchModules
(
)
;
Message
.
info
(
"loading repository metadata..."
)
;
for
(
int
i
=
0
;
i
<
mrids
.
length
;
i
++
)
{
try
{
loadModuleRevision
(
mrids
[
i
]
)
;
}
catch
(
Exception
e
)
{
errors
.
put
(
mrids
[
i
]
,
e
.
getMessage
(
)
)
;
}
}
long
endTime
=
System
.
currentTimeMillis
(
)
;
Message
.
info
(
"\nrepository loaded: "
+
modules
.
size
(
)
+
" modules; "
+
revisions
.
size
(
)
+
" revisions; "
+
(
settings
.
dumpMemoryUsage
(
)
?
(
MemoryUtil
.
getUsedMemory
(
)
-
startingMemoryUse
)
/
KILO
+
"kB; "
:
""
)
+
(
endTime
-
startTime
)
/
THOUSAND
+
"s"
)
;
loaded
=
true
;
}
public
void
analyze
(
)
{
ensureLoaded
(
)
;
Message
.
info
(
"\nanalyzing dependencies..."
)
;
for
(
Iterator
iterator
=
revisions
.
values
(
)
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
ModuleDescriptor
md
=
(
ModuleDescriptor
)
iterator
.
next
(
)
;
DependencyDescriptor
[
]
dds
=
md
.
getDependencies
(
)
;
for
(
int
i
=
0
;
i
<
dds
.
length
;
i
++
)
{
ModuleRevisionId
dep
=
getDependency
(
dds
[
i
]
)
;
if
(
dep
==
null
)
{
Message
.
warn
(
"inconsistent repository: declared dependency not found: "
+
dds
[
i
]
)
;
}
else
{
getDependers
(
dep
)
.
add
(
md
.
getModuleRevisionId
(
)
)
;
}
}
Message
.
progress
(
)
;
}
analyzed
=
true
;
}
public
int
getRevisionsNumber
(
)
{
ensureLoaded
(
)
;
return
revisions
.
size
(
)
;
}
public
int
getModuleIdsNumber
(
)
{
ensureLoaded
(
)
;
return
modules
.
size
(
)
;
}
public
Collection
getOrphans
(
)
{
ensureAnalyzed
(
)
;
Collection
orphans
=
new
HashSet
(
revisions
.
keySet
(
)
)
;
orphans
.
removeAll
(
dependers
.
keySet
(
)
)
;
return
orphans
;
}
private
ModuleRevisionId
[
]
searchModules
(
)
{
ModuleRevisionId
[
]
mrids
=
searchEngine
.
listModules
(
ModuleRevisionId
.
newInstance
(
PatternMatcher
.
ANY_EXPRESSION
,
PatternMatcher
.
ANY_EXPRESSION
,
PatternMatcher
.
ANY_EXPRESSION
,
PatternMatcher
.
ANY_EXPRESSION
)
,
RegexpPatternMatcher
.
INSTANCE
)
;
return
mrids
;
}
private
ModuleRevisionId
getDependency
(
DependencyDescriptor
dd
)
{
ModuleRevisionId
askedMrid
=
dd
.
getDependencyRevisionId
(
)
;
VersionMatcher
vmatcher
=
settings
.
getVersionMatcher
(
)
;
if
(
vmatcher
.
isDynamic
(
askedMrid
)
)
{
ModuleRevisionId
mrid
=
(
ModuleRevisionId
)
cache
.
get
(
askedMrid
)
;
if
(
mrid
==
null
)
{
Collection
revs
=
getAllRevisions
(
askedMrid
)
;
for
(
Iterator
iterator
=
revs
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
ModuleDescriptor
md
=
(
ModuleDescriptor
)
iterator
.
next
(
)
;
if
(
vmatcher
.
needModuleDescriptor
(
askedMrid
,
md
.
getResolvedModuleRevisionId
(
)
)
)
{
if
(
vmatcher
.
accept
(
askedMrid
,
md
)
)
{
mrid
=
md
.
getResolvedModuleRevisionId
(
)
;
break
;
}
}
else
{
if
(
vmatcher
.
accept
(
askedMrid
,
md
.
getResolvedModuleRevisionId
(
)
)
)
{
mrid
=
md
.
getResolvedModuleRevisionId
(
)
;
break
;
}
}
}
if
(
mrid
==
null
)
{
return
null
;
}
else
{
cache
.
put
(
askedMrid
,
mrid
)
;
}
}
return
mrid
;
}
else
{
return
askedMrid
;
}
}
private
Collection
getDependers
(
ModuleRevisionId
id
)
{
Collection
depders
=
(
Collection
)
dependers
.
get
(
id
)
;
if
(
depders
==
null
)
{
depders
=
new
ArrayList
(
)
;
dependers
.
put
(
id
,
depders
)
;
}
return
depders
;
}
private
void
loadModuleRevision
(
ModuleRevisionId
mrid
)
throws
Exception
{
ResolvedModuleRevision
module
=
settings
.
getResolver
(
mrid
)
.
getDependency
(
new
DefaultDependencyDescriptor
(
mrid
,
false
)
,
newResolveData
(
)
)
;
if
(
module
==
null
)
{
Message
.
warn
(
"module not found while listed: "
+
mrid
)
;
}
else
{
revisions
.
put
(
module
.
getId
(
)
,
module
.
getDescriptor
(
)
)
;
getAllRevisions
(
module
.
getId
(
)
)
.
add
(
module
.
getDescriptor
(
)
)
;
}
Message
.
progress
(
)
;
}
private
Collection
getAllRevisions
(
ModuleRevisionId
id
)
{
Collection
revisions
=
(
Collection
)
modules
.
get
(
id
.
getModuleId
(
)
)
;
if
(
revisions
==
null
)
{
revisions
=
new
TreeSet
(
new
Comparator
(
)
{
public
int
compare
(
Object
o1
,
Object
o2
)
{
ModuleDescriptor
md1
=
(
ModuleDescriptor
)
o1
;
ModuleDescriptor
md2
=
(
ModuleDescriptor
)
o2
;
return
settings
.
getDefaultLatestStrategy
(
)
.
sort
(
new
ArtifactInfo
[
]
{
md1
,
md2
}
)
.
get
(
0
)
.
equals
(
md1
)
?
1
:
-
1
;
}
}
)
;
modules
.
put
(
id
.
getModuleId
(
)
,
revisions
)
;
}
return
revisions
;
}
private
ResolveData
newResolveData
(
)
{
return
new
ResolveData
(
resolveEngine
,
new
ResolveOptions
(
)
)
;
}
private
void
ensureAnalyzed
(
)
{
if
(
!
analyzed
)
{
throw
new
IllegalStateException
(
"repository must have been analyzed to perform this method"
)
;
}
}
private
void
ensureLoaded
(
)
{
if
(
!
loaded
)
{
throw
new
IllegalStateException
(
"repository must have be loaded to perform this method"
)
;
}
}
}
