package
org
.
apache
.
ivy
.
plugins
.
conflict
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
LinkedHashSet
;
import
java
.
util
.
Stack
;
import
org
.
apache
.
ivy
.
core
.
IvyContext
;
import
org
.
apache
.
ivy
.
core
.
module
.
descriptor
.
DependencyDescriptor
;
import
org
.
apache
.
ivy
.
core
.
module
.
id
.
ModuleRevisionId
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
IvyNode
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
IvyNodeBlacklist
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
ResolveData
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
RestartResolveProcess
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
IvyNodeCallers
.
Caller
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
IvyNodeEviction
.
EvictionData
;
import
org
.
apache
.
ivy
.
core
.
settings
.
IvySettings
;
import
org
.
apache
.
ivy
.
plugins
.
latest
.
LatestStrategy
;
import
org
.
apache
.
ivy
.
plugins
.
version
.
VersionMatcher
;
import
org
.
apache
.
ivy
.
util
.
Message
;
public
class
LatestCompatibleConflictManager
extends
LatestConflictManager
{
public
LatestCompatibleConflictManager
(
)
{
}
public
LatestCompatibleConflictManager
(
String
name
,
LatestStrategy
strategy
)
{
super
(
name
,
strategy
)
;
}
public
Collection
resolveConflicts
(
IvyNode
parent
,
Collection
conflicts
)
{
if
(
conflicts
.
size
(
)
<
2
)
{
return
conflicts
;
}
VersionMatcher
versionMatcher
=
getSettings
(
)
.
getVersionMatcher
(
)
;
Iterator
iter
=
conflicts
.
iterator
(
)
;
IvyNode
node
=
(
IvyNode
)
iter
.
next
(
)
;
ModuleRevisionId
mrid
=
node
.
getResolvedId
(
)
;
if
(
versionMatcher
.
isDynamic
(
mrid
)
)
{
while
(
iter
.
hasNext
(
)
)
{
IvyNode
other
=
(
IvyNode
)
iter
.
next
(
)
;
if
(
versionMatcher
.
isDynamic
(
other
.
getResolvedId
(
)
)
)
{
return
null
;
}
else
if
(
!
versionMatcher
.
accept
(
mrid
,
other
.
getResolvedId
(
)
)
)
{
if
(
!
handleIncompatibleConflict
(
parent
,
conflicts
,
node
,
other
)
)
{
return
null
;
}
}
}
if
(
conflicts
.
size
(
)
==
2
)
{
Iterator
it
=
conflicts
.
iterator
(
)
;
it
.
next
(
)
;
return
Collections
.
singleton
(
it
.
next
(
)
)
;
}
Collection
newConflicts
=
new
LinkedHashSet
(
conflicts
)
;
newConflicts
.
remove
(
node
)
;
return
super
.
resolveConflicts
(
parent
,
newConflicts
)
;
}
else
{
while
(
iter
.
hasNext
(
)
)
{
IvyNode
other
=
(
IvyNode
)
iter
.
next
(
)
;
if
(
!
versionMatcher
.
accept
(
other
.
getResolvedId
(
)
,
mrid
)
)
{
if
(
!
handleIncompatibleConflict
(
parent
,
conflicts
,
node
,
other
)
)
{
return
null
;
}
}
}
return
Collections
.
singleton
(
node
)
;
}
}
private
boolean
handleIncompatibleConflict
(
IvyNode
parent
,
Collection
conflicts
,
IvyNode
node
,
IvyNode
other
)
{
try
{
IvyNodeArtifactInfo
latest
=
(
IvyNodeArtifactInfo
)
getStrategy
(
)
.
findLatest
(
toArtifactInfo
(
Arrays
.
asList
(
new
IvyNode
[
]
{
node
,
other
}
)
)
,
null
)
;
if
(
latest
!=
null
)
{
IvyNode
latestNode
=
latest
.
getNode
(
)
;
IvyNode
oldestNode
=
latestNode
==
node
?
other
:
node
;
blackListIncompatibleCallerAndRestartResolveIfPossible
(
getSettings
(
)
,
parent
,
oldestNode
,
latestNode
)
;
blackListIncompatibleCallerAndRestartResolveIfPossible
(
getSettings
(
)
,
parent
,
latestNode
,
oldestNode
)
;
handleUnsolvableConflict
(
parent
,
conflicts
,
node
,
other
)
;
return
true
;
}
else
{
return
false
;
}
}
catch
(
NoConflictResolvedYetException
ex
)
{
return
false
;
}
}
private
void
blackListIncompatibleCallerAndRestartResolveIfPossible
(
IvySettings
settings
,
IvyNode
parent
,
IvyNode
selected
,
IvyNode
evicted
)
{
Stack
callerStack
=
new
Stack
(
)
;
callerStack
.
push
(
evicted
)
;
final
Collection
toBlacklist
=
blackListIncompatibleCaller
(
settings
.
getVersionMatcher
(
)
,
parent
,
selected
,
evicted
,
callerStack
)
;
if
(
toBlacklist
!=
null
)
{
final
StringBuffer
blacklisted
=
new
StringBuffer
(
)
;
for
(
Iterator
iterator
=
toBlacklist
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
IvyNodeBlacklist
blacklist
=
(
IvyNodeBlacklist
)
iterator
.
next
(
)
;
blacklist
.
getBlacklistedNode
(
)
.
blacklist
(
blacklist
)
;
blacklisted
.
append
(
blacklist
.
getBlacklistedNode
(
)
)
;
if
(
iterator
.
hasNext
(
)
)
{
blacklisted
.
append
(
" "
)
;
}
}
String
rootModuleConf
=
parent
.
getData
(
)
.
getReport
(
)
.
getConfiguration
(
)
;
evicted
.
markEvicted
(
new
EvictionData
(
rootModuleConf
,
parent
,
this
,
Collections
.
singleton
(
selected
)
,
"with blacklisting of "
+
blacklisted
)
)
;
if
(
settings
.
debugConflictResolution
(
)
)
{
Message
.
debug
(
"evicting "
+
evicted
+
" by "
+
evicted
.
getEvictedData
(
rootModuleConf
)
)
;
}
throw
new
RestartResolveProcess
(
"trying to handle incompatibilities between "
+
selected
+
" and "
+
evicted
)
;
}
}
private
Collection
blackListIncompatibleCaller
(
VersionMatcher
versionMatcher
,
IvyNode
conflictParent
,
IvyNode
selectedNode
,
IvyNode
evictedNode
,
Stack
callerStack
)
{
Collection
blacklisted
=
new
ArrayList
(
)
;
IvyNode
node
=
(
IvyNode
)
callerStack
.
peek
(
)
;
String
rootModuleConf
=
conflictParent
.
getData
(
)
.
getReport
(
)
.
getConfiguration
(
)
;
Caller
[
]
callers
=
node
.
getCallers
(
rootModuleConf
)
;
for
(
int
i
=
0
;
i
<
callers
.
length
;
i
++
)
{
IvyNode
callerNode
=
node
.
findNode
(
callers
[
i
]
.
getModuleRevisionId
(
)
)
;
if
(
callerNode
.
isBlacklisted
(
rootModuleConf
)
)
{
continue
;
}
if
(
versionMatcher
.
isDynamic
(
callers
[
i
]
.
getAskedDependencyId
(
node
.
getData
(
)
)
)
)
{
blacklisted
.
add
(
new
IvyNodeBlacklist
(
conflictParent
,
selectedNode
,
evictedNode
,
node
,
rootModuleConf
)
)
;
}
else
{
if
(
callerStack
.
subList
(
0
,
callerStack
.
size
(
)
-
1
)
.
contains
(
node
)
)
{
}
else
{
if
(
callerNode
==
null
)
{
return
null
;
}
callerStack
.
push
(
callerNode
)
;
Collection
sub
=
blackListIncompatibleCaller
(
versionMatcher
,
conflictParent
,
selectedNode
,
evictedNode
,
callerStack
)
;
callerStack
.
pop
(
)
;
if
(
sub
==
null
)
{
return
null
;
}
else
{
blacklisted
.
addAll
(
sub
)
;
}
}
}
}
if
(
blacklisted
.
isEmpty
(
)
&&
!
callerStack
.
subList
(
0
,
callerStack
.
size
(
)
-
1
)
.
contains
(
node
)
)
{
return
null
;
}
return
blacklisted
;
}
protected
void
handleUnsolvableConflict
(
IvyNode
parent
,
Collection
conflicts
,
IvyNode
node1
,
IvyNode
node2
)
{
throw
new
StrictConflictException
(
node1
,
node2
)
;
}
public
void
handleAllBlacklistedRevisions
(
DependencyDescriptor
dd
,
Collection
foundBlacklisted
)
{
ResolveData
resolveData
=
IvyContext
.
getContext
(
)
.
getResolveData
(
)
;
Collection
blacklisted
=
new
HashSet
(
)
;
for
(
Iterator
iterator
=
foundBlacklisted
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
ModuleRevisionId
mrid
=
(
ModuleRevisionId
)
iterator
.
next
(
)
;
blacklisted
.
add
(
resolveData
.
getNode
(
mrid
)
)
;
}
for
(
Iterator
iterator
=
blacklisted
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
IvyNode
node
=
(
IvyNode
)
iterator
.
next
(
)
;
IvyNodeBlacklist
bdata
=
node
.
getBlacklistData
(
resolveData
.
getReport
(
)
.
getConfiguration
(
)
)
;
handleUnsolvableConflict
(
bdata
.
getConflictParent
(
)
,
Arrays
.
asList
(
new
Object
[
]
{
bdata
.
getEvictedNode
(
)
,
bdata
.
getSelectedNode
(
)
}
)
,
bdata
.
getEvictedNode
(
)
,
bdata
.
getSelectedNode
(
)
)
;
}
}
public
String
toString
(
)
{
return
getName
(
)
;
}
}
