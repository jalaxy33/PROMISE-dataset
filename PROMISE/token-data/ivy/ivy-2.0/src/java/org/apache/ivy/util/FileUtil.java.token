package
org
.
apache
.
ivy
.
util
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
PrintWriter
;
import
java
.
io
.
StringWriter
;
import
java
.
net
.
URL
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Collections
;
import
java
.
util
.
List
;
import
org
.
apache
.
ivy
.
util
.
url
.
URLHandlerRegistry
;
public
final
class
FileUtil
{
private
FileUtil
(
)
{
}
private
static
final
int
BUFFER_SIZE
=
64
*
1024
;
private
static
final
byte
[
]
EMPTY_BUFFER
=
new
byte
[
0
]
;
public
static
void
symlink
(
File
src
,
File
dest
,
CopyProgressListener
l
,
boolean
overwrite
)
throws
IOException
{
try
{
if
(
dest
.
exists
(
)
)
{
if
(
!
dest
.
isFile
(
)
)
{
throw
new
IOException
(
"impossible to copy: destination is not a file: "
+
dest
)
;
}
if
(
!
overwrite
)
{
Message
.
verbose
(
dest
+
" already exists, nothing done"
)
;
return
;
}
}
if
(
dest
.
getParentFile
(
)
!=
null
)
{
dest
.
getParentFile
(
)
.
mkdirs
(
)
;
}
Runtime
runtime
=
Runtime
.
getRuntime
(
)
;
Message
.
verbose
(
"executing 'ln -s -f "
+
src
.
getAbsolutePath
(
)
+
" "
+
dest
.
getPath
(
)
+
"'"
)
;
Process
process
=
runtime
.
exec
(
new
String
[
]
{
"ln"
,
"-s"
,
"-f"
,
src
.
getAbsolutePath
(
)
,
dest
.
getPath
(
)
}
)
;
if
(
process
.
waitFor
(
)
!=
0
)
{
InputStream
errorStream
=
process
.
getErrorStream
(
)
;
InputStreamReader
isr
=
new
InputStreamReader
(
errorStream
)
;
BufferedReader
br
=
new
BufferedReader
(
isr
)
;
StringBuffer
error
=
new
StringBuffer
(
)
;
String
line
;
while
(
(
line
=
br
.
readLine
(
)
)
!=
null
)
{
error
.
append
(
line
)
;
error
.
append
(
'\n'
)
;
}
throw
new
IOException
(
"error symlinking "
+
src
+
" to "
+
dest
+
":\n"
+
error
)
;
}
if
(
!
dest
.
exists
(
)
)
{
throw
new
IOException
(
"error symlinking "
+
dest
+
" doesn't exists"
)
;
}
}
catch
(
IOException
x
)
{
Message
.
verbose
(
"symlink failed; falling back to copy"
)
;
StringWriter
buffer
=
new
StringWriter
(
)
;
x
.
printStackTrace
(
new
PrintWriter
(
buffer
)
)
;
Message
.
debug
(
buffer
.
toString
(
)
)
;
copy
(
src
,
dest
,
l
,
overwrite
)
;
}
catch
(
InterruptedException
x
)
{
Thread
.
currentThread
(
)
.
interrupt
(
)
;
}
}
public
static
boolean
copy
(
File
src
,
File
dest
,
CopyProgressListener
l
)
throws
IOException
{
return
copy
(
src
,
dest
,
l
,
false
)
;
}
public
static
boolean
copy
(
File
src
,
File
dest
,
CopyProgressListener
l
,
boolean
overwrite
)
throws
IOException
{
if
(
dest
.
exists
(
)
)
{
if
(
!
dest
.
isFile
(
)
)
{
throw
new
IOException
(
"impossible to copy: destination is not a file: "
+
dest
)
;
}
if
(
overwrite
)
{
if
(
!
dest
.
canWrite
(
)
)
{
dest
.
delete
(
)
;
}
}
else
{
Message
.
verbose
(
dest
+
" already exists, nothing done"
)
;
return
false
;
}
}
copy
(
new
FileInputStream
(
src
)
,
dest
,
l
)
;
long
srcLen
=
src
.
length
(
)
;
long
destLen
=
dest
.
length
(
)
;
if
(
srcLen
!=
destLen
)
{
dest
.
delete
(
)
;
throw
new
IOException
(
"size of source file "
+
src
.
toString
(
)
+
"("
+
srcLen
+
") differs from size of dest file "
+
dest
.
toString
(
)
+
"("
+
destLen
+
") - please retry"
)
;
}
dest
.
setLastModified
(
src
.
lastModified
(
)
)
;
return
true
;
}
public
static
void
copy
(
URL
src
,
File
dest
,
CopyProgressListener
l
)
throws
IOException
{
URLHandlerRegistry
.
getDefault
(
)
.
download
(
src
,
dest
,
l
)
;
}
public
static
void
copy
(
File
src
,
URL
dest
,
CopyProgressListener
l
)
throws
IOException
{
URLHandlerRegistry
.
getDefault
(
)
.
upload
(
src
,
dest
,
l
)
;
}
public
static
void
copy
(
InputStream
src
,
File
dest
,
CopyProgressListener
l
)
throws
IOException
{
if
(
dest
.
getParentFile
(
)
!=
null
)
{
dest
.
getParentFile
(
)
.
mkdirs
(
)
;
}
copy
(
src
,
new
FileOutputStream
(
dest
)
,
l
)
;
}
public
static
void
copy
(
InputStream
src
,
OutputStream
dest
,
CopyProgressListener
l
)
throws
IOException
{
CopyProgressEvent
evt
=
null
;
if
(
l
!=
null
)
{
evt
=
new
CopyProgressEvent
(
)
;
}
try
{
byte
[
]
buffer
=
new
byte
[
BUFFER_SIZE
]
;
int
c
;
long
total
=
0
;
if
(
l
!=
null
)
{
l
.
start
(
evt
)
;
}
while
(
(
c
=
src
.
read
(
buffer
)
)
!=
-
1
)
{
if
(
Thread
.
currentThread
(
)
.
isInterrupted
(
)
)
{
throw
new
IOException
(
"transfer interrupted"
)
;
}
dest
.
write
(
buffer
,
0
,
c
)
;
total
+=
c
;
if
(
l
!=
null
)
{
l
.
progress
(
evt
.
update
(
buffer
,
c
,
total
)
)
;
}
}
if
(
l
!=
null
)
{
evt
.
update
(
EMPTY_BUFFER
,
0
,
total
)
;
}
try
{
dest
.
flush
(
)
;
}
catch
(
IOException
ex
)
{
}
src
.
close
(
)
;
dest
.
close
(
)
;
}
finally
{
try
{
src
.
close
(
)
;
}
catch
(
IOException
ex
)
{
}
try
{
dest
.
close
(
)
;
}
catch
(
IOException
ex
)
{
}
}
if
(
l
!=
null
)
{
l
.
end
(
evt
)
;
}
}
public
static
String
readEntirely
(
BufferedReader
in
)
throws
IOException
{
try
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
String
line
=
in
.
readLine
(
)
;
while
(
line
!=
null
)
{
buf
.
append
(
line
+
"\n"
)
;
line
=
in
.
readLine
(
)
;
}
return
buf
.
toString
(
)
;
}
finally
{
in
.
close
(
)
;
}
}
public
static
String
readEntirely
(
File
f
)
throws
IOException
{
return
readEntirely
(
new
FileInputStream
(
f
)
)
;
}
public
static
String
readEntirely
(
InputStream
is
)
throws
IOException
{
try
{
StringBuffer
sb
=
new
StringBuffer
(
)
;
byte
[
]
buffer
=
new
byte
[
BUFFER_SIZE
]
;
int
c
;
while
(
(
c
=
is
.
read
(
buffer
)
)
!=
-
1
)
{
sb
.
append
(
new
String
(
buffer
,
0
,
c
)
)
;
}
return
sb
.
toString
(
)
;
}
finally
{
is
.
close
(
)
;
}
}
public
static
String
concat
(
String
dir
,
String
file
)
{
return
dir
+
"/"
+
file
;
}
public
static
boolean
forceDelete
(
File
file
)
{
if
(
!
file
.
exists
(
)
)
{
return
true
;
}
if
(
file
.
isDirectory
(
)
)
{
File
[
]
files
=
file
.
listFiles
(
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
if
(
!
forceDelete
(
files
[
i
]
)
)
{
return
false
;
}
}
}
return
file
.
delete
(
)
;
}
public
static
List
getPathFiles
(
File
root
,
File
file
)
{
List
ret
=
new
ArrayList
(
)
;
while
(
file
!=
null
&&
!
file
.
getAbsolutePath
(
)
.
equals
(
root
.
getAbsolutePath
(
)
)
)
{
ret
.
add
(
file
)
;
file
=
file
.
getParentFile
(
)
;
}
if
(
root
!=
null
)
{
ret
.
add
(
root
)
;
}
Collections
.
reverse
(
ret
)
;
return
ret
;
}
public
static
Collection
listAll
(
File
dir
,
Collection
ignore
)
{
return
listAll
(
dir
,
new
ArrayList
(
)
,
ignore
)
;
}
private
static
Collection
listAll
(
File
file
,
Collection
list
,
Collection
ignore
)
{
if
(
ignore
.
contains
(
file
.
getName
(
)
)
)
{
return
list
;
}
if
(
file
.
exists
(
)
)
{
list
.
add
(
file
)
;
}
if
(
file
.
isDirectory
(
)
)
{
File
[
]
files
=
file
.
listFiles
(
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
listAll
(
files
[
i
]
,
list
,
ignore
)
;
}
}
return
list
;
}
public
static
File
resolveFile
(
File
file
,
String
filename
)
{
File
f
=
new
File
(
filename
)
;
if
(
f
.
isAbsolute
(
)
)
{
return
f
;
}
return
new
File
(
file
,
filename
)
;
}
}
