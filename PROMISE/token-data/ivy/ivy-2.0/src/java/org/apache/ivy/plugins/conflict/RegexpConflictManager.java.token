package
org
.
apache
.
ivy
.
plugins
.
conflict
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
regex
.
Matcher
;
import
java
.
util
.
regex
.
Pattern
;
import
org
.
apache
.
ivy
.
core
.
resolve
.
IvyNode
;
import
org
.
apache
.
ivy
.
util
.
Message
;
public
class
RegexpConflictManager
extends
AbstractConflictManager
{
private
Pattern
pattern
=
Pattern
.
compile
(
"(.*)"
)
;
private
boolean
mIgnoreNonMatching
;
public
RegexpConflictManager
(
)
{
}
public
void
setRegexp
(
String
regexp
)
{
pattern
=
Pattern
.
compile
(
regexp
)
;
Matcher
matcher
=
pattern
.
matcher
(
"abcdef"
)
;
if
(
matcher
.
groupCount
(
)
!=
1
)
{
String
message
=
"Pattern does not contain ONE (capturing group): '"
+
pattern
+
"'"
;
Message
.
error
(
message
)
;
throw
new
IllegalArgumentException
(
message
)
;
}
}
public
void
setIgnoreNonMatching
(
boolean
ignoreNonMatching
)
{
mIgnoreNonMatching
=
ignoreNonMatching
;
}
public
Collection
resolveConflicts
(
IvyNode
parent
,
Collection
conflicts
)
{
IvyNode
lastNode
=
null
;
for
(
Iterator
iter
=
conflicts
.
iterator
(
)
;
iter
.
hasNext
(
)
;
)
{
IvyNode
node
=
(
IvyNode
)
iter
.
next
(
)
;
if
(
lastNode
!=
null
&&
!
matchEquals
(
node
,
lastNode
)
)
{
String
msg
=
lastNode
+
":"
+
getMatch
(
lastNode
)
+
" (needed by "
+
Arrays
.
asList
(
lastNode
.
getAllRealCallers
(
)
)
+
") conflicts with "
+
node
+
":"
+
getMatch
(
node
)
+
" (needed by "
+
Arrays
.
asList
(
node
.
getAllRealCallers
(
)
)
+
")"
;
throw
new
StrictConflictException
(
msg
)
;
}
if
(
lastNode
==
null
||
nodeIsGreater
(
node
,
lastNode
)
)
{
lastNode
=
node
;
}
}
return
Collections
.
singleton
(
lastNode
)
;
}
private
boolean
nodeIsGreater
(
IvyNode
node
,
IvyNode
lastNode
)
{
return
getMatch
(
node
)
.
compareTo
(
getMatch
(
lastNode
)
)
>
0
;
}
private
boolean
matchEquals
(
IvyNode
lastNode
,
IvyNode
node
)
{
return
getMatch
(
lastNode
)
.
equals
(
getMatch
(
node
)
)
;
}
private
String
getMatch
(
IvyNode
node
)
{
String
revision
=
node
.
getId
(
)
.
getRevision
(
)
;
Matcher
matcher
=
pattern
.
matcher
(
revision
)
;
if
(
matcher
.
matches
(
)
)
{
String
match
=
matcher
.
group
(
1
)
;
if
(
match
!=
null
)
{
return
match
;
}
warnOrThrow
(
"First group of pattern: '"
+
pattern
+
"' does not match: "
+
revision
+
" "
+
node
)
;
}
else
{
warnOrThrow
(
"Pattern: '"
+
pattern
+
"' does not match: "
+
revision
+
" "
+
node
)
;
}
return
revision
;
}
private
void
warnOrThrow
(
String
message
)
{
if
(
mIgnoreNonMatching
)
{
Message
.
warn
(
message
)
;
}
else
{
throw
new
StrictConflictException
(
message
)
;
}
}
}
