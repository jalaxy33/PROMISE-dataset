package
fr
.
jayasoft
.
ivy
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
LinkedHashMap
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
Stack
;
import
fr
.
jayasoft
.
ivy
.
circular
.
CircularDependencyException
;
import
fr
.
jayasoft
.
ivy
.
circular
.
CircularDependencyHelper
;
import
fr
.
jayasoft
.
ivy
.
util
.
Message
;
import
fr
.
jayasoft
.
ivy
.
version
.
VersionMatcher
;
class
ModuleDescriptorSorter
{
public
static
List
sortNodes
(
VersionMatcher
matcher
,
Collection
nodes
)
{
Map
dependenciesMap
=
new
LinkedHashMap
(
)
;
List
nulls
=
new
ArrayList
(
)
;
for
(
Iterator
iter
=
nodes
.
iterator
(
)
;
iter
.
hasNext
(
)
;
)
{
IvyNode
node
=
(
IvyNode
)
iter
.
next
(
)
;
if
(
node
.
getDescriptor
(
)
==
null
)
{
nulls
.
add
(
node
)
;
}
else
{
List
n
=
(
List
)
dependenciesMap
.
get
(
node
.
getDescriptor
(
)
)
;
if
(
n
==
null
)
{
n
=
new
ArrayList
(
)
;
dependenciesMap
.
put
(
node
.
getDescriptor
(
)
,
n
)
;
}
n
.
add
(
node
)
;
}
}
List
list
=
sortModuleDescriptors
(
matcher
,
dependenciesMap
.
keySet
(
)
)
;
List
ret
=
new
ArrayList
(
(
int
)
(
list
.
size
(
)
*
1.3
+
nulls
.
size
(
)
)
)
;
for
(
int
i
=
0
;
i
<
list
.
size
(
)
;
i
++
)
{
ModuleDescriptor
md
=
(
ModuleDescriptor
)
list
.
get
(
i
)
;
List
n
=
(
List
)
dependenciesMap
.
get
(
md
)
;
ret
.
addAll
(
n
)
;
}
ret
.
addAll
(
0
,
nulls
)
;
return
ret
;
}
public
static
List
sortModuleDescriptors
(
VersionMatcher
matcher
,
Collection
moduleDescriptors
)
throws
CircularDependencyException
{
return
new
ModuleDescriptorSorter
(
moduleDescriptors
)
.
sortModuleDescriptors
(
matcher
)
;
}
private
final
Collection
moduleDescriptors
;
private
final
Iterator
moduleDescriptorsIterator
;
private
final
List
sorted
=
new
LinkedList
(
)
;
public
ModuleDescriptorSorter
(
Collection
moduleDescriptors
)
{
this
.
moduleDescriptors
=
moduleDescriptors
;
moduleDescriptorsIterator
=
new
LinkedList
(
moduleDescriptors
)
.
iterator
(
)
;
}
public
List
sortModuleDescriptors
(
VersionMatcher
matcher
)
throws
CircularDependencyException
{
while
(
moduleDescriptorsIterator
.
hasNext
(
)
)
{
sortModuleDescriptorsHelp
(
matcher
,
(
ModuleDescriptor
)
moduleDescriptorsIterator
.
next
(
)
,
new
Stack
(
)
)
;
}
return
sorted
;
}
private
void
sortModuleDescriptorsHelp
(
VersionMatcher
matcher
,
ModuleDescriptor
current
,
Stack
callStack
)
throws
CircularDependencyException
{
if
(
sorted
.
contains
(
current
)
)
{
return
;
}
if
(
callStack
.
contains
(
current
)
)
{
callStack
.
add
(
current
)
;
Message
.
verbose
(
"circular dependency ignored during sort: "
+
CircularDependencyHelper
.
formatMessage
(
(
ModuleDescriptor
[
]
)
callStack
.
toArray
(
new
ModuleDescriptor
[
callStack
.
size
(
)
]
)
)
)
;
return
;
}
DependencyDescriptor
[
]
descriptors
=
current
.
getDependencies
(
)
;
ModuleDescriptor
moduleDescriptorDependency
=
null
;
for
(
int
i
=
0
;
descriptors
!=
null
&&
i
<
descriptors
.
length
;
i
++
)
{
moduleDescriptorDependency
=
getModuleDescriptorDependency
(
matcher
,
descriptors
[
i
]
)
;
if
(
moduleDescriptorDependency
!=
null
)
{
callStack
.
push
(
current
)
;
sortModuleDescriptorsHelp
(
matcher
,
moduleDescriptorDependency
,
callStack
)
;
callStack
.
pop
(
)
;
}
}
sorted
.
add
(
current
)
;
}
private
ModuleDescriptor
getModuleDescriptorDependency
(
VersionMatcher
matcher
,
DependencyDescriptor
descriptor
)
{
Iterator
i
=
moduleDescriptors
.
iterator
(
)
;
ModuleDescriptor
md
=
null
;
while
(
i
.
hasNext
(
)
)
{
md
=
(
ModuleDescriptor
)
i
.
next
(
)
;
if
(
descriptor
.
getDependencyId
(
)
.
equals
(
md
.
getModuleRevisionId
(
)
.
getModuleId
(
)
)
)
{
if
(
md
.
getResolvedModuleRevisionId
(
)
.
getRevision
(
)
==
null
)
{
return
md
;
}
else
if
(
matcher
.
accept
(
descriptor
.
getDependencyRevisionId
(
)
,
md
)
)
{
return
md
;
}
}
}
return
null
;
}
}
