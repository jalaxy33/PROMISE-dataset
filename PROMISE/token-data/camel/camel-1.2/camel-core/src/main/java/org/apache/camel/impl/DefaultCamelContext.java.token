package
org
.
apache
.
camel
.
impl
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collection
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
concurrent
.
Callable
;
import
javax
.
naming
.
Context
;
import
org
.
apache
.
camel
.
CamelContext
;
import
org
.
apache
.
camel
.
Component
;
import
org
.
apache
.
camel
.
Endpoint
;
import
org
.
apache
.
camel
.
Exchange
;
import
org
.
apache
.
camel
.
spi
.
LifecycleStrategy
;
import
org
.
apache
.
camel
.
Processor
;
import
org
.
apache
.
camel
.
ResolveEndpointFailedException
;
import
org
.
apache
.
camel
.
Route
;
import
org
.
apache
.
camel
.
RuntimeCamelException
;
import
org
.
apache
.
camel
.
Service
;
import
org
.
apache
.
camel
.
TypeConverter
;
import
org
.
apache
.
camel
.
model
.
RouteType
;
import
org
.
apache
.
camel
.
builder
.
RouteBuilder
;
import
org
.
apache
.
camel
.
impl
.
converter
.
DefaultTypeConverter
;
import
org
.
apache
.
camel
.
spi
.
ComponentResolver
;
import
org
.
apache
.
camel
.
spi
.
ExchangeConverter
;
import
org
.
apache
.
camel
.
spi
.
Injector
;
import
org
.
apache
.
camel
.
spi
.
Language
;
import
org
.
apache
.
camel
.
spi
.
LanguageResolver
;
import
org
.
apache
.
camel
.
spi
.
Registry
;
import
org
.
apache
.
camel
.
util
.
FactoryFinder
;
import
org
.
apache
.
camel
.
util
.
NoFactoryAvailableException
;
import
org
.
apache
.
camel
.
util
.
ObjectHelper
;
import
static
org
.
apache
.
camel
.
util
.
ServiceHelper
.
startServices
;
import
static
org
.
apache
.
camel
.
util
.
ServiceHelper
.
stopServices
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
public
class
DefaultCamelContext
extends
ServiceSupport
implements
CamelContext
,
Service
{
private
static
final
transient
Log
LOG
=
LogFactory
.
getLog
(
DefaultCamelContext
.
class
)
;
private
static
final
String
NAME_PREFIX
=
"camel-"
;
private
static
int
NAME_SUFFIX
=
0
;
private
String
name
;
private
Map
<
String
,
Endpoint
>
endpoints
=
new
HashMap
<
String
,
Endpoint
>
(
)
;
private
Map
<
String
,
Component
>
components
=
new
HashMap
<
String
,
Component
>
(
)
;
private
List
<
Route
>
routes
;
private
List
<
Service
>
servicesToClose
=
new
ArrayList
<
Service
>
(
)
;
private
TypeConverter
typeConverter
;
private
ExchangeConverter
exchangeConverter
;
private
Injector
injector
;
private
ComponentResolver
componentResolver
;
private
boolean
autoCreateComponents
=
true
;
private
LanguageResolver
languageResolver
=
new
DefaultLanguageResolver
(
)
;
private
Registry
registry
;
private
LifecycleStrategy
lifecycleStrategy
=
new
DefaultLifecycleStrategy
(
)
;
private
List
<
RouteType
>
routeDefinitions
=
new
ArrayList
<
RouteType
>
(
)
;
public
DefaultCamelContext
(
)
{
name
=
NAME_PREFIX
+
++
NAME_SUFFIX
;
}
public
DefaultCamelContext
(
Context
jndiContext
)
{
this
(
new
JndiRegistry
(
jndiContext
)
)
;
}
public
DefaultCamelContext
(
Registry
registry
)
{
this
(
)
;
this
.
registry
=
registry
;
}
public
String
getName
(
)
{
return
name
;
}
public
void
setName
(
String
name
)
{
this
.
name
=
name
;
}
public
void
addComponent
(
String
componentName
,
final
Component
component
)
{
if
(
component
==
null
)
{
throw
new
IllegalArgumentException
(
"Component cannot be null"
)
;
}
synchronized
(
components
)
{
if
(
components
.
containsKey
(
componentName
)
)
{
throw
new
IllegalArgumentException
(
"Component previously added: "
+
componentName
)
;
}
component
.
setCamelContext
(
this
)
;
components
.
put
(
componentName
,
component
)
;
}
}
public
Component
getComponent
(
String
name
)
{
synchronized
(
components
)
{
Component
component
=
components
.
get
(
name
)
;
if
(
component
==
null
&&
autoCreateComponents
)
{
try
{
component
=
getComponentResolver
(
)
.
resolveComponent
(
name
,
this
)
;
if
(
component
!=
null
)
{
addComponent
(
name
,
component
)
;
if
(
isStarted
(
)
)
{
startServices
(
component
)
;
}
}
}
catch
(
Exception
e
)
{
throw
new
RuntimeCamelException
(
"Could not auto create component: "
+
name
,
e
)
;
}
}
return
component
;
}
}
public
<
T
extends
Component
>
T
getComponent
(
String
name
,
Class
<
T
>
componentType
)
{
Component
component
=
getComponent
(
name
)
;
if
(
componentType
.
isInstance
(
component
)
)
{
return
componentType
.
cast
(
component
)
;
}
else
{
throw
new
IllegalArgumentException
(
"The component is not of type: "
+
componentType
+
" but is: "
+
component
)
;
}
}
public
Component
removeComponent
(
String
componentName
)
{
synchronized
(
components
)
{
return
components
.
remove
(
componentName
)
;
}
}
public
Component
getOrCreateComponent
(
String
componentName
,
Callable
<
Component
>
factory
)
{
synchronized
(
components
)
{
Component
component
=
components
.
get
(
componentName
)
;
if
(
component
==
null
)
{
try
{
component
=
factory
.
call
(
)
;
if
(
component
==
null
)
{
throw
new
RuntimeCamelException
(
"Factory failed to create the "
+
componentName
+
" component, it returned null."
)
;
}
components
.
put
(
componentName
,
component
)
;
component
.
setCamelContext
(
this
)
;
}
catch
(
Exception
e
)
{
throw
new
RuntimeCamelException
(
"Factory failed to create the "
+
componentName
+
" component"
,
e
)
;
}
}
return
component
;
}
}
public
Collection
<
Endpoint
>
getSingletonEndpoints
(
)
{
synchronized
(
endpoints
)
{
return
new
ArrayList
<
Endpoint
>
(
endpoints
.
values
(
)
)
;
}
}
public
Endpoint
addSingletonEndpoint
(
String
uri
,
Endpoint
endpoint
)
throws
Exception
{
Endpoint
oldEndpoint
;
synchronized
(
endpoints
)
{
startServices
(
endpoint
)
;
oldEndpoint
=
endpoints
.
remove
(
uri
)
;
endpoints
.
put
(
uri
,
endpoint
)
;
stopServices
(
oldEndpoint
)
;
}
return
oldEndpoint
;
}
public
Endpoint
removeSingletonEndpoint
(
String
uri
)
throws
Exception
{
Endpoint
oldEndpoint
;
synchronized
(
endpoints
)
{
oldEndpoint
=
endpoints
.
remove
(
uri
)
;
stopServices
(
oldEndpoint
)
;
}
return
oldEndpoint
;
}
public
Endpoint
getEndpoint
(
String
uri
)
{
Endpoint
answer
;
synchronized
(
endpoints
)
{
answer
=
endpoints
.
get
(
uri
)
;
if
(
answer
==
null
)
{
try
{
String
splitURI
[
]
=
ObjectHelper
.
splitOnCharacter
(
uri
,
":"
,
2
)
;
if
(
splitURI
[
1
]
!=
null
)
{
String
scheme
=
splitURI
[
0
]
;
Component
component
=
getComponent
(
scheme
)
;
if
(
component
!=
null
)
{
answer
=
component
.
createEndpoint
(
uri
)
;
if
(
answer
!=
null
&&
LOG
.
isDebugEnabled
(
)
)
{
LOG
.
debug
(
uri
+
" converted to endpoint: "
+
answer
+
" by component: "
+
component
)
;
}
}
}
if
(
answer
==
null
)
{
answer
=
createEndpoint
(
uri
)
;
}
if
(
answer
!=
null
&&
answer
.
isSingleton
(
)
)
{
startServices
(
answer
)
;
endpoints
.
put
(
uri
,
answer
)
;
lifecycleStrategy
.
onEndpointAdd
(
answer
)
;
}
}
catch
(
Exception
e
)
{
throw
new
ResolveEndpointFailedException
(
uri
,
e
)
;
}
}
}
return
answer
;
}
public
<
T
extends
Endpoint
>
T
getEndpoint
(
String
name
,
Class
<
T
>
endpointType
)
{
Endpoint
endpoint
=
getEndpoint
(
name
)
;
if
(
endpointType
.
isInstance
(
endpoint
)
)
{
return
endpointType
.
cast
(
endpoint
)
;
}
else
{
throw
new
IllegalArgumentException
(
"The endpoint is not of type: "
+
endpointType
+
" but is: "
+
endpoint
)
;
}
}
public
List
<
Route
>
getRoutes
(
)
{
return
routes
;
}
public
void
setRoutes
(
List
<
Route
>
routes
)
{
this
.
routes
=
routes
;
}
public
void
addRoutes
(
Collection
<
Route
>
routes
)
throws
Exception
{
if
(
this
.
routes
==
null
)
{
this
.
routes
=
new
ArrayList
<
Route
>
(
routes
)
;
}
else
{
this
.
routes
.
addAll
(
routes
)
;
}
lifecycleStrategy
.
onRoutesAdd
(
routes
)
;
if
(
shouldStartRoutes
(
)
)
{
startRoutes
(
routes
)
;
}
}
public
void
addRoutes
(
RouteBuilder
builder
)
throws
Exception
{
builder
.
setContext
(
this
)
;
List
<
Route
>
routeList
=
builder
.
getRouteList
(
)
;
LOG
.
debug
(
"Adding routes from: "
+
builder
+
" routes: "
+
routeList
)
;
addRoutes
(
routeList
)
;
}
public
void
addRouteDefinitions
(
Collection
<
RouteType
>
routeDefinitions
)
throws
Exception
{
this
.
routeDefinitions
.
addAll
(
routeDefinitions
)
;
if
(
shouldStartRoutes
(
)
)
{
startRouteDefinitions
(
routeDefinitions
)
;
}
}
public
Language
resolveLanguage
(
String
language
)
{
return
getLanguageResolver
(
)
.
resolveLanguage
(
language
,
this
)
;
}
public
ExchangeConverter
getExchangeConverter
(
)
{
if
(
exchangeConverter
==
null
)
{
exchangeConverter
=
createExchangeConverter
(
)
;
}
return
exchangeConverter
;
}
public
void
setExchangeConverter
(
ExchangeConverter
exchangeConverter
)
{
this
.
exchangeConverter
=
exchangeConverter
;
}
public
TypeConverter
getTypeConverter
(
)
{
if
(
typeConverter
==
null
)
{
typeConverter
=
createTypeConverter
(
)
;
}
return
typeConverter
;
}
public
void
setTypeConverter
(
TypeConverter
typeConverter
)
{
this
.
typeConverter
=
typeConverter
;
}
public
Injector
getInjector
(
)
{
if
(
injector
==
null
)
{
injector
=
createInjector
(
)
;
}
return
injector
;
}
public
void
setInjector
(
Injector
injector
)
{
this
.
injector
=
injector
;
}
public
ComponentResolver
getComponentResolver
(
)
{
if
(
componentResolver
==
null
)
{
componentResolver
=
createComponentResolver
(
)
;
}
return
componentResolver
;
}
public
void
setComponentResolver
(
ComponentResolver
componentResolver
)
{
this
.
componentResolver
=
componentResolver
;
}
public
LanguageResolver
getLanguageResolver
(
)
{
return
languageResolver
;
}
public
void
setLanguageResolver
(
LanguageResolver
languageResolver
)
{
this
.
languageResolver
=
languageResolver
;
}
public
boolean
isAutoCreateComponents
(
)
{
return
autoCreateComponents
;
}
public
void
setAutoCreateComponents
(
boolean
autoCreateComponents
)
{
this
.
autoCreateComponents
=
autoCreateComponents
;
}
public
Registry
getRegistry
(
)
{
if
(
registry
==
null
)
{
registry
=
createRegistry
(
)
;
}
return
registry
;
}
public
void
setRegistry
(
Registry
registry
)
{
this
.
registry
=
registry
;
}
public
LifecycleStrategy
getLifecycleStrategy
(
)
{
return
lifecycleStrategy
;
}
public
void
setLifecycleStrategy
(
LifecycleStrategy
lifecycleStrategy
)
{
this
.
lifecycleStrategy
=
lifecycleStrategy
;
}
public
List
<
RouteType
>
getRouteDefinitions
(
)
{
return
routeDefinitions
;
}
protected
void
doStart
(
)
throws
Exception
{
forceLazyInitialization
(
)
;
if
(
components
!=
null
)
{
for
(
Component
component
:
components
.
values
(
)
)
{
startServices
(
component
)
;
}
}
startRouteDefinitions
(
routeDefinitions
)
;
startRoutes
(
routes
)
;
}
protected
void
startRouteDefinitions
(
Collection
<
RouteType
>
list
)
throws
Exception
{
if
(
list
!=
null
)
{
for
(
RouteType
route
:
list
)
{
lifecycleStrategy
.
beforeStartRouteType
(
this
,
route
)
;
route
.
addRoutes
(
this
)
;
}
}
}
protected
void
doStop
(
)
throws
Exception
{
stopServices
(
servicesToClose
)
;
if
(
components
!=
null
)
{
for
(
Component
component
:
components
.
values
(
)
)
{
stopServices
(
component
)
;
}
}
}
protected
void
startRoutes
(
Collection
<
Route
>
routeList
)
throws
Exception
{
if
(
routeList
!=
null
)
{
for
(
Route
<
Exchange
>
route
:
routeList
)
{
List
<
Service
>
services
=
route
.
getServicesForRoute
(
)
;
servicesToClose
.
addAll
(
services
)
;
startServices
(
services
)
;
}
}
}
protected
void
forceLazyInitialization
(
)
{
getExchangeConverter
(
)
;
getInjector
(
)
;
getLanguageResolver
(
)
;
getTypeConverter
(
)
;
}
protected
ExchangeConverter
createExchangeConverter
(
)
{
return
new
DefaultExchangeConverter
(
)
;
}
protected
TypeConverter
createTypeConverter
(
)
{
return
new
DefaultTypeConverter
(
getInjector
(
)
)
;
}
protected
Injector
createInjector
(
)
{
FactoryFinder
finder
=
new
FactoryFinder
(
)
;
try
{
return
(
Injector
)
finder
.
newInstance
(
"Injector"
)
;
}
catch
(
NoFactoryAvailableException
e
)
{
return
new
ReflectionInjector
(
)
;
}
catch
(
IllegalAccessException
e
)
{
throw
new
RuntimeCamelException
(
e
)
;
}
catch
(
InstantiationException
e
)
{
throw
new
RuntimeCamelException
(
e
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeCamelException
(
e
)
;
}
catch
(
ClassNotFoundException
e
)
{
throw
new
RuntimeCamelException
(
e
)
;
}
}
protected
ComponentResolver
createComponentResolver
(
)
{
return
new
DefaultComponentResolver
(
)
;
}
protected
Registry
createRegistry
(
)
{
return
new
JndiRegistry
(
)
;
}
protected
Endpoint
createEndpoint
(
String
uri
)
{
Object
value
=
getRegistry
(
)
.
lookup
(
uri
)
;
if
(
value
instanceof
Endpoint
)
{
return
(
Endpoint
)
value
;
}
else
if
(
value
instanceof
Processor
)
{
return
new
ProcessorEndpoint
(
uri
,
this
,
(
Processor
)
value
)
;
}
else
if
(
value
!=
null
)
{
return
convertBeanToEndpoint
(
uri
,
value
)
;
}
return
null
;
}
protected
Endpoint
convertBeanToEndpoint
(
String
uri
,
Object
bean
)
{
throw
new
IllegalArgumentException
(
"uri: "
+
uri
+
" bean: "
+
bean
+
" could not be converted to an Endpoint"
)
;
}
protected
boolean
shouldStartRoutes
(
)
{
return
isStarted
(
)
&&
!
isStarting
(
)
;
}
}
