package
org
.
apache
.
camel
.
util
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
annotation
.
Annotation
;
import
java
.
net
.
URL
;
import
java
.
net
.
URLDecoder
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Set
;
import
java
.
util
.
jar
.
JarEntry
;
import
java
.
util
.
jar
.
JarInputStream
;
public
class
ResolverUtil
<
T
>
{
private
static
final
transient
Log
LOG
=
LogFactory
.
getLog
(
ResolverUtil
.
class
)
;
public
static
interface
Test
{
boolean
matches
(
Class
type
)
;
}
public
static
class
IsA
implements
Test
{
private
Class
parent
;
public
IsA
(
Class
parentType
)
{
this
.
parent
=
parentType
;
}
public
boolean
matches
(
Class
type
)
{
return
type
!=
null
&&
parent
.
isAssignableFrom
(
type
)
;
}
@
Override
public
String
toString
(
)
{
return
"is assignable to "
+
parent
.
getSimpleName
(
)
;
}
}
public
static
class
AnnotatedWith
implements
Test
{
private
Class
<
?
extends
Annotation
>
annotation
;
public
AnnotatedWith
(
Class
<
?
extends
Annotation
>
annotation
)
{
this
.
annotation
=
annotation
;
}
public
boolean
matches
(
Class
type
)
{
return
type
!=
null
&&
type
.
isAnnotationPresent
(
annotation
)
;
}
@
Override
public
String
toString
(
)
{
return
"annotated with @"
+
annotation
.
getSimpleName
(
)
;
}
}
private
Set
<
Class
<
?
extends
T
>
>
matches
=
new
HashSet
<
Class
<
?
extends
T
>
>
(
)
;
private
Set
<
ClassLoader
>
classLoaders
;
public
Set
<
Class
<
?
extends
T
>
>
getClasses
(
)
{
return
matches
;
}
public
Set
<
ClassLoader
>
getClassLoaders
(
)
{
if
(
classLoaders
==
null
)
{
classLoaders
=
new
HashSet
<
ClassLoader
>
(
)
;
classLoaders
.
add
(
Thread
.
currentThread
(
)
.
getContextClassLoader
(
)
)
;
}
return
classLoaders
;
}
public
void
setClassLoaders
(
Set
<
ClassLoader
>
classLoaders
)
{
this
.
classLoaders
=
classLoaders
;
}
public
void
findImplementations
(
Class
parent
,
String
...
packageNames
)
{
if
(
packageNames
==
null
)
{
return
;
}
LOG
.
debug
(
"Searching for implementations of "
+
parent
.
getName
(
)
+
" in packages: "
+
Arrays
.
asList
(
packageNames
)
)
;
Test
test
=
new
IsA
(
parent
)
;
for
(
String
pkg
:
packageNames
)
{
find
(
test
,
pkg
)
;
}
LOG
.
debug
(
"Found: "
+
getClasses
(
)
)
;
}
public
void
findAnnotated
(
Class
<
?
extends
Annotation
>
annotation
,
String
...
packageNames
)
{
if
(
packageNames
==
null
)
{
return
;
}
Test
test
=
new
AnnotatedWith
(
annotation
)
;
for
(
String
pkg
:
packageNames
)
{
find
(
test
,
pkg
)
;
}
}
public
void
find
(
Test
test
,
String
packageName
)
{
packageName
=
packageName
.
replace
(
'.'
,
'/'
)
;
Set
<
ClassLoader
>
set
=
getClassLoaders
(
)
;
for
(
ClassLoader
classLoader
:
set
)
{
LOG
.
trace
(
"Searching: "
+
classLoader
)
;
find
(
test
,
packageName
,
classLoader
)
;
}
}
protected
void
find
(
Test
test
,
String
packageName
,
ClassLoader
loader
)
{
Enumeration
<
URL
>
urls
;
try
{
urls
=
loader
.
getResources
(
packageName
)
;
}
catch
(
IOException
ioe
)
{
LOG
.
warn
(
"Could not read package: "
+
packageName
,
ioe
)
;
return
;
}
while
(
urls
.
hasMoreElements
(
)
)
{
try
{
URL
url
=
urls
.
nextElement
(
)
;
String
urlPath
=
url
.
getFile
(
)
;
urlPath
=
URLDecoder
.
decode
(
urlPath
,
"UTF-8"
)
;
if
(
urlPath
.
startsWith
(
"file:"
)
)
{
urlPath
=
urlPath
.
substring
(
5
)
;
}
if
(
urlPath
.
indexOf
(
'!'
)
>
0
)
{
urlPath
=
urlPath
.
substring
(
0
,
urlPath
.
indexOf
(
'!'
)
)
;
}
LOG
.
debug
(
"Scanning for classes in ["
+
urlPath
+
"] matching criteria: "
+
test
)
;
File
file
=
new
File
(
urlPath
)
;
if
(
file
.
isDirectory
(
)
)
{
loadImplementationsInDirectory
(
test
,
packageName
,
file
)
;
}
else
{
loadImplementationsInJar
(
test
,
packageName
,
file
)
;
}
}
catch
(
IOException
ioe
)
{
LOG
.
warn
(
"could not read entries"
,
ioe
)
;
}
}
}
private
void
loadImplementationsInDirectory
(
Test
test
,
String
parent
,
File
location
)
{
File
[
]
files
=
location
.
listFiles
(
)
;
StringBuilder
builder
=
null
;
for
(
File
file
:
files
)
{
builder
=
new
StringBuilder
(
100
)
;
String
name
=
file
.
getName
(
)
;
if
(
name
!=
null
)
{
name
=
name
.
trim
(
)
;
}
builder
.
append
(
parent
)
.
append
(
"/"
)
.
append
(
name
)
;
String
packageOrClass
=
parent
==
null
?
name
:
builder
.
toString
(
)
;
if
(
file
.
isDirectory
(
)
)
{
loadImplementationsInDirectory
(
test
,
packageOrClass
,
file
)
;
}
else
if
(
name
.
endsWith
(
".class"
)
)
{
addIfMatching
(
test
,
packageOrClass
)
;
}
}
}
private
void
loadImplementationsInJar
(
Test
test
,
String
parent
,
File
jarfile
)
{
try
{
JarEntry
entry
;
JarInputStream
jarStream
=
new
JarInputStream
(
new
FileInputStream
(
jarfile
)
)
;
while
(
(
entry
=
jarStream
.
getNextJarEntry
(
)
)
!=
null
)
{
String
name
=
entry
.
getName
(
)
;
if
(
name
!=
null
)
{
name
=
name
.
trim
(
)
;
}
if
(
!
entry
.
isDirectory
(
)
&&
name
.
startsWith
(
parent
)
&&
name
.
endsWith
(
".class"
)
)
{
addIfMatching
(
test
,
name
)
;
}
}
}
catch
(
IOException
ioe
)
{
LOG
.
error
(
"Could not search jar file '"
+
jarfile
+
"' for classes matching criteria: "
+
test
+
"due to an IOException: "
+
ioe
.
getMessage
(
)
)
;
}
}
protected
void
addIfMatching
(
Test
test
,
String
fqn
)
{
try
{
String
externalName
=
fqn
.
substring
(
0
,
fqn
.
indexOf
(
'.'
)
)
.
replace
(
'/'
,
'.'
)
;
Set
<
ClassLoader
>
set
=
getClassLoaders
(
)
;
boolean
found
=
false
;
for
(
ClassLoader
classLoader
:
set
)
{
LOG
.
trace
(
"Checking to see if class "
+
externalName
+
" matches criteria ["
+
test
+
"]"
)
;
try
{
Class
type
=
classLoader
.
loadClass
(
externalName
)
;
if
(
test
.
matches
(
type
)
)
{
matches
.
add
(
(
Class
<
T
>
)
type
)
;
}
found
=
true
;
break
;
}
catch
(
ClassNotFoundException
e
)
{
LOG
.
debug
(
"Could not find class '"
+
fqn
+
"' in class loader: "
+
classLoader
+
". Reason: "
+
e
,
e
)
;
}
}
if
(
!
found
)
{
LOG
.
warn
(
"Could not find class '"
+
fqn
+
"' in any class loaders: "
+
set
)
;
}
}
catch
(
Throwable
t
)
{
LOG
.
warn
(
"Could not examine class '"
+
fqn
+
"' due to a "
+
t
.
getClass
(
)
.
getName
(
)
+
" with message: "
+
t
.
getMessage
(
)
)
;
}
}
}
