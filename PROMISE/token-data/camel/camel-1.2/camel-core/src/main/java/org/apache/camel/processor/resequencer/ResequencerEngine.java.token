package
org
.
apache
.
camel
.
processor
.
resequencer
;
import
java
.
util
.
Queue
;
import
java
.
util
.
Timer
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
public
class
ResequencerEngine
<
E
>
implements
TimeoutHandler
{
private
static
final
Log
LOG
=
LogFactory
.
getLog
(
ResequencerEngine
.
class
)
;
private
long
timeout
;
private
int
capacity
;
private
Queue
<
E
>
outQueue
;
private
Element
<
E
>
lastDelivered
;
private
Sequence
<
Element
<
E
>
>
sequence
;
private
Timer
timer
;
public
ResequencerEngine
(
SequenceElementComparator
<
E
>
comparator
)
{
this
(
comparator
,
Integer
.
MAX_VALUE
)
;
}
public
ResequencerEngine
(
SequenceElementComparator
<
E
>
comparator
,
int
capacity
)
{
this
.
timer
=
new
Timer
(
"Resequencer Timer"
)
;
this
.
sequence
=
createSequence
(
comparator
)
;
this
.
capacity
=
capacity
;
this
.
timeout
=
2000L
;
this
.
lastDelivered
=
null
;
}
public
void
stop
(
)
{
this
.
timer
.
cancel
(
)
;
}
public
Queue
<
E
>
getOutQueue
(
)
{
return
outQueue
;
}
public
void
setOutQueue
(
Queue
<
E
>
outQueue
)
{
this
.
outQueue
=
outQueue
;
}
public
long
getTimeout
(
)
{
return
timeout
;
}
public
void
setTimeout
(
long
timeout
)
{
this
.
timeout
=
timeout
;
}
public
synchronized
void
timeout
(
Timeout
timout
)
{
try
{
while
(
deliver
(
)
)
{
}
}
catch
(
RuntimeException
e
)
{
LOG
.
error
(
"error during delivery"
,
e
)
;
}
}
public
synchronized
void
add
(
E
o
)
{
if
(
sequence
.
size
(
)
>=
capacity
)
{
throw
new
IllegalStateException
(
"maximum capacity is reached"
)
;
}
insert
(
o
)
;
}
public
synchronized
void
put
(
E
o
)
throws
InterruptedException
{
if
(
sequence
.
size
(
)
>=
capacity
)
{
wait
(
)
;
}
insert
(
o
)
;
}
E
getLastDelivered
(
)
{
if
(
lastDelivered
==
null
)
{
return
null
;
}
return
lastDelivered
.
getObject
(
)
;
}
void
setLastDelivered
(
E
o
)
{
lastDelivered
=
new
Element
<
E
>
(
o
)
;
}
private
void
insert
(
E
o
)
{
Element
<
E
>
element
=
new
Element
<
E
>
(
o
)
;
sequence
.
add
(
element
)
;
Element
<
E
>
successor
=
sequence
.
successor
(
element
)
;
if
(
successor
!=
null
)
{
successor
.
cancel
(
)
;
}
if
(
successorOfLastDelivered
(
element
)
)
{
}
else
if
(
sequence
.
predecessor
(
element
)
!=
null
)
{
}
else
{
Timeout
t
=
defineTimeout
(
)
;
element
.
schedule
(
t
)
;
}
while
(
deliver
(
)
)
{
}
}
private
boolean
deliver
(
)
{
if
(
sequence
.
size
(
)
==
0
)
{
return
false
;
}
Element
<
E
>
element
=
sequence
.
first
(
)
;
if
(
element
.
scheduled
(
)
)
{
return
false
;
}
sequence
.
remove
(
element
)
;
lastDelivered
=
element
;
notify
(
)
;
outQueue
.
add
(
element
.
getObject
(
)
)
;
return
true
;
}
private
boolean
successorOfLastDelivered
(
Element
<
E
>
element
)
{
if
(
lastDelivered
==
null
)
{
return
false
;
}
if
(
sequence
.
comparator
(
)
.
successor
(
element
,
lastDelivered
)
)
{
return
true
;
}
return
false
;
}
private
Timeout
defineTimeout
(
)
{
Timeout
result
=
new
Timeout
(
timer
,
timeout
)
;
result
.
addTimeoutHandler
(
this
)
;
return
result
;
}
private
static
<
E
>
Sequence
<
Element
<
E
>
>
createSequence
(
SequenceElementComparator
<
E
>
comparator
)
{
return
new
Sequence
<
Element
<
E
>
>
(
new
ElementComparator
<
E
>
(
comparator
)
)
;
}
}
