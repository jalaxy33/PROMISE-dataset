package
org
.
apache
.
camel
.
util
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
annotation
.
Annotation
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
net
.
URL
;
import
java
.
net
.
URLDecoder
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Set
;
import
java
.
util
.
jar
.
JarEntry
;
import
java
.
util
.
jar
.
JarInputStream
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
public
class
ResolverUtil
<
T
>
{
protected
static
final
transient
Log
LOG
=
LogFactory
.
getLog
(
ResolverUtil
.
class
)
;
public
static
interface
Test
{
boolean
matches
(
Class
type
)
;
}
public
static
class
IsA
implements
Test
{
private
Class
parent
;
public
IsA
(
Class
parentType
)
{
this
.
parent
=
parentType
;
}
public
boolean
matches
(
Class
type
)
{
return
type
!=
null
&&
parent
.
isAssignableFrom
(
type
)
;
}
@
Override
public
String
toString
(
)
{
return
"is assignable to "
+
parent
.
getSimpleName
(
)
;
}
}
public
static
class
AnnotatedWith
implements
Test
{
private
Class
<
?
extends
Annotation
>
annotation
;
public
AnnotatedWith
(
Class
<
?
extends
Annotation
>
annotation
)
{
this
.
annotation
=
annotation
;
}
public
boolean
matches
(
Class
type
)
{
return
type
!=
null
&&
type
.
isAnnotationPresent
(
annotation
)
;
}
@
Override
public
String
toString
(
)
{
return
"annotated with @"
+
annotation
.
getSimpleName
(
)
;
}
}
private
Set
<
Class
<
?
extends
T
>
>
matches
=
new
HashSet
<
Class
<
?
extends
T
>
>
(
)
;
private
Set
<
ClassLoader
>
classLoaders
;
public
Set
<
Class
<
?
extends
T
>
>
getClasses
(
)
{
return
matches
;
}
public
Set
<
ClassLoader
>
getClassLoaders
(
)
{
if
(
classLoaders
==
null
)
{
classLoaders
=
new
HashSet
<
ClassLoader
>
(
)
;
classLoaders
.
add
(
Thread
.
currentThread
(
)
.
getContextClassLoader
(
)
)
;
classLoaders
.
add
(
ResolverUtil
.
class
.
getClassLoader
(
)
)
;
}
return
classLoaders
;
}
public
void
setClassLoaders
(
Set
<
ClassLoader
>
classLoaders
)
{
this
.
classLoaders
=
classLoaders
;
}
public
void
findImplementations
(
Class
parent
,
String
...
packageNames
)
{
if
(
packageNames
==
null
)
{
return
;
}
if
(
LOG
.
isDebugEnabled
(
)
)
{
LOG
.
debug
(
"Searching for implementations of "
+
parent
.
getName
(
)
+
" in packages: "
+
Arrays
.
asList
(
packageNames
)
)
;
}
Test
test
=
new
IsA
(
parent
)
;
for
(
String
pkg
:
packageNames
)
{
find
(
test
,
pkg
)
;
}
if
(
LOG
.
isDebugEnabled
(
)
)
{
LOG
.
debug
(
"Found: "
+
getClasses
(
)
)
;
}
}
public
void
findAnnotated
(
Class
<
?
extends
Annotation
>
annotation
,
String
...
packageNames
)
{
if
(
packageNames
==
null
)
{
return
;
}
if
(
LOG
.
isDebugEnabled
(
)
)
{
LOG
.
debug
(
"Searching for annotations of "
+
annotation
.
getName
(
)
+
" in packages: "
+
Arrays
.
asList
(
packageNames
)
)
;
}
Test
test
=
new
AnnotatedWith
(
annotation
)
;
for
(
String
pkg
:
packageNames
)
{
find
(
test
,
pkg
)
;
}
if
(
LOG
.
isDebugEnabled
(
)
)
{
LOG
.
debug
(
"Found: "
+
getClasses
(
)
)
;
}
}
public
void
find
(
Test
test
,
String
packageName
)
{
packageName
=
packageName
.
replace
(
'.'
,
'/'
)
;
Set
<
ClassLoader
>
set
=
getClassLoaders
(
)
;
for
(
ClassLoader
classLoader
:
set
)
{
find
(
test
,
packageName
,
classLoader
)
;
}
}
protected
void
find
(
Test
test
,
String
packageName
,
ClassLoader
loader
)
{
if
(
LOG
.
isTraceEnabled
(
)
)
{
LOG
.
trace
(
"Searching for: "
+
test
+
" in package: "
+
packageName
+
" using classloader: "
+
loader
.
getClass
(
)
.
getName
(
)
)
;
}
if
(
loader
.
getClass
(
)
.
getName
(
)
.
endsWith
(
"org.apache.felix.framework.searchpolicy.ContentClassLoader"
)
)
{
LOG
.
trace
(
"This is not an URL classloader, skipping"
)
;
return
;
}
try
{
Method
mth
=
loader
.
getClass
(
)
.
getMethod
(
"getBundle"
,
new
Class
[
]
{
}
)
;
if
(
mth
!=
null
)
{
if
(
LOG
.
isDebugEnabled
(
)
)
{
LOG
.
debug
(
"Loading from osgi buindle using classloader: "
+
loader
)
;
}
loadImplementationsInBundle
(
test
,
packageName
,
loader
,
mth
)
;
return
;
}
}
catch
(
NoSuchMethodException
e
)
{
LOG
.
trace
(
"It's not an osgi bundle classloader"
)
;
}
Enumeration
<
URL
>
urls
;
try
{
urls
=
getResources
(
loader
,
packageName
)
;
if
(
!
urls
.
hasMoreElements
(
)
)
{
LOG
.
trace
(
"No URLs returned by classloader"
)
;
}
}
catch
(
IOException
ioe
)
{
LOG
.
warn
(
"Could not read package: "
+
packageName
,
ioe
)
;
return
;
}
while
(
urls
.
hasMoreElements
(
)
)
{
URL
url
=
null
;
try
{
url
=
urls
.
nextElement
(
)
;
if
(
LOG
.
isTraceEnabled
(
)
)
{
LOG
.
trace
(
"URL from classloader: "
+
url
)
;
}
String
urlPath
=
url
.
getFile
(
)
;
urlPath
=
URLDecoder
.
decode
(
urlPath
,
"UTF-8"
)
;
if
(
LOG
.
isTraceEnabled
(
)
)
{
LOG
.
trace
(
"Decoded urlPath: "
+
urlPath
)
;
}
if
(
urlPath
.
startsWith
(
"file:"
)
)
{
urlPath
=
urlPath
.
substring
(
5
)
;
}
if
(
urlPath
.
startsWith
(
"bundle:"
)
)
{
LOG
.
trace
(
"It's a virtual osgi bundle, skipping"
)
;
continue
;
}
if
(
urlPath
.
indexOf
(
'!'
)
>
0
)
{
urlPath
=
urlPath
.
substring
(
0
,
urlPath
.
indexOf
(
'!'
)
)
;
}
if
(
LOG
.
isTraceEnabled
(
)
)
{
LOG
.
trace
(
"Scanning for classes in ["
+
urlPath
+
"] matching criteria: "
+
test
)
;
}
File
file
=
new
File
(
urlPath
)
;
if
(
file
.
isDirectory
(
)
)
{
if
(
LOG
.
isDebugEnabled
(
)
)
{
LOG
.
debug
(
"Loading from directory: "
+
file
)
;
}
loadImplementationsInDirectory
(
test
,
packageName
,
file
)
;
}
else
{
if
(
LOG
.
isDebugEnabled
(
)
)
{
LOG
.
debug
(
"Loading from jar: "
+
file
)
;
}
loadImplementationsInJar
(
test
,
packageName
,
file
)
;
}
}
catch
(
IOException
ioe
)
{
LOG
.
warn
(
"Could not read entries in url: "
+
url
,
ioe
)
;
}
}
}
protected
Enumeration
<
URL
>
getResources
(
ClassLoader
loader
,
String
packageName
)
throws
IOException
{
if
(
LOG
.
isTraceEnabled
(
)
)
{
LOG
.
trace
(
"Getting resource URL for package: "
+
packageName
+
" with classloader: "
+
loader
)
;
}
return
loader
.
getResources
(
packageName
)
;
}
private
void
loadImplementationsInBundle
(
Test
test
,
String
packageName
,
ClassLoader
loader
,
Method
mth
)
{
Set
<
String
>
urls
=
OsgiUtil
.
getImplementationsInBundle
(
test
,
packageName
,
loader
,
mth
)
;
if
(
urls
!=
null
)
{
for
(
String
url
:
urls
)
{
addIfMatching
(
test
,
url
)
;
}
}
}
private
static
final
class
OsgiUtil
{
private
OsgiUtil
(
)
{
}
static
Set
<
String
>
getImplementationsInBundle
(
Test
test
,
String
packageName
,
ClassLoader
loader
,
Method
mth
)
{
try
{
org
.
osgi
.
framework
.
Bundle
bundle
=
(
org
.
osgi
.
framework
.
Bundle
)
mth
.
invoke
(
loader
)
;
org
.
osgi
.
framework
.
Bundle
[
]
bundles
=
bundle
.
getBundleContext
(
)
.
getBundles
(
)
;
Set
<
String
>
urls
=
new
HashSet
<
String
>
(
)
;
for
(
org
.
osgi
.
framework
.
Bundle
bd
:
bundles
)
{
if
(
LOG
.
isTraceEnabled
(
)
)
{
LOG
.
trace
(
"Searching in bundle:"
+
bd
)
;
}
Enumeration
<
URL
>
paths
=
bd
.
findEntries
(
"/"
+
packageName
,
"*.class"
,
true
)
;
while
(
paths
!=
null
&&
paths
.
hasMoreElements
(
)
)
{
URL
path
=
paths
.
nextElement
(
)
;
urls
.
add
(
path
.
getPath
(
)
.
substring
(
1
)
)
;
}
}
return
urls
;
}
catch
(
Throwable
t
)
{
LOG
.
error
(
"Could not search osgi bundles for classes matching criteria: "
+
test
+
"due to an Exception: "
+
t
.
getMessage
(
)
)
;
return
null
;
}
}
}
private
void
loadImplementationsInDirectory
(
Test
test
,
String
parent
,
File
location
)
{
File
[
]
files
=
location
.
listFiles
(
)
;
StringBuilder
builder
=
null
;
for
(
File
file
:
files
)
{
builder
=
new
StringBuilder
(
100
)
;
String
name
=
file
.
getName
(
)
;
if
(
name
!=
null
)
{
name
=
name
.
trim
(
)
;
builder
.
append
(
parent
)
.
append
(
"/"
)
.
append
(
name
)
;
String
packageOrClass
=
parent
==
null
?
name
:
builder
.
toString
(
)
;
if
(
file
.
isDirectory
(
)
)
{
loadImplementationsInDirectory
(
test
,
packageOrClass
,
file
)
;
}
else
if
(
name
.
endsWith
(
".class"
)
)
{
addIfMatching
(
test
,
packageOrClass
)
;
}
}
}
}
private
void
loadImplementationsInJar
(
Test
test
,
String
parent
,
File
jarfile
)
{
JarInputStream
jarStream
=
null
;
try
{
jarStream
=
new
JarInputStream
(
new
FileInputStream
(
jarfile
)
)
;
JarEntry
entry
;
while
(
(
entry
=
jarStream
.
getNextJarEntry
(
)
)
!=
null
)
{
String
name
=
entry
.
getName
(
)
;
if
(
name
!=
null
)
{
name
=
name
.
trim
(
)
;
if
(
!
entry
.
isDirectory
(
)
&&
name
.
startsWith
(
parent
)
&&
name
.
endsWith
(
".class"
)
)
{
addIfMatching
(
test
,
name
)
;
}
}
}
}
catch
(
IOException
ioe
)
{
LOG
.
error
(
"Could not search jar file '"
+
jarfile
+
"' for classes matching criteria: "
+
test
+
" due to an IOException: "
+
ioe
.
getMessage
(
)
,
ioe
)
;
}
finally
{
ObjectHelper
.
close
(
jarStream
,
jarfile
.
getPath
(
)
,
LOG
)
;
}
}
protected
void
addIfMatching
(
Test
test
,
String
fqn
)
{
try
{
String
externalName
=
fqn
.
substring
(
0
,
fqn
.
indexOf
(
'.'
)
)
.
replace
(
'/'
,
'.'
)
;
Set
<
ClassLoader
>
set
=
getClassLoaders
(
)
;
boolean
found
=
false
;
for
(
ClassLoader
classLoader
:
set
)
{
if
(
LOG
.
isTraceEnabled
(
)
)
{
LOG
.
trace
(
"Testing for class "
+
externalName
+
" matches criteria ["
+
test
+
"]"
)
;
}
try
{
Class
type
=
classLoader
.
loadClass
(
externalName
)
;
if
(
test
.
matches
(
type
)
)
{
if
(
LOG
.
isTraceEnabled
(
)
)
{
LOG
.
trace
(
"Found class: "
+
type
+
" in classloader: "
+
classLoader
)
;
}
matches
.
add
(
(
Class
<
T
>
)
type
)
;
}
found
=
true
;
break
;
}
catch
(
ClassNotFoundException
e
)
{
LOG
.
debug
(
"Could not find class '"
+
fqn
+
"' in classloader: "
+
classLoader
+
". Reason: "
+
e
,
e
)
;
}
catch
(
NoClassDefFoundError
e
)
{
LOG
.
debug
(
"Could not find the class defintion '"
+
fqn
+
"' in classloader: "
+
classLoader
+
". Reason: "
+
e
,
e
)
;
}
}
if
(
!
found
)
{
LOG
.
warn
(
"Could not find class '"
+
fqn
+
"' in any classloaders: "
+
set
)
;
}
}
catch
(
Throwable
t
)
{
LOG
.
warn
(
"Could not examine class '"
+
fqn
+
"' due to a "
+
t
.
getClass
(
)
.
getName
(
)
+
" with message: "
+
t
.
getMessage
(
)
,
t
)
;
}
}
}
