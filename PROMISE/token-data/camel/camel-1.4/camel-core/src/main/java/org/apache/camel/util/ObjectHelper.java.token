package
org
.
apache
.
camel
.
util
;
import
java
.
io
.
Closeable
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
lang
.
annotation
.
Annotation
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
nio
.
charset
.
Charset
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
org
.
w3c
.
dom
.
Node
;
import
org
.
w3c
.
dom
.
NodeList
;
import
org
.
apache
.
camel
.
RuntimeCamelException
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
public
final
class
ObjectHelper
{
private
static
final
transient
Log
LOG
=
LogFactory
.
getLog
(
ObjectHelper
.
class
)
;
private
ObjectHelper
(
)
{
}
@
Deprecated
public
static
boolean
equals
(
Object
a
,
Object
b
)
{
return
equal
(
a
,
b
)
;
}
public
static
boolean
equal
(
Object
a
,
Object
b
)
{
if
(
a
==
b
)
{
return
true
;
}
if
(
a
instanceof
byte
[
]
&&
b
instanceof
byte
[
]
)
{
return
equalByteArray
(
(
byte
[
]
)
a
,
(
byte
[
]
)
b
)
;
}
return
a
!=
null
&&
b
!=
null
&&
a
.
equals
(
b
)
;
}
public
static
boolean
equalByteArray
(
byte
[
]
a
,
byte
[
]
b
)
{
if
(
a
==
b
)
{
return
true
;
}
if
(
a
!=
null
&&
b
!=
null
&&
a
.
length
==
b
.
length
)
{
for
(
int
i
=
0
;
i
<
a
.
length
;
i
++
)
{
if
(
a
[
i
]
!=
b
[
i
]
)
{
return
false
;
}
}
return
true
;
}
return
false
;
}
public
static
boolean
isEqualToAny
(
Object
object
,
Object
...
values
)
{
for
(
Object
value
:
values
)
{
if
(
equal
(
object
,
value
)
)
{
return
true
;
}
}
return
false
;
}
public
static
int
compare
(
Object
a
,
Object
b
)
{
if
(
a
==
b
)
{
return
0
;
}
if
(
a
==
null
)
{
return
-
1
;
}
if
(
b
==
null
)
{
return
1
;
}
if
(
a
instanceof
Comparable
)
{
Comparable
comparable
=
(
Comparable
)
a
;
return
comparable
.
compareTo
(
b
)
;
}
else
{
int
answer
=
a
.
getClass
(
)
.
getName
(
)
.
compareTo
(
b
.
getClass
(
)
.
getName
(
)
)
;
if
(
answer
==
0
)
{
answer
=
a
.
hashCode
(
)
-
b
.
hashCode
(
)
;
}
return
answer
;
}
}
public
static
Boolean
toBoolean
(
Object
value
)
{
if
(
value
instanceof
Boolean
)
{
return
(
Boolean
)
value
;
}
if
(
value
instanceof
String
)
{
return
"true"
.
equalsIgnoreCase
(
value
.
toString
(
)
)
?
Boolean
.
TRUE
:
Boolean
.
FALSE
;
}
if
(
value
instanceof
Integer
)
{
return
(
Integer
)
value
>
0
?
Boolean
.
TRUE
:
Boolean
.
FALSE
;
}
return
null
;
}
public
static
void
notNull
(
Object
value
,
String
name
)
{
if
(
value
==
null
)
{
throw
new
IllegalArgumentException
(
name
+
" must be specified"
)
;
}
}
public
static
String
[
]
splitOnCharacter
(
String
value
,
String
needle
,
int
count
)
{
String
rc
[
]
=
new
String
[
count
]
;
rc
[
0
]
=
value
;
for
(
int
i
=
1
;
i
<
count
;
i
++
)
{
String
v
=
rc
[
i
-
1
]
;
int
p
=
v
.
indexOf
(
needle
)
;
if
(
p
<
0
)
{
return
rc
;
}
rc
[
i
-
1
]
=
v
.
substring
(
0
,
p
)
;
rc
[
i
]
=
v
.
substring
(
p
+
1
)
;
}
return
rc
;
}
public
static
String
removeStartingCharacters
(
String
text
,
char
ch
)
{
int
idx
=
0
;
while
(
text
.
charAt
(
idx
)
==
ch
)
{
idx
++
;
}
if
(
idx
>
0
)
{
return
text
.
substring
(
idx
)
;
}
return
text
;
}
public
static
String
capitalize
(
String
text
)
{
if
(
text
==
null
)
{
return
null
;
}
int
length
=
text
.
length
(
)
;
if
(
length
==
0
)
{
return
text
;
}
String
answer
=
text
.
substring
(
0
,
1
)
.
toUpperCase
(
)
;
if
(
length
>
1
)
{
answer
+=
text
.
substring
(
1
,
length
)
;
}
return
answer
;
}
@
SuppressWarnings
(
"unchecked"
)
public
static
boolean
contains
(
Object
collectionOrArray
,
Object
value
)
{
if
(
collectionOrArray
instanceof
Collection
)
{
Collection
collection
=
(
Collection
)
collectionOrArray
;
return
collection
.
contains
(
value
)
;
}
else
if
(
collectionOrArray
instanceof
String
&&
value
instanceof
String
)
{
String
str
=
(
String
)
collectionOrArray
;
String
subStr
=
(
String
)
value
;
return
str
.
contains
(
subStr
)
;
}
else
{
Iterator
iter
=
createIterator
(
collectionOrArray
)
;
while
(
iter
.
hasNext
(
)
)
{
if
(
equal
(
value
,
iter
.
next
(
)
)
)
{
return
true
;
}
}
}
return
false
;
}
@
SuppressWarnings
(
"unchecked"
)
public
static
Iterator
createIterator
(
Object
value
)
{
if
(
value
==
null
)
{
return
Collections
.
EMPTY_LIST
.
iterator
(
)
;
}
else
if
(
value
instanceof
Collection
)
{
Collection
collection
=
(
Collection
)
value
;
return
collection
.
iterator
(
)
;
}
else
if
(
value
.
getClass
(
)
.
isArray
(
)
)
{
List
<
Object
>
list
=
Arrays
.
asList
(
(
Object
[
]
)
value
)
;
return
list
.
iterator
(
)
;
}
else
if
(
value
instanceof
NodeList
)
{
final
NodeList
nodeList
=
(
NodeList
)
value
;
return
new
Iterator
<
Node
>
(
)
{
int
idx
=
-
1
;
public
boolean
hasNext
(
)
{
return
++
idx
<
nodeList
.
getLength
(
)
;
}
public
Node
next
(
)
{
return
nodeList
.
item
(
idx
)
;
}
public
void
remove
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
}
;
}
else
{
return
Collections
.
singletonList
(
value
)
.
iterator
(
)
;
}
}
public
static
boolean
matches
(
List
list
)
{
if
(
!
list
.
isEmpty
(
)
)
{
Object
value
=
list
.
get
(
0
)
;
if
(
value
instanceof
Boolean
)
{
Boolean
flag
=
(
Boolean
)
value
;
return
flag
.
booleanValue
(
)
;
}
else
{
return
true
;
}
}
return
false
;
}
public
static
boolean
isNotNullAndNonEmpty
(
String
text
)
{
return
text
!=
null
&&
text
.
trim
(
)
.
length
(
)
>
0
;
}
public
static
boolean
isNullOrBlank
(
String
text
)
{
return
text
==
null
||
text
.
trim
(
)
.
length
(
)
<=
0
;
}
public
static
String
getSystemProperty
(
String
name
,
String
defaultValue
)
{
try
{
return
System
.
getProperty
(
name
,
defaultValue
)
;
}
catch
(
Exception
e
)
{
if
(
LOG
.
isDebugEnabled
(
)
)
{
LOG
.
debug
(
"Caught security exception accessing system property: "
+
name
+
". Reason: "
+
e
,
e
)
;
}
return
defaultValue
;
}
}
public
static
String
name
(
Class
type
)
{
return
type
!=
null
?
type
.
getName
(
)
:
null
;
}
public
static
String
className
(
Object
value
)
{
return
name
(
value
!=
null
?
value
.
getClass
(
)
:
null
)
;
}
public
static
Class
<
?
>
loadClass
(
String
name
)
{
return
loadClass
(
name
,
ObjectHelper
.
class
.
getClassLoader
(
)
)
;
}
public
static
Class
<
?
>
loadClass
(
String
name
,
ClassLoader
loader
)
{
ClassLoader
contextClassLoader
=
Thread
.
currentThread
(
)
.
getContextClassLoader
(
)
;
if
(
contextClassLoader
!=
null
)
{
try
{
return
contextClassLoader
.
loadClass
(
name
)
;
}
catch
(
ClassNotFoundException
e
)
{
try
{
return
loader
.
loadClass
(
name
)
;
}
catch
(
ClassNotFoundException
e1
)
{
LOG
.
debug
(
"Could not find class: "
+
name
+
". Reason: "
+
e
)
;
}
}
}
return
null
;
}
public
static
InputStream
loadResourceAsStream
(
String
name
)
{
InputStream
in
=
null
;
ClassLoader
contextClassLoader
=
Thread
.
currentThread
(
)
.
getContextClassLoader
(
)
;
if
(
contextClassLoader
!=
null
)
{
in
=
contextClassLoader
.
getResourceAsStream
(
name
)
;
}
if
(
in
==
null
)
{
in
=
ObjectHelper
.
class
.
getClassLoader
(
)
.
getResourceAsStream
(
name
)
;
}
return
in
;
}
public
static
Object
invokeMethod
(
Method
method
,
Object
instance
,
Object
...
parameters
)
{
try
{
return
method
.
invoke
(
instance
,
parameters
)
;
}
catch
(
IllegalAccessException
e
)
{
throw
new
RuntimeCamelException
(
e
)
;
}
catch
(
InvocationTargetException
e
)
{
throw
new
RuntimeCamelException
(
e
.
getCause
(
)
)
;
}
}
public
static
List
<
Method
>
findMethodsWithAnnotation
(
Class
<
?
>
type
,
Class
<
?
extends
Annotation
>
annotationType
)
{
List
<
Method
>
answer
=
new
ArrayList
<
Method
>
(
)
;
do
{
Method
[
]
methods
=
type
.
getDeclaredMethods
(
)
;
for
(
Method
method
:
methods
)
{
if
(
method
.
getAnnotation
(
annotationType
)
!=
null
)
{
answer
.
add
(
method
)
;
}
}
type
=
type
.
getSuperclass
(
)
;
}
while
(
type
!=
null
)
;
return
answer
;
}
public
static
String
asString
(
Object
[
]
objects
)
{
if
(
objects
==
null
)
{
return
"null"
;
}
else
{
StringBuffer
buffer
=
new
StringBuffer
(
"{"
)
;
int
counter
=
0
;
for
(
Object
object
:
objects
)
{
if
(
counter
++
>
0
)
{
buffer
.
append
(
", "
)
;
}
String
text
=
(
object
==
null
)
?
"null"
:
object
.
toString
(
)
;
buffer
.
append
(
text
)
;
}
buffer
.
append
(
"}"
)
;
return
buffer
.
toString
(
)
;
}
}
public
static
boolean
isAssignableFrom
(
Class
a
,
Class
b
)
{
a
=
convertPrimitiveTypeToWrapperType
(
a
)
;
b
=
convertPrimitiveTypeToWrapperType
(
b
)
;
return
a
.
isAssignableFrom
(
b
)
;
}
public
static
Class
convertPrimitiveTypeToWrapperType
(
Class
type
)
{
Class
rc
=
type
;
if
(
type
.
isPrimitive
(
)
)
{
if
(
type
==
int
.
class
)
{
rc
=
Integer
.
class
;
}
else
if
(
type
==
long
.
class
)
{
rc
=
Long
.
class
;
}
else
if
(
type
==
double
.
class
)
{
rc
=
Double
.
class
;
}
else
if
(
type
==
float
.
class
)
{
rc
=
Float
.
class
;
}
else
if
(
type
==
short
.
class
)
{
rc
=
Short
.
class
;
}
else
if
(
type
==
byte
.
class
)
{
rc
=
Byte
.
class
;
}
}
return
rc
;
}
public
static
String
getDefaultCharacterSet
(
)
{
return
Charset
.
defaultCharset
(
)
.
name
(
)
;
}
public
static
String
getPropertyName
(
Method
method
)
{
String
propertyName
=
method
.
getName
(
)
;
if
(
propertyName
.
startsWith
(
"set"
)
&&
method
.
getParameterTypes
(
)
.
length
==
1
)
{
propertyName
=
propertyName
.
substring
(
3
,
4
)
.
toLowerCase
(
)
+
propertyName
.
substring
(
4
)
;
}
return
propertyName
;
}
public
static
boolean
hasAnnotation
(
Annotation
[
]
annotations
,
Class
<
?
>
type
)
{
for
(
Annotation
annotation
:
annotations
)
{
if
(
type
.
isInstance
(
annotation
)
)
{
return
true
;
}
}
return
false
;
}
public
static
void
close
(
Closeable
closeable
,
String
name
,
Log
log
)
{
if
(
closeable
!=
null
)
{
try
{
closeable
.
close
(
)
;
}
catch
(
IOException
e
)
{
if
(
log
!=
null
)
{
log
.
warn
(
"Could not close: "
+
name
+
". Reason: "
+
e
,
e
)
;
}
}
}
}
public
static
<
T
>
T
cast
(
Class
<
T
>
toType
,
Object
value
)
{
if
(
toType
==
boolean
.
class
)
{
return
(
T
)
cast
(
Boolean
.
class
,
value
)
;
}
else
if
(
toType
.
isPrimitive
(
)
)
{
Class
newType
=
convertPrimitiveTypeToWrapperType
(
toType
)
;
if
(
newType
!=
toType
)
{
return
(
T
)
cast
(
newType
,
value
)
;
}
}
try
{
return
toType
.
cast
(
value
)
;
}
catch
(
ClassCastException
e
)
{
throw
new
IllegalArgumentException
(
"Failed to convert: "
+
value
+
" to type: "
+
toType
.
getName
(
)
+
" due to: "
+
e
,
e
)
;
}
}
public
static
<
T
>
T
newInstance
(
Class
<
T
>
type
)
{
try
{
return
type
.
newInstance
(
)
;
}
catch
(
InstantiationException
e
)
{
throw
new
RuntimeCamelException
(
e
.
getCause
(
)
)
;
}
catch
(
IllegalAccessException
e
)
{
throw
new
RuntimeCamelException
(
e
)
;
}
}
public
static
<
T
>
T
newInstance
(
Class
<
?
>
actualType
,
Class
<
T
>
expectedType
)
{
try
{
Object
value
=
actualType
.
newInstance
(
)
;
return
cast
(
expectedType
,
value
)
;
}
catch
(
InstantiationException
e
)
{
throw
new
RuntimeCamelException
(
e
.
getCause
(
)
)
;
}
catch
(
IllegalAccessException
e
)
{
throw
new
RuntimeCamelException
(
e
)
;
}
}
public
static
boolean
isJavaIdentifier
(
String
name
)
{
if
(
name
==
null
)
{
return
false
;
}
int
size
=
name
.
length
(
)
;
if
(
size
<
1
)
{
return
false
;
}
if
(
Character
.
isJavaIdentifierStart
(
name
.
charAt
(
0
)
)
)
{
for
(
int
i
=
1
;
i
<
size
;
i
++
)
{
if
(
!
Character
.
isJavaIdentifierPart
(
name
.
charAt
(
i
)
)
)
{
return
false
;
}
}
return
true
;
}
return
false
;
}
public
static
Object
type
(
Object
bean
)
{
return
bean
!=
null
?
bean
.
getClass
(
)
:
null
;
}
public
static
boolean
evaluateValuePredicate
(
Object
value
)
{
if
(
value
instanceof
Boolean
)
{
Boolean
aBoolean
=
(
Boolean
)
value
;
return
aBoolean
.
booleanValue
(
)
;
}
return
value
!=
null
;
}
}
