package
org
.
apache
.
camel
.
builder
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
List
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
regex
.
Pattern
;
import
org
.
apache
.
camel
.
Exchange
;
import
org
.
apache
.
camel
.
Expression
;
import
org
.
apache
.
camel
.
Message
;
public
final
class
ExpressionBuilder
{
private
ExpressionBuilder
(
)
{
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
headerExpression
(
final
String
headerName
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
Object
header
=
exchange
.
getIn
(
)
.
getHeader
(
headerName
)
;
if
(
header
==
null
)
{
header
=
exchange
.
getProperty
(
headerName
)
;
}
return
header
;
}
@
Override
public
String
toString
(
)
{
return
"header("
+
headerName
+
")"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
headersExpression
(
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
.
getIn
(
)
.
getHeaders
(
)
;
}
@
Override
public
String
toString
(
)
{
return
"headers"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
outHeaderExpression
(
final
String
headerName
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
Message
out
=
exchange
.
getOut
(
false
)
;
if
(
out
==
null
)
{
return
null
;
}
Object
header
=
out
.
getHeader
(
headerName
)
;
if
(
header
==
null
)
{
header
=
exchange
.
getProperty
(
headerName
)
;
}
return
header
;
}
@
Override
public
String
toString
(
)
{
return
"outHeader("
+
headerName
+
")"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
outHeadersExpression
(
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
.
getOut
(
)
.
getHeaders
(
)
;
}
@
Override
public
String
toString
(
)
{
return
"outHeaders"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
propertyExpression
(
final
String
propertyName
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
.
getProperty
(
propertyName
)
;
}
@
Override
public
String
toString
(
)
{
return
"property("
+
propertyName
+
")"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
propertiesExpression
(
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
.
getProperties
(
)
;
}
@
Override
public
String
toString
(
)
{
return
"properties"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
systemPropertyExpression
(
final
String
propertyName
)
{
return
systemPropertyExpression
(
propertyName
,
null
)
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
systemPropertyExpression
(
final
String
propertyName
,
final
String
defaultValue
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
System
.
getProperty
(
propertyName
,
defaultValue
)
;
}
@
Override
public
String
toString
(
)
{
return
"systemProperty("
+
propertyName
+
")"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
constantExpression
(
final
Object
value
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
value
;
}
@
Override
public
String
toString
(
)
{
return
""
+
value
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
bodyExpression
(
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
.
getIn
(
)
.
getBody
(
)
;
}
@
Override
public
String
toString
(
)
{
return
"body"
;
}
}
;
}
public
static
<
E
extends
Exchange
,
T
>
Expression
<
E
>
bodyExpression
(
final
Class
<
T
>
type
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
.
getIn
(
)
.
getBody
(
type
)
;
}
@
Override
public
String
toString
(
)
{
return
"bodyAs["
+
type
.
getName
(
)
+
"]"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
outBodyExpression
(
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
Message
out
=
exchange
.
getOut
(
false
)
;
if
(
out
==
null
)
{
return
null
;
}
return
out
.
getBody
(
)
;
}
@
Override
public
String
toString
(
)
{
return
"outBody"
;
}
}
;
}
public
static
<
E
extends
Exchange
,
T
>
Expression
<
E
>
outBodyExpression
(
final
Class
<
T
>
type
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
Message
out
=
exchange
.
getOut
(
false
)
;
if
(
out
==
null
)
{
return
null
;
}
return
out
.
getBody
(
type
)
;
}
@
Override
public
String
toString
(
)
{
return
"outBodyAs["
+
type
.
getName
(
)
+
"]"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
faultBodyExpression
(
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
.
getFault
(
)
.
getBody
(
)
;
}
@
Override
public
String
toString
(
)
{
return
"faultBody"
;
}
}
;
}
public
static
<
E
extends
Exchange
,
T
>
Expression
<
E
>
faultBodyExpression
(
final
Class
<
T
>
type
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
.
getFault
(
)
.
getBody
(
type
)
;
}
@
Override
public
String
toString
(
)
{
return
"faultBodyAs["
+
type
.
getName
(
)
+
"]"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
exchangeExpression
(
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
;
}
@
Override
public
String
toString
(
)
{
return
"exchange"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
inMessageExpression
(
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
.
getIn
(
)
;
}
@
Override
public
String
toString
(
)
{
return
"inMessage"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
outMessageExpression
(
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
exchange
.
getOut
(
)
;
}
@
Override
public
String
toString
(
)
{
return
"outMessage"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
convertTo
(
final
Expression
expression
,
final
Class
type
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
Object
value
=
expression
.
evaluate
(
exchange
)
;
return
exchange
.
getContext
(
)
.
getTypeConverter
(
)
.
convertTo
(
type
,
value
)
;
}
@
Override
public
String
toString
(
)
{
return
""
+
expression
+
".convertTo("
+
type
.
getName
(
)
+
".class)"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
tokenizeExpression
(
final
Expression
<
E
>
expression
,
final
String
token
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
String
text
=
evaluateStringExpression
(
expression
,
exchange
)
;
if
(
text
==
null
)
{
return
null
;
}
StringTokenizer
iter
=
new
StringTokenizer
(
text
,
token
)
;
List
<
String
>
answer
=
new
ArrayList
<
String
>
(
)
;
while
(
iter
.
hasMoreTokens
(
)
)
{
answer
.
add
(
iter
.
nextToken
(
)
)
;
}
return
answer
;
}
@
Override
public
String
toString
(
)
{
return
"tokenize("
+
expression
+
", "
+
token
+
")"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
regexTokenize
(
final
Expression
<
E
>
expression
,
String
regexTokenizer
)
{
final
Pattern
pattern
=
Pattern
.
compile
(
regexTokenizer
)
;
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
String
text
=
evaluateStringExpression
(
expression
,
exchange
)
;
if
(
text
==
null
)
{
return
null
;
}
return
Arrays
.
asList
(
pattern
.
split
(
text
)
)
;
}
@
Override
public
String
toString
(
)
{
return
"regexTokenize("
+
expression
+
", "
+
pattern
.
pattern
(
)
+
")"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
regexReplaceAll
(
final
Expression
<
E
>
expression
,
String
regex
,
final
String
replacement
)
{
final
Pattern
pattern
=
Pattern
.
compile
(
regex
)
;
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
String
text
=
evaluateStringExpression
(
expression
,
exchange
)
;
if
(
text
==
null
)
{
return
null
;
}
return
pattern
.
matcher
(
text
)
.
replaceAll
(
replacement
)
;
}
@
Override
public
String
toString
(
)
{
return
"regexReplaceAll("
+
expression
+
", "
+
pattern
.
pattern
(
)
+
")"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
regexReplaceAll
(
final
Expression
<
E
>
expression
,
String
regex
,
final
Expression
<
E
>
replacementExpression
)
{
final
Pattern
pattern
=
Pattern
.
compile
(
regex
)
;
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
String
text
=
evaluateStringExpression
(
expression
,
exchange
)
;
String
replacement
=
evaluateStringExpression
(
replacementExpression
,
exchange
)
;
if
(
text
==
null
||
replacement
==
null
)
{
return
null
;
}
return
pattern
.
matcher
(
text
)
.
replaceAll
(
replacement
)
;
}
@
Override
public
String
toString
(
)
{
return
"regexReplaceAll("
+
expression
+
", "
+
pattern
.
pattern
(
)
+
")"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
append
(
final
Expression
<
E
>
left
,
final
Expression
<
E
>
right
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
evaluateStringExpression
(
left
,
exchange
)
+
evaluateStringExpression
(
right
,
exchange
)
;
}
@
Override
public
String
toString
(
)
{
return
"append("
+
left
+
", "
+
right
+
")"
;
}
}
;
}
public
static
<
E
extends
Exchange
>
String
evaluateStringExpression
(
Expression
<
E
>
expression
,
E
exchange
)
{
Object
value
=
expression
.
evaluate
(
exchange
)
;
return
exchange
.
getContext
(
)
.
getTypeConverter
(
)
.
convertTo
(
String
.
class
,
value
)
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
systemProperty
(
final
String
name
)
{
return
systemProperty
(
name
,
null
)
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
systemProperty
(
final
String
name
,
final
String
defaultValue
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
return
System
.
getProperty
(
name
,
defaultValue
)
;
}
}
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
concatExpression
(
final
Collection
<
Expression
>
expressions
)
{
return
concatExpression
(
expressions
,
null
)
;
}
public
static
<
E
extends
Exchange
>
Expression
<
E
>
concatExpression
(
final
Collection
<
Expression
>
expressions
,
final
String
expression
)
{
return
new
Expression
<
E
>
(
)
{
public
Object
evaluate
(
E
exchange
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
for
(
Expression
<
E
>
expression
:
expressions
)
{
String
text
=
evaluateStringExpression
(
expression
,
exchange
)
;
if
(
text
!=
null
)
{
buffer
.
append
(
text
)
;
}
}
return
buffer
.
toString
(
)
;
}
@
Override
public
String
toString
(
)
{
if
(
expression
!=
null
)
{
return
expression
;
}
else
{
return
"concat"
+
expressions
;
}
}
}
;
}
}
