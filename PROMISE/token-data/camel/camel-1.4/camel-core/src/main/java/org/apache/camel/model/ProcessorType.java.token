package
org
.
apache
.
camel
.
model
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
import
java
.
util
.
Set
;
import
java
.
util
.
concurrent
.
ThreadPoolExecutor
;
import
javax
.
xml
.
bind
.
annotation
.
XmlAccessType
;
import
javax
.
xml
.
bind
.
annotation
.
XmlAccessorType
;
import
javax
.
xml
.
bind
.
annotation
.
XmlAttribute
;
import
javax
.
xml
.
bind
.
annotation
.
XmlTransient
;
import
org
.
apache
.
camel
.
CamelContext
;
import
org
.
apache
.
camel
.
CamelException
;
import
org
.
apache
.
camel
.
Endpoint
;
import
org
.
apache
.
camel
.
Exchange
;
import
org
.
apache
.
camel
.
Expression
;
import
org
.
apache
.
camel
.
Predicate
;
import
org
.
apache
.
camel
.
Processor
;
import
org
.
apache
.
camel
.
Route
;
import
org
.
apache
.
camel
.
RuntimeCamelException
;
import
org
.
apache
.
camel
.
builder
.
DataFormatClause
;
import
org
.
apache
.
camel
.
builder
.
DeadLetterChannelBuilder
;
import
org
.
apache
.
camel
.
builder
.
ErrorHandlerBuilder
;
import
org
.
apache
.
camel
.
builder
.
ErrorHandlerBuilderRef
;
import
org
.
apache
.
camel
.
builder
.
ExpressionClause
;
import
org
.
apache
.
camel
.
builder
.
NoErrorHandlerBuilder
;
import
org
.
apache
.
camel
.
builder
.
ProcessorBuilder
;
import
org
.
apache
.
camel
.
impl
.
DefaultCamelContext
;
import
org
.
apache
.
camel
.
model
.
dataformat
.
DataFormatType
;
import
org
.
apache
.
camel
.
model
.
language
.
ExpressionType
;
import
org
.
apache
.
camel
.
model
.
language
.
LanguageExpression
;
import
org
.
apache
.
camel
.
processor
.
ConvertBodyProcessor
;
import
org
.
apache
.
camel
.
processor
.
DelegateProcessor
;
import
org
.
apache
.
camel
.
processor
.
Pipeline
;
import
org
.
apache
.
camel
.
processor
.
aggregate
.
AggregationCollection
;
import
org
.
apache
.
camel
.
processor
.
aggregate
.
AggregationStrategy
;
import
org
.
apache
.
camel
.
processor
.
idempotent
.
MessageIdRepository
;
import
org
.
apache
.
camel
.
spi
.
DataFormat
;
import
org
.
apache
.
camel
.
spi
.
ErrorHandlerWrappingStrategy
;
import
org
.
apache
.
camel
.
spi
.
InterceptStrategy
;
import
org
.
apache
.
camel
.
spi
.
Policy
;
import
org
.
apache
.
camel
.
spi
.
RouteContext
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
@
XmlAccessorType
(
XmlAccessType
.
PROPERTY
)
public
abstract
class
ProcessorType
<
Type
extends
ProcessorType
>
extends
OptionalIdentifiedType
<
Type
>
implements
Block
{
public
static
final
String
DEFAULT_TRACE_CATEGORY
=
"org.apache.camel.TRACE"
;
private
static
final
transient
Log
LOG
=
LogFactory
.
getLog
(
ProcessorType
.
class
)
;
private
ErrorHandlerBuilder
errorHandlerBuilder
;
private
Boolean
inheritErrorHandlerFlag
;
private
NodeFactory
nodeFactory
;
private
LinkedList
<
Block
>
blocks
=
new
LinkedList
<
Block
>
(
)
;
private
ProcessorType
<
?
extends
ProcessorType
>
parent
;
private
List
<
InterceptorType
>
interceptors
=
new
ArrayList
<
InterceptorType
>
(
)
;
private
String
errorHandlerRef
;
public
abstract
List
<
ProcessorType
<
?
>
>
getOutputs
(
)
;
public
Processor
createProcessor
(
RouteContext
routeContext
)
throws
Exception
{
throw
new
UnsupportedOperationException
(
"Not implemented yet for class: "
+
getClass
(
)
.
getName
(
)
)
;
}
public
Processor
createOutputsProcessor
(
RouteContext
routeContext
)
throws
Exception
{
Collection
<
ProcessorType
<
?
>
>
outputs
=
getOutputs
(
)
;
return
createOutputsProcessor
(
routeContext
,
outputs
)
;
}
public
void
addRoutes
(
RouteContext
routeContext
,
Collection
<
Route
>
routes
)
throws
Exception
{
Processor
processor
=
makeProcessor
(
routeContext
)
;
if
(
!
routeContext
.
isRouteAdded
(
)
)
{
routeContext
.
addEventDrivenProcessor
(
processor
)
;
}
}
public
Processor
wrapProcessor
(
RouteContext
routeContext
,
Processor
processor
)
throws
Exception
{
processor
=
wrapProcessorInInterceptors
(
routeContext
,
processor
)
;
return
wrapInErrorHandler
(
routeContext
,
processor
)
;
}
public
Type
to
(
String
uri
)
{
addOutput
(
new
ToType
(
uri
)
)
;
return
(
Type
)
this
;
}
public
Type
to
(
Endpoint
endpoint
)
{
addOutput
(
new
ToType
(
endpoint
)
)
;
return
(
Type
)
this
;
}
public
Type
to
(
String
...
uris
)
{
for
(
String
uri
:
uris
)
{
addOutput
(
new
ToType
(
uri
)
)
;
}
return
(
Type
)
this
;
}
public
Type
to
(
Endpoint
...
endpoints
)
{
for
(
Endpoint
endpoint
:
endpoints
)
{
addOutput
(
new
ToType
(
endpoint
)
)
;
}
return
(
Type
)
this
;
}
public
Type
to
(
Collection
<
Endpoint
>
endpoints
)
{
for
(
Endpoint
endpoint
:
endpoints
)
{
addOutput
(
new
ToType
(
endpoint
)
)
;
}
return
(
Type
)
this
;
}
public
MulticastType
multicast
(
)
{
MulticastType
answer
=
new
MulticastType
(
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
MulticastType
multicast
(
AggregationStrategy
aggregationStrategy
,
boolean
parallelProcessing
)
{
MulticastType
answer
=
new
MulticastType
(
)
;
addOutput
(
answer
)
;
answer
.
setAggregationStrategy
(
aggregationStrategy
)
;
answer
.
setParallelProcessing
(
parallelProcessing
)
;
return
answer
;
}
public
MulticastType
multicast
(
AggregationStrategy
aggregationStrategy
)
{
MulticastType
answer
=
new
MulticastType
(
)
;
addOutput
(
answer
)
;
answer
.
setAggregationStrategy
(
aggregationStrategy
)
;
return
answer
;
}
public
Type
pipeline
(
String
...
uris
)
{
return
to
(
uris
)
;
}
public
Type
pipeline
(
Endpoint
...
endpoints
)
{
return
to
(
endpoints
)
;
}
public
Type
pipeline
(
Collection
<
Endpoint
>
endpoints
)
{
return
to
(
endpoints
)
;
}
public
ProcessorType
<
?
extends
ProcessorType
>
end
(
)
{
if
(
blocks
.
isEmpty
(
)
)
{
if
(
parent
==
null
)
{
throw
new
IllegalArgumentException
(
"Root node with no active block"
)
;
}
return
parent
;
}
popBlock
(
)
;
return
this
;
}
public
ThreadType
thread
(
int
coreSize
)
{
ThreadType
answer
=
new
ThreadType
(
coreSize
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
ProcessorType
<
Type
>
thread
(
ThreadPoolExecutor
executor
)
{
ThreadType
answer
=
new
ThreadType
(
executor
)
;
addOutput
(
answer
)
;
return
this
;
}
public
IdempotentConsumerType
idempotentConsumer
(
Expression
messageIdExpression
,
MessageIdRepository
messageIdRepository
)
{
IdempotentConsumerType
answer
=
new
IdempotentConsumerType
(
messageIdExpression
,
messageIdRepository
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
ExpressionClause
<
IdempotentConsumerType
>
idempotentConsumer
(
MessageIdRepository
messageIdRepository
)
{
IdempotentConsumerType
answer
=
new
IdempotentConsumerType
(
)
;
answer
.
setMessageIdRepository
(
messageIdRepository
)
;
addOutput
(
answer
)
;
return
ExpressionClause
.
createAndSetExpression
(
answer
)
;
}
public
ExpressionClause
<
FilterType
>
filter
(
)
{
FilterType
filter
=
new
FilterType
(
)
;
addOutput
(
filter
)
;
return
ExpressionClause
.
createAndSetExpression
(
filter
)
;
}
public
FilterType
filter
(
Predicate
predicate
)
{
FilterType
filter
=
new
FilterType
(
predicate
)
;
addOutput
(
filter
)
;
return
filter
;
}
public
FilterType
filter
(
ExpressionType
expression
)
{
FilterType
filter
=
getNodeFactory
(
)
.
createFilter
(
)
;
filter
.
setExpression
(
expression
)
;
addOutput
(
filter
)
;
return
filter
;
}
public
FilterType
filter
(
String
language
,
String
expression
)
{
return
filter
(
new
LanguageExpression
(
language
,
expression
)
)
;
}
public
LoadBalanceType
loadBalance
(
)
{
LoadBalanceType
answer
=
new
LoadBalanceType
(
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
ChoiceType
choice
(
)
{
ChoiceType
answer
=
new
ChoiceType
(
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
TryType
tryBlock
(
)
{
TryType
answer
=
new
TryType
(
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
Type
recipientList
(
Expression
receipients
)
{
RecipientListType
answer
=
new
RecipientListType
(
receipients
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
ExpressionClause
<
ProcessorType
<
Type
>
>
recipientList
(
)
{
RecipientListType
answer
=
new
RecipientListType
(
)
;
addOutput
(
answer
)
;
ExpressionClause
<
ProcessorType
<
Type
>
>
clause
=
new
ExpressionClause
<
ProcessorType
<
Type
>
>
(
(
Type
)
this
)
;
answer
.
setExpression
(
clause
)
;
return
clause
;
}
public
Type
routingSlip
(
String
header
,
String
uriDelimiter
)
{
RoutingSlipType
answer
=
new
RoutingSlipType
(
header
,
uriDelimiter
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
routingSlip
(
String
header
)
{
RoutingSlipType
answer
=
new
RoutingSlipType
(
header
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
routingSlip
(
)
{
RoutingSlipType
answer
=
new
RoutingSlipType
(
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
SplitterType
splitter
(
Expression
receipients
)
{
SplitterType
answer
=
new
SplitterType
(
receipients
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
ExpressionClause
<
SplitterType
>
splitter
(
)
{
SplitterType
answer
=
new
SplitterType
(
)
;
addOutput
(
answer
)
;
return
ExpressionClause
.
createAndSetExpression
(
answer
)
;
}
public
SplitterType
splitter
(
Expression
partsExpression
,
AggregationStrategy
aggregationStrategy
)
{
SplitterType
answer
=
new
SplitterType
(
partsExpression
)
;
addOutput
(
answer
)
;
answer
.
setAggregationStrategy
(
aggregationStrategy
)
;
return
answer
;
}
public
ExpressionClause
<
SplitterType
>
splitter
(
AggregationStrategy
aggregationStrategy
)
{
SplitterType
answer
=
new
SplitterType
(
)
;
addOutput
(
answer
)
;
answer
.
setAggregationStrategy
(
aggregationStrategy
)
;
return
ExpressionClause
.
createAndSetExpression
(
answer
)
;
}
public
SplitterType
splitter
(
Expression
receipients
,
boolean
parallelProcessing
)
{
SplitterType
answer
=
new
SplitterType
(
receipients
)
;
addOutput
(
answer
)
;
answer
.
setParallelProcessing
(
parallelProcessing
)
;
return
answer
;
}
public
ExpressionClause
<
SplitterType
>
splitter
(
boolean
parallelProcessing
)
{
SplitterType
answer
=
new
SplitterType
(
)
;
addOutput
(
answer
)
;
answer
.
setParallelProcessing
(
parallelProcessing
)
;
return
ExpressionClause
.
createAndSetExpression
(
answer
)
;
}
public
SplitterType
splitter
(
Expression
partsExpression
,
AggregationStrategy
aggregationStrategy
,
boolean
parallelProcessing
)
{
SplitterType
answer
=
new
SplitterType
(
partsExpression
)
;
addOutput
(
answer
)
;
answer
.
setAggregationStrategy
(
aggregationStrategy
)
;
answer
.
setParallelProcessing
(
parallelProcessing
)
;
return
answer
;
}
public
ExpressionClause
<
SplitterType
>
splitter
(
AggregationStrategy
aggregationStrategy
,
boolean
parallelProcessing
)
{
SplitterType
answer
=
new
SplitterType
(
)
;
addOutput
(
answer
)
;
answer
.
setAggregationStrategy
(
aggregationStrategy
)
;
answer
.
setParallelProcessing
(
parallelProcessing
)
;
return
ExpressionClause
.
createAndSetExpression
(
answer
)
;
}
public
ExpressionClause
<
ResequencerType
>
resequencer
(
)
{
ResequencerType
answer
=
new
ResequencerType
(
)
;
addOutput
(
answer
)
;
ExpressionClause
<
ResequencerType
>
clause
=
new
ExpressionClause
<
ResequencerType
>
(
answer
)
;
answer
.
expression
(
clause
)
;
return
clause
;
}
public
ResequencerType
resequencer
(
Expression
<
Exchange
>
expression
)
{
return
resequencer
(
Collections
.
<
Expression
>
singletonList
(
expression
)
)
;
}
public
ResequencerType
resequencer
(
List
<
Expression
>
expressions
)
{
ResequencerType
answer
=
new
ResequencerType
(
expressions
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
ResequencerType
resequencer
(
Expression
...
expressions
)
{
List
<
Expression
>
list
=
new
ArrayList
<
Expression
>
(
)
;
list
.
addAll
(
Arrays
.
asList
(
expressions
)
)
;
return
resequencer
(
list
)
;
}
public
ExpressionClause
<
AggregatorType
>
aggregator
(
)
{
AggregatorType
answer
=
new
AggregatorType
(
)
;
addOutput
(
answer
)
;
return
ExpressionClause
.
createAndSetExpression
(
answer
)
;
}
public
ExpressionClause
<
AggregatorType
>
aggregator
(
AggregationStrategy
aggregationStrategy
)
{
AggregatorType
answer
=
new
AggregatorType
(
)
;
answer
.
setAggregationStrategy
(
aggregationStrategy
)
;
addOutput
(
answer
)
;
return
ExpressionClause
.
createAndSetExpression
(
answer
)
;
}
public
ExpressionClause
<
AggregatorType
>
aggregator
(
AggregationCollection
aggregationCollection
)
{
AggregatorType
answer
=
new
AggregatorType
(
)
;
answer
.
setAggregationCollection
(
aggregationCollection
)
;
addOutput
(
answer
)
;
return
ExpressionClause
.
createAndSetExpression
(
answer
)
;
}
public
AggregatorType
aggregator
(
Expression
correlationExpression
)
{
AggregatorType
answer
=
new
AggregatorType
(
correlationExpression
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
AggregatorType
aggregator
(
Expression
correlationExpression
,
AggregationStrategy
aggregationStrategy
)
{
AggregatorType
answer
=
new
AggregatorType
(
correlationExpression
,
aggregationStrategy
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
DelayerType
delayer
(
Expression
<
Exchange
>
processAtExpression
)
{
return
delayer
(
processAtExpression
,
0L
)
;
}
public
DelayerType
delayer
(
Expression
<
Exchange
>
processAtExpression
,
long
delay
)
{
DelayerType
answer
=
new
DelayerType
(
processAtExpression
,
delay
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
ExpressionClause
<
DelayerType
>
delayer
(
)
{
DelayerType
answer
=
new
DelayerType
(
)
;
addOutput
(
answer
)
;
return
ExpressionClause
.
createAndSetExpression
(
answer
)
;
}
public
DelayerType
delayer
(
long
delay
)
{
return
delayer
(
null
,
delay
)
;
}
public
ThrottlerType
throttler
(
long
maximumRequestCount
)
{
ThrottlerType
answer
=
new
ThrottlerType
(
maximumRequestCount
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
Type
throwFault
(
Throwable
fault
)
{
ThrowFaultType
answer
=
new
ThrowFaultType
(
)
;
answer
.
setFault
(
fault
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
throwFault
(
String
message
)
{
return
throwFault
(
new
CamelException
(
message
)
)
;
}
public
Type
interceptor
(
String
ref
)
{
InterceptorRef
interceptor
=
new
InterceptorRef
(
ref
)
;
intercept
(
interceptor
)
;
return
(
Type
)
this
;
}
public
Type
intercept
(
DelegateProcessor
interceptor
)
{
intercept
(
new
InterceptorRef
(
interceptor
)
)
;
return
(
Type
)
this
;
}
public
InterceptType
intercept
(
)
{
InterceptType
answer
=
new
InterceptType
(
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
void
intercept
(
InterceptorType
interceptor
)
{
addOutput
(
interceptor
)
;
pushBlock
(
interceptor
)
;
}
public
void
addInterceptor
(
InterceptorType
interceptor
)
{
interceptors
.
add
(
interceptor
)
;
}
public
void
addInterceptor
(
DelegateProcessor
interceptor
)
{
addInterceptor
(
new
InterceptorRef
(
interceptor
)
)
;
}
protected
void
pushBlock
(
Block
block
)
{
blocks
.
add
(
block
)
;
}
protected
Block
popBlock
(
)
{
return
blocks
.
isEmpty
(
)
?
null
:
blocks
.
removeLast
(
)
;
}
public
Type
proceed
(
)
{
ProceedType
proceed
=
null
;
ProcessorType
currentProcessor
=
this
;
if
(
currentProcessor
instanceof
InterceptType
)
{
proceed
=
(
(
InterceptType
)
currentProcessor
)
.
getProceed
(
)
;
LOG
.
info
(
"proceed() is the implied and hence not needed for an intercept()"
)
;
}
if
(
proceed
==
null
)
{
for
(
ProcessorType
node
=
parent
;
node
!=
null
;
node
=
node
.
getParent
(
)
)
{
if
(
node
instanceof
InterceptType
)
{
InterceptType
intercept
=
(
InterceptType
)
node
;
proceed
=
intercept
.
getProceed
(
)
;
break
;
}
}
if
(
proceed
==
null
)
{
throw
new
IllegalArgumentException
(
"Cannot use proceed() without being within an intercept() block"
)
;
}
}
addOutput
(
proceed
)
;
return
(
Type
)
this
;
}
public
Type
stop
(
)
{
ProcessorType
currentProcessor
=
this
;
if
(
currentProcessor
instanceof
InterceptType
)
{
(
(
InterceptType
)
currentProcessor
)
.
stopIntercept
(
)
;
}
else
{
ProcessorType
node
;
for
(
node
=
parent
;
node
!=
null
;
node
=
node
.
getParent
(
)
)
{
if
(
node
instanceof
InterceptType
)
{
(
(
InterceptType
)
node
)
.
stopIntercept
(
)
;
break
;
}
}
if
(
node
==
null
)
{
throw
new
IllegalArgumentException
(
"Cannot use stop() without being within an intercept() block"
)
;
}
}
return
(
Type
)
this
;
}
public
ExceptionType
exception
(
Class
exceptionType
)
{
ExceptionType
answer
=
new
ExceptionType
(
exceptionType
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
ChoiceType
intercept
(
Predicate
predicate
)
{
InterceptType
answer
=
new
InterceptType
(
)
;
addOutput
(
answer
)
;
return
answer
.
when
(
predicate
)
;
}
public
Type
interceptors
(
String
...
refs
)
{
for
(
String
ref
:
refs
)
{
interceptor
(
ref
)
;
}
return
(
Type
)
this
;
}
public
Type
trace
(
)
{
return
trace
(
DEFAULT_TRACE_CATEGORY
)
;
}
public
Type
trace
(
String
category
)
{
final
Log
log
=
LogFactory
.
getLog
(
category
)
;
return
intercept
(
new
DelegateProcessor
(
)
{
@
Override
public
void
process
(
Exchange
exchange
)
throws
Exception
{
log
.
trace
(
exchange
)
;
processNext
(
exchange
)
;
}
}
)
;
}
public
PolicyRef
policies
(
)
{
PolicyRef
answer
=
new
PolicyRef
(
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
PolicyRef
policy
(
Policy
policy
)
{
PolicyRef
answer
=
new
PolicyRef
(
policy
)
;
addOutput
(
answer
)
;
return
answer
;
}
public
Type
handleFault
(
)
{
intercept
(
new
HandleFaultType
(
)
)
;
return
(
Type
)
this
;
}
public
Type
errorHandler
(
ErrorHandlerBuilder
errorHandlerBuilder
)
{
setErrorHandlerBuilder
(
errorHandlerBuilder
)
;
return
(
Type
)
this
;
}
public
Type
inheritErrorHandler
(
boolean
condition
)
{
setInheritErrorHandlerFlag
(
condition
)
;
return
(
Type
)
this
;
}
public
Type
process
(
Processor
processor
)
{
ProcessorRef
answer
=
new
ProcessorRef
(
processor
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
processRef
(
String
ref
)
{
ProcessorRef
answer
=
new
ProcessorRef
(
)
;
answer
.
setRef
(
ref
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
bean
(
Object
bean
)
{
BeanRef
answer
=
new
BeanRef
(
)
;
answer
.
setBean
(
bean
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
bean
(
Object
bean
,
String
method
)
{
BeanRef
answer
=
new
BeanRef
(
)
;
answer
.
setBean
(
bean
)
;
answer
.
setMethod
(
method
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
bean
(
Class
beanType
)
{
BeanRef
answer
=
new
BeanRef
(
)
;
answer
.
setBeanType
(
beanType
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
bean
(
Class
beanType
,
String
method
)
{
BeanRef
answer
=
new
BeanRef
(
)
;
answer
.
setBeanType
(
beanType
)
;
answer
.
setMethod
(
method
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
beanRef
(
String
ref
)
{
BeanRef
answer
=
new
BeanRef
(
ref
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
beanRef
(
String
ref
,
String
method
)
{
BeanRef
answer
=
new
BeanRef
(
ref
,
method
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
ExpressionClause
<
ProcessorType
<
Type
>
>
setBody
(
)
{
ExpressionClause
<
ProcessorType
<
Type
>
>
clause
=
new
ExpressionClause
<
ProcessorType
<
Type
>
>
(
(
Type
)
this
)
;
SetBodyType
answer
=
new
SetBodyType
(
clause
)
;
addOutput
(
answer
)
;
return
clause
;
}
public
Type
setBody
(
Expression
expression
)
{
SetBodyType
answer
=
new
SetBodyType
(
expression
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
@
Deprecated
public
Type
setOutBody
(
Expression
expression
)
{
return
transform
(
expression
)
;
}
@
Deprecated
public
ExpressionClause
<
ProcessorType
<
Type
>
>
setOutBody
(
)
{
return
transform
(
)
;
}
public
Type
transform
(
Expression
expression
)
{
TransformType
answer
=
new
TransformType
(
expression
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
ExpressionClause
<
ProcessorType
<
Type
>
>
transform
(
)
{
ExpressionClause
<
ProcessorType
<
Type
>
>
clause
=
new
ExpressionClause
<
ProcessorType
<
Type
>
>
(
(
Type
)
this
)
;
TransformType
answer
=
new
TransformType
(
clause
)
;
addOutput
(
answer
)
;
return
clause
;
}
public
Type
setFaultBody
(
Expression
expression
)
{
return
process
(
ProcessorBuilder
.
setFaultBody
(
expression
)
)
;
}
public
ExpressionClause
<
ProcessorType
<
Type
>
>
setHeader
(
String
name
)
{
ExpressionClause
<
ProcessorType
<
Type
>
>
clause
=
new
ExpressionClause
<
ProcessorType
<
Type
>
>
(
(
Type
)
this
)
;
SetHeaderType
answer
=
new
SetHeaderType
(
name
,
clause
)
;
addOutput
(
answer
)
;
return
clause
;
}
public
Type
setHeader
(
String
name
,
Expression
expression
)
{
SetHeaderType
answer
=
new
SetHeaderType
(
name
,
expression
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
Type
setHeader
(
String
name
,
String
value
)
{
SetHeaderType
answer
=
new
SetHeaderType
(
name
,
value
)
;
addOutput
(
answer
)
;
return
(
Type
)
this
;
}
public
ExpressionClause
<
ProcessorType
<
Type
>
>
setOutHeader
(
String
name
)
{
ExpressionClause
<
ProcessorType
<
Type
>
>
clause
=
new
ExpressionClause
<
ProcessorType
<
Type
>
>
(
(
Type
)
this
)
;
process
(
ProcessorBuilder
.
setOutHeader
(
name
,
clause
)
)
;
return
clause
;
}
public
Type
setOutHeader
(
String
name
,
Expression
expression
)
{
return
process
(
ProcessorBuilder
.
setOutHeader
(
name
,
expression
)
)
;
}
public
Type
setOutHeader
(
String
name
,
String
value
)
{
return
(
Type
)
setOutHeader
(
name
)
.
constant
(
value
)
;
}
public
Type
setFaultHeader
(
String
name
,
Expression
expression
)
{
return
process
(
ProcessorBuilder
.
setFaultHeader
(
name
,
expression
)
)
;
}
public
Type
setProperty
(
String
name
,
Expression
expression
)
{
return
process
(
ProcessorBuilder
.
setProperty
(
name
,
expression
)
)
;
}
public
ExpressionClause
<
ProcessorType
<
Type
>
>
setProperty
(
String
name
)
{
ExpressionClause
<
ProcessorType
<
Type
>
>
clause
=
new
ExpressionClause
<
ProcessorType
<
Type
>
>
(
(
Type
)
this
)
;
process
(
ProcessorBuilder
.
setProperty
(
name
,
clause
)
)
;
return
clause
;
}
public
Type
removeHeader
(
String
name
)
{
return
process
(
ProcessorBuilder
.
removeHeader
(
name
)
)
;
}
public
Type
removeOutHeader
(
String
name
)
{
return
process
(
ProcessorBuilder
.
removeOutHeader
(
name
)
)
;
}
public
Type
removeFaultHeader
(
String
name
)
{
return
process
(
ProcessorBuilder
.
removeFaultHeader
(
name
)
)
;
}
public
Type
removeProperty
(
String
name
)
{
return
process
(
ProcessorBuilder
.
removeProperty
(
name
)
)
;
}
public
Type
convertBodyTo
(
Class
type
)
{
addOutput
(
new
ConvertBodyType
(
type
)
)
;
return
(
Type
)
this
;
}
@
Deprecated
public
Type
convertOutBodyTo
(
Class
type
)
{
return
process
(
new
ConvertBodyProcessor
(
type
)
)
;
}
@
Deprecated
public
Type
convertFaultBodyTo
(
Class
type
)
{
return
process
(
new
ConvertBodyProcessor
(
type
)
)
;
}
public
DataFormatClause
<
ProcessorType
<
Type
>
>
unmarshal
(
)
{
return
new
DataFormatClause
<
ProcessorType
<
Type
>
>
(
this
,
DataFormatClause
.
Operation
.
Unmarshal
)
;
}
public
Type
unmarshal
(
DataFormatType
dataFormatType
)
{
addOutput
(
new
UnmarshalType
(
dataFormatType
)
)
;
return
(
Type
)
this
;
}
public
Type
unmarshal
(
DataFormat
dataFormat
)
{
return
unmarshal
(
new
DataFormatType
(
dataFormat
)
)
;
}
public
Type
unmarshal
(
String
dataTypeRef
)
{
addOutput
(
new
UnmarshalType
(
dataTypeRef
)
)
;
return
(
Type
)
this
;
}
public
DataFormatClause
<
ProcessorType
<
Type
>
>
marshal
(
)
{
return
new
DataFormatClause
<
ProcessorType
<
Type
>
>
(
this
,
DataFormatClause
.
Operation
.
Marshal
)
;
}
public
Type
marshal
(
DataFormatType
dataFormatType
)
{
addOutput
(
new
MarshalType
(
dataFormatType
)
)
;
return
(
Type
)
this
;
}
public
Type
marshal
(
DataFormat
dataFormat
)
{
return
marshal
(
new
DataFormatType
(
dataFormat
)
)
;
}
public
Type
marshal
(
String
dataTypeRef
)
{
addOutput
(
new
MarshalType
(
dataTypeRef
)
)
;
return
(
Type
)
this
;
}
@
XmlTransient
public
ProcessorType
<
?
extends
ProcessorType
>
getParent
(
)
{
return
parent
;
}
public
void
setParent
(
ProcessorType
<
?
extends
ProcessorType
>
parent
)
{
this
.
parent
=
parent
;
}
@
XmlTransient
public
ErrorHandlerBuilder
getErrorHandlerBuilder
(
)
{
if
(
errorHandlerBuilder
==
null
)
{
errorHandlerBuilder
=
createErrorHandlerBuilder
(
)
;
}
return
errorHandlerBuilder
;
}
public
void
setErrorHandlerBuilder
(
ErrorHandlerBuilder
errorHandlerBuilder
)
{
this
.
errorHandlerBuilder
=
errorHandlerBuilder
;
}
protected
void
setErrorHandlerBuilderIfNull
(
ErrorHandlerBuilder
errorHandlerBuilder
)
{
if
(
this
.
errorHandlerBuilder
==
null
)
{
setErrorHandlerBuilder
(
errorHandlerBuilder
)
;
}
}
public
String
getErrorHandlerRef
(
)
{
return
errorHandlerRef
;
}
@
XmlAttribute
(
required
=
false
)
public
void
setErrorHandlerRef
(
String
errorHandlerRef
)
{
this
.
errorHandlerRef
=
errorHandlerRef
;
setErrorHandlerBuilder
(
new
ErrorHandlerBuilderRef
(
errorHandlerRef
)
)
;
}
@
XmlTransient
public
boolean
isInheritErrorHandler
(
)
{
return
isInheritErrorHandler
(
getInheritErrorHandlerFlag
(
)
)
;
}
public
static
boolean
isInheritErrorHandler
(
Boolean
value
)
{
return
value
==
null
||
value
.
booleanValue
(
)
;
}
@
XmlAttribute
(
name
=
"inheritErrorHandler"
,
required
=
false
)
public
Boolean
getInheritErrorHandlerFlag
(
)
{
return
inheritErrorHandlerFlag
;
}
public
void
setInheritErrorHandlerFlag
(
Boolean
inheritErrorHandlerFlag
)
{
this
.
inheritErrorHandlerFlag
=
inheritErrorHandlerFlag
;
}
@
XmlTransient
public
NodeFactory
getNodeFactory
(
)
{
if
(
nodeFactory
==
null
)
{
nodeFactory
=
new
NodeFactory
(
)
;
}
return
nodeFactory
;
}
public
void
setNodeFactory
(
NodeFactory
nodeFactory
)
{
this
.
nodeFactory
=
nodeFactory
;
}
public
String
getLabel
(
)
{
return
""
;
}
protected
Processor
makeProcessor
(
RouteContext
routeContext
)
throws
Exception
{
Processor
processor
=
createProcessor
(
routeContext
)
;
return
wrapProcessor
(
routeContext
,
processor
)
;
}
protected
Processor
wrapProcessorInInterceptors
(
RouteContext
routeContext
,
Processor
target
)
throws
Exception
{
if
(
target
==
null
)
{
throw
new
RuntimeCamelException
(
"target not provided."
)
;
}
List
<
InterceptStrategy
>
strategies
=
new
ArrayList
<
InterceptStrategy
>
(
)
;
CamelContext
camelContext
=
routeContext
.
getCamelContext
(
)
;
if
(
camelContext
instanceof
DefaultCamelContext
)
{
DefaultCamelContext
defaultCamelContext
=
(
DefaultCamelContext
)
camelContext
;
strategies
.
addAll
(
defaultCamelContext
.
getInterceptStrategies
(
)
)
;
}
strategies
.
addAll
(
routeContext
.
getInterceptStrategies
(
)
)
;
for
(
InterceptStrategy
strategy
:
strategies
)
{
if
(
strategy
!=
null
)
{
target
=
strategy
.
wrapProcessorInInterceptors
(
this
,
target
)
;
}
}
List
<
InterceptorType
>
list
=
routeContext
.
getRoute
(
)
.
getInterceptors
(
)
;
if
(
interceptors
!=
null
)
{
list
.
addAll
(
interceptors
)
;
}
Collections
.
reverse
(
list
)
;
Set
<
Processor
>
interceptors
=
new
HashSet
<
Processor
>
(
)
;
interceptors
.
add
(
target
)
;
for
(
InterceptorType
interceptorType
:
list
)
{
DelegateProcessor
interceptor
=
interceptorType
.
createInterceptor
(
routeContext
)
;
if
(
!
interceptors
.
contains
(
interceptor
)
)
{
interceptors
.
add
(
interceptor
)
;
if
(
interceptor
.
getProcessor
(
)
!=
null
)
{
LOG
.
warn
(
"Interceptor "
+
interceptor
+
" currently wraps target "
+
interceptor
.
getProcessor
(
)
+
" is attempting to change target "
+
target
+
" new wrapping has been denied."
)
;
}
else
{
interceptor
.
setProcessor
(
target
)
;
target
=
interceptor
;
}
}
}
return
target
;
}
protected
Processor
wrapInErrorHandler
(
RouteContext
routeContext
,
Processor
target
)
throws
Exception
{
if
(
target
==
null
)
{
throw
new
RuntimeCamelException
(
"target not provided."
)
;
}
ErrorHandlerWrappingStrategy
strategy
=
routeContext
.
getErrorHandlerWrappingStrategy
(
)
;
if
(
strategy
!=
null
)
{
return
strategy
.
wrapProcessorInErrorHandler
(
routeContext
,
this
,
target
)
;
}
return
getErrorHandlerBuilder
(
)
.
createErrorHandler
(
routeContext
,
target
)
;
}
protected
ErrorHandlerBuilder
createErrorHandlerBuilder
(
)
{
if
(
errorHandlerRef
!=
null
)
{
return
new
ErrorHandlerBuilderRef
(
errorHandlerRef
)
;
}
if
(
isInheritErrorHandler
(
)
)
{
return
new
DeadLetterChannelBuilder
(
)
;
}
else
{
return
new
NoErrorHandlerBuilder
(
)
;
}
}
protected
void
configureChild
(
ProcessorType
output
)
{
output
.
setNodeFactory
(
getNodeFactory
(
)
)
;
}
public
void
addOutput
(
ProcessorType
processorType
)
{
processorType
.
setParent
(
this
)
;
configureChild
(
processorType
)
;
if
(
blocks
.
isEmpty
(
)
)
{
getOutputs
(
)
.
add
(
processorType
)
;
}
else
{
Block
block
=
blocks
.
getLast
(
)
;
block
.
addOutput
(
processorType
)
;
}
}
protected
Processor
createCompositeProcessor
(
List
<
Processor
>
list
)
{
return
new
Pipeline
(
list
)
;
}
protected
Processor
createOutputsProcessor
(
RouteContext
routeContext
,
Collection
<
ProcessorType
<
?
>
>
outputs
)
throws
Exception
{
List
<
Processor
>
list
=
new
ArrayList
<
Processor
>
(
)
;
for
(
ProcessorType
output
:
outputs
)
{
Processor
processor
=
output
.
createProcessor
(
routeContext
)
;
processor
=
output
.
wrapProcessorInInterceptors
(
routeContext
,
processor
)
;
ProcessorType
currentProcessor
=
this
;
if
(
!
(
currentProcessor
instanceof
ExceptionType
||
currentProcessor
instanceof
TryType
)
)
{
processor
=
output
.
wrapInErrorHandler
(
routeContext
,
processor
)
;
}
list
.
add
(
processor
)
;
}
Processor
processor
=
null
;
if
(
!
list
.
isEmpty
(
)
)
{
if
(
list
.
size
(
)
==
1
)
{
processor
=
list
.
get
(
0
)
;
}
else
{
processor
=
createCompositeProcessor
(
list
)
;
}
}
return
processor
;
}
public
void
clearOutput
(
)
{
getOutputs
(
)
.
clear
(
)
;
blocks
.
clear
(
)
;
}
}
