package
org
.
apache
.
camel
.
component
.
mock
;
import
java
.
beans
.
PropertyChangeListener
;
import
java
.
beans
.
PropertyChangeSupport
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
import
java
.
util
.
concurrent
.
CopyOnWriteArrayList
;
import
java
.
util
.
concurrent
.
CountDownLatch
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
org
.
apache
.
camel
.
CamelContext
;
import
org
.
apache
.
camel
.
Component
;
import
org
.
apache
.
camel
.
Consumer
;
import
org
.
apache
.
camel
.
Endpoint
;
import
org
.
apache
.
camel
.
Exchange
;
import
org
.
apache
.
camel
.
Expression
;
import
org
.
apache
.
camel
.
Message
;
import
org
.
apache
.
camel
.
Processor
;
import
org
.
apache
.
camel
.
Producer
;
import
org
.
apache
.
camel
.
impl
.
DefaultEndpoint
;
import
org
.
apache
.
camel
.
impl
.
DefaultProducer
;
import
org
.
apache
.
camel
.
spi
.
BrowsableEndpoint
;
import
org
.
apache
.
camel
.
util
.
CamelContextHelper
;
import
org
.
apache
.
camel
.
util
.
ExpressionComparator
;
import
org
.
apache
.
camel
.
util
.
ObjectHelper
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
public
class
MockEndpoint
extends
DefaultEndpoint
<
Exchange
>
implements
BrowsableEndpoint
<
Exchange
>
{
private
static
final
transient
Log
LOG
=
LogFactory
.
getLog
(
MockEndpoint
.
class
)
;
private
int
expectedCount
;
private
int
counter
;
private
Processor
defaultProcessor
;
private
Map
<
Integer
,
Processor
>
processors
;
private
List
<
Exchange
>
receivedExchanges
;
private
List
<
Throwable
>
failures
;
private
List
<
Runnable
>
tests
;
private
CountDownLatch
latch
;
private
long
sleepForEmptyTest
;
private
long
resultWaitTime
;
private
long
resultMinimumWaitTime
;
private
int
expectedMinimumCount
;
private
List
expectedBodyValues
;
private
List
actualBodyValues
;
private
PropertyChangeSupport
propertyChangeSupport
=
new
PropertyChangeSupport
(
this
)
;
private
String
headerName
;
private
String
headerValue
;
private
Object
actualHeader
;
private
Processor
reporter
;
public
MockEndpoint
(
String
endpointUri
,
Component
component
)
{
super
(
endpointUri
,
component
)
;
init
(
)
;
}
public
MockEndpoint
(
String
endpointUri
)
{
super
(
endpointUri
)
;
init
(
)
;
}
public
static
MockEndpoint
resolve
(
CamelContext
context
,
String
uri
)
{
return
CamelContextHelper
.
getMandatoryEndpoint
(
context
,
uri
,
MockEndpoint
.
class
)
;
}
public
static
void
assertWait
(
long
timeout
,
TimeUnit
unit
,
MockEndpoint
...
endpoints
)
throws
InterruptedException
{
long
start
=
System
.
currentTimeMillis
(
)
;
long
left
=
unit
.
toMillis
(
timeout
)
;
long
end
=
start
+
left
;
for
(
MockEndpoint
endpoint
:
endpoints
)
{
if
(
!
endpoint
.
await
(
left
,
TimeUnit
.
MILLISECONDS
)
)
{
throw
new
AssertionError
(
"Timeout waiting for endpoints to receive enough messages. "
+
endpoint
.
getEndpointUri
(
)
+
" timed out."
)
;
}
left
=
end
-
System
.
currentTimeMillis
(
)
;
if
(
left
<=
0
)
{
left
=
0
;
}
}
}
public
static
void
assertIsSatisfied
(
long
timeout
,
TimeUnit
unit
,
MockEndpoint
...
endpoints
)
throws
InterruptedException
{
assertWait
(
timeout
,
unit
,
endpoints
)
;
for
(
MockEndpoint
endpoint
:
endpoints
)
{
endpoint
.
assertIsSatisfied
(
)
;
}
}
public
static
void
assertIsSatisfied
(
MockEndpoint
...
endpoints
)
throws
InterruptedException
{
for
(
MockEndpoint
endpoint
:
endpoints
)
{
endpoint
.
assertIsSatisfied
(
)
;
}
}
public
static
void
assertIsSatisfied
(
CamelContext
context
)
throws
InterruptedException
{
ObjectHelper
.
notNull
(
context
,
"camelContext"
)
;
Collection
<
Endpoint
>
endpoints
=
context
.
getSingletonEndpoints
(
)
;
for
(
Endpoint
endpoint
:
endpoints
)
{
if
(
endpoint
instanceof
MockEndpoint
)
{
MockEndpoint
mockEndpoint
=
(
MockEndpoint
)
endpoint
;
mockEndpoint
.
assertIsSatisfied
(
)
;
}
}
}
public
static
void
expectsMessageCount
(
int
count
,
MockEndpoint
...
endpoints
)
throws
InterruptedException
{
for
(
MockEndpoint
endpoint
:
endpoints
)
{
MockEndpoint
.
expectsMessageCount
(
count
)
;
}
}
public
List
<
Exchange
>
getExchanges
(
)
{
return
getReceivedExchanges
(
)
;
}
public
void
addPropertyChangeListener
(
PropertyChangeListener
listener
)
{
propertyChangeSupport
.
addPropertyChangeListener
(
listener
)
;
}
public
void
removePropertyChangeListener
(
PropertyChangeListener
listener
)
{
propertyChangeSupport
.
removePropertyChangeListener
(
listener
)
;
}
public
Consumer
<
Exchange
>
createConsumer
(
Processor
processor
)
throws
Exception
{
throw
new
UnsupportedOperationException
(
"You cannot consume from this endpoint"
)
;
}
public
Producer
<
Exchange
>
createProducer
(
)
throws
Exception
{
return
new
DefaultProducer
<
Exchange
>
(
this
)
{
public
void
process
(
Exchange
exchange
)
{
onExchange
(
exchange
)
;
}
}
;
}
public
void
reset
(
)
{
init
(
)
;
}
public
void
whenExchangeReceived
(
int
index
,
Processor
processor
)
{
this
.
processors
.
put
(
index
,
processor
)
;
}
public
void
whenAnyExchangeReceived
(
Processor
processor
)
{
this
.
defaultProcessor
=
processor
;
}
public
void
assertIsSatisfied
(
)
throws
InterruptedException
{
assertIsSatisfied
(
sleepForEmptyTest
)
;
}
public
void
assertIsSatisfied
(
long
timeoutForEmptyEndpoints
)
throws
InterruptedException
{
LOG
.
info
(
"Asserting: "
+
this
+
" is satisfied"
)
;
if
(
expectedCount
==
0
)
{
if
(
timeoutForEmptyEndpoints
>
0
)
{
LOG
.
debug
(
"Sleeping for: "
+
timeoutForEmptyEndpoints
+
" millis to check there really are no messages received"
)
;
Thread
.
sleep
(
timeoutForEmptyEndpoints
)
;
}
assertEquals
(
"Received message count"
,
expectedCount
,
getReceivedCounter
(
)
)
;
}
else
if
(
expectedCount
>
0
)
{
if
(
expectedCount
!=
getReceivedCounter
(
)
)
{
waitForCompleteLatch
(
)
;
}
assertEquals
(
"Received message count"
,
expectedCount
,
getReceivedCounter
(
)
)
;
}
else
if
(
expectedMinimumCount
>
0
&&
getReceivedCounter
(
)
<
expectedMinimumCount
)
{
waitForCompleteLatch
(
)
;
}
if
(
expectedMinimumCount
>=
0
)
{
int
receivedCounter
=
getReceivedCounter
(
)
;
assertTrue
(
"Received message count "
+
receivedCounter
+
", expected at least "
+
expectedMinimumCount
,
expectedMinimumCount
<=
receivedCounter
)
;
}
for
(
Runnable
test
:
tests
)
{
test
.
run
(
)
;
}
for
(
Throwable
failure
:
failures
)
{
if
(
failure
!=
null
)
{
LOG
.
error
(
"Caught on "
+
getEndpointUri
(
)
+
" Exception: "
+
failure
,
failure
)
;
fail
(
"Failed due to caught exception: "
+
failure
)
;
}
}
}
public
void
assertIsNotSatisfied
(
)
throws
InterruptedException
{
try
{
assertIsSatisfied
(
)
;
fail
(
"Expected assertion failure!"
)
;
}
catch
(
AssertionError
e
)
{
LOG
.
info
(
"Caught expected failure: "
+
e
)
;
}
}
public
void
expectedMessageCount
(
int
expectedCount
)
{
setExpectedMessageCount
(
expectedCount
)
;
}
public
void
expectedMinimumMessageCount
(
int
expectedCount
)
{
setMinimumExpectedMessageCount
(
expectedCount
)
;
}
public
void
expectedHeaderReceived
(
String
name
,
String
value
)
{
this
.
headerName
=
name
;
this
.
headerValue
=
value
;
expects
(
new
Runnable
(
)
{
public
void
run
(
)
{
assertTrue
(
"No header with name "
+
headerName
+
" found."
,
actualHeader
!=
null
)
;
assertEquals
(
"Header of message"
,
headerValue
,
actualHeader
)
;
}
}
)
;
}
public
void
expectedBodiesReceived
(
final
List
bodies
)
{
expectedMessageCount
(
bodies
.
size
(
)
)
;
this
.
expectedBodyValues
=
bodies
;
this
.
actualBodyValues
=
new
ArrayList
(
)
;
expects
(
new
Runnable
(
)
{
public
void
run
(
)
{
for
(
int
i
=
0
;
i
<
expectedBodyValues
.
size
(
)
;
i
++
)
{
Exchange
exchange
=
getReceivedExchanges
(
)
.
get
(
i
)
;
assertTrue
(
"No exchange received for counter: "
+
i
,
exchange
!=
null
)
;
Object
expectedBody
=
expectedBodyValues
.
get
(
i
)
;
Object
actualBody
=
null
;
if
(
i
<
actualBodyValues
.
size
(
)
)
{
actualBody
=
actualBodyValues
.
get
(
i
)
;
}
assertEquals
(
"Body of message: "
+
i
,
expectedBody
,
actualBody
)
;
}
}
}
)
;
}
public
void
expectedBodiesReceived
(
Object
...
bodies
)
{
List
bodyList
=
new
ArrayList
(
)
;
bodyList
.
addAll
(
Arrays
.
asList
(
bodies
)
)
;
expectedBodiesReceived
(
bodyList
)
;
}
public
void
expectedBodiesReceivedInAnyOrder
(
final
List
bodies
)
{
expectedMessageCount
(
bodies
.
size
(
)
)
;
this
.
expectedBodyValues
=
bodies
;
this
.
actualBodyValues
=
new
ArrayList
(
)
;
expects
(
new
Runnable
(
)
{
public
void
run
(
)
{
Set
actualBodyValuesSet
=
new
HashSet
(
actualBodyValues
)
;
for
(
int
i
=
0
;
i
<
expectedBodyValues
.
size
(
)
;
i
++
)
{
Exchange
exchange
=
getReceivedExchanges
(
)
.
get
(
i
)
;
assertTrue
(
"No exchange received for counter: "
+
i
,
exchange
!=
null
)
;
Object
expectedBody
=
expectedBodyValues
.
get
(
i
)
;
assertTrue
(
"Message with body "
+
expectedBody
+
" was expected but not found in "
+
actualBodyValuesSet
,
actualBodyValuesSet
.
remove
(
expectedBody
)
)
;
}
}
}
)
;
}
public
void
expectedBodiesReceivedInAnyOrder
(
Object
...
bodies
)
{
List
bodyList
=
new
ArrayList
(
)
;
bodyList
.
addAll
(
Arrays
.
asList
(
bodies
)
)
;
expectedBodiesReceivedInAnyOrder
(
bodyList
)
;
}
public
void
expectsAscending
(
final
Expression
<
Exchange
>
expression
)
{
expects
(
new
Runnable
(
)
{
public
void
run
(
)
{
assertMessagesAscending
(
expression
)
;
}
}
)
;
}
public
void
expectsDescending
(
final
Expression
<
Exchange
>
expression
)
{
expects
(
new
Runnable
(
)
{
public
void
run
(
)
{
assertMessagesDescending
(
expression
)
;
}
}
)
;
}
public
void
expectsNoDuplicates
(
final
Expression
<
Exchange
>
expression
)
{
expects
(
new
Runnable
(
)
{
public
void
run
(
)
{
assertNoDuplicates
(
expression
)
;
}
}
)
;
}
public
void
assertMessagesAscending
(
Expression
<
Exchange
>
expression
)
{
assertMessagesSorted
(
expression
,
true
)
;
}
public
void
assertMessagesDescending
(
Expression
<
Exchange
>
expression
)
{
assertMessagesSorted
(
expression
,
false
)
;
}
protected
void
assertMessagesSorted
(
Expression
<
Exchange
>
expression
,
boolean
ascending
)
{
String
type
=
ascending
?
"ascending"
:
"descending"
;
ExpressionComparator
comparator
=
new
ExpressionComparator
(
expression
)
;
List
<
Exchange
>
list
=
getReceivedExchanges
(
)
;
for
(
int
i
=
1
;
i
<
list
.
size
(
)
;
i
++
)
{
int
j
=
i
-
1
;
Exchange
e1
=
list
.
get
(
j
)
;
Exchange
e2
=
list
.
get
(
i
)
;
int
result
=
comparator
.
compare
(
e1
,
e2
)
;
if
(
result
==
0
)
{
fail
(
"Messages not "
+
type
+
". Messages"
+
j
+
" and "
+
i
+
" are equal with value: "
+
expression
.
evaluate
(
e1
)
+
" for expression: "
+
expression
+
". Exchanges: "
+
e1
+
" and "
+
e2
)
;
}
else
{
if
(
!
ascending
)
{
result
=
result
*
-
1
;
}
if
(
result
>
0
)
{
fail
(
"Messages not "
+
type
+
". Message "
+
j
+
" has value: "
+
expression
.
evaluate
(
e1
)
+
" and message "
+
i
+
" has value: "
+
expression
.
evaluate
(
e2
)
+
" for expression: "
+
expression
+
". Exchanges: "
+
e1
+
" and "
+
e2
)
;
}
}
}
}
public
void
assertNoDuplicates
(
Expression
<
Exchange
>
expression
)
{
Map
<
Object
,
Exchange
>
map
=
new
HashMap
<
Object
,
Exchange
>
(
)
;
List
<
Exchange
>
list
=
getReceivedExchanges
(
)
;
for
(
int
i
=
0
;
i
<
list
.
size
(
)
;
i
++
)
{
Exchange
e2
=
list
.
get
(
i
)
;
Object
key
=
expression
.
evaluate
(
e2
)
;
Exchange
e1
=
map
.
get
(
key
)
;
if
(
e1
!=
null
)
{
fail
(
"Duplicate message found on message "
+
i
+
" has value: "
+
key
+
" for expression: "
+
expression
+
". Exchanges: "
+
e1
+
" and "
+
e2
)
;
}
else
{
map
.
put
(
key
,
e2
)
;
}
}
}
public
void
expects
(
Runnable
runnable
)
{
tests
.
add
(
runnable
)
;
}
public
AssertionClause
message
(
final
int
messageIndex
)
{
AssertionClause
clause
=
new
AssertionClause
(
)
{
public
void
run
(
)
{
applyAssertionOn
(
MockEndpoint
.
this
,
messageIndex
,
assertExchangeReceived
(
messageIndex
)
)
;
}
}
;
expects
(
clause
)
;
return
clause
;
}
public
AssertionClause
allMessages
(
)
{
AssertionClause
clause
=
new
AssertionClause
(
)
{
public
void
run
(
)
{
List
<
Exchange
>
list
=
getReceivedExchanges
(
)
;
int
index
=
0
;
for
(
Exchange
exchange
:
list
)
{
applyAssertionOn
(
MockEndpoint
.
this
,
index
++
,
exchange
)
;
}
}
}
;
expects
(
clause
)
;
return
clause
;
}
public
Exchange
assertExchangeReceived
(
int
index
)
{
int
count
=
getReceivedCounter
(
)
;
assertTrue
(
"Not enough messages received. Was: "
+
count
,
count
>
index
)
;
return
getReceivedExchanges
(
)
.
get
(
index
)
;
}
public
List
<
Throwable
>
getFailures
(
)
{
return
failures
;
}
public
int
getReceivedCounter
(
)
{
return
getReceivedExchanges
(
)
.
size
(
)
;
}
public
List
<
Exchange
>
getReceivedExchanges
(
)
{
return
receivedExchanges
;
}
public
int
getExpectedCount
(
)
{
return
expectedCount
;
}
public
long
getSleepForEmptyTest
(
)
{
return
sleepForEmptyTest
;
}
public
void
setSleepForEmptyTest
(
long
sleepForEmptyTest
)
{
this
.
sleepForEmptyTest
=
sleepForEmptyTest
;
}
public
long
getResultWaitTime
(
)
{
return
resultWaitTime
;
}
public
void
setResultWaitTime
(
long
resultWaitTime
)
{
this
.
resultWaitTime
=
resultWaitTime
;
}
public
void
setMinimumResultWaitTime
(
long
resultMinimumWaitTime
)
{
this
.
resultMinimumWaitTime
=
resultMinimumWaitTime
;
}
public
void
setExpectedMessageCount
(
int
expectedCount
)
{
this
.
expectedCount
=
expectedCount
;
if
(
expectedCount
<=
0
)
{
latch
=
null
;
}
else
{
latch
=
new
CountDownLatch
(
expectedCount
)
;
}
}
public
void
setMinimumExpectedMessageCount
(
int
expectedCount
)
{
this
.
expectedMinimumCount
=
expectedCount
;
if
(
expectedCount
<=
0
)
{
latch
=
null
;
}
else
{
latch
=
new
CountDownLatch
(
expectedMinimumCount
)
;
}
}
public
Processor
getReporter
(
)
{
return
reporter
;
}
public
void
setReporter
(
Processor
reporter
)
{
this
.
reporter
=
reporter
;
}
private
void
init
(
)
{
expectedCount
=
-
1
;
counter
=
0
;
processors
=
new
HashMap
<
Integer
,
Processor
>
(
)
;
receivedExchanges
=
new
CopyOnWriteArrayList
<
Exchange
>
(
)
;
failures
=
new
CopyOnWriteArrayList
<
Throwable
>
(
)
;
tests
=
new
CopyOnWriteArrayList
<
Runnable
>
(
)
;
latch
=
null
;
sleepForEmptyTest
=
0
;
resultWaitTime
=
20000L
;
resultMinimumWaitTime
=
0L
;
expectedMinimumCount
=
-
1
;
expectedBodyValues
=
null
;
actualBodyValues
=
new
ArrayList
(
)
;
}
protected
synchronized
void
onExchange
(
Exchange
exchange
)
{
try
{
if
(
reporter
!=
null
)
{
reporter
.
process
(
exchange
)
;
}
performAssertions
(
exchange
)
;
}
catch
(
Throwable
e
)
{
failures
.
add
(
e
)
;
}
if
(
latch
!=
null
)
{
latch
.
countDown
(
)
;
}
}
protected
void
performAssertions
(
Exchange
exchange
)
throws
Exception
{
Message
in
=
exchange
.
getIn
(
)
;
Object
actualBody
=
in
.
getBody
(
)
;
if
(
headerName
!=
null
)
{
actualHeader
=
in
.
getHeader
(
headerName
)
;
}
if
(
expectedBodyValues
!=
null
)
{
int
index
=
actualBodyValues
.
size
(
)
;
if
(
expectedBodyValues
.
size
(
)
>
index
)
{
Object
expectedBody
=
expectedBodyValues
.
get
(
index
)
;
if
(
expectedBody
!=
null
)
{
actualBody
=
in
.
getBody
(
expectedBody
.
getClass
(
)
)
;
}
actualBodyValues
.
add
(
actualBody
)
;
}
}
LOG
.
debug
(
getEndpointUri
(
)
+
" >>>> "
+
(
++
counter
)
+
" : "
+
exchange
+
" with body: "
+
actualBody
)
;
receivedExchanges
.
add
(
exchange
)
;
Processor
processor
=
processors
.
get
(
getReceivedCounter
(
)
)
!=
null
?
processors
.
get
(
getReceivedCounter
(
)
)
:
defaultProcessor
;
if
(
processor
!=
null
)
{
processor
.
process
(
exchange
)
;
}
}
protected
void
waitForCompleteLatch
(
)
throws
InterruptedException
{
if
(
latch
==
null
)
{
fail
(
"Should have a latch!"
)
;
}
LOG
.
debug
(
"Waiting on the latch for: "
+
resultWaitTime
+
" millis"
)
;
long
start
=
System
.
currentTimeMillis
(
)
;
latch
.
await
(
resultWaitTime
,
TimeUnit
.
MILLISECONDS
)
;
long
delta
=
System
.
currentTimeMillis
(
)
-
start
;
LOG
.
debug
(
"Took "
+
delta
+
" millis to complete latch"
)
;
if
(
resultMinimumWaitTime
>
0
&&
delta
<
resultMinimumWaitTime
)
{
fail
(
"Expected minimum "
+
resultWaitTime
+
" millis waiting on the result, but was faster with "
+
delta
+
" millis."
)
;
}
}
protected
void
assertEquals
(
String
message
,
Object
expectedValue
,
Object
actualValue
)
{
if
(
!
ObjectHelper
.
equal
(
expectedValue
,
actualValue
)
)
{
fail
(
message
+
". Expected: <"
+
expectedValue
+
"> but was: <"
+
actualValue
+
">"
)
;
}
}
protected
void
assertTrue
(
String
message
,
boolean
predicate
)
{
if
(
!
predicate
)
{
fail
(
message
)
;
}
}
protected
void
fail
(
Object
message
)
{
if
(
LOG
.
isDebugEnabled
(
)
)
{
List
<
Exchange
>
list
=
getReceivedExchanges
(
)
;
int
index
=
0
;
for
(
Exchange
exchange
:
list
)
{
LOG
.
debug
(
"Received["
+
(
++
index
)
+
"]: "
+
exchange
)
;
}
}
throw
new
AssertionError
(
getEndpointUri
(
)
+
" "
+
message
)
;
}
public
int
getExpectedMinimumCount
(
)
{
return
expectedMinimumCount
;
}
public
void
await
(
)
throws
InterruptedException
{
if
(
latch
!=
null
)
{
latch
.
await
(
)
;
}
}
public
boolean
await
(
long
timeout
,
TimeUnit
unit
)
throws
InterruptedException
{
if
(
latch
!=
null
)
{
return
latch
.
await
(
timeout
,
unit
)
;
}
return
true
;
}
public
boolean
isSingleton
(
)
{
return
true
;
}
}
