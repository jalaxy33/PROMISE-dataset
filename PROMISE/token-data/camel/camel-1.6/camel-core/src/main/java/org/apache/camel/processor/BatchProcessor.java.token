package
org
.
apache
.
camel
.
processor
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
concurrent
.
LinkedBlockingQueue
;
import
org
.
apache
.
camel
.
Exchange
;
import
org
.
apache
.
camel
.
Processor
;
import
org
.
apache
.
camel
.
impl
.
LoggingExceptionHandler
;
import
org
.
apache
.
camel
.
impl
.
ServiceSupport
;
import
org
.
apache
.
camel
.
spi
.
ExceptionHandler
;
import
org
.
apache
.
camel
.
util
.
ServiceHelper
;
public
class
BatchProcessor
extends
ServiceSupport
implements
Processor
{
public
static
final
long
DEFAULT_BATCH_TIMEOUT
=
1000L
;
public
static
final
int
DEFAULT_BATCH_SIZE
=
100
;
private
long
batchTimeout
=
DEFAULT_BATCH_TIMEOUT
;
private
int
batchSize
=
DEFAULT_BATCH_SIZE
;
private
int
outBatchSize
;
private
Processor
processor
;
private
Collection
<
Exchange
>
collection
;
private
ExceptionHandler
exceptionHandler
;
private
BatchSender
sender
;
public
BatchProcessor
(
Processor
processor
,
Collection
<
Exchange
>
collection
)
{
this
.
processor
=
processor
;
this
.
collection
=
collection
;
this
.
sender
=
new
BatchSender
(
)
;
}
@
Override
public
String
toString
(
)
{
return
"BatchProcessor[to: "
+
processor
+
"]"
;
}
public
ExceptionHandler
getExceptionHandler
(
)
{
if
(
exceptionHandler
==
null
)
{
exceptionHandler
=
new
LoggingExceptionHandler
(
getClass
(
)
)
;
}
return
exceptionHandler
;
}
public
void
setExceptionHandler
(
ExceptionHandler
exceptionHandler
)
{
this
.
exceptionHandler
=
exceptionHandler
;
}
public
int
getBatchSize
(
)
{
return
batchSize
;
}
public
void
setBatchSize
(
int
batchSize
)
{
this
.
batchSize
=
batchSize
;
}
public
int
getOutBatchSize
(
)
{
return
outBatchSize
;
}
public
void
setOutBatchSize
(
int
outBatchSize
)
{
this
.
outBatchSize
=
outBatchSize
;
}
public
long
getBatchTimeout
(
)
{
return
batchTimeout
;
}
public
void
setBatchTimeout
(
long
batchTimeout
)
{
this
.
batchTimeout
=
batchTimeout
;
}
public
Processor
getProcessor
(
)
{
return
processor
;
}
protected
boolean
isInBatchCompleted
(
int
num
)
{
return
num
>=
batchSize
;
}
protected
boolean
isOutBatchCompleted
(
)
{
if
(
outBatchSize
==
0
)
{
return
true
;
}
return
collection
.
size
(
)
>
0
&&
collection
.
size
(
)
>=
outBatchSize
;
}
protected
void
processExchange
(
Exchange
exchange
)
throws
Exception
{
processor
.
process
(
exchange
)
;
}
protected
void
doStart
(
)
throws
Exception
{
ServiceHelper
.
startServices
(
processor
)
;
sender
.
start
(
)
;
}
protected
void
doStop
(
)
throws
Exception
{
sender
.
cancel
(
)
;
ServiceHelper
.
stopServices
(
processor
)
;
collection
.
clear
(
)
;
}
protected
Collection
<
Exchange
>
getCollection
(
)
{
return
collection
;
}
public
void
process
(
Exchange
exchange
)
throws
Exception
{
sender
.
enqueueExchange
(
exchange
)
;
}
private
class
BatchSender
extends
Thread
{
private
volatile
boolean
cancelRequested
;
private
LinkedBlockingQueue
<
Exchange
>
queue
;
public
BatchSender
(
)
{
super
(
"Batch Sender"
)
;
this
.
queue
=
new
LinkedBlockingQueue
<
Exchange
>
(
)
;
}
@
Override
public
void
run
(
)
{
while
(
true
)
{
try
{
Thread
.
sleep
(
batchTimeout
)
;
queue
.
drainTo
(
collection
,
batchSize
)
;
}
catch
(
InterruptedException
e
)
{
if
(
cancelRequested
)
{
return
;
}
while
(
isInBatchCompleted
(
queue
.
size
(
)
)
)
{
queue
.
drainTo
(
collection
,
batchSize
)
;
}
if
(
!
isOutBatchCompleted
(
)
)
{
continue
;
}
}
try
{
sendExchanges
(
)
;
}
catch
(
Exception
e
)
{
getExceptionHandler
(
)
.
handleException
(
e
)
;
}
}
}
public
void
cancel
(
)
{
cancelRequested
=
true
;
interrupt
(
)
;
}
public
void
enqueueExchange
(
Exchange
exchange
)
{
queue
.
add
(
exchange
)
;
interrupt
(
)
;
}
private
void
sendExchanges
(
)
throws
Exception
{
Iterator
<
Exchange
>
iter
=
collection
.
iterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
Exchange
exchange
=
iter
.
next
(
)
;
iter
.
remove
(
)
;
processExchange
(
exchange
)
;
}
}
}
}
