package
org
.
apache
.
camel
.
model
;
import
java
.
util
.
List
;
import
java
.
util
.
concurrent
.
ThreadPoolExecutor
;
import
javax
.
xml
.
bind
.
annotation
.
XmlAccessType
;
import
javax
.
xml
.
bind
.
annotation
.
XmlAccessorType
;
import
javax
.
xml
.
bind
.
annotation
.
XmlAttribute
;
import
javax
.
xml
.
bind
.
annotation
.
XmlRootElement
;
import
javax
.
xml
.
bind
.
annotation
.
XmlTransient
;
import
org
.
apache
.
camel
.
Processor
;
import
org
.
apache
.
camel
.
processor
.
MulticastProcessor
;
import
org
.
apache
.
camel
.
processor
.
aggregate
.
AggregationStrategy
;
import
org
.
apache
.
camel
.
processor
.
aggregate
.
UseLatestAggregationStrategy
;
import
org
.
apache
.
camel
.
processor
.
interceptor
.
StreamCachingInterceptor
;
import
org
.
apache
.
camel
.
spi
.
RouteContext
;
@
XmlRootElement
(
name
=
"multicast"
)
@
XmlAccessorType
(
XmlAccessType
.
FIELD
)
public
class
MulticastType
extends
OutputType
<
ProcessorType
>
{
@
XmlAttribute
(
required
=
false
)
private
Boolean
parallelProcessing
;
@
XmlAttribute
(
required
=
false
)
private
String
strategyRef
;
@
XmlAttribute
(
required
=
false
)
private
String
threadPoolRef
;
@
XmlTransient
private
AggregationStrategy
aggregationStrategy
;
@
XmlTransient
private
ThreadPoolExecutor
threadPoolExecutor
;
@
Override
public
String
toString
(
)
{
return
"Multicast["
+
getOutputs
(
)
+
"]"
;
}
@
Override
public
String
getShortName
(
)
{
return
"multicast"
;
}
@
Override
public
Processor
createProcessor
(
RouteContext
routeContext
)
throws
Exception
{
return
createOutputsProcessor
(
routeContext
)
;
}
public
MulticastType
aggregationStrategy
(
AggregationStrategy
aggregationStrategy
)
{
setAggregationStrategy
(
aggregationStrategy
)
;
return
this
;
}
public
MulticastType
parallelProcessing
(
)
{
setParallelProcessing
(
true
)
;
return
this
;
}
public
MulticastType
parallelProcessing
(
boolean
parallelProcessing
)
{
setParallelProcessing
(
parallelProcessing
)
;
return
this
;
}
public
MulticastType
executor
(
ThreadPoolExecutor
executor
)
{
setThreadPoolExecutor
(
executor
)
;
return
this
;
}
protected
Processor
createCompositeProcessor
(
RouteContext
routeContext
,
List
<
Processor
>
list
)
{
if
(
aggregationStrategy
==
null
&&
strategyRef
!=
null
)
{
aggregationStrategy
=
routeContext
.
lookup
(
strategyRef
,
AggregationStrategy
.
class
)
;
}
if
(
aggregationStrategy
==
null
)
{
aggregationStrategy
=
new
UseLatestAggregationStrategy
(
)
;
}
if
(
threadPoolRef
!=
null
)
{
threadPoolExecutor
=
routeContext
.
lookup
(
threadPoolRef
,
ThreadPoolExecutor
.
class
)
;
}
return
new
MulticastProcessor
(
list
,
aggregationStrategy
,
isParallelProcessing
(
)
,
threadPoolExecutor
)
;
}
public
AggregationStrategy
getAggregationStrategy
(
)
{
return
aggregationStrategy
;
}
public
void
setAggregationStrategy
(
AggregationStrategy
aggregationStrategy
)
{
this
.
aggregationStrategy
=
aggregationStrategy
;
}
public
boolean
isParallelProcessing
(
)
{
return
parallelProcessing
!=
null
?
parallelProcessing
:
false
;
}
public
void
setParallelProcessing
(
boolean
parallelProcessing
)
{
this
.
parallelProcessing
=
parallelProcessing
;
}
public
ThreadPoolExecutor
getThreadPoolExecutor
(
)
{
return
threadPoolExecutor
;
}
public
void
setThreadPoolExecutor
(
ThreadPoolExecutor
executor
)
{
this
.
threadPoolExecutor
=
executor
;
}
@
Override
protected
Processor
wrapProcessorInInterceptors
(
RouteContext
routeContext
,
Processor
target
)
throws
Exception
{
return
super
.
wrapProcessorInInterceptors
(
routeContext
,
new
StreamCachingInterceptor
(
target
)
)
;
}
}
