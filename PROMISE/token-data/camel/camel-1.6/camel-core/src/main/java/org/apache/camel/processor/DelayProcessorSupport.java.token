package
org
.
apache
.
camel
.
processor
;
import
java
.
util
.
concurrent
.
CountDownLatch
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
org
.
apache
.
camel
.
AlreadyStoppedException
;
import
org
.
apache
.
camel
.
Exchange
;
import
org
.
apache
.
camel
.
Processor
;
import
org
.
apache
.
commons
.
logging
.
Log
;
import
org
.
apache
.
commons
.
logging
.
LogFactory
;
public
abstract
class
DelayProcessorSupport
extends
DelegateProcessor
{
private
static
final
transient
Log
LOG
=
LogFactory
.
getLog
(
Delayer
.
class
)
;
private
CountDownLatch
stoppedLatch
=
new
CountDownLatch
(
1
)
;
private
boolean
fastStop
=
true
;
public
DelayProcessorSupport
(
Processor
processor
)
{
super
(
processor
)
;
}
public
void
process
(
Exchange
exchange
)
throws
Exception
{
delay
(
exchange
)
;
super
.
process
(
exchange
)
;
}
public
boolean
isFastStop
(
)
{
return
fastStop
;
}
public
void
setFastStop
(
boolean
fastStop
)
{
this
.
fastStop
=
fastStop
;
}
protected
void
doStop
(
)
throws
Exception
{
stoppedLatch
.
countDown
(
)
;
super
.
doStop
(
)
;
}
protected
abstract
void
delay
(
Exchange
exchange
)
throws
Exception
;
protected
void
waitUntil
(
long
time
,
Exchange
exchange
)
throws
Exception
{
while
(
true
)
{
long
delay
=
time
-
currentSystemTime
(
)
;
if
(
delay
<
0
)
{
return
;
}
else
{
if
(
isFastStop
(
)
&&
!
isRunAllowed
(
)
)
{
throw
new
AlreadyStoppedException
(
)
;
}
try
{
sleep
(
delay
)
;
}
catch
(
InterruptedException
e
)
{
handleSleepInteruptedException
(
e
)
;
}
}
}
}
protected
void
sleep
(
long
delay
)
throws
InterruptedException
{
if
(
delay
<=
0
)
{
return
;
}
if
(
LOG
.
isTraceEnabled
(
)
)
{
LOG
.
trace
(
"Sleeping for: "
+
delay
+
" millis"
)
;
}
if
(
isFastStop
(
)
)
{
stoppedLatch
.
await
(
delay
,
TimeUnit
.
MILLISECONDS
)
;
}
else
{
Thread
.
sleep
(
delay
)
;
}
}
protected
void
handleSleepInteruptedException
(
InterruptedException
e
)
{
LOG
.
debug
(
"Sleep interupted: "
+
e
,
e
)
;
}
protected
long
currentSystemTime
(
)
{
return
System
.
currentTimeMillis
(
)
;
}
}
