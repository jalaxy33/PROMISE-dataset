package
org
.
apache
.
camel
.
model
;
import
java
.
util
.
concurrent
.
LinkedBlockingQueue
;
import
java
.
util
.
concurrent
.
ThreadPoolExecutor
;
import
java
.
util
.
concurrent
.
TimeUnit
;
import
javax
.
xml
.
bind
.
annotation
.
XmlAccessType
;
import
javax
.
xml
.
bind
.
annotation
.
XmlAccessorType
;
import
javax
.
xml
.
bind
.
annotation
.
XmlAttribute
;
import
javax
.
xml
.
bind
.
annotation
.
XmlRootElement
;
import
javax
.
xml
.
bind
.
annotation
.
XmlTransient
;
import
org
.
apache
.
camel
.
Expression
;
import
org
.
apache
.
camel
.
Processor
;
import
org
.
apache
.
camel
.
model
.
language
.
ExpressionType
;
import
org
.
apache
.
camel
.
processor
.
Splitter
;
import
org
.
apache
.
camel
.
processor
.
aggregate
.
AggregationStrategy
;
import
org
.
apache
.
camel
.
processor
.
aggregate
.
UseLatestAggregationStrategy
;
import
org
.
apache
.
camel
.
spi
.
RouteContext
;
@
XmlRootElement
(
name
=
"splitter"
)
@
XmlAccessorType
(
XmlAccessType
.
FIELD
)
public
class
SplitterType
extends
ExpressionNode
{
@
XmlTransient
private
AggregationStrategy
aggregationStrategy
;
@
XmlAttribute
(
required
=
false
)
private
Boolean
parallelProcessing
;
@
XmlTransient
private
ThreadPoolExecutor
threadPoolExecutor
;
@
XmlAttribute
(
required
=
false
)
private
String
threadPoolExecutorRef
;
@
XmlAttribute
(
required
=
false
)
private
Boolean
streaming
=
false
;
public
SplitterType
(
)
{
}
public
SplitterType
(
Expression
expression
)
{
super
(
expression
)
;
}
public
SplitterType
(
ExpressionType
expression
)
{
super
(
expression
)
;
}
@
Override
public
String
toString
(
)
{
return
"Splitter["
+
getExpression
(
)
+
" -> "
+
getOutputs
(
)
+
"]"
;
}
@
Override
public
String
getShortName
(
)
{
return
"splitter"
;
}
@
Override
public
Processor
createProcessor
(
RouteContext
routeContext
)
throws
Exception
{
Processor
childProcessor
=
routeContext
.
createProcessor
(
this
)
;
if
(
aggregationStrategy
==
null
)
{
aggregationStrategy
=
new
UseLatestAggregationStrategy
(
)
;
}
threadPoolExecutor
=
createThreadPoolExecutor
(
routeContext
)
;
return
new
Splitter
(
getExpression
(
)
.
createExpression
(
routeContext
)
,
childProcessor
,
aggregationStrategy
,
isParallelProcessing
(
)
,
threadPoolExecutor
,
streaming
)
;
}
public
SplitterType
aggregationStrategy
(
AggregationStrategy
aggregationStrategy
)
{
setAggregationStrategy
(
aggregationStrategy
)
;
return
this
;
}
public
SplitterType
parallelProcessing
(
)
{
setParallelProcessing
(
true
)
;
return
this
;
}
public
SplitterType
parallelProcessing
(
boolean
parallelProcessing
)
{
setParallelProcessing
(
parallelProcessing
)
;
return
this
;
}
public
SplitterType
streaming
(
)
{
setStreaming
(
true
)
;
return
this
;
}
public
SplitterType
executor
(
ThreadPoolExecutor
executor
)
{
setThreadPoolExecutor
(
executor
)
;
return
this
;
}
public
AggregationStrategy
getAggregationStrategy
(
)
{
return
aggregationStrategy
;
}
public
void
setAggregationStrategy
(
AggregationStrategy
aggregationStrategy
)
{
this
.
aggregationStrategy
=
aggregationStrategy
;
}
public
boolean
isParallelProcessing
(
)
{
return
parallelProcessing
!=
null
?
parallelProcessing
:
false
;
}
public
void
setParallelProcessing
(
boolean
parallelProcessing
)
{
this
.
parallelProcessing
=
parallelProcessing
;
}
public
boolean
isStreaming
(
)
{
return
streaming
!=
null
?
streaming
:
false
;
}
public
void
setStreaming
(
boolean
streaming
)
{
this
.
streaming
=
streaming
;
}
private
ThreadPoolExecutor
createThreadPoolExecutor
(
RouteContext
routeContext
)
{
ThreadPoolExecutor
threadPoolExecutor
=
getThreadPoolExecutor
(
)
;
if
(
threadPoolExecutor
==
null
&&
threadPoolExecutorRef
!=
null
)
{
threadPoolExecutor
=
routeContext
.
lookup
(
threadPoolExecutorRef
,
ThreadPoolExecutor
.
class
)
;
}
if
(
threadPoolExecutor
==
null
)
{
threadPoolExecutor
=
new
ThreadPoolExecutor
(
4
,
16
,
0L
,
TimeUnit
.
MILLISECONDS
,
new
LinkedBlockingQueue
(
)
)
;
}
return
threadPoolExecutor
;
}
public
ThreadPoolExecutor
getThreadPoolExecutor
(
)
{
return
threadPoolExecutor
;
}
public
void
setThreadPoolExecutor
(
ThreadPoolExecutor
threadPoolExecutor
)
{
this
.
threadPoolExecutor
=
threadPoolExecutor
;
}
}
