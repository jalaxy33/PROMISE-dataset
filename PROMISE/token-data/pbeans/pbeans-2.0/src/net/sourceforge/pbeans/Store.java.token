package
net
.
sourceforge
.
pbeans
;
import
java
.
sql
.
*
;
import
java
.
util
.
*
;
import
java
.
lang
.
ref
.
*
;
import
java
.
lang
.
reflect
.
*
;
import
java
.
beans
.
*
;
import
javax
.
sql
.
*
;
import
net
.
sourceforge
.
pbeans
.
data
.
*
;
import
net
.
sourceforge
.
pbeans
.
util
.
*
;
import
net
.
sourceforge
.
pbeans
.
annotations
.
*
;
import
java
.
util
.
logging
.
*
;
public
class
Store
{
private
static
final
Logger
logger
=
Logger
.
getLogger
(
Store
.
class
.
getName
(
)
)
;
private
static
final
Object
[
]
EMPTY_PARAMETERS
=
new
Object
[
0
]
;
private
final
Object
objectsMonitor
=
new
Object
(
)
;
private
final
Map
<
GlobalPersistentID
,
ObjectInfo
>
objectInfosByID
=
new
HashMap
<
GlobalPersistentID
,
ObjectInfo
>
(
)
;
private
final
Map
<
Object
,
ObjectInfo
>
objectInfosByObject
=
new
java
.
util
.
WeakHashMap
<
Object
,
ObjectInfo
>
(
)
;
private
final
Map
<
Class
,
StoreInfo
>
storeInfoByClass
=
new
HashMap
<
Class
,
StoreInfo
>
(
)
;
private
final
ReferenceQueue
REF_QUEUE
=
new
ReferenceQueue
(
)
;
private
final
Database
database
;
private
final
int
maxTableNameLength
;
private
final
int
maxColumnNameLength
;
private
final
DatabaseFactory
databaseFactory
;
private
final
ClassLoader
defaultClassLoader
;
public
Store
(
DataSource
dataSource
,
DatabaseFactory
dbf
,
ClassLoader
defaultClassLoader
)
throws
StoreException
{
try
{
this
.
databaseFactory
=
dbf
;
this
.
database
=
dbf
.
getDatabase
(
dataSource
)
;
this
.
maxTableNameLength
=
this
.
database
.
getMaxTableNameLength
(
)
;
this
.
maxColumnNameLength
=
this
.
database
.
getMaxColumnNameLength
(
)
;
this
.
defaultClassLoader
=
defaultClassLoader
;
}
catch
(
SQLException
se
)
{
throw
new
StoreException
(
se
)
;
}
}
public
Store
(
DataSource
dataSource
)
throws
StoreException
{
this
(
dataSource
,
new
DefaultDatabaseFactory
(
null
)
,
null
)
;
}
public
Store
(
DataSource
dataSource
,
int
maxConnections
,
int
connectionTimeout
)
throws
StoreException
{
this
(
dataSource
,
new
DefaultDatabaseFactory
(
null
)
,
null
)
;
DefaultDatabaseFactory
ddb
=
(
DefaultDatabaseFactory
)
this
.
databaseFactory
;
ddb
.
setMaxConnections
(
maxConnections
)
;
ddb
.
setConnectionTimeout
(
connectionTimeout
)
;
}
public
Store
(
DataSource
dataSource
,
int
maxConnections
,
int
connectionTimeout
,
ClassLoader
classLoader
)
throws
StoreException
{
this
(
dataSource
,
new
DefaultDatabaseFactory
(
classLoader
)
,
classLoader
)
;
DefaultDatabaseFactory
ddb
=
(
DefaultDatabaseFactory
)
this
.
databaseFactory
;
ddb
.
setMaxConnections
(
maxConnections
)
;
ddb
.
setConnectionTimeout
(
connectionTimeout
)
;
}
public
int
getMaxColumnNameLength
(
)
{
return
this
.
maxColumnNameLength
;
}
public
int
getMaxTableNameLength
(
)
{
return
this
.
maxTableNameLength
;
}
protected
String
getFieldName
(
StoreInfo
sinfo
,
String
propertyName
)
throws
StoreException
{
PropertyDescriptor
pd
=
sinfo
.
getPropertyDescriptor
(
propertyName
)
;
if
(
pd
==
null
)
{
throw
new
StoreException
(
"No property named "
+
propertyName
)
;
}
FieldDescriptor
fd
=
sinfo
.
getFieldDescriptor
(
this
,
pd
)
;
if
(
fd
==
null
)
{
throw
new
StoreException
(
"Property named "
+
propertyName
+
" is not persistent."
)
;
}
return
fd
.
getName
(
)
;
}
String
getShortColumnName
(
String
name
,
String
prefix
)
{
int
maxColumnNameLength
=
this
.
getMaxColumnNameLength
(
)
;
String
tName
=
name
;
int
totalLength
=
tName
.
length
(
)
;
if
(
totalLength
<=
maxColumnNameLength
)
{
return
tName
;
}
int
hash
=
Math
.
abs
(
Hash
.
fixedHash
(
name
)
)
;
String
hashStr
=
String
.
valueOf
(
hash
)
;
int
canUseLength
=
maxColumnNameLength
-
prefix
.
length
(
)
-
hashStr
.
length
(
)
;
String
fieldName
=
prefix
+
hashStr
+
tName
.
substring
(
tName
.
length
(
)
-
canUseLength
,
tName
.
length
(
)
)
;
return
fieldName
;
}
public
StoreInfo
getStoreInfo
(
Class
beanClass
)
throws
StoreException
{
synchronized
(
storeInfoByClass
)
{
StoreInfo
sinfo
=
storeInfoByClass
.
get
(
beanClass
)
;
if
(
sinfo
!=
null
)
{
return
sinfo
;
}
sinfo
=
createStoreInfo
(
beanClass
)
;
storeInfoByClass
.
put
(
beanClass
,
sinfo
)
;
String
objectIdFieldName
=
sinfo
.
getIdField
(
)
;
String
tableName
=
getTableName
(
beanClass
)
;
try
{
BeanInfo
binfo
=
Introspector
.
getBeanInfo
(
beanClass
)
;
PropertyDescriptor
[
]
ppDescriptors
=
binfo
.
getPropertyDescriptors
(
)
;
Collection
<
FieldDescriptor
>
fieldDescriptors
=
new
LinkedList
<
FieldDescriptor
>
(
)
;
for
(
int
i
=
0
;
i
<
ppDescriptors
.
length
;
i
++
)
{
FieldDescriptor
fd
=
sinfo
.
getFieldDescriptor
(
this
,
ppDescriptors
[
i
]
)
;
if
(
fd
!=
null
)
{
fieldDescriptors
.
add
(
fd
)
;
}
}
Collection
indexDescriptors
=
new
LinkedList
(
)
;
Index
[
]
indexes
=
sinfo
.
getIndexes
(
this
)
;
for
(
int
i
=
0
;
i
<
indexes
.
length
;
i
++
)
{
Index
index
=
indexes
[
i
]
;
String
indexName
=
getIndexName
(
index
)
;
try
{
indexDescriptors
.
add
(
new
IndexDescriptor
(
indexName
,
index
.
isUnique
(
)
,
getFieldNames
(
sinfo
,
index
.
getPropertyNames
(
)
)
,
index
.
getKeyLength
(
)
)
)
;
}
catch
(
StoreException
se
)
{
throw
new
StoreException
(
"Unable to add index named "
+
indexName
+
" to table "
+
tableName
+
" because: "
+
se
.
getMessage
(
)
,
se
)
;
}
}
FieldDescriptor
oidDescriptor
=
new
FieldDescriptor
(
objectIdFieldName
,
Types
.
BIGINT
,
false
,
null
,
true
,
false
)
;
try
{
database
.
ensureTableExists
(
tableName
,
oidDescriptor
,
fieldDescriptors
,
indexDescriptors
,
sinfo
.
isUserManaged
(
)
,
sinfo
.
isAutoIncrementRequested
(
)
,
sinfo
.
isDeleteFields
(
)
)
;
}
catch
(
SQLException
se
)
{
if
(
database
.
isDuplicateEntryError
(
se
)
)
{
throw
new
DuplicateEntryException
(
"Unable to modify table "
+
tableName
+
" perhaps because the requested changes apparently generate a duplicate entry error (e.g adding an index on a column that has existing duplicate values.) You might want to change your StoreInfo settings or modify the database manually."
)
;
}
else
{
throw
new
StoreException
(
"Unable to modify table "
+
tableName
+
" because: "
+
se
.
getMessage
(
)
+
". You might want to change your StoreInfo settings or modify the database manually."
,
se
)
;
}
}
}
catch
(
IntrospectionException
ie
)
{
throw
new
StoreException
(
ie
)
;
}
return
sinfo
;
}
}
private
String
getIndexName
(
Index
index
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
buf
.
append
(
"I"
)
;
Collection
propNames
=
index
.
getPropertyNames
(
)
;
Iterator
i
=
propNames
.
iterator
(
)
;
while
(
i
.
hasNext
(
)
)
{
buf
.
append
(
'_'
)
;
buf
.
append
(
i
.
next
(
)
)
;
}
return
getShortColumnName
(
buf
.
toString
(
)
,
"I"
)
;
}
private
String
[
]
getFieldNames
(
StoreInfo
sinfo
,
Collection
propertyNames
)
throws
StoreException
{
int
size
=
propertyNames
.
size
(
)
;
String
[
]
fieldNames
=
new
String
[
size
]
;
Iterator
i
=
propertyNames
.
iterator
(
)
;
int
idx
=
0
;
while
(
i
.
hasNext
(
)
)
{
fieldNames
[
idx
++
]
=
getFieldName
(
sinfo
,
(
String
)
i
.
next
(
)
)
;
}
return
fieldNames
;
}
private
Class
lookupClass
(
String
name
)
throws
ClassNotFoundException
{
ClassLoader
cl
=
this
.
defaultClassLoader
;
return
cl
==
null
?
Class
.
forName
(
name
)
:
cl
.
loadClass
(
name
)
;
}
private
StoreInfo
createStoreInfo
(
Class
beanClass
)
throws
StoreException
{
if
(
!
Persistent
.
class
.
isAssignableFrom
(
beanClass
)
)
{
return
new
DefaultStoreInfo
(
beanClass
,
this
)
;
}
String
checkName
=
beanClass
.
getName
(
)
+
"_StoreInfo"
;
try
{
ClassLoader
cl
=
beanClass
.
getClassLoader
(
)
;
Class
sinfobeanClass
=
cl
==
null
?
this
.
lookupClass
(
checkName
)
:
cl
.
loadClass
(
checkName
)
;
return
(
StoreInfo
)
sinfobeanClass
.
newInstance
(
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
return
new
DefaultStoreInfo
(
beanClass
,
this
)
;
}
catch
(
InstantiationException
ie
)
{
throw
new
StoreException
(
"Unable to create instance of "
+
checkName
+
". It should have a public default constructor."
)
;
}
catch
(
IllegalAccessException
iae
)
{
throw
new
StoreException
(
iae
)
;
}
}
public
void
put
(
String
name
,
Object
obj
)
throws
StoreException
{
PersistentMap
<
String
,
Object
>
map
=
getRootMap
(
)
;
map
.
putObject
(
name
,
obj
)
;
}
public
Object
get
(
String
name
)
throws
StoreException
{
checkWeakReferences
(
)
;
PersistentMap
<
String
,
Object
>
map
=
getRootMap
(
)
;
return
map
.
getObject
(
name
)
;
}
public
void
remove
(
String
name
)
throws
StoreException
{
PersistentMap
<
String
,
Object
>
map
=
getRootMap
(
)
;
map
.
removeObject
(
name
)
;
}
private
static
final
String
ROOT_MAP_NAME
=
"pbeans.root.map"
;
private
Object
getRootMapMonitor
(
)
{
return
(
"Monitor:"
+
ROOT_MAP_NAME
)
.
intern
(
)
;
}
protected
PersistentMap
<
String
,
Object
>
getRootMap
(
)
throws
StoreException
{
PersistentMap
<
String
,
Object
>
rootMap
=
(
PersistentMap
<
String
,
Object
>
)
this
.
selectSingle
(
PersistentMap
.
class
,
"name"
,
ROOT_MAP_NAME
)
;
if
(
rootMap
==
null
)
{
synchronized
(
this
.
getRootMapMonitor
(
)
)
{
rootMap
=
(
PersistentMap
<
String
,
Object
>
)
this
.
selectSingle
(
PersistentMap
.
class
,
"name"
,
ROOT_MAP_NAME
)
;
if
(
rootMap
==
null
)
{
rootMap
=
new
PersistentMap
<
String
,
Object
>
(
)
;
rootMap
.
setName
(
ROOT_MAP_NAME
)
;
this
.
register
(
rootMap
)
;
}
rootMap
.
setStore
(
this
)
;
}
}
rootMap
.
setStore
(
this
)
;
return
rootMap
;
}
private
void
checkWeakReferences
(
)
{
for
(
;
;
)
{
ObjectInfo
wr
=
(
ObjectInfo
)
this
.
REF_QUEUE
.
poll
(
)
;
if
(
wr
==
null
)
{
break
;
}
GlobalPersistentID
objectID
=
wr
.
getGlobalPersistentID
(
)
;
synchronized
(
objectsMonitor
)
{
this
.
objectInfosByID
.
remove
(
objectID
)
;
}
}
}
public
Object
getObject
(
GlobalPersistentID
globalID
)
throws
StoreException
{
Object
obj
=
this
.
getCachedObject
(
globalID
)
;
if
(
obj
==
null
)
{
obj
=
this
.
lookupStoredObject
(
globalID
,
null
)
;
}
return
obj
;
}
public
Object
getObject
(
GlobalPersistentID
globalID
,
ClassLoader
classLoader
)
throws
StoreException
{
Object
obj
=
this
.
getCachedObject
(
globalID
)
;
if
(
obj
==
null
)
{
obj
=
this
.
lookupStoredObject
(
globalID
,
classLoader
)
;
}
return
obj
;
}
public
Object
getObject
(
PersistentID
objectID
,
Class
beanClass
)
throws
StoreException
{
GlobalPersistentID
globalID
=
new
GlobalPersistentID
(
objectID
,
beanClass
)
;
Object
obj
=
this
.
getCachedObject
(
globalID
)
;
if
(
obj
==
null
)
{
obj
=
this
.
lookupStoredObject
(
objectID
,
beanClass
)
;
}
return
obj
;
}
public
Object
getCachedObject
(
GlobalPersistentID
globalID
)
{
synchronized
(
objectsMonitor
)
{
return
this
.
getCachedObjectImpl
(
globalID
)
;
}
}
private
Object
getCachedObjectImpl
(
GlobalPersistentID
globalID
)
{
ObjectInfo
oi
=
(
ObjectInfo
)
this
.
objectInfosByID
.
get
(
globalID
)
;
if
(
oi
==
null
)
{
return
null
;
}
return
oi
.
getObject
(
)
;
}
private
Object
lookupStoredObject
(
GlobalPersistentID
globalID
,
ClassLoader
classLoader
)
throws
StoreException
{
PersistentID
objectID
=
globalID
.
getObjectID
(
)
;
String
className
=
globalID
.
getClassName
(
)
;
try
{
Class
beanClass
=
classLoader
==
null
?
this
.
lookupClass
(
className
)
:
classLoader
.
loadClass
(
className
)
;
return
lookupStoredObject
(
objectID
,
beanClass
)
;
}
catch
(
ClassNotFoundException
cnf
)
{
throw
new
StoreException
(
cnf
)
;
}
}
protected
String
getTableName
(
Class
beanClass
)
throws
StoreException
{
StoreInfo
sinfo
=
this
.
getStoreInfo
(
beanClass
)
;
return
sinfo
.
getTableName
(
this
.
maxTableNameLength
)
;
}
private
Object
lookupStoredObject
(
PersistentID
objectID
,
Class
beanClass
)
throws
StoreException
{
StoreInfo
sinfo
=
getStoreInfo
(
beanClass
)
;
BeanFactory
factory
=
new
SimpleBeanFactory
(
beanClass
)
;
String
tableName
=
sinfo
.
getTableName
(
this
.
maxTableNameLength
)
;
String
sqlString
=
"SELECT * FROM "
+
tableName
+
" WHERE "
+
sinfo
.
getIdField
(
)
+
"="
+
objectID
;
ResultsIterator
results
=
this
.
select
(
sinfo
.
getBeanClass
(
)
,
sqlString
,
new
Object
[
0
]
,
factory
)
;
try
{
if
(
results
.
hasNext
(
)
)
{
return
results
.
next
(
)
;
}
else
{
return
null
;
}
}
finally
{
results
.
close
(
)
;
}
}
public
void
reload
(
Object
persObject
)
throws
StoreException
{
PersistentID
objectID
=
this
.
getPersistentID
(
persObject
)
;
Class
beanClass
=
persObject
.
getClass
(
)
;
this
.
lookupStoredObject
(
objectID
,
beanClass
)
;
}
public
void
save
(
Object
persObject
)
throws
StoreException
{
this
.
save
(
persObject
,
false
,
false
)
;
}
public
void
save
(
Object
persObject
,
boolean
force
,
boolean
reload
)
throws
StoreException
{
checkWeakReferences
(
)
;
ObjectInfo
oi
=
getObjectInfo
(
persObject
)
;
try
{
oi
.
save
(
force
)
;
}
catch
(
StoreException
err
)
{
if
(
reload
)
{
if
(
logger
.
isLoggable
(
Level
.
INFO
)
)
{
logger
.
info
(
"save(): Operation failed; reloading record..."
)
;
}
this
.
reload
(
persObject
)
;
}
throw
err
;
}
}
public
void
insert
(
Object
persObject
)
throws
StoreException
{
checkWeakReferences
(
)
;
ObjectInfo
oi
;
synchronized
(
this
.
objectsMonitor
)
{
oi
=
this
.
objectInfosByObject
.
get
(
persObject
)
;
if
(
oi
!=
null
)
{
throw
new
StoreException
(
"Object already known by Store. A new bean must be created before invoking insert."
)
;
}
}
this
.
insertBeanTransac
(
persObject
)
;
}
public
void
register
(
Object
persObject
)
throws
StoreException
{
checkWeakReferences
(
)
;
getObjectInfo
(
persObject
)
;
}
public
void
delete
(
Object
persObject
)
throws
StoreException
{
this
.
delete
(
persObject
,
false
)
;
}
public
void
delete
(
Object
persObject
,
boolean
forget
)
throws
StoreException
{
ObjectInfo
oi
=
getObjectInfo
(
persObject
)
;
oi
.
delete
(
forget
)
;
}
public
PersistentID
getPersistentID
(
Object
persObject
)
throws
StoreException
{
ObjectInfo
oi
=
getObjectInfo
(
persObject
)
;
return
oi
.
getObjectID
(
)
;
}
public
GlobalPersistentID
getGlobalPersistentID
(
Object
persObject
)
throws
StoreException
{
ObjectInfo
oi
=
getObjectInfo
(
persObject
)
;
return
new
GlobalPersistentID
(
oi
.
getObjectID
(
)
,
oi
.
getClassName
(
)
)
;
}
private
ObjectInfo
getObjectInfo
(
Object
persObject
)
throws
StoreException
{
return
getObjectInfo
(
persObject
,
true
)
;
}
public
void
beginTransaction
(
)
throws
StoreException
{
this
.
beginTransaction
(
Connection
.
TRANSACTION_READ_COMMITTED
)
;
}
public
void
beginTransaction
(
int
transactionIsolationLevel
)
throws
StoreException
{
try
{
this
.
database
.
beginTransaction
(
transactionIsolationLevel
)
;
}
catch
(
SQLException
err
)
{
throw
new
StoreException
(
err
)
;
}
}
public
void
endTransaction
(
)
throws
StoreException
{
try
{
this
.
database
.
endTransaction
(
)
;
}
catch
(
SQLException
err
)
{
throw
new
StoreException
(
err
)
;
}
}
public
boolean
inTransaction
(
)
{
return
this
.
database
.
inTransaction
(
)
;
}
public
void
requestLock
(
Class
beanClass
,
String
dataName
)
throws
StoreException
,
InterruptedException
{
this
.
requestLock
(
beanClass
,
dataName
,
Connection
.
TRANSACTION_READ_COMMITTED
)
;
}
public
void
requestLock
(
Class
beanClass
,
String
dataName
,
int
transactionIsolationLevel
)
throws
StoreException
,
InterruptedException
{
String
lockName
=
beanClass
.
getName
(
)
+
":"
+
dataName
;
try
{
this
.
database
.
requestLock
(
lockName
,
transactionIsolationLevel
)
;
}
catch
(
SQLException
se
)
{
throw
new
StoreException
(
se
)
;
}
}
public
void
relinquishLock
(
)
throws
StoreException
{
try
{
this
.
database
.
relinquishLock
(
)
;
}
catch
(
SQLException
se
)
{
throw
new
StoreException
(
se
)
;
}
}
private
ObjectInfo
insertBeanTransac
(
Object
persObject
)
throws
StoreException
{
boolean
inTransaction
=
this
.
inTransaction
(
)
;
if
(
!
inTransaction
)
{
this
.
beginTransaction
(
)
;
}
try
{
Long
id
=
this
.
insertBeanImpl
(
persObject
)
;
PersistentID
pid
=
new
PersistentID
(
id
)
;
Class
clazz
=
persObject
.
getClass
(
)
;
GlobalPersistentID
gid
=
new
GlobalPersistentID
(
pid
,
clazz
)
;
synchronized
(
this
.
objectsMonitor
)
{
ObjectInfo
oi
=
this
.
objectInfosByID
.
get
(
gid
)
;
if
(
oi
!=
null
)
{
throw
new
IllegalStateException
(
"Object with same ID as that just inserted already registered. There must be a problem with JDBC transaction support, class-table mapping consistency, or bean identity (i.e. the equals method does not implement identity properly)."
)
;
}
oi
=
new
ObjectInfo
(
pid
,
persObject
,
clazz
)
;
this
.
objectInfosByID
.
put
(
gid
,
oi
)
;
this
.
objectInfosByObject
.
put
(
persObject
,
oi
)
;
return
oi
;
}
}
finally
{
if
(
!
inTransaction
)
{
this
.
endTransaction
(
)
;
}
}
}
private
ObjectInfo
getObjectInfo
(
Object
persObject
,
boolean
doInsert
)
throws
StoreException
{
if
(
persObject
==
null
)
{
throw
new
java
.
lang
.
IllegalArgumentException
(
"Persistent object cannot be null."
)
;
}
this
.
checkWeakReferences
(
)
;
ObjectInfo
oi
;
synchronized
(
this
.
objectsMonitor
)
{
oi
=
this
.
objectInfosByObject
.
get
(
persObject
)
;
if
(
oi
!=
null
)
{
return
oi
;
}
}
return
this
.
insertBeanTransac
(
persObject
)
;
}
public
static
boolean
isPersistable
(
Class
beanClass
)
{
return
beanClass
.
isAnnotationPresent
(
PersistentClass
.
class
)
||
Persistent
.
class
.
isAssignableFrom
(
beanClass
)
;
}
private
NameValueArray
marshallBean
(
Object
bean
,
StoreInfo
sinfo
,
boolean
normalizeFieldNames
,
InsertionEntry
currentInsertionEntry
)
throws
StoreException
{
PropertyDescriptor
[
]
pds
=
sinfo
.
getPropertyDescriptors
(
)
;
ArrayList
pairList
=
new
ArrayList
(
pds
.
length
)
;
Database
database
=
this
.
database
;
for
(
int
i
=
0
;
i
<
pds
.
length
;
i
++
)
{
PropertyDescriptor
pd
=
pds
[
i
]
;
FieldDescriptor
fd
=
sinfo
.
getFieldDescriptor
(
this
,
pd
)
;
if
(
fd
!=
null
)
{
Method
readMethod
=
pd
.
getReadMethod
(
)
;
Object
value
;
try
{
value
=
readMethod
.
invoke
(
bean
,
new
Object
[
0
]
)
;
}
catch
(
IllegalAccessException
iae
)
{
String
propName
=
pd
.
getName
(
)
;
throw
new
StoreException
(
"Store has no access to property "
+
propName
+
" in class "
+
sinfo
.
getBeanClass
(
)
.
getName
(
)
+
"."
,
iae
)
;
}
catch
(
InvocationTargetException
ite
)
{
String
propName
=
pd
.
getName
(
)
;
throw
new
StoreException
(
"Unable to invoke getter of property "
+
propName
+
" in class "
+
sinfo
.
getBeanClass
(
)
.
getName
(
)
+
"."
,
ite
)
;
}
String
fieldName
=
normalizeFieldNames
?
database
.
normalizeName
(
fd
.
getName
(
)
)
:
fd
.
getName
(
)
;
pairList
.
add
(
new
Object
[
]
{
fieldName
,
marshallValue
(
sinfo
,
pd
,
value
,
currentInsertionEntry
)
}
)
;
}
}
int
length
=
pairList
.
size
(
)
;
NameValueArray
nva
=
new
NameValueArray
(
length
)
;
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
Object
[
]
pair
=
(
Object
[
]
)
pairList
.
get
(
i
)
;
nva
.
setPair
(
i
,
(
String
)
pair
[
0
]
,
pair
[
1
]
)
;
}
return
nva
;
}
private
Map
marshallCriteriaValues
(
Class
beanClass
,
StoreInfo
sinfo
,
Map
values
)
throws
StoreException
{
Map
mValues
;
if
(
values
instanceof
Criteria
)
{
Criteria
tmpCrit
=
(
Criteria
)
values
;
mValues
=
new
Criteria
(
tmpCrit
.
getOperatorMap
(
)
,
tmpCrit
.
getDefaultComparisonOperator
(
)
,
tmpCrit
.
getLogicalOperatorMap
(
)
,
tmpCrit
.
getDefaultLogicalOperator
(
)
)
;
}
else
{
mValues
=
new
HashMap
(
)
;
}
try
{
BeanInfo
beanInfo
=
Introspector
.
getBeanInfo
(
beanClass
)
;
PropertyDescriptor
[
]
pds
=
beanInfo
.
getPropertyDescriptors
(
)
;
for
(
int
i
=
0
;
i
<
pds
.
length
;
i
++
)
{
PropertyDescriptor
pd
=
pds
[
i
]
;
FieldDescriptor
fd
=
sinfo
.
getFieldDescriptor
(
this
,
pd
)
;
if
(
fd
!=
null
)
{
String
propName
=
pd
.
getName
(
)
;
if
(
values
.
containsKey
(
propName
)
)
{
Object
value
=
values
.
get
(
propName
)
;
String
fieldName
=
fd
.
getName
(
)
;
if
(
value
!=
null
)
{
mValues
.
put
(
fieldName
,
marshallValue
(
sinfo
,
pd
,
value
,
null
)
)
;
}
else
{
mValues
.
put
(
fieldName
,
null
)
;
}
}
}
}
}
catch
(
IntrospectionException
ie
)
{
throw
new
StoreException
(
ie
)
;
}
return
mValues
;
}
private
Object
marshallValue
(
StoreInfo
sinfo
,
String
propertyName
,
Object
value
,
InsertionEntry
currentInsertionEntry
)
throws
StoreException
{
PropertyDescriptor
pd
=
sinfo
.
getPropertyDescriptor
(
propertyName
)
;
if
(
pd
==
null
)
{
throw
new
StoreException
(
"Property "
+
pd
.
getName
(
)
+
" does not exist."
)
;
}
return
this
.
marshallValue
(
sinfo
,
pd
,
value
,
currentInsertionEntry
)
;
}
private
long
[
]
fetchRawIDDArrayDuringMarshall
(
StoreInfo
sinfo
,
PropertyDescriptor
pd
,
FieldDescriptor
fd
,
Object
[
]
objects
,
InsertionEntry
currentInsertionEntry
)
throws
StoreException
{
if
(
fd
==
null
)
{
throw
new
IllegalStateException
(
"Property "
+
pd
.
getName
(
)
+
" is not persistent."
)
;
}
LinkedList
<
InsertionEntry
>
insertionStack
=
this
.
insertionStackTL
.
get
(
)
;
if
(
insertionStack
!=
null
)
{
if
(
currentInsertionEntry
==
null
&&
!
insertionStack
.
isEmpty
(
)
)
{
throw
new
IllegalStateException
(
"Insertion stack is active but not currently in an insertion; scenario not supported (UpdateEntry would be necessary)."
)
;
}
}
Map
<
InsertionEntry
,
Collection
<
Integer
>
>
indexesByObject
=
new
IdentityHashMap
<
InsertionEntry
,
Collection
<
Integer
>
>
(
)
;
long
[
]
rawObjectIDs
=
new
long
[
objects
.
length
]
;
for
(
int
objidx
=
0
;
objidx
<
objects
.
length
;
objidx
++
)
{
Object
persObject
=
objects
[
objidx
]
;
if
(
persObject
==
null
)
{
rawObjectIDs
[
objidx
]
=
0
;
}
else
{
boolean
matchesStack
=
false
;
if
(
insertionStack
!=
null
)
{
for
(
int
i
=
insertionStack
.
size
(
)
;
--
i
>=
0
;
)
{
InsertionEntry
entry
=
insertionStack
.
get
(
i
)
;
if
(
entry
.
contains
(
persObject
)
)
{
matchesStack
=
true
;
Collection
<
Integer
>
indexes
=
indexesByObject
.
get
(
entry
)
;
if
(
indexes
==
null
)
{
indexes
=
new
LinkedList
<
Integer
>
(
)
;
indexesByObject
.
put
(
entry
,
indexes
)
;
}
indexes
.
add
(
objidx
)
;
break
;
}
}
}
if
(
matchesStack
)
{
rawObjectIDs
[
objidx
]
=
0
;
}
else
{
PersistentID
pid
=
this
.
getPersistentID
(
persObject
)
;
rawObjectIDs
[
objidx
]
=
pid
.
longValue
(
)
;
}
}
}
if
(
indexesByObject
!=
null
)
{
Iterator
<
Map
.
Entry
<
InsertionEntry
,
Collection
<
Integer
>
>
>
i
=
indexesByObject
.
entrySet
(
)
.
iterator
(
)
;
while
(
i
.
hasNext
(
)
)
{
Map
.
Entry
<
InsertionEntry
,
Collection
<
Integer
>
>
entry
=
i
.
next
(
)
;
InsertionEntry
insentry
=
entry
.
getKey
(
)
;
Collection
<
Integer
>
indexes
=
entry
.
getValue
(
)
;
LateUpdate
update
=
new
LateUpdate
(
sinfo
,
pd
,
fd
.
getName
(
)
,
false
,
rawObjectIDs
,
indexes
)
;
insentry
.
addLateUpdateToExecute
(
update
)
;
currentInsertionEntry
.
addLateUpdateToModify
(
update
)
;
}
}
return
rawObjectIDs
;
}
private
PersistentID
fetchPersistentIDDuringMarshall
(
StoreInfo
sinfo
,
PropertyDescriptor
pd
,
FieldDescriptor
fd
,
Object
propertyValueObject
,
boolean
forGlobalReference
,
InsertionEntry
currentInsertionEntry
)
throws
StoreException
{
if
(
fd
==
null
)
{
throw
new
IllegalStateException
(
"Property "
+
pd
.
getName
(
)
+
" is not persistent."
)
;
}
LinkedList
<
InsertionEntry
>
insertionStack
=
this
.
insertionStackTL
.
get
(
)
;
if
(
insertionStack
!=
null
)
{
if
(
currentInsertionEntry
==
null
&&
!
insertionStack
.
isEmpty
(
)
)
{
throw
new
IllegalStateException
(
"Insertion stack is active but not currently in an insertion; scenario not supported (UpdateEntry would be necessary)."
)
;
}
LateUpdate
update
=
null
;
for
(
int
i
=
insertionStack
.
size
(
)
;
--
i
>=
0
;
)
{
InsertionEntry
entry
=
insertionStack
.
get
(
i
)
;
if
(
entry
.
contains
(
propertyValueObject
)
)
{
if
(
update
==
null
)
{
update
=
new
LateUpdate
(
sinfo
,
pd
,
fd
.
getName
(
)
,
forGlobalReference
)
;
}
entry
.
addLateUpdateToExecute
(
update
)
;
break
;
}
}
if
(
update
!=
null
)
{
currentInsertionEntry
.
addLateUpdateToModify
(
update
)
;
return
new
PersistentID
(
0L
)
;
}
}
return
this
.
getPersistentID
(
propertyValueObject
)
;
}
private
Object
marshallValue
(
StoreInfo
sinfo
,
PropertyDescriptor
pd
,
Object
value
,
InsertionEntry
currentInsertionEntry
)
throws
StoreException
{
if
(
value
instanceof
String
||
value
instanceof
Integer
||
value
instanceof
Long
||
value
==
null
)
{
return
value
;
}
else
{
Class
propertyType
=
pd
.
getPropertyType
(
)
;
FieldDescriptor
fd
=
sinfo
.
getFieldDescriptor
(
this
,
pd
)
;
boolean
globalRef
=
fd
==
null
?
false
:
fd
.
isGlobalReference
(
)
;
if
(
globalRef
)
{
Class
valueClass
=
value
.
getClass
(
)
;
if
(
!
Store
.
isPersistable
(
valueClass
)
)
{
throw
new
StoreException
(
"Unable to marshall value of type "
+
value
.
getClass
(
)
.
getName
(
)
+
" for global reference property in class "
+
sinfo
.
getBeanClass
(
)
.
getName
(
)
+
". The value type must either be null, a class annotated with @PersistentClass or one that implements Persistent."
)
;
}
PersistentID
pid
=
this
.
fetchPersistentIDDuringMarshall
(
sinfo
,
pd
,
fd
,
value
,
true
,
currentInsertionEntry
)
;
GlobalPersistentID
gpid
=
new
GlobalPersistentID
(
pid
,
valueClass
)
;
return
gpid
.
toString
(
)
;
}
else
if
(
Store
.
isPersistable
(
propertyType
)
)
{
Class
valueClass
=
value
.
getClass
(
)
;
if
(
valueClass
!=
pd
.
getPropertyType
(
)
)
{
throw
new
StoreException
(
"Unable to marshall value of type "
+
valueClass
.
getName
(
)
+
" for property of type "
+
pd
.
getPropertyType
(
)
+
" in class "
+
sinfo
.
getBeanClass
(
)
.
getName
(
)
+
". Values not matching the property type exactly are not allowed unless the property is annotated using the globalReference element of the @PersistentProperty annotation."
)
;
}
return
this
.
fetchPersistentIDDuringMarshall
(
sinfo
,
pd
,
fd
,
value
,
false
,
currentInsertionEntry
)
.
longValue
(
)
;
}
else
if
(
propertyType
.
isArray
(
)
&&
Store
.
isPersistable
(
propertyType
.
getComponentType
(
)
)
)
{
Class
componentType
=
propertyType
.
getComponentType
(
)
;
Object
[
]
objects
=
(
Object
[
]
)
value
;
for
(
int
i
=
0
;
i
<
objects
.
length
;
i
++
)
{
Object
object
=
objects
[
i
]
;
if
(
object
!=
null
)
{
if
(
object
.
getClass
(
)
!=
componentType
)
{
throw
new
StoreException
(
"Unable to marshall value of type "
+
object
.
getClass
(
)
.
getName
(
)
+
" for array property with component type "
+
componentType
.
getClass
(
)
.
getName
(
)
+
" in class "
+
sinfo
.
getBeanClass
(
)
.
getName
(
)
+
"."
)
;
}
}
}
long
[
]
rawObjectIDs
=
this
.
fetchRawIDDArrayDuringMarshall
(
sinfo
,
pd
,
fd
,
objects
,
currentInsertionEntry
)
;
return
sinfo
.
marshallValue
(
pd
,
rawObjectIDs
)
;
}
else
{
return
sinfo
.
marshallValue
(
pd
,
value
)
;
}
}
}
private
Object
unmarshallValue
(
StoreInfo
sinfo
,
PropertyDescriptor
pd
,
Object
value
)
throws
StoreException
{
if
(
value
==
null
)
{
return
null
;
}
else
{
FieldDescriptor
fd
=
sinfo
.
getFieldDescriptor
(
this
,
pd
)
;
boolean
globalRef
=
fd
==
null
?
false
:
fd
.
isGlobalReference
(
)
;
if
(
globalRef
)
{
String
rawGid
=
value
instanceof
String
?
(
String
)
value
:
String
.
valueOf
(
value
)
;
GlobalPersistentID
gid
;
try
{
gid
=
GlobalPersistentID
.
valueOf
(
rawGid
)
;
}
catch
(
Exception
err
)
{
logger
.
warning
(
"unmarshallValue(): Unable to parse globalPersistentID="
+
rawGid
)
;
return
null
;
}
return
this
.
getObject
(
gid
)
;
}
else
{
Class
propType
=
pd
.
getPropertyType
(
)
;
if
(
Store
.
isPersistable
(
propType
)
)
{
if
(
!
(
value
instanceof
Long
)
)
{
logger
.
warning
(
"Expected value for property "
+
pd
.
getName
(
)
+
" to be of type Long, not "
+
value
.
getClass
(
)
.
getName
(
)
+
"."
)
;
return
null
;
}
PersistentID
objectID
=
new
PersistentID
(
(
(
Long
)
value
)
.
longValue
(
)
)
;
return
getObject
(
objectID
,
propType
)
;
}
else
if
(
propType
.
isArray
(
)
)
{
Class
componentType
=
propType
.
getComponentType
(
)
;
if
(
Store
.
isPersistable
(
componentType
)
)
{
long
[
]
rawObjectIDs
=
(
long
[
]
)
sinfo
.
unmarshallValue
(
pd
,
value
)
;
if
(
rawObjectIDs
==
null
)
{
return
null
;
}
Object
[
]
objects
=
(
Object
[
]
)
java
.
lang
.
reflect
.
Array
.
newInstance
(
componentType
,
rawObjectIDs
.
length
)
;
for
(
int
i
=
0
;
i
<
objects
.
length
;
i
++
)
{
long
rawID
=
rawObjectIDs
[
i
]
;
Object
object
=
rawID
==
0
?
null
:
this
.
getObject
(
new
PersistentID
(
rawID
)
,
componentType
)
;
objects
[
i
]
=
object
;
}
return
objects
;
}
else
{
return
sinfo
.
unmarshallValue
(
pd
,
value
)
;
}
}
else
{
return
sinfo
.
unmarshallValue
(
pd
,
value
)
;
}
}
}
}
private
boolean
equalValues
(
NameValueArray
array1
,
NameValueArray
array2
)
{
if
(
array1
==
null
)
{
return
array2
==
null
;
}
else
if
(
array2
==
null
)
{
return
false
;
}
int
length
=
array1
.
length
;
Object
[
]
values1
=
array1
.
valueArray
;
Object
[
]
values2
=
array2
.
valueArray
;
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
Object
val1
=
values1
[
i
]
;
Object
val2
=
values2
[
i
]
;
if
(
val1
==
null
)
{
if
(
val2
!=
null
)
{
return
false
;
}
}
else
if
(
!
val1
.
equals
(
val2
)
)
{
return
false
;
}
}
return
true
;
}
private
boolean
equalValues
(
Map
values1
,
Map
values2
)
{
if
(
values2
==
null
)
{
return
values1
==
null
;
}
Iterator
i1
=
values1
.
entrySet
(
)
.
iterator
(
)
;
while
(
i1
.
hasNext
(
)
)
{
Map
.
Entry
entry1
=
(
Map
.
Entry
)
i1
.
next
(
)
;
String
key1
=
(
String
)
entry1
.
getKey
(
)
;
Object
val1
=
entry1
.
getValue
(
)
;
Object
val2
=
values2
.
get
(
key1
)
;
if
(
val1
==
null
)
{
if
(
val2
!=
null
)
{
return
false
;
}
}
else
if
(
!
val1
.
equals
(
val2
)
)
{
return
false
;
}
}
return
true
;
}
private
void
warn
(
String
text
)
{
if
(
logger
.
isLoggable
(
Level
.
WARNING
)
)
{
logger
.
warning
(
text
)
;
}
}
public
ResultsIterator
selectParts
(
Object
containerBean
,
final
Class
partbeanClass
,
String
linkPropertyInPart
)
throws
StoreException
{
Map
props
=
new
HashMap
(
2
)
;
props
.
put
(
linkPropertyInPart
,
containerBean
)
;
return
select
(
partbeanClass
,
props
)
;
}
public
ResultsIterator
selectParts
(
PersistentID
containerBeanID
,
final
Class
partbeanClass
,
String
linkPropertyInPart
)
throws
StoreException
{
Map
props
=
new
HashMap
(
2
)
;
props
.
put
(
linkPropertyInPart
,
containerBeanID
)
;
return
select
(
partbeanClass
,
props
)
;
}
public
ResultsIterator
selectParts
(
final
PersistentID
containerBeanID
,
final
Class
linkClass
,
final
Class
partClass
,
String
propertyLinkingContainer
,
String
propertyLinkingPart
)
throws
StoreException
{
Database
database
=
this
.
database
;
StoreInfo
partSinfo
=
this
.
getStoreInfo
(
partClass
)
;
String
partNormalTableName
=
database
.
normalizeName
(
partSinfo
.
getTableName
(
this
.
maxTableNameLength
)
)
;
String
partNormalFieldID
=
database
.
normalizeName
(
partSinfo
.
getIdField
(
)
)
;
StoreInfo
linkSinfo
=
this
.
getStoreInfo
(
linkClass
)
;
String
linkNormalTableName
=
database
.
normalizeName
(
linkSinfo
.
getTableName
(
this
.
maxTableNameLength
)
)
;
StringBuffer
sqlBuffer
=
new
StringBuffer
(
)
;
sqlBuffer
.
append
(
"SELECT "
)
;
sqlBuffer
.
append
(
partNormalTableName
)
;
sqlBuffer
.
append
(
".* FROM "
)
;
sqlBuffer
.
append
(
linkNormalTableName
)
;
sqlBuffer
.
append
(
" INNER JOIN "
)
;
sqlBuffer
.
append
(
partNormalTableName
)
;
sqlBuffer
.
append
(
" ON ("
)
;
sqlBuffer
.
append
(
linkNormalTableName
)
;
sqlBuffer
.
append
(
'.'
)
;
sqlBuffer
.
append
(
propertyLinkingPart
)
;
sqlBuffer
.
append
(
'='
)
;
sqlBuffer
.
append
(
partNormalTableName
)
;
sqlBuffer
.
append
(
'.'
)
;
sqlBuffer
.
append
(
partNormalFieldID
)
;
sqlBuffer
.
append
(
") WHERE "
)
;
sqlBuffer
.
append
(
linkNormalTableName
)
;
sqlBuffer
.
append
(
'.'
)
;
sqlBuffer
.
append
(
propertyLinkingContainer
)
;
sqlBuffer
.
append
(
'='
)
;
sqlBuffer
.
append
(
containerBeanID
)
;
String
sqlQuery
=
sqlBuffer
.
toString
(
)
;
if
(
logger
.
isLoggable
(
Level
.
INFO
)
)
{
logger
.
info
(
"selectParts(): sql=["
+
sqlQuery
+
"]"
)
;
}
return
this
.
select
(
partClass
,
sqlQuery
,
new
Object
[
0
]
)
;
}
public
ResultsIterator
select
(
final
Class
inbeanClass
)
throws
StoreException
{
return
select
(
inbeanClass
,
null
)
;
}
public
Object
selectSingle
(
final
Class
beanClass
,
String
propertyName
,
Object
propertyValue
)
throws
StoreException
{
Map
values
=
new
HashMap
(
2
)
;
values
.
put
(
propertyName
,
propertyValue
)
;
return
selectSingle
(
beanClass
,
values
)
;
}
public
Object
selectSingle
(
final
Class
beanClass
,
Map
values
)
throws
StoreException
{
ResultsIterator
i
=
select
(
beanClass
,
values
)
;
try
{
if
(
i
.
hasNext
(
)
)
{
return
i
.
next
(
)
;
}
}
finally
{
i
.
close
(
)
;
}
return
null
;
}
public
Object
selectSingle
(
final
Class
beanClass
,
Map
values
,
String
orderBy
,
boolean
descending
)
throws
StoreException
{
ResultsIterator
i
=
select
(
beanClass
,
values
,
orderBy
,
descending
,
new
Integer
(
1
)
)
;
try
{
if
(
i
.
hasNext
(
)
)
{
return
i
.
next
(
)
;
}
}
finally
{
i
.
close
(
)
;
}
return
null
;
}
public
ResultsIterator
select
(
final
Class
beanClass
,
Map
values
)
throws
StoreException
{
return
select
(
beanClass
,
values
,
null
,
false
,
null
)
;
}
public
ResultsIterator
select
(
final
Class
beanClass
,
Map
values
,
String
orderByProperty
,
boolean
descending
,
Integer
limit
)
throws
StoreException
{
BeanFactory
beanFactory
=
new
SimpleBeanFactory
(
beanClass
)
;
return
this
.
select
(
beanClass
,
values
,
orderByProperty
,
descending
,
limit
,
beanFactory
)
;
}
public
ResultsIterator
select
(
final
Class
beanClass
,
Map
propertyValues
,
String
orderByProperty
,
boolean
descending
,
Integer
limit
,
BeanFactory
beanFactory
)
throws
StoreException
{
StoreInfo
sinfo
=
this
.
getStoreInfo
(
beanClass
)
;
String
tableName
=
sinfo
.
getTableName
(
this
.
maxTableNameLength
)
;
String
cond
=
propertyValues
==
null
?
null
:
getNameValueSequence
(
sinfo
,
propertyValues
,
"AND"
,
true
,
true
)
;
Object
[
]
params
=
propertyValues
==
null
?
EMPTY_PARAMETERS
:
getParameters
(
sinfo
,
propertyValues
,
true
,
null
)
;
String
orderBy
=
null
;
if
(
orderByProperty
!=
null
)
{
PropertyDescriptor
orderByPd
=
sinfo
.
getPropertyDescriptor
(
orderByProperty
)
;
if
(
orderByPd
==
null
)
{
throw
new
StoreException
(
"No such property: "
+
orderByProperty
)
;
}
FieldDescriptor
orderByFd
=
sinfo
.
getFieldDescriptor
(
this
,
orderByPd
)
;
if
(
orderByFd
==
null
)
{
throw
new
StoreException
(
"Property "
+
orderByProperty
+
" not persistent."
)
;
}
orderBy
=
orderByFd
.
getName
(
)
;
}
Database
database
=
this
.
database
;
String
normalTableName
=
database
.
normalizeName
(
tableName
)
;
String
normalOrderBy
=
database
.
normalizeName
(
orderBy
)
;
String
queryString
=
"SELECT * FROM "
+
normalTableName
+
(
cond
==
null
?
""
:
" WHERE "
+
cond
)
+
(
normalOrderBy
==
null
?
""
:
" ORDER BY "
+
normalOrderBy
)
+
(
descending
?
" DESC "
:
""
)
+
(
limit
==
null
?
""
:
" LIMIT "
+
limit
)
;
return
this
.
select
(
beanClass
,
queryString
,
params
,
beanFactory
)
;
}
public
ResultsIterator
select
(
Class
beanClass
,
String
sqlQuery
,
Object
[
]
parameters
)
throws
StoreException
{
BeanFactory
factory
=
new
SimpleBeanFactory
(
beanClass
)
;
return
this
.
select
(
beanClass
,
sqlQuery
,
parameters
,
factory
)
;
}
public
ResultsIterator
select
(
Class
beanClass
,
String
sqlQuery
,
Object
[
]
parameters
,
BeanFactory
beanFactory
)
throws
StoreException
{
StoreInfo
sinfo
=
this
.
getStoreInfo
(
beanClass
)
;
BeanUnmarshaller
bu
=
new
LocalBeanUnmarshaller
(
sinfo
,
beanFactory
)
;
try
{
final
ResultsIterator
<
BeanWrapper
>
llbi
=
this
.
database
.
query
(
sqlQuery
,
parameters
,
bu
)
;
return
new
ResultsIterator
(
)
{
@
Override
public
void
finalize
(
)
{
llbi
.
close
(
)
;
}
public
boolean
hasNext
(
)
{
return
llbi
.
hasNext
(
)
;
}
public
Object
next
(
)
{
BeanWrapper
bw
=
llbi
.
next
(
)
;
return
bw
.
bean
;
}
public
void
remove
(
)
{
throw
new
UnsupportedOperationException
(
)
;
}
public
void
close
(
)
{
llbi
.
close
(
)
;
}
}
;
}
catch
(
SQLException
se
)
{
throw
new
StoreException
(
se
)
;
}
}
public
boolean
delete
(
Class
beanClass
,
Map
values
)
throws
StoreException
{
StoreInfo
sinfo
=
getStoreInfo
(
beanClass
)
;
String
tableName
=
getTableName
(
beanClass
)
;
Map
mValues
=
marshallCriteriaValues
(
beanClass
,
sinfo
,
values
)
;
if
(
mValues
.
size
(
)
==
0
)
{
throw
new
StoreException
(
"No marshalled condition values found from map provided. Make sure property names used in query exist, are not capitalized, and are persistent."
)
;
}
try
{
return
deleteRecords
(
tableName
,
mValues
)
;
}
catch
(
SQLException
se
)
{
throw
new
StoreException
(
se
)
;
}
}
public
boolean
update
(
Class
beanClass
,
String
sqlStatement
,
String
[
]
propertyNames
,
Object
[
]
parameters
)
throws
StoreException
{
StoreInfo
sinfo
=
this
.
getStoreInfo
(
beanClass
)
;
Object
[
]
newParameters
=
new
Object
[
parameters
.
length
]
;
for
(
int
i
=
0
;
i
<
parameters
.
length
;
i
++
)
{
if
(
i
<
propertyNames
.
length
)
{
PropertyDescriptor
pd
=
sinfo
.
getPropertyDescriptor
(
propertyNames
[
i
]
)
;
if
(
pd
==
null
)
{
throw
new
StoreException
(
"No property named "
+
propertyNames
[
i
]
+
" found in class "
+
beanClass
.
getName
(
)
+
"."
)
;
}
newParameters
[
i
]
=
this
.
marshallValue
(
sinfo
,
pd
,
parameters
[
i
]
,
null
)
;
}
else
{
newParameters
[
i
]
=
parameters
[
i
]
;
}
}
try
{
return
this
.
database
.
update
(
sqlStatement
,
newParameters
)
>
0
;
}
catch
(
SQLException
se
)
{
throw
new
StoreException
(
se
)
;
}
}
private
boolean
deleteRecords
(
String
tableName
,
Map
fieldValues
)
throws
SQLException
,
StoreException
{
String
cond
=
getNameValueSequence
(
null
,
fieldValues
,
" AND "
,
true
,
false
)
;
Object
[
]
params
=
getParameters
(
null
,
fieldValues
,
false
,
null
)
;
return
this
.
database
.
update
(
"DELETE FROM "
+
tableName
+
" WHERE "
+
cond
,
params
)
>
0
;
}
private
final
ThreadLocal
<
LinkedList
<
InsertionEntry
>
>
insertionStackTL
=
new
ThreadLocal
<
LinkedList
<
InsertionEntry
>
>
(
)
;
private
Long
insertBeanImpl
(
Object
persObject
)
throws
StoreException
{
Class
beanClass
=
persObject
.
getClass
(
)
;
StoreInfo
sinfo
=
this
.
getStoreInfo
(
beanClass
)
;
Long
resultingID
=
null
;
LinkedList
<
InsertionEntry
>
insertionStack
=
this
.
insertionStackTL
.
get
(
)
;
if
(
insertionStack
==
null
)
{
insertionStack
=
new
LinkedList
<
InsertionEntry
>
(
)
;
this
.
insertionStackTL
.
set
(
insertionStack
)
;
}
InsertionEntry
entry
=
new
InsertionEntry
(
persObject
)
;
insertionStack
.
add
(
entry
)
;
try
{
String
tableName
=
sinfo
.
getTableName
(
this
.
maxTableNameLength
)
;
String
idField
=
sinfo
.
getIdField
(
)
;
boolean
autoIncrementRequested
=
sinfo
.
isAutoIncrementRequested
(
)
;
NameValueArray
pairs
=
this
.
marshallBean
(
persObject
,
sinfo
,
true
,
entry
)
;
try
{
resultingID
=
this
.
database
.
insert
(
tableName
,
idField
,
pairs
.
nameArray
,
pairs
.
valueArray
,
autoIncrementRequested
)
;
return
resultingID
;
}
catch
(
SQLException
se
)
{
if
(
database
.
isDuplicateEntryError
(
se
)
)
{
throw
new
DuplicateEntryException
(
"Duplicate entry on "
+
beanClass
.
getName
(
)
,
se
)
;
}
else
{
throw
new
StoreException
(
se
)
;
}
}
}
finally
{
insertionStack
.
removeLast
(
)
;
LinkedList
lateUpdatesToModify
=
entry
.
getLateUpdatesToModify
(
)
;
if
(
lateUpdatesToModify
!=
null
)
{
PersistentID
pid
=
new
PersistentID
(
resultingID
)
;
Iterator
i
=
lateUpdatesToModify
.
iterator
(
)
;
while
(
i
.
hasNext
(
)
)
{
LateUpdate
update
=
(
LateUpdate
)
i
.
next
(
)
;
update
.
setIdToUpdate
(
pid
)
;
}
}
LinkedList
lateUpdatesToExecute
=
entry
.
getLateUpdatesToExecute
(
)
;
if
(
lateUpdatesToExecute
!=
null
)
{
Iterator
i
=
lateUpdatesToExecute
.
iterator
(
)
;
while
(
i
.
hasNext
(
)
)
{
LateUpdate
update
=
(
LateUpdate
)
i
.
next
(
)
;
try
{
if
(
logger
.
isLoggable
(
Level
.
INFO
)
)
{
logger
.
info
(
"insertBeanImpl(): Will execute late update due to self-loop: "
+
update
+
"."
)
;
}
update
.
execute
(
beanClass
,
resultingID
)
;
}
catch
(
Exception
err
)
{
logger
.
log
(
Level
.
WARNING
,
"insertBeanImpl(): Unable to execute late update: "
+
update
+
"."
,
err
)
;
}
}
}
}
}
private
boolean
updateBeanImpl
(
Object
persObject
,
PersistentID
objectID
)
throws
StoreException
{
Database
database
=
this
.
database
;
Class
beanClass
=
persObject
.
getClass
(
)
;
StoreInfo
sinfo
=
this
.
getStoreInfo
(
beanClass
)
;
String
tableName
=
database
.
normalizeName
(
sinfo
.
getTableName
(
this
.
maxTableNameLength
)
)
;
String
idField
=
database
.
normalizeName
(
sinfo
.
getIdField
(
)
)
;
NameValueArray
pairs
=
this
.
marshallBean
(
persObject
,
sinfo
,
false
,
null
)
;
String
setters
=
this
.
getUpdateNameValueSequence
(
sinfo
,
pairs
)
;
Object
[
]
parameters
=
pairs
.
valueArray
;
String
sql
=
"UPDATE "
+
tableName
+
" SET "
+
setters
+
" WHERE "
+
idField
+
"="
+
objectID
;
try
{
return
this
.
database
.
update
(
sql
,
parameters
)
>
0
;
}
catch
(
SQLException
se
)
{
if
(
database
.
isDuplicateEntryError
(
se
)
)
{
throw
new
DuplicateEntryException
(
"Duplicate entry on "
+
beanClass
.
getName
(
)
,
se
)
;
}
else
{
throw
new
StoreException
(
se
)
;
}
}
}
private
boolean
updatePairsImpl
(
StoreInfo
sinfo
,
NameValueArray
fieldValuePairs
,
PersistentID
objectID
)
throws
StoreException
{
String
tableName
=
sinfo
.
getTableName
(
this
.
maxTableNameLength
)
;
Database
database
=
this
.
database
;
String
idField
=
database
.
normalizeName
(
sinfo
.
getIdField
(
)
)
;
String
setters
=
this
.
getUpdateNameValueSequence
(
sinfo
,
fieldValuePairs
)
;
Object
[
]
parameters
=
fieldValuePairs
.
valueArray
;
String
sql
=
"UPDATE "
+
database
.
normalizeName
(
tableName
)
+
" SET "
+
setters
+
" WHERE "
+
idField
+
"="
+
objectID
;
try
{
return
this
.
database
.
update
(
sql
,
parameters
)
>
0
;
}
catch
(
SQLException
se
)
{
if
(
database
.
isDuplicateEntryError
(
se
)
)
{
throw
new
DuplicateEntryException
(
"Duplicate entry on "
+
sinfo
.
getClass
(
)
.
getName
(
)
,
se
)
;
}
else
{
throw
new
StoreException
(
se
)
;
}
}
}
private
boolean
deleteBeanImpl
(
StoreInfo
sinfo
,
PersistentID
objectID
)
throws
StoreException
{
String
tableName
=
sinfo
.
getTableName
(
this
.
maxTableNameLength
)
;
String
sql
=
"DELETE FROM "
+
tableName
+
" WHERE "
+
sinfo
.
getIdField
(
)
+
"="
+
objectID
;
try
{
return
this
.
database
.
update
(
sql
,
new
Object
[
0
]
)
>
0
;
}
catch
(
SQLException
se
)
{
throw
new
StoreException
(
se
)
;
}
}
private
String
getUpdateNameValueSequence
(
StoreInfo
storeInfo
,
NameValueArray
fieldValuePairs
)
{
int
length
=
fieldValuePairs
.
length
;
String
[
]
nameArray
=
fieldValuePairs
.
nameArray
;
StringBuffer
condBuf
=
new
StringBuffer
(
)
;
Database
database
=
this
.
database
;
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
if
(
i
>
0
)
{
condBuf
.
append
(
","
)
;
}
String
fieldName
=
nameArray
[
i
]
;
condBuf
.
append
(
database
.
normalizeName
(
fieldName
)
)
;
condBuf
.
append
(
"=?"
)
;
}
return
condBuf
.
toString
(
)
;
}
private
String
getNameValueSequence
(
StoreInfo
storeInfo
,
Map
values
,
String
defaultLogicalOperator
,
boolean
isQuery
,
boolean
isPropertyValues
)
throws
StoreException
{
StringBuffer
condBuf
=
new
StringBuffer
(
)
;
Criteria
criteria
=
null
;
LogicalOperator
logicalOperator
=
new
SimpleLogicalOperator
(
defaultLogicalOperator
)
;
if
(
values
instanceof
Criteria
)
{
criteria
=
(
Criteria
)
values
;
}
Database
database
=
this
.
database
;
Iterator
i
=
values
.
entrySet
(
)
.
iterator
(
)
;
while
(
i
.
hasNext
(
)
)
{
Map
.
Entry
entry
=
(
Map
.
Entry
)
i
.
next
(
)
;
String
fieldName
;
String
itemName
=
(
String
)
entry
.
getKey
(
)
;
if
(
isPropertyValues
)
{
String
propertyName
=
itemName
;
PropertyDescriptor
pd
=
storeInfo
.
getPropertyDescriptor
(
propertyName
)
;
if
(
pd
==
null
)
{
throw
new
StoreException
(
"Property "
+
propertyName
+
" not found."
)
;
}
FieldDescriptor
fd
=
storeInfo
.
getFieldDescriptor
(
this
,
pd
)
;
if
(
fd
==
null
)
{
throw
new
StoreException
(
"Property "
+
propertyName
+
" is not persistent."
)
;
}
fieldName
=
database
.
normalizeName
(
fd
.
getName
(
)
)
;
}
else
{
fieldName
=
database
.
normalizeName
(
itemName
)
;
}
Object
rawValue
=
entry
.
getValue
(
)
;
if
(
criteria
!=
null
)
{
Operator
operator
=
criteria
.
getOperator
(
fieldName
)
;
logicalOperator
=
criteria
.
getLogicalOperator
(
fieldName
)
;
if
(
rawValue
instanceof
MultiValueContainer
)
{
MultiValueContainer
container
=
(
MultiValueContainer
)
rawValue
;
Iterator
itContainer
=
container
.
iterator
(
)
;
while
(
itContainer
.
hasNext
(
)
)
{
Object
entryObject
=
itContainer
.
next
(
)
;
if
(
(
operator
==
Operator
.
EQUALS
||
operator
==
Operator
.
LIKE
)
&&
isQuery
&&
entryObject
==
null
)
{
operator
=
Operator
.
IS
;
}
if
(
entryObject
!=
null
&&
operator
==
Operator
.
LIKE
&&
(
entryObject
.
getClass
(
)
==
Integer
.
class
||
entryObject
.
getClass
(
)
==
Long
.
class
)
)
{
operator
=
Operator
.
EQUALS
;
}
condBuf
.
append
(
operator
.
operation
(
fieldName
,
"?"
)
)
;
if
(
itContainer
.
hasNext
(
)
)
{
condBuf
.
append
(
" "
+
logicalOperator
.
operatorString
(
)
+
" "
)
;
}
}
}
else
{
if
(
(
operator
==
Operator
.
EQUALS
||
operator
==
Operator
.
LIKE
)
&&
isQuery
&&
entry
.
getValue
(
)
==
null
)
{
operator
=
Operator
.
IS
;
}
if
(
entry
.
getValue
(
)
!=
null
&&
operator
==
Operator
.
LIKE
&&
(
entry
.
getValue
(
)
.
getClass
(
)
==
Integer
.
class
||
entry
.
getValue
(
)
.
getClass
(
)
==
Long
.
class
)
)
{
operator
=
Operator
.
EQUALS
;
}
condBuf
.
append
(
operator
.
operation
(
fieldName
,
"?"
)
)
;
}
}
else
{
condBuf
.
append
(
fieldName
)
;
if
(
isQuery
&&
entry
.
getValue
(
)
==
null
)
{
condBuf
.
append
(
" IS "
)
;
}
else
{
condBuf
.
append
(
'='
)
;
}
condBuf
.
append
(
'?'
)
;
}
if
(
i
.
hasNext
(
)
)
{
condBuf
.
append
(
" "
+
logicalOperator
.
operatorString
(
)
+
" "
)
;
}
}
return
condBuf
.
toString
(
)
;
}
private
Object
[
]
getParameters
(
StoreInfo
storeInfo
,
Map
values
,
boolean
isPropertyValues
,
InsertionEntry
currentInsertionEntry
)
throws
StoreException
{
Iterator
i
=
values
.
entrySet
(
)
.
iterator
(
)
;
Collection
params
=
new
LinkedList
(
)
;
while
(
i
.
hasNext
(
)
)
{
Map
.
Entry
entry
=
(
Map
.
Entry
)
i
.
next
(
)
;
Object
rawValue
=
entry
.
getValue
(
)
;
if
(
rawValue
instanceof
IMultiValueContainer
)
{
Iterator
MultiValueIt
=
(
(
IMultiValueContainer
)
rawValue
)
.
iterator
(
)
;
while
(
MultiValueIt
.
hasNext
(
)
)
{
Object
nestedRawValue
=
MultiValueIt
.
next
(
)
;
Object
nestedValue
;
if
(
isPropertyValues
)
{
String
propertyName
=
(
String
)
entry
.
getKey
(
)
;
nestedValue
=
this
.
marshallValue
(
storeInfo
,
propertyName
,
nestedRawValue
,
null
)
;
}
else
{
nestedValue
=
rawValue
;
}
params
.
add
(
nestedValue
)
;
}
}
else
{
Object
value
;
if
(
isPropertyValues
)
{
String
propertyName
=
(
String
)
entry
.
getKey
(
)
;
value
=
this
.
marshallValue
(
storeInfo
,
propertyName
,
rawValue
,
currentInsertionEntry
)
;
}
else
{
value
=
rawValue
;
}
params
.
add
(
value
)
;
}
}
return
params
.
toArray
(
)
;
}
String
normalizeName
(
String
name
)
{
return
this
.
database
.
normalizeName
(
name
)
;
}
class
ObjectInfo
extends
WeakReference
<
Object
>
{
private
final
PersistentID
objectID
;
private
final
Class
beanClass
;
private
final
Object
saveMonitor
;
private
final
StoreInfo
storeInfo
;
private
volatile
NameValueArray
lastValues
=
null
;
ObjectInfo
(
PersistentID
objectID
,
Object
persObject
)
throws
StoreException
{
super
(
persObject
,
REF_QUEUE
)
;
if
(
persObject
==
null
)
{
throw
new
IllegalArgumentException
(
"persObject is null"
)
;
}
this
.
objectID
=
objectID
;
this
.
beanClass
=
persObject
.
getClass
(
)
;
this
.
storeInfo
=
Store
.
this
.
getStoreInfo
(
this
.
beanClass
)
;
this
.
saveMonitor
=
this
;
}
ObjectInfo
(
PersistentID
objectID
,
Object
persObject
,
Class
beanClass
)
throws
StoreException
{
super
(
persObject
,
REF_QUEUE
)
;
if
(
persObject
==
null
)
{
throw
new
IllegalArgumentException
(
"persObject is null"
)
;
}
this
.
objectID
=
objectID
;
this
.
beanClass
=
beanClass
;
this
.
saveMonitor
=
this
;
this
.
storeInfo
=
Store
.
this
.
getStoreInfo
(
beanClass
)
;
}
String
getClassName
(
)
{
return
this
.
beanClass
.
getName
(
)
;
}
Class
getPersistentClass
(
)
{
return
this
.
beanClass
;
}
PersistentID
getObjectID
(
)
{
return
this
.
objectID
;
}
GlobalPersistentID
getGlobalPersistentID
(
)
{
return
new
GlobalPersistentID
(
this
.
objectID
,
this
.
beanClass
)
;
}
Object
getObject
(
)
{
return
this
.
get
(
)
;
}
void
save
(
boolean
force
)
throws
StoreException
{
Object
bean
=
this
.
getObject
(
)
;
StoreInfo
sinfo
=
this
.
storeInfo
;
NameValueArray
newValues
=
Store
.
this
.
marshallBean
(
bean
,
sinfo
,
false
,
null
)
;
synchronized
(
this
.
saveMonitor
)
{
NameValueArray
oldValues
=
this
.
lastValues
;
if
(
force
||
!
equalValues
(
newValues
,
oldValues
)
)
{
Store
.
this
.
updatePairsImpl
(
sinfo
,
newValues
,
objectID
)
;
this
.
lastValues
=
newValues
;
}
}
}
void
delete
(
boolean
forget
)
throws
StoreException
{
synchronized
(
this
.
saveMonitor
)
{
Store
.
this
.
deleteBeanImpl
(
this
.
storeInfo
,
this
.
objectID
)
;
this
.
lastValues
=
null
;
}
if
(
forget
)
{
Object
bean
=
this
.
getObject
(
)
;
GlobalPersistentID
gid
=
new
GlobalPersistentID
(
this
.
objectID
,
this
.
beanClass
)
;
synchronized
(
Store
.
this
.
objectsMonitor
)
{
Store
.
this
.
objectInfosByID
.
remove
(
gid
)
;
if
(
bean
!=
null
)
{
Store
.
this
.
objectInfosByObject
.
remove
(
bean
)
;
}
}
}
}
}
private
class
LocalBeanUnmarshaller
implements
BeanUnmarshaller
{
private
final
StoreInfo
storeInfo
;
private
final
BeanFactory
beanFactory
;
public
LocalBeanUnmarshaller
(
StoreInfo
storeInfo
,
BeanFactory
beanFactory
)
{
this
.
storeInfo
=
storeInfo
;
this
.
beanFactory
=
beanFactory
;
}
public
Object
registerBean
(
Long
id
)
{
Class
beanClass
=
this
.
storeInfo
.
getBeanClass
(
)
;
PersistentID
objectID
=
new
PersistentID
(
id
)
;
GlobalPersistentID
gid
=
new
GlobalPersistentID
(
objectID
,
beanClass
)
;
synchronized
(
Store
.
this
.
objectsMonitor
)
{
Object
existingBean
=
Store
.
this
.
getCachedObjectImpl
(
gid
)
;
if
(
existingBean
!=
null
)
{
return
existingBean
;
}
Object
persObject
=
this
.
beanFactory
.
create
(
)
;
try
{
ObjectInfo
oi
=
new
ObjectInfo
(
objectID
,
persObject
)
;
Store
.
this
.
objectInfosByObject
.
put
(
persObject
,
oi
)
;
Store
.
this
.
objectInfosByID
.
put
(
new
GlobalPersistentID
(
objectID
,
persObject
.
getClass
(
)
)
,
oi
)
;
}
catch
(
StoreException
err
)
{
throw
new
IllegalStateException
(
err
)
;
}
return
persObject
;
}
}
public
String
getIDField
(
)
{
return
this
.
storeInfo
.
getIdField
(
)
;
}
public
void
setProperty
(
Object
bean
,
String
normalFieldName
,
Object
fieldValue
)
{
StoreInfo
sinfo
=
this
.
storeInfo
;
PropertyDescriptor
pd
=
sinfo
.
getPropertyDescriptorByNormalFieldName
(
Store
.
this
,
normalFieldName
)
;
if
(
pd
!=
null
)
{
Method
writeMethod
=
pd
.
getWriteMethod
(
)
;
Object
umvalue
=
null
;
try
{
umvalue
=
Store
.
this
.
unmarshallValue
(
sinfo
,
pd
,
fieldValue
)
;
writeMethod
.
invoke
(
bean
,
umvalue
)
;
}
catch
(
Exception
err
)
{
throw
new
IllegalStateException
(
"Unable to set property "
+
pd
.
getName
(
)
+
" in class "
+
sinfo
.
getBeanClass
(
)
.
getName
(
)
+
" with value "
+
umvalue
+
", unmarshalled from "
+
fieldValue
,
err
)
;
}
}
}
}
private
static
class
SimpleBeanFactory
implements
BeanFactory
{
private
final
Class
beanClass
;
public
SimpleBeanFactory
(
Class
beanClass
)
{
this
.
beanClass
=
beanClass
;
}
public
Object
create
(
)
{
try
{
return
this
.
beanClass
.
newInstance
(
)
;
}
catch
(
Exception
err
)
{
throw
new
IllegalStateException
(
"Unable to instantiate class "
+
this
.
beanClass
.
getName
(
)
+
"."
,
err
)
;
}
}
}
private
static
class
InsertionEntry
{
private
final
Object
insertedObject
;
private
LinkedList
<
LateUpdate
>
updatesToExecute
;
private
LinkedList
<
LateUpdate
>
updatesToModify
;
public
InsertionEntry
(
Object
insertedObject
)
{
this
.
insertedObject
=
insertedObject
;
}
public
final
void
addLateUpdateToExecute
(
LateUpdate
update
)
{
LinkedList
<
LateUpdate
>
updates
=
this
.
updatesToExecute
;
if
(
updates
==
null
)
{
updates
=
new
LinkedList
<
LateUpdate
>
(
)
;
this
.
updatesToExecute
=
updates
;
}
updates
.
add
(
update
)
;
}
public
final
void
addLateUpdateToModify
(
LateUpdate
update
)
{
LinkedList
<
LateUpdate
>
updates
=
this
.
updatesToModify
;
if
(
updates
==
null
)
{
updates
=
new
LinkedList
<
LateUpdate
>
(
)
;
this
.
updatesToModify
=
updates
;
}
updates
.
add
(
update
)
;
}
public
final
LinkedList
<
LateUpdate
>
getLateUpdatesToExecute
(
)
{
return
this
.
updatesToExecute
;
}
public
final
LinkedList
<
LateUpdate
>
getLateUpdatesToModify
(
)
{
return
this
.
updatesToModify
;
}
public
final
boolean
contains
(
Object
bean
)
{
return
bean
==
this
.
insertedObject
;
}
}
private
class
LateUpdate
{
private
final
StoreInfo
storeInfoToUpdate
;
private
final
PropertyDescriptor
pd
;
private
final
String
fieldToUpdate
;
private
final
boolean
globalReference
;
private
final
long
[
]
rawObjectIDs
;
private
final
Collection
indexesToChange
;
private
PersistentID
idToUpdate
;
public
LateUpdate
(
StoreInfo
storeInfoToUpdate
,
PropertyDescriptor
pd
,
String
fieldToUpdate
,
boolean
globalReference
)
{
this
.
storeInfoToUpdate
=
storeInfoToUpdate
;
this
.
fieldToUpdate
=
fieldToUpdate
;
this
.
globalReference
=
globalReference
;
this
.
pd
=
pd
;
this
.
rawObjectIDs
=
null
;
this
.
indexesToChange
=
null
;
}
public
LateUpdate
(
final
StoreInfo
storeInfoToUpdate
,
PropertyDescriptor
pd
,
final
String
fieldToUpdate
,
final
boolean
globalReference
,
final
long
[
]
rawObjectIDs
,
final
Collection
indexesToChange
)
{
super
(
)
;
this
.
storeInfoToUpdate
=
storeInfoToUpdate
;
this
.
fieldToUpdate
=
fieldToUpdate
;
this
.
globalReference
=
globalReference
;
this
.
pd
=
pd
;
this
.
rawObjectIDs
=
rawObjectIDs
;
this
.
indexesToChange
=
indexesToChange
;
}
public
void
setIdToUpdate
(
PersistentID
id
)
{
this
.
idToUpdate
=
id
;
}
public
void
execute
(
Class
insertedBeanClass
,
Long
insertionID
)
throws
StoreException
{
PersistentID
idToUpdate
=
this
.
idToUpdate
;
if
(
idToUpdate
==
null
)
{
throw
new
IllegalStateException
(
"No ID to update in "
+
this
+
"."
)
;
}
PersistentID
pid
=
new
PersistentID
(
insertionID
)
;
Object
fieldValue
;
long
[
]
rawObjectIDs
=
this
.
rawObjectIDs
;
if
(
rawObjectIDs
!=
null
)
{
long
[
]
newRawObjectIDs
=
new
long
[
rawObjectIDs
.
length
]
;
System
.
arraycopy
(
rawObjectIDs
,
0
,
newRawObjectIDs
,
0
,
rawObjectIDs
.
length
)
;
Iterator
i
=
this
.
indexesToChange
.
iterator
(
)
;
while
(
i
.
hasNext
(
)
)
{
int
index
=
(
Integer
)
i
.
next
(
)
;
newRawObjectIDs
[
index
]
=
insertionID
;
}
fieldValue
=
this
.
storeInfoToUpdate
.
marshallValue
(
this
.
pd
,
newRawObjectIDs
)
;
}
else
{
fieldValue
=
this
.
globalReference
?
new
GlobalPersistentID
(
pid
,
insertedBeanClass
)
.
toString
(
)
:
pid
.
longValue
(
)
;
}
NameValueArray
pairs
=
new
NameValueArray
(
1
)
;
pairs
.
setPair
(
0
,
this
.
fieldToUpdate
,
fieldValue
)
;
Store
.
this
.
updatePairsImpl
(
this
.
storeInfoToUpdate
,
pairs
,
this
.
idToUpdate
)
;
}
public
String
toString
(
)
{
return
"LateUpdate[class="
+
this
.
storeInfoToUpdate
.
getBeanClass
(
)
.
getName
(
)
+
",fieldToUpdate="
+
this
.
fieldToUpdate
+
",globalReference="
+
globalReference
+
",idToUpdate="
+
this
.
idToUpdate
+
",rawObjectIDs="
+
this
.
rawObjectIDs
+
",indexesToChange="
+
this
.
indexesToChange
+
"]"
;
}
}
}
