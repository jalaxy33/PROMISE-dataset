package
org
.
apache
.
xml
.
serializer
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
util
.
Properties
;
import
javax
.
xml
.
transform
.
Result
;
import
org
.
apache
.
xml
.
res
.
XMLErrorResources
;
import
org
.
apache
.
xml
.
res
.
XMLMessages
;
import
org
.
apache
.
xml
.
utils
.
BoolStack
;
import
org
.
apache
.
xml
.
utils
.
Trie
;
import
org
.
xml
.
sax
.
Attributes
;
import
org
.
xml
.
sax
.
SAXException
;
public
class
ToHTMLStream
extends
ToStream
{
protected
BoolStack
m_isRawStack
=
new
BoolStack
(
)
;
private
boolean
m_inBlockElem
=
false
;
protected
static
CharInfo
m_htmlcharInfo
=
CharInfo
.
getCharInfo
(
CharInfo
.
HTML_ENTITIES_RESOURCE
)
;
static
Trie
m_elementFlags
=
new
Trie
(
)
;
static
{
m_elementFlags
.
put
(
"BASEFONT"
,
new
ElemDesc
(
0
|
ElemDesc
.
EMPTY
)
)
;
m_elementFlags
.
put
(
"FRAME"
,
new
ElemDesc
(
0
|
ElemDesc
.
EMPTY
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"FRAMESET"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"NOFRAMES"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"ISINDEX"
,
new
ElemDesc
(
0
|
ElemDesc
.
EMPTY
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"APPLET"
,
new
ElemDesc
(
0
|
ElemDesc
.
WHITESPACESENSITIVE
)
)
;
m_elementFlags
.
put
(
"CENTER"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"DIR"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"MENU"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"TT"
,
new
ElemDesc
(
0
|
ElemDesc
.
FONTSTYLE
)
)
;
m_elementFlags
.
put
(
"I"
,
new
ElemDesc
(
0
|
ElemDesc
.
FONTSTYLE
)
)
;
m_elementFlags
.
put
(
"B"
,
new
ElemDesc
(
0
|
ElemDesc
.
FONTSTYLE
)
)
;
m_elementFlags
.
put
(
"BIG"
,
new
ElemDesc
(
0
|
ElemDesc
.
FONTSTYLE
)
)
;
m_elementFlags
.
put
(
"SMALL"
,
new
ElemDesc
(
0
|
ElemDesc
.
FONTSTYLE
)
)
;
m_elementFlags
.
put
(
"EM"
,
new
ElemDesc
(
0
|
ElemDesc
.
PHRASE
)
)
;
m_elementFlags
.
put
(
"STRONG"
,
new
ElemDesc
(
0
|
ElemDesc
.
PHRASE
)
)
;
m_elementFlags
.
put
(
"DFN"
,
new
ElemDesc
(
0
|
ElemDesc
.
PHRASE
)
)
;
m_elementFlags
.
put
(
"CODE"
,
new
ElemDesc
(
0
|
ElemDesc
.
PHRASE
)
)
;
m_elementFlags
.
put
(
"SAMP"
,
new
ElemDesc
(
0
|
ElemDesc
.
PHRASE
)
)
;
m_elementFlags
.
put
(
"KBD"
,
new
ElemDesc
(
0
|
ElemDesc
.
PHRASE
)
)
;
m_elementFlags
.
put
(
"VAR"
,
new
ElemDesc
(
0
|
ElemDesc
.
PHRASE
)
)
;
m_elementFlags
.
put
(
"CITE"
,
new
ElemDesc
(
0
|
ElemDesc
.
PHRASE
)
)
;
m_elementFlags
.
put
(
"ABBR"
,
new
ElemDesc
(
0
|
ElemDesc
.
PHRASE
)
)
;
m_elementFlags
.
put
(
"ACRONYM"
,
new
ElemDesc
(
0
|
ElemDesc
.
PHRASE
)
)
;
m_elementFlags
.
put
(
"SUP"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
|
ElemDesc
.
ASPECIAL
)
)
;
m_elementFlags
.
put
(
"SUB"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
|
ElemDesc
.
ASPECIAL
)
)
;
m_elementFlags
.
put
(
"SPAN"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
|
ElemDesc
.
ASPECIAL
)
)
;
m_elementFlags
.
put
(
"BDO"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
|
ElemDesc
.
ASPECIAL
)
)
;
m_elementFlags
.
put
(
"BR"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
|
ElemDesc
.
ASPECIAL
|
ElemDesc
.
EMPTY
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"BODY"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"ADDRESS"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
)
)
;
m_elementFlags
.
put
(
"DIV"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
)
)
;
m_elementFlags
.
put
(
"A"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
)
)
;
m_elementFlags
.
put
(
"MAP"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
|
ElemDesc
.
ASPECIAL
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"AREA"
,
new
ElemDesc
(
0
|
ElemDesc
.
EMPTY
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"LINK"
,
new
ElemDesc
(
0
|
ElemDesc
.
HEADMISC
|
ElemDesc
.
EMPTY
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"IMG"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
|
ElemDesc
.
ASPECIAL
|
ElemDesc
.
EMPTY
|
ElemDesc
.
WHITESPACESENSITIVE
)
)
;
m_elementFlags
.
put
(
"OBJECT"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
|
ElemDesc
.
ASPECIAL
|
ElemDesc
.
HEADMISC
|
ElemDesc
.
WHITESPACESENSITIVE
)
)
;
m_elementFlags
.
put
(
"PARAM"
,
new
ElemDesc
(
0
|
ElemDesc
.
EMPTY
)
)
;
m_elementFlags
.
put
(
"HR"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
|
ElemDesc
.
EMPTY
)
)
;
m_elementFlags
.
put
(
"P"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
)
)
;
m_elementFlags
.
put
(
"H1"
,
new
ElemDesc
(
0
|
ElemDesc
.
HEAD
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"H2"
,
new
ElemDesc
(
0
|
ElemDesc
.
HEAD
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"H3"
,
new
ElemDesc
(
0
|
ElemDesc
.
HEAD
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"H4"
,
new
ElemDesc
(
0
|
ElemDesc
.
HEAD
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"H5"
,
new
ElemDesc
(
0
|
ElemDesc
.
HEAD
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"H6"
,
new
ElemDesc
(
0
|
ElemDesc
.
HEAD
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"PRE"
,
new
ElemDesc
(
0
|
ElemDesc
.
PREFORMATTED
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"Q"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
|
ElemDesc
.
ASPECIAL
)
)
;
m_elementFlags
.
put
(
"BLOCKQUOTE"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
)
)
;
m_elementFlags
.
put
(
"INS"
,
new
ElemDesc
(
0
)
)
;
m_elementFlags
.
put
(
"DEL"
,
new
ElemDesc
(
0
)
)
;
m_elementFlags
.
put
(
"DL"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
)
)
;
m_elementFlags
.
put
(
"DT"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"DD"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"OL"
,
new
ElemDesc
(
0
|
ElemDesc
.
LIST
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"UL"
,
new
ElemDesc
(
0
|
ElemDesc
.
LIST
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"LI"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"FORM"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"LABEL"
,
new
ElemDesc
(
0
|
ElemDesc
.
FORMCTRL
)
)
;
m_elementFlags
.
put
(
"INPUT"
,
new
ElemDesc
(
0
|
ElemDesc
.
FORMCTRL
|
ElemDesc
.
INLINELABEL
|
ElemDesc
.
EMPTY
)
)
;
m_elementFlags
.
put
(
"SELECT"
,
new
ElemDesc
(
0
|
ElemDesc
.
FORMCTRL
|
ElemDesc
.
INLINELABEL
)
)
;
m_elementFlags
.
put
(
"OPTGROUP"
,
new
ElemDesc
(
0
)
)
;
m_elementFlags
.
put
(
"OPTION"
,
new
ElemDesc
(
0
)
)
;
m_elementFlags
.
put
(
"TEXTAREA"
,
new
ElemDesc
(
0
|
ElemDesc
.
FORMCTRL
|
ElemDesc
.
INLINELABEL
)
)
;
m_elementFlags
.
put
(
"FIELDSET"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
)
)
;
m_elementFlags
.
put
(
"LEGEND"
,
new
ElemDesc
(
0
)
)
;
m_elementFlags
.
put
(
"BUTTON"
,
new
ElemDesc
(
0
|
ElemDesc
.
FORMCTRL
|
ElemDesc
.
INLINELABEL
)
)
;
m_elementFlags
.
put
(
"TABLE"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
)
)
;
m_elementFlags
.
put
(
"CAPTION"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"THEAD"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"TFOOT"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"TBODY"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"COLGROUP"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"COL"
,
new
ElemDesc
(
0
|
ElemDesc
.
EMPTY
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"TR"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"TH"
,
new
ElemDesc
(
0
)
)
;
m_elementFlags
.
put
(
"TD"
,
new
ElemDesc
(
0
)
)
;
m_elementFlags
.
put
(
"HEAD"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
HEADELEM
)
)
;
m_elementFlags
.
put
(
"TITLE"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"BASE"
,
new
ElemDesc
(
0
|
ElemDesc
.
EMPTY
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"META"
,
new
ElemDesc
(
0
|
ElemDesc
.
HEADMISC
|
ElemDesc
.
EMPTY
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"STYLE"
,
new
ElemDesc
(
0
|
ElemDesc
.
HEADMISC
|
ElemDesc
.
RAW
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"SCRIPT"
,
new
ElemDesc
(
0
|
ElemDesc
.
SPECIAL
|
ElemDesc
.
ASPECIAL
|
ElemDesc
.
HEADMISC
|
ElemDesc
.
RAW
)
)
;
m_elementFlags
.
put
(
"NOSCRIPT"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
)
)
;
m_elementFlags
.
put
(
"HTML"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
)
;
m_elementFlags
.
put
(
"FONT"
,
new
ElemDesc
(
0
|
ElemDesc
.
FONTSTYLE
)
)
;
m_elementFlags
.
put
(
"S"
,
new
ElemDesc
(
0
|
ElemDesc
.
FONTSTYLE
)
)
;
m_elementFlags
.
put
(
"STRIKE"
,
new
ElemDesc
(
0
|
ElemDesc
.
FONTSTYLE
)
)
;
m_elementFlags
.
put
(
"U"
,
new
ElemDesc
(
0
|
ElemDesc
.
FONTSTYLE
)
)
;
m_elementFlags
.
put
(
"NOBR"
,
new
ElemDesc
(
0
|
ElemDesc
.
FONTSTYLE
)
)
;
m_elementFlags
.
put
(
"IFRAME"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
)
)
;
m_elementFlags
.
put
(
"LAYER"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
)
)
;
m_elementFlags
.
put
(
"ILAYER"
,
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
|
ElemDesc
.
BLOCKFORM
|
ElemDesc
.
BLOCKFORMFIELDSET
)
)
;
ElemDesc
elemDesc
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"AREA"
)
;
elemDesc
.
setAttr
(
"HREF"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"NOHREF"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"BASE"
)
;
elemDesc
.
setAttr
(
"HREF"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"BLOCKQUOTE"
)
;
elemDesc
.
setAttr
(
"CITE"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"Q"
)
;
elemDesc
.
setAttr
(
"CITE"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"INS"
)
;
elemDesc
.
setAttr
(
"CITE"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"DEL"
)
;
elemDesc
.
setAttr
(
"CITE"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"A"
)
;
elemDesc
.
setAttr
(
"HREF"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"NAME"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"LINK"
)
;
elemDesc
.
setAttr
(
"HREF"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"INPUT"
)
;
elemDesc
.
setAttr
(
"SRC"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"USEMAP"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"CHECKED"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
.
setAttr
(
"DISABLED"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
.
setAttr
(
"ISMAP"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
.
setAttr
(
"READONLY"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"SELECT"
)
;
elemDesc
.
setAttr
(
"DISABLED"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
.
setAttr
(
"MULTIPLE"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"OPTGROUP"
)
;
elemDesc
.
setAttr
(
"DISABLED"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"OPTION"
)
;
elemDesc
.
setAttr
(
"SELECTED"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
.
setAttr
(
"DISABLED"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"TEXTAREA"
)
;
elemDesc
.
setAttr
(
"DISABLED"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
.
setAttr
(
"READONLY"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"BUTTON"
)
;
elemDesc
.
setAttr
(
"DISABLED"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"SCRIPT"
)
;
elemDesc
.
setAttr
(
"SRC"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"FOR"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"DEFER"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"IMG"
)
;
elemDesc
.
setAttr
(
"SRC"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"LONGDESC"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"USEMAP"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"ISMAP"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"OBJECT"
)
;
elemDesc
.
setAttr
(
"CLASSID"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"CODEBASE"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"DATA"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"ARCHIVE"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"USEMAP"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"DECLARE"
,
ElemDesc
.
ATTREMPTY
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"FORM"
)
;
elemDesc
.
setAttr
(
"ACTION"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"HEAD"
)
;
elemDesc
.
setAttr
(
"PROFILE"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"FRAME"
)
;
elemDesc
.
setAttr
(
"SRC"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"LONGDESC"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"IFRAME"
)
;
elemDesc
.
setAttr
(
"SRC"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
.
setAttr
(
"LONGDESC"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"LAYER"
)
;
elemDesc
.
setAttr
(
"SRC"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"ILAYER"
)
;
elemDesc
.
setAttr
(
"SRC"
,
ElemDesc
.
ATTRURL
)
;
elemDesc
=
(
ElemDesc
)
m_elementFlags
.
get
(
"DIV"
)
;
elemDesc
.
setAttr
(
"SRC"
,
ElemDesc
.
ATTRURL
)
;
}
static
private
ElemDesc
m_dummy
=
new
ElemDesc
(
0
|
ElemDesc
.
BLOCK
)
;
private
boolean
m_specialEscapeURLs
=
true
;
private
boolean
m_omitMetaTag
=
false
;
private
ElemDesc
m_elementDesc
=
null
;
public
void
setSpecialEscapeURLs
(
boolean
bool
)
{
m_specialEscapeURLs
=
bool
;
}
public
void
setOmitMetaTag
(
boolean
bool
)
{
m_omitMetaTag
=
bool
;
}
public
void
setOutputFormat
(
Properties
format
)
{
m_specialEscapeURLs
=
OutputPropertyUtils
.
getBooleanProperty
(
OutputPropertiesFactory
.
S_USE_URL_ESCAPING
,
format
)
;
m_omitMetaTag
=
OutputPropertyUtils
.
getBooleanProperty
(
OutputPropertiesFactory
.
S_OMIT_META_TAG
,
format
)
;
super
.
setOutputFormat
(
format
)
;
}
private
final
boolean
getSpecialEscapeURLs
(
)
{
return
m_specialEscapeURLs
;
}
private
final
boolean
getOmitMetaTag
(
)
{
return
m_omitMetaTag
;
}
private
final
ElemDesc
getElemDesc
(
String
name
)
{
if
(
null
!=
name
)
{
Object
obj
=
m_elementFlags
.
get
(
name
)
;
if
(
null
!=
obj
)
return
(
ElemDesc
)
obj
;
}
return
m_dummy
;
}
public
ToHTMLStream
(
)
{
super
(
)
;
m_charInfo
=
m_htmlcharInfo
;
m_prefixMap
=
new
NamespaceMappings
(
)
;
}
private
String
m_currentElementName
=
null
;
protected
void
startDocumentInternal
(
)
throws
org
.
xml
.
sax
.
SAXException
{
super
.
startDocumentInternal
(
)
;
m_needToCallStartDocument
=
false
;
m_needToOutputDocTypeDecl
=
true
;
m_startNewLine
=
false
;
setOmitXMLDeclaration
(
true
)
;
if
(
true
==
m_needToOutputDocTypeDecl
)
{
String
doctypeSystem
=
getDoctypeSystem
(
)
;
String
doctypePublic
=
getDoctypePublic
(
)
;
if
(
(
null
!=
doctypeSystem
)
||
(
null
!=
doctypePublic
)
)
{
try
{
m_writer
.
write
(
"<!DOCTYPE HTML"
)
;
if
(
null
!=
doctypePublic
)
{
m_writer
.
write
(
" PUBLIC \""
)
;
m_writer
.
write
(
doctypePublic
)
;
m_writer
.
write
(
"\""
)
;
}
if
(
null
!=
doctypeSystem
)
{
if
(
null
==
doctypePublic
)
m_writer
.
write
(
" SYSTEM \""
)
;
else
m_writer
.
write
(
" \""
)
;
m_writer
.
write
(
doctypeSystem
)
;
m_writer
.
write
(
"\""
)
;
}
m_writer
.
write
(
">"
)
;
outputLineSep
(
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
}
m_needToOutputDocTypeDecl
=
false
;
}
public
final
void
endDocument
(
)
throws
org
.
xml
.
sax
.
SAXException
{
flushPending
(
)
;
if
(
m_doIndent
&&
!
m_isprevtext
)
{
try
{
outputLineSep
(
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
flushWriter
(
)
;
super
.
fireEndDoc
(
)
;
}
public
void
startElement
(
String
namespaceURI
,
String
localName
,
String
name
,
Attributes
atts
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
else
if
(
m_needToCallStartDocument
)
startDocumentInternal
(
)
;
if
(
null
!=
namespaceURI
&&
namespaceURI
.
length
(
)
>
0
)
{
super
.
startElement
(
namespaceURI
,
localName
,
name
,
atts
)
;
return
;
}
try
{
boolean
savedDoIndent
=
m_doIndent
;
boolean
noLineBreak
;
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
ElemDesc
elemDesc
=
getElemDesc
(
name
)
;
m_elementLocalName
=
localName
;
m_elementURI
=
namespaceURI
;
m_elementName
=
name
;
m_elementDesc
=
elemDesc
;
boolean
isBlockElement
=
elemDesc
.
is
(
ElemDesc
.
BLOCK
)
;
boolean
isHeadElement
=
elemDesc
.
is
(
ElemDesc
.
HEADELEM
)
;
if
(
m_ispreserve
)
m_ispreserve
=
false
;
else
if
(
m_doIndent
&&
(
null
!=
m_currentElementName
)
&&
(
!
m_inBlockElem
||
isBlockElement
)
)
{
m_startNewLine
=
true
;
indent
(
)
;
}
m_inBlockElem
=
!
isBlockElement
;
m_isRawStack
.
push
(
elemDesc
.
is
(
ElemDesc
.
RAW
)
)
;
m_currentElementName
=
name
;
m_writer
.
write
(
'<'
)
;
m_writer
.
write
(
name
)
;
if
(
atts
!=
null
)
addAttributes
(
atts
)
;
m_startTagOpen
=
true
;
m_currentElemDepth
++
;
m_isprevtext
=
false
;
m_doIndent
=
savedDoIndent
;
if
(
isHeadElement
)
{
if
(
m_startTagOpen
)
closeStartTag
(
)
;
if
(
!
m_omitMetaTag
)
{
if
(
m_doIndent
)
indent
(
)
;
m_writer
.
write
(
"<META http-equiv=\"Content-Type\" content=\"text/html; charset="
)
;
String
encoding
=
getEncoding
(
)
;
String
encode
=
Encodings
.
getMimeEncoding
(
encoding
)
;
m_writer
.
write
(
encode
)
;
m_writer
.
write
(
'"'
)
;
m_writer
.
write
(
'>'
)
;
}
}
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
public
final
void
endElement
(
String
namespaceURI
,
String
localName
,
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
if
(
null
!=
namespaceURI
&&
namespaceURI
.
length
(
)
>
0
)
{
super
.
endElement
(
namespaceURI
,
localName
,
name
)
;
return
;
}
m_currentElemDepth
--
;
m_isRawStack
.
pop
(
)
;
ElemDesc
elemDesc
=
getElemDesc
(
name
)
;
m_elementDesc
=
elemDesc
;
boolean
isBlockElement
=
elemDesc
.
is
(
ElemDesc
.
BLOCK
)
;
boolean
shouldIndent
=
false
;
if
(
m_ispreserve
)
{
m_ispreserve
=
false
;
}
else
if
(
m_doIndent
&&
(
!
m_inBlockElem
||
isBlockElement
)
)
{
m_startNewLine
=
true
;
shouldIndent
=
true
;
}
m_inBlockElem
=
!
isBlockElement
;
try
{
if
(
!
m_startTagOpen
)
{
if
(
shouldIndent
)
indent
(
)
;
m_writer
.
write
(
"</"
)
;
m_writer
.
write
(
name
)
;
m_writer
.
write
(
'>'
)
;
m_currentElementName
=
name
;
m_cdataSectionStates
.
pop
(
)
;
if
(
!
m_preserves
.
isEmpty
(
)
)
m_preserves
.
pop
(
)
;
}
else
{
processAttributes
(
)
;
if
(
!
elemDesc
.
is
(
ElemDesc
.
EMPTY
)
)
{
m_writer
.
write
(
'>'
)
;
m_writer
.
write
(
'<'
)
;
m_writer
.
write
(
'/'
)
;
m_writer
.
write
(
name
)
;
m_writer
.
write
(
'>'
)
;
}
else
{
m_writer
.
write
(
'>'
)
;
}
}
if
(
elemDesc
.
is
(
ElemDesc
.
WHITESPACESENSITIVE
)
)
m_ispreserve
=
true
;
m_startTagOpen
=
false
;
m_isprevtext
=
false
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
super
.
fireEndElem
(
name
)
;
}
protected
void
processAttribute
(
String
name
,
String
value
,
ElemDesc
elemDesc
)
throws
IOException
{
m_writer
.
write
(
' '
)
;
if
(
(
(
value
.
length
(
)
==
0
)
||
value
.
equalsIgnoreCase
(
name
)
)
&&
elemDesc
!=
null
&&
elemDesc
.
isAttrFlagSet
(
name
,
ElemDesc
.
ATTREMPTY
)
)
{
m_writer
.
write
(
name
)
;
}
else
{
m_writer
.
write
(
name
)
;
m_writer
.
write
(
'='
)
;
m_writer
.
write
(
'\"'
)
;
if
(
elemDesc
!=
null
&&
elemDesc
.
isAttrFlagSet
(
name
,
ElemDesc
.
ATTRURL
)
)
writeAttrURI
(
value
,
m_specialEscapeURLs
)
;
else
writeAttrString
(
value
,
this
.
getEncoding
(
)
)
;
m_writer
.
write
(
'\"'
)
;
}
}
private
boolean
isASCIIDigit
(
char
c
)
{
return
(
c
>=
'0'
&&
c
<=
'9'
)
;
}
private
String
makeHHString
(
int
i
)
{
String
s
=
Integer
.
toHexString
(
i
)
.
toUpperCase
(
)
;
if
(
s
.
length
(
)
==
1
)
{
s
=
"0"
+
s
;
}
return
s
;
}
private
boolean
isHHSign
(
String
str
)
{
boolean
sign
=
true
;
try
{
char
r
=
(
char
)
Integer
.
parseInt
(
str
,
16
)
;
}
catch
(
NumberFormatException
e
)
{
sign
=
false
;
}
return
sign
;
}
public
void
writeAttrURI
(
String
string
,
boolean
doURLEscaping
)
throws
IOException
{
char
[
]
stringArray
=
string
.
toCharArray
(
)
;
int
len
=
stringArray
.
length
;
for
(
int
i
=
0
;
i
<
len
;
i
++
)
{
char
ch
=
stringArray
[
i
]
;
if
(
(
ch
<
32
)
||
(
ch
>
126
)
)
{
if
(
doURLEscaping
)
{
if
(
ch
<=
0x7F
)
{
m_writer
.
write
(
'%'
)
;
m_writer
.
write
(
makeHHString
(
ch
)
)
;
}
else
if
(
ch
<=
0x7FF
)
{
int
high
=
(
ch
>
>
6
)
|
0xC0
;
int
low
=
(
ch
&
0x3F
)
|
0x80
;
m_writer
.
write
(
'%'
)
;
m_writer
.
write
(
makeHHString
(
high
)
)
;
m_writer
.
write
(
'%'
)
;
m_writer
.
write
(
makeHHString
(
low
)
)
;
}
else
if
(
isUTF16Surrogate
(
ch
)
)
{
int
highSurrogate
=
(
(
int
)
ch
)
&
0x03FF
;
int
wwww
=
(
(
highSurrogate
&
0x03C0
)
>
>
6
)
;
int
uuuuu
=
wwww
+
1
;
int
zzzz
=
(
highSurrogate
&
0x003C
)
>
>
2
;
int
yyyyyy
=
(
(
highSurrogate
&
0x0003
)
<<
4
)
&
0x30
;
ch
=
stringArray
[
++
i
]
;
int
lowSurrogate
=
(
(
int
)
ch
)
&
0x03FF
;
yyyyyy
=
yyyyyy
|
(
(
lowSurrogate
&
0x03C0
)
>
>
6
)
;
int
xxxxxx
=
(
lowSurrogate
&
0x003F
)
;
int
byte1
=
0xF0
|
(
uuuuu
>
>
2
)
;
int
byte2
=
0x80
|
(
(
(
uuuuu
&
0x03
)
<<
4
)
&
0x30
)
|
zzzz
;
int
byte3
=
0x80
|
yyyyyy
;
int
byte4
=
0x80
|
xxxxxx
;
m_writer
.
write
(
'%'
)
;
m_writer
.
write
(
makeHHString
(
byte1
)
)
;
m_writer
.
write
(
'%'
)
;
m_writer
.
write
(
makeHHString
(
byte2
)
)
;
m_writer
.
write
(
'%'
)
;
m_writer
.
write
(
makeHHString
(
byte3
)
)
;
m_writer
.
write
(
'%'
)
;
m_writer
.
write
(
makeHHString
(
byte4
)
)
;
}
else
{
int
high
=
(
ch
>
>
12
)
|
0xE0
;
int
middle
=
(
(
ch
&
0x0FC0
)
>
>
6
)
|
0x80
;
int
low
=
(
ch
&
0x3F
)
|
0x80
;
m_writer
.
write
(
'%'
)
;
m_writer
.
write
(
makeHHString
(
high
)
)
;
m_writer
.
write
(
'%'
)
;
m_writer
.
write
(
makeHHString
(
middle
)
)
;
m_writer
.
write
(
'%'
)
;
m_writer
.
write
(
makeHHString
(
low
)
)
;
}
}
else
if
(
escapingNotNeeded
(
ch
)
)
{
m_writer
.
write
(
ch
)
;
}
else
{
m_writer
.
write
(
"&#"
)
;
m_writer
.
write
(
Integer
.
toString
(
ch
)
)
;
m_writer
.
write
(
';'
)
;
}
}
else
if
(
'%'
==
ch
)
{
m_writer
.
write
(
ch
)
;
}
else
if
(
ch
==
'"'
)
{
if
(
doURLEscaping
)
m_writer
.
write
(
"%22"
)
;
else
m_writer
.
write
(
"&quot;"
)
;
}
else
{
m_writer
.
write
(
ch
)
;
}
}
}
public
void
writeAttrString
(
String
string
,
String
encoding
)
throws
IOException
{
final
char
chars
[
]
=
string
.
toCharArray
(
)
;
final
int
strLen
=
chars
.
length
;
for
(
int
i
=
0
;
i
<
strLen
;
i
++
)
{
char
ch
=
chars
[
i
]
;
if
(
escapingNotNeeded
(
ch
)
&&
(
!
m_charInfo
.
isSpecial
(
ch
)
)
)
{
m_writer
.
write
(
ch
)
;
}
else
if
(
'<'
==
ch
||
'>'
==
ch
)
{
m_writer
.
write
(
ch
)
;
}
else
if
(
(
'&'
==
ch
)
&&
(
(
i
+
1
)
<
strLen
)
&&
(
'{'
==
chars
[
i
+
1
]
)
)
{
m_writer
.
write
(
ch
)
;
}
else
{
int
pos
=
accumDefaultEntity
(
m_writer
,
ch
,
i
,
chars
,
strLen
,
false
)
;
if
(
i
!=
pos
)
{
i
=
pos
-
1
;
}
else
{
if
(
isUTF16Surrogate
(
ch
)
)
{
i
=
writeUTF16Surrogate
(
ch
,
chars
,
i
,
strLen
)
;
}
String
entityName
=
m_charInfo
.
getEntityNameForChar
(
ch
)
;
if
(
null
!=
entityName
)
{
m_writer
.
write
(
'&'
)
;
m_writer
.
write
(
entityName
)
;
m_writer
.
write
(
';'
)
;
}
else
if
(
escapingNotNeeded
(
ch
)
)
{
m_writer
.
write
(
ch
)
;
}
else
{
m_writer
.
write
(
"&#"
)
;
m_writer
.
write
(
Integer
.
toString
(
ch
)
)
;
m_writer
.
write
(
';'
)
;
}
}
}
}
}
public
final
void
characters
(
char
chars
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_isRawStack
.
peekOrFalse
(
)
)
{
try
{
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
m_ispreserve
=
true
;
writeNormalizedChars
(
chars
,
start
,
length
,
false
)
;
super
.
fireCharEvent
(
chars
,
start
,
length
)
;
return
;
}
catch
(
IOException
ioe
)
{
throw
new
org
.
xml
.
sax
.
SAXException
(
XMLMessages
.
createXMLMessage
(
XMLErrorResources
.
ER_OIERROR
,
null
)
,
ioe
)
;
}
}
else
{
super
.
characters
(
chars
,
start
,
length
)
;
}
}
public
final
void
cdata
(
char
ch
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
(
null
!=
m_currentElementName
)
&&
(
m_currentElementName
.
equalsIgnoreCase
(
"SCRIPT"
)
||
m_currentElementName
.
equalsIgnoreCase
(
"STYLE"
)
)
)
{
try
{
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
m_ispreserve
=
true
;
if
(
shouldIndent
(
)
)
indent
(
)
;
writeNormalizedChars
(
ch
,
start
,
length
,
true
)
;
}
catch
(
IOException
ioe
)
{
throw
new
org
.
xml
.
sax
.
SAXException
(
XMLMessages
.
createXMLMessage
(
XMLErrorResources
.
ER_OIERROR
,
null
)
,
ioe
)
;
}
}
else
{
super
.
cdata
(
ch
,
start
,
length
)
;
}
}
public
void
processingInstruction
(
String
target
,
String
data
)
throws
org
.
xml
.
sax
.
SAXException
{
flushPending
(
)
;
if
(
target
.
equals
(
Result
.
PI_DISABLE_OUTPUT_ESCAPING
)
)
{
startNonEscaping
(
)
;
}
else
if
(
target
.
equals
(
Result
.
PI_ENABLE_OUTPUT_ESCAPING
)
)
{
endNonEscaping
(
)
;
}
else
{
try
{
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
else
if
(
m_needToCallStartDocument
)
startDocumentInternal
(
)
;
if
(
shouldIndent
(
)
)
indent
(
)
;
m_writer
.
write
(
"<?"
+
target
)
;
if
(
data
.
length
(
)
>
0
&&
!
Character
.
isSpaceChar
(
data
.
charAt
(
0
)
)
)
m_writer
.
write
(
" "
)
;
m_writer
.
write
(
data
+
">"
)
;
if
(
m_currentElemDepth
<=
0
)
outputLineSep
(
)
;
m_startNewLine
=
true
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
super
.
fireEscapingEvent
(
target
,
data
)
;
}
public
final
void
entityReference
(
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
m_writer
.
write
(
"&"
)
;
m_writer
.
write
(
name
)
;
m_writer
.
write
(
";"
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
public
final
void
endElement
(
String
elemName
)
throws
SAXException
{
endElement
(
null
,
null
,
elemName
)
;
}
public
void
processAttributes
(
)
throws
IOException
,
SAXException
{
super
.
fireStartElem
(
m_elementName
)
;
int
nAttrs
=
0
;
if
(
(
nAttrs
=
m_attributes
.
getLength
(
)
)
>
0
)
{
for
(
int
i
=
0
;
i
<
nAttrs
;
i
++
)
{
processAttribute
(
m_attributes
.
getQName
(
i
)
,
m_attributes
.
getValue
(
i
)
,
m_elementDesc
)
;
}
m_attributes
.
clear
(
)
;
}
}
protected
void
closeStartTag
(
)
throws
SAXException
{
if
(
m_startTagOpen
)
{
try
{
processAttributes
(
)
;
m_writer
.
write
(
'>'
)
;
pushCdataSectionState
(
)
;
m_isprevtext
=
false
;
m_preserves
.
push
(
m_ispreserve
)
;
m_startTagOpen
=
false
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
}
protected
synchronized
void
init
(
OutputStream
output
,
Properties
format
)
throws
UnsupportedEncodingException
{
if
(
null
==
format
)
{
format
=
OutputPropertiesFactory
.
getDefaultMethodProperties
(
Method
.
HTML
)
;
}
super
.
init
(
output
,
format
,
false
)
;
}
public
void
setOutputStream
(
OutputStream
output
)
{
try
{
Properties
format
;
if
(
null
==
m_format
)
format
=
OutputPropertiesFactory
.
getDefaultMethodProperties
(
Method
.
HTML
)
;
else
format
=
m_format
;
init
(
output
,
format
,
true
)
;
}
catch
(
UnsupportedEncodingException
uee
)
{
}
}
public
void
namespaceAfterStartElement
(
String
prefix
,
String
uri
)
throws
SAXException
{
if
(
m_elementURI
==
null
)
{
String
prefix1
=
getPrefixPart
(
m_elementName
)
;
if
(
prefix1
==
null
&&
EMPTYSTRING
.
equals
(
prefix
)
)
{
m_elementURI
=
uri
;
}
}
startPrefixMapping
(
prefix
,
uri
,
false
)
;
}
}
