package
org
.
apache
.
xml
.
serializer
;
import
java
.
io
.
IOException
;
import
javax
.
xml
.
transform
.
ErrorListener
;
import
javax
.
xml
.
transform
.
Result
;
import
javax
.
xml
.
transform
.
Transformer
;
import
javax
.
xml
.
transform
.
TransformerException
;
import
org
.
apache
.
xml
.
res
.
XMLErrorResources
;
import
org
.
apache
.
xml
.
res
.
XMLMessages
;
import
org
.
xml
.
sax
.
SAXException
;
public
class
ToXMLStream
extends
ToStream
{
private
boolean
m_cdataTagOpen
=
false
;
protected
static
CharInfo
m_xmlcharInfo
=
CharInfo
.
getCharInfo
(
CharInfo
.
XML_ENTITIES_RESOURCE
)
;
public
ToXMLStream
(
)
{
m_charInfo
=
m_xmlcharInfo
;
initCDATA
(
)
;
m_prefixMap
=
new
NamespaceMappings
(
)
;
}
public
void
CopyFrom
(
ToXMLStream
xmlListener
)
{
m_writer
=
xmlListener
.
m_writer
;
String
encoding
=
xmlListener
.
getEncoding
(
)
;
setEncoding
(
encoding
)
;
setOmitXMLDeclaration
(
xmlListener
.
getOmitXMLDeclaration
(
)
)
;
m_startTagOpen
=
xmlListener
.
m_startTagOpen
;
m_ispreserve
=
xmlListener
.
m_ispreserve
;
m_preserves
=
xmlListener
.
m_preserves
;
m_isprevtext
=
xmlListener
.
m_isprevtext
;
m_doIndent
=
xmlListener
.
m_doIndent
;
m_currentElemDepth
=
xmlListener
.
m_currentElemDepth
;
setIndentAmount
(
xmlListener
.
getIndentAmount
(
)
)
;
m_startNewLine
=
xmlListener
.
m_startNewLine
;
m_needToOutputDocTypeDecl
=
xmlListener
.
m_needToOutputDocTypeDecl
;
setDoctypeSystem
(
xmlListener
.
getDoctypeSystem
(
)
)
;
setDoctypePublic
(
xmlListener
.
getDoctypePublic
(
)
)
;
setStandalone
(
xmlListener
.
getStandalone
(
)
)
;
setMediaType
(
xmlListener
.
getMediaType
(
)
)
;
m_maxCharacter
=
xmlListener
.
m_maxCharacter
;
m_spaceBeforeClose
=
xmlListener
.
m_spaceBeforeClose
;
m_cdataStartCalled
=
xmlListener
.
m_cdataStartCalled
;
}
public
void
startDocumentInternal
(
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_needToCallStartDocument
)
{
super
.
startDocumentInternal
(
)
;
m_needToCallStartDocument
=
false
;
if
(
m_inEntityRef
)
return
;
m_needToOutputDocTypeDecl
=
true
;
m_startNewLine
=
false
;
if
(
getOmitXMLDeclaration
(
)
==
false
)
{
String
encoding
=
Encodings
.
getMimeEncoding
(
getEncoding
(
)
)
;
String
version
=
getVersion
(
)
;
if
(
version
==
null
)
version
=
"1.0"
;
String
standalone
;
if
(
m_standaloneWasSpecified
)
{
standalone
=
" standalone=\""
+
getStandalone
(
)
+
"\""
;
}
else
{
standalone
=
""
;
}
try
{
m_writer
.
write
(
"<?xml version=\""
)
;
m_writer
.
write
(
version
)
;
m_writer
.
write
(
"\" encoding=\""
)
;
m_writer
.
write
(
encoding
)
;
m_writer
.
write
(
'\"'
)
;
m_writer
.
write
(
standalone
)
;
m_writer
.
write
(
"?>"
)
;
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
}
}
public
void
endDocument
(
)
throws
org
.
xml
.
sax
.
SAXException
{
flushPending
(
)
;
if
(
m_doIndent
&&
!
m_isprevtext
)
{
try
{
outputLineSep
(
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
flushWriter
(
)
;
super
.
fireEndDoc
(
)
;
}
public
void
startPreserving
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_preserves
.
push
(
true
)
;
m_ispreserve
=
true
;
}
public
void
endPreserving
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_ispreserve
=
m_preserves
.
isEmpty
(
)
?
false
:
m_preserves
.
pop
(
)
;
}
public
void
processingInstruction
(
String
target
,
String
data
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_inEntityRef
)
return
;
flushPending
(
)
;
if
(
target
.
equals
(
Result
.
PI_DISABLE_OUTPUT_ESCAPING
)
)
{
startNonEscaping
(
)
;
}
else
if
(
target
.
equals
(
Result
.
PI_ENABLE_OUTPUT_ESCAPING
)
)
{
endNonEscaping
(
)
;
}
else
{
try
{
if
(
m_startTagOpen
)
closeStartTag
(
)
;
if
(
shouldIndent
(
)
)
indent
(
)
;
m_writer
.
write
(
'<'
)
;
m_writer
.
write
(
'?'
)
;
m_writer
.
write
(
target
)
;
if
(
data
.
length
(
)
>
0
&&
!
Character
.
isSpaceChar
(
data
.
charAt
(
0
)
)
)
m_writer
.
write
(
' '
)
;
int
indexOfQLT
=
data
.
indexOf
(
"?>"
)
;
if
(
indexOfQLT
>=
0
)
{
if
(
indexOfQLT
>
0
)
{
m_writer
.
write
(
data
.
substring
(
0
,
indexOfQLT
)
)
;
}
m_writer
.
write
(
"? >"
)
;
if
(
(
indexOfQLT
+
2
)
<
data
.
length
(
)
)
{
m_writer
.
write
(
data
.
substring
(
indexOfQLT
+
2
)
)
;
}
}
else
{
m_writer
.
write
(
data
)
;
}
m_writer
.
write
(
'?'
)
;
m_writer
.
write
(
'>'
)
;
if
(
m_currentElemDepth
<=
0
)
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
m_startNewLine
=
true
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
super
.
fireEscapingEvent
(
target
,
data
)
;
}
public
void
entityReference
(
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
try
{
if
(
shouldIndent
(
)
)
indent
(
)
;
m_writer
.
write
(
"&"
)
;
m_writer
.
write
(
name
)
;
m_writer
.
write
(
";"
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
super
.
fireEntityReference
(
name
)
;
}
public
void
addAttribute
(
String
uri
,
String
localName
,
String
rawName
,
String
type
,
String
value
)
throws
SAXException
{
if
(
m_startTagOpen
)
{
if
(
!
rawName
.
startsWith
(
"xmlns"
)
)
{
String
prefixUsed
=
ensureAttributesNamespaceIsDeclared
(
uri
,
localName
,
rawName
)
;
if
(
prefixUsed
!=
null
&&
rawName
!=
null
&&
!
rawName
.
startsWith
(
prefixUsed
)
)
{
rawName
=
prefixUsed
+
":"
+
localName
;
}
}
addAttributeAlways
(
uri
,
localName
,
rawName
,
type
,
value
)
;
}
else
{
String
msg
=
XMLMessages
.
createXMLMessage
(
XMLErrorResources
.
ER_ILLEGAL_ATTRIBUTE_POSITION
,
new
Object
[
]
{
localName
}
)
;
try
{
Transformer
tran
=
super
.
getTransformer
(
)
;
ErrorListener
errHandler
=
tran
.
getErrorListener
(
)
;
if
(
null
!=
errHandler
&&
m_sourceLocator
!=
null
)
errHandler
.
warning
(
new
TransformerException
(
msg
,
m_sourceLocator
)
)
;
else
System
.
out
.
println
(
msg
)
;
}
catch
(
Exception
e
)
{
}
}
}
private
String
escapeString
(
String
value
)
{
final
char
[
]
ch
=
value
.
toCharArray
(
)
;
final
int
limit
=
ch
.
length
;
StringBuffer
result
=
new
StringBuffer
(
)
;
int
offset
=
0
;
for
(
int
i
=
0
;
i
<
limit
;
i
++
)
{
switch
(
ch
[
i
]
)
{
case
'&'
:
result
.
append
(
ch
,
offset
,
i
-
offset
)
.
append
(
ENTITY_AMP
)
;
offset
=
i
+
1
;
break
;
case
'"'
:
result
.
append
(
ch
,
offset
,
i
-
offset
)
.
append
(
ENTITY_QUOT
)
;
offset
=
i
+
1
;
break
;
case
'<'
:
result
.
append
(
ch
,
offset
,
i
-
offset
)
.
append
(
ENTITY_LT
)
;
offset
=
i
+
1
;
break
;
case
'>'
:
result
.
append
(
ch
,
offset
,
i
-
offset
)
.
append
(
ENTITY_GT
)
;
offset
=
i
+
1
;
break
;
case
'\n'
:
result
.
append
(
ch
,
offset
,
i
-
offset
)
.
append
(
ENTITY_CRLF
)
;
offset
=
i
+
1
;
break
;
}
}
if
(
offset
<
limit
)
{
result
.
append
(
ch
,
offset
,
limit
-
offset
)
;
}
return
result
.
toString
(
)
;
}
public
void
endElement
(
String
elemName
)
throws
SAXException
{
endElement
(
null
,
null
,
elemName
)
;
}
public
void
namespaceAfterStartElement
(
final
String
prefix
,
final
String
uri
)
throws
SAXException
{
if
(
m_elementURI
==
null
)
{
String
prefix1
=
getPrefixPart
(
m_elementName
)
;
if
(
prefix1
==
null
&&
EMPTYSTRING
.
equals
(
prefix
)
)
{
m_elementURI
=
uri
;
}
}
startPrefixMapping
(
prefix
,
uri
,
false
)
;
return
;
}
protected
boolean
pushNamespace
(
String
prefix
,
String
uri
)
{
try
{
if
(
m_prefixMap
.
pushNamespace
(
prefix
,
uri
,
m_currentElemDepth
)
)
{
startPrefixMapping
(
prefix
,
uri
)
;
return
true
;
}
}
catch
(
SAXException
e
)
{
}
return
false
;
}
}
