package
org
.
apache
.
xml
.
serializer
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
io
.
Writer
;
import
java
.
util
.
BitSet
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Properties
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Vector
;
import
javax
.
xml
.
transform
.
OutputKeys
;
import
javax
.
xml
.
transform
.
Transformer
;
import
org
.
apache
.
xml
.
res
.
XMLErrorResources
;
import
org
.
apache
.
xml
.
res
.
XMLMessages
;
import
org
.
apache
.
xml
.
utils
.
BoolStack
;
import
org
.
apache
.
xml
.
utils
.
FastStringBuffer
;
import
org
.
apache
.
xml
.
utils
.
QName
;
import
org
.
apache
.
xml
.
utils
.
SystemIDResolver
;
import
org
.
apache
.
xml
.
utils
.
TreeWalker
;
import
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
;
import
org
.
w3c
.
dom
.
Node
;
import
org
.
xml
.
sax
.
Attributes
;
import
org
.
xml
.
sax
.
ContentHandler
;
import
org
.
xml
.
sax
.
SAXException
;
abstract
public
class
ToStream
extends
SerializerBase
{
private
static
final
String
COMMENT_BEGIN
=
"<!--"
;
private
static
final
String
COMMENT_END
=
"-->"
;
protected
BoolStack
m_disableOutputEscapingStates
=
new
BoolStack
(
)
;
boolean
m_triedToGetConverter
=
false
;
java
.
lang
.
reflect
.
Method
m_canConvertMeth
;
Object
m_charToByteConverter
=
null
;
protected
BoolStack
m_preserves
=
new
BoolStack
(
)
;
protected
boolean
m_ispreserve
=
false
;
protected
boolean
m_isprevtext
=
false
;
private
static
CharInfo
m_xmlcharInfo
=
CharInfo
.
getCharInfo
(
CharInfo
.
XML_ENTITIES_RESOURCE
)
;
protected
int
m_maxCharacter
=
Encodings
.
getLastPrintable
(
)
;
protected
final
char
[
]
m_lineSep
=
System
.
getProperty
(
"line.separator"
)
.
toCharArray
(
)
;
protected
final
int
m_lineSepLen
=
m_lineSep
.
length
;
protected
CharInfo
m_charInfo
;
private
static
Hashtable
m_charInfos
=
null
;
boolean
m_shouldFlush
=
true
;
protected
boolean
m_spaceBeforeClose
=
false
;
boolean
m_startNewLine
;
protected
boolean
m_inDoctype
=
false
;
boolean
m_isUTF8
=
false
;
protected
Properties
m_format
;
protected
boolean
m_cdataStartCalled
=
false
;
public
ToStream
(
)
{
}
protected
void
closeCDATA
(
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
m_writer
.
write
(
CDATA_DELIMITER_CLOSE
)
;
m_cdataTagOpen
=
false
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
public
void
serialize
(
Node
node
)
throws
IOException
{
try
{
TreeWalker
walker
=
new
TreeWalker
(
this
,
new
org
.
apache
.
xml
.
utils
.
DOM2Helper
(
)
)
;
walker
.
traverse
(
node
)
;
}
catch
(
org
.
xml
.
sax
.
SAXException
se
)
{
throw
new
WrappedRuntimeException
(
se
)
;
}
}
static
final
boolean
isUTF16Surrogate
(
char
c
)
{
return
(
c
&
0xFC00
)
==
0xD800
;
}
private
boolean
m_escaping
=
true
;
protected
final
void
flushWriter
(
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
null
!=
m_writer
)
{
try
{
if
(
m_writer
instanceof
WriterToUTF8Buffered
)
{
if
(
m_shouldFlush
)
(
(
WriterToUTF8Buffered
)
m_writer
)
.
flush
(
)
;
else
(
(
WriterToUTF8Buffered
)
m_writer
)
.
flushBuffer
(
)
;
}
if
(
m_writer
instanceof
WriterToUTF8
)
{
if
(
m_shouldFlush
)
m_writer
.
flush
(
)
;
}
else
if
(
m_writer
instanceof
WriterToASCI
)
{
if
(
m_shouldFlush
)
m_writer
.
flush
(
)
;
}
else
{
m_writer
.
flush
(
)
;
}
}
catch
(
IOException
ioe
)
{
throw
new
org
.
xml
.
sax
.
SAXException
(
ioe
)
;
}
}
}
public
OutputStream
getOutputStream
(
)
{
if
(
m_writer
instanceof
WriterToUTF8Buffered
)
return
(
(
WriterToUTF8Buffered
)
m_writer
)
.
getOutputStream
(
)
;
if
(
m_writer
instanceof
WriterToUTF8
)
return
(
(
WriterToUTF8
)
m_writer
)
.
getOutputStream
(
)
;
else
if
(
m_writer
instanceof
WriterToASCI
)
return
(
(
WriterToASCI
)
m_writer
)
.
getOutputStream
(
)
;
else
return
null
;
}
public
void
elementDecl
(
String
name
,
String
model
)
throws
SAXException
{
if
(
m_inExternalDTD
)
return
;
try
{
if
(
m_inDoctype
)
{
m_writer
.
write
(
" ["
)
;
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
m_inDoctype
=
false
;
}
m_writer
.
write
(
"<!ELEMENT "
)
;
m_writer
.
write
(
name
)
;
m_writer
.
write
(
' '
)
;
m_writer
.
write
(
model
)
;
m_writer
.
write
(
'>'
)
;
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
public
void
internalEntityDecl
(
String
name
,
String
value
)
throws
SAXException
{
if
(
m_inExternalDTD
)
return
;
try
{
if
(
m_inDoctype
)
{
m_writer
.
write
(
" ["
)
;
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
m_inDoctype
=
false
;
}
outputEntityDecl
(
name
,
value
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
void
outputEntityDecl
(
String
name
,
String
value
)
throws
IOException
{
m_writer
.
write
(
"<!ENTITY "
)
;
m_writer
.
write
(
name
)
;
m_writer
.
write
(
" \""
)
;
m_writer
.
write
(
value
)
;
m_writer
.
write
(
"\">"
)
;
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
protected
final
void
outputLineSep
(
)
throws
IOException
{
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
public
void
setOutputFormat
(
Properties
format
)
{
boolean
shouldFlush
=
m_shouldFlush
;
init
(
m_writer
,
format
,
false
,
false
)
;
m_shouldFlush
=
shouldFlush
;
}
private
synchronized
void
init
(
Writer
writer
,
Properties
format
,
boolean
defaultProperties
,
boolean
shouldFlush
)
{
m_shouldFlush
=
shouldFlush
;
if
(
m_tracer
!=
null
&&
!
(
writer
instanceof
SerializerTraceWriter
)
)
m_writer
=
new
SerializerTraceWriter
(
writer
,
m_tracer
)
;
else
m_writer
=
writer
;
m_format
=
format
;
setCdataSectionElements
(
OutputKeys
.
CDATA_SECTION_ELEMENTS
,
format
)
;
setIndentAmount
(
OutputPropertyUtils
.
getIntProperty
(
OutputPropertiesFactory
.
S_KEY_INDENT_AMOUNT
,
format
)
)
;
setIndent
(
OutputPropertyUtils
.
getBooleanProperty
(
OutputKeys
.
INDENT
,
format
)
)
;
boolean
shouldNotWriteXMLHeader
=
OutputPropertyUtils
.
getBooleanProperty
(
OutputKeys
.
OMIT_XML_DECLARATION
,
format
)
;
setOmitXMLDeclaration
(
shouldNotWriteXMLHeader
)
;
setDoctypeSystem
(
format
.
getProperty
(
OutputKeys
.
DOCTYPE_SYSTEM
)
)
;
String
doctypePublic
=
format
.
getProperty
(
OutputKeys
.
DOCTYPE_PUBLIC
)
;
setDoctypePublic
(
doctypePublic
)
;
if
(
format
.
get
(
OutputKeys
.
STANDALONE
)
!=
null
)
{
String
val
=
format
.
getProperty
(
OutputKeys
.
STANDALONE
)
;
if
(
defaultProperties
)
setStandaloneInternal
(
val
)
;
else
setStandalone
(
val
)
;
}
setMediaType
(
format
.
getProperty
(
OutputKeys
.
MEDIA_TYPE
)
)
;
if
(
null
!=
doctypePublic
)
{
if
(
doctypePublic
.
startsWith
(
"-//W3C//DTD XHTML"
)
)
m_spaceBeforeClose
=
true
;
}
String
encoding
=
getEncoding
(
)
;
if
(
null
==
encoding
)
{
encoding
=
Encodings
.
getMimeEncoding
(
format
.
getProperty
(
OutputKeys
.
ENCODING
)
)
;
setEncoding
(
encoding
)
;
}
m_isUTF8
=
encoding
.
equals
(
Encodings
.
DEFAULT_MIME_ENCODING
)
;
m_maxCharacter
=
Encodings
.
getLastPrintable
(
encoding
)
;
String
entitiesFileName
=
(
String
)
format
.
get
(
OutputPropertiesFactory
.
S_KEY_ENTITIES
)
;
if
(
null
!=
entitiesFileName
)
{
m_charInfo
=
CharInfo
.
getCharInfo
(
entitiesFileName
)
;
}
}
private
synchronized
void
init
(
Writer
writer
,
Properties
format
)
{
init
(
writer
,
format
,
false
,
false
)
;
}
protected
synchronized
void
init
(
OutputStream
output
,
Properties
format
,
boolean
defaultProperties
)
throws
UnsupportedEncodingException
{
String
encoding
=
getEncoding
(
)
;
if
(
encoding
==
null
)
{
encoding
=
Encodings
.
getMimeEncoding
(
format
.
getProperty
(
OutputKeys
.
ENCODING
)
)
;
setEncoding
(
encoding
)
;
}
if
(
encoding
.
equalsIgnoreCase
(
"UTF-8"
)
)
{
m_isUTF8
=
true
;
if
(
output
instanceof
java
.
io
.
BufferedOutputStream
)
{
init
(
new
WriterToUTF8
(
output
)
,
format
,
defaultProperties
,
true
)
;
}
else
{
init
(
new
WriterToUTF8Buffered
(
output
)
,
format
,
defaultProperties
,
true
)
;
}
}
else
if
(
encoding
.
equals
(
"WINDOWS-1250"
)
||
encoding
.
equals
(
"US-ASCII"
)
||
encoding
.
equals
(
"ASCII"
)
)
{
init
(
new
WriterToASCI
(
output
)
,
format
,
defaultProperties
,
true
)
;
}
else
{
Writer
osw
;
try
{
osw
=
Encodings
.
getWriter
(
output
,
encoding
)
;
}
catch
(
UnsupportedEncodingException
uee
)
{
System
.
out
.
println
(
"Warning: encoding \""
+
encoding
+
"\" not supported"
+
", using "
+
Encodings
.
DEFAULT_MIME_ENCODING
)
;
encoding
=
Encodings
.
DEFAULT_MIME_ENCODING
;
setEncoding
(
encoding
)
;
osw
=
Encodings
.
getWriter
(
output
,
encoding
)
;
}
m_maxCharacter
=
Encodings
.
getLastPrintable
(
encoding
)
;
init
(
osw
,
format
,
defaultProperties
,
true
)
;
}
}
public
Properties
getOutputFormat
(
)
{
return
m_format
;
}
public
void
setWriter
(
Writer
writer
)
{
if
(
m_tracer
!=
null
&&
!
(
writer
instanceof
SerializerTraceWriter
)
)
m_writer
=
new
SerializerTraceWriter
(
writer
,
m_tracer
)
;
else
m_writer
=
writer
;
}
public
void
setOutputStream
(
OutputStream
output
)
{
try
{
Properties
format
;
if
(
null
==
m_format
)
format
=
OutputPropertiesFactory
.
getDefaultMethodProperties
(
Method
.
XML
)
;
else
format
=
m_format
;
init
(
output
,
format
,
true
)
;
}
catch
(
UnsupportedEncodingException
uee
)
{
}
}
public
boolean
setEscaping
(
boolean
escape
)
{
final
boolean
temp
=
m_escaping
;
m_escaping
=
escape
;
return
temp
;
}
public
boolean
reset
(
)
{
m_needToCallStartDocument
=
true
;
return
false
;
}
protected
void
indent
(
)
throws
IOException
{
if
(
m_startNewLine
)
outputLineSep
(
)
;
if
(
m_indentAmount
>
0
)
printSpace
(
m_currentElemDepth
*
m_indentAmount
)
;
}
private
void
printSpace
(
int
n
)
throws
IOException
{
for
(
int
i
=
0
;
i
<
n
;
i
++
)
{
m_writer
.
write
(
' '
)
;
}
}
public
void
attributeDecl
(
String
eName
,
String
aName
,
String
type
,
String
valueDefault
,
String
value
)
throws
SAXException
{
if
(
m_inExternalDTD
)
return
;
try
{
if
(
m_inDoctype
)
{
m_writer
.
write
(
" ["
)
;
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
m_inDoctype
=
false
;
}
m_writer
.
write
(
"<!ATTLIST "
)
;
m_writer
.
write
(
eName
)
;
m_writer
.
write
(
" "
)
;
m_writer
.
write
(
aName
)
;
m_writer
.
write
(
" "
)
;
m_writer
.
write
(
type
)
;
if
(
valueDefault
!=
null
)
{
m_writer
.
write
(
" "
)
;
m_writer
.
write
(
valueDefault
)
;
}
m_writer
.
write
(
">"
)
;
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
public
Writer
getWriter
(
)
{
return
m_writer
;
}
public
void
externalEntityDecl
(
String
name
,
String
publicId
,
String
systemId
)
throws
SAXException
{
}
protected
boolean
escapingNotNeeded
(
char
ch
)
{
if
(
ch
<
127
)
{
if
(
ch
>=
0x20
||
(
0x0A
==
ch
||
0x0D
==
ch
||
0x09
==
ch
)
)
return
true
;
else
return
false
;
}
if
(
null
==
m_charToByteConverter
&&
false
==
m_triedToGetConverter
)
{
m_triedToGetConverter
=
true
;
try
{
m_charToByteConverter
=
Encodings
.
getCharToByteConverter
(
getEncoding
(
)
)
;
if
(
null
!=
m_charToByteConverter
)
{
Class
argsTypes
[
]
=
new
Class
[
1
]
;
argsTypes
[
0
]
=
Character
.
TYPE
;
Class
convClass
=
m_charToByteConverter
.
getClass
(
)
;
m_canConvertMeth
=
convClass
.
getMethod
(
"canConvert"
,
argsTypes
)
;
}
}
catch
(
Exception
e
)
{
System
.
err
.
println
(
"Warning: "
+
e
.
getMessage
(
)
)
;
}
}
if
(
null
!=
m_charToByteConverter
)
{
try
{
Object
args
[
]
=
new
Object
[
1
]
;
args
[
0
]
=
new
Character
(
ch
)
;
Boolean
bool
=
(
Boolean
)
m_canConvertMeth
.
invoke
(
m_charToByteConverter
,
args
)
;
return
bool
.
booleanValue
(
)
?
!
Character
.
isISOControl
(
ch
)
:
false
;
}
catch
(
java
.
lang
.
reflect
.
InvocationTargetException
ite
)
{
System
.
err
.
println
(
"Warning: InvocationTargetException in canConvert!"
)
;
}
catch
(
java
.
lang
.
IllegalAccessException
iae
)
{
System
.
err
.
println
(
"Warning: IllegalAccessException in canConvert!"
)
;
}
}
return
(
ch
<=
m_maxCharacter
)
;
}
protected
int
writeUTF16Surrogate
(
char
c
,
char
ch
[
]
,
int
i
,
int
end
)
throws
IOException
{
int
surrogateValue
=
getURF16SurrogateValue
(
c
,
ch
,
i
,
end
)
;
i
++
;
m_writer
.
write
(
'&'
)
;
m_writer
.
write
(
'#'
)
;
m_writer
.
write
(
Integer
.
toString
(
surrogateValue
)
)
;
m_writer
.
write
(
';'
)
;
return
i
;
}
int
getURF16SurrogateValue
(
char
c
,
char
ch
[
]
,
int
i
,
int
end
)
throws
IOException
{
int
next
;
if
(
i
+
1
>=
end
)
{
throw
new
IOException
(
XMLMessages
.
createXMLMessage
(
XMLErrorResources
.
ER_INVALID_UTF16_SURROGATE
,
new
Object
[
]
{
Integer
.
toHexString
(
(
int
)
c
)
}
)
)
;
}
else
{
next
=
ch
[
++
i
]
;
if
(
!
(
0xdc00
<=
next
&&
next
<
0xe000
)
)
throw
new
IOException
(
XMLMessages
.
createXMLMessage
(
XMLErrorResources
.
ER_INVALID_UTF16_SURROGATE
,
new
Object
[
]
{
Integer
.
toHexString
(
(
int
)
c
)
+
" "
+
Integer
.
toHexString
(
next
)
}
)
)
;
next
=
(
(
c
-
0xd800
)
<<
10
)
+
next
-
0xdc00
+
0x00010000
;
}
return
next
;
}
protected
int
accumDefaultEntity
(
java
.
io
.
Writer
writer
,
char
ch
,
int
i
,
char
[
]
chars
,
int
len
,
boolean
escLF
)
throws
IOException
{
if
(
!
escLF
&&
CharInfo
.
S_LINEFEED
==
ch
)
{
writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
else
{
if
(
m_charInfo
.
isSpecial
(
ch
)
)
{
String
entityRef
=
m_charInfo
.
getEntityNameForChar
(
ch
)
;
if
(
null
!=
entityRef
)
{
writer
.
write
(
'&'
)
;
writer
.
write
(
entityRef
)
;
writer
.
write
(
';'
)
;
}
else
return
i
;
}
else
return
i
;
}
return
i
+
1
;
}
void
writeNormalizedChars
(
char
ch
[
]
,
int
start
,
int
length
,
boolean
isCData
)
throws
IOException
,
org
.
xml
.
sax
.
SAXException
{
int
end
=
start
+
length
;
for
(
int
i
=
start
;
i
<
end
;
i
++
)
{
char
c
=
ch
[
i
]
;
if
(
CharInfo
.
S_LINEFEED
==
c
)
{
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
else
if
(
isCData
&&
(
!
escapingNotNeeded
(
c
)
)
)
{
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
if
(
isUTF16Surrogate
(
c
)
)
{
i
=
writeUTF16Surrogate
(
c
,
ch
,
i
,
end
)
;
}
else
{
m_writer
.
write
(
"&#"
)
;
String
intStr
=
Integer
.
toString
(
(
int
)
c
)
;
m_writer
.
write
(
intStr
)
;
m_writer
.
write
(
';'
)
;
}
}
else
if
(
isCData
&&
(
(
i
<
(
end
-
2
)
)
&&
(
']'
==
c
)
&&
(
']'
==
ch
[
i
+
1
]
)
&&
(
'>'
==
ch
[
i
+
2
]
)
)
)
{
m_writer
.
write
(
CDATA_CONTINUE
)
;
i
+=
2
;
}
else
{
if
(
escapingNotNeeded
(
c
)
)
{
if
(
isCData
&&
!
m_cdataTagOpen
)
{
m_writer
.
write
(
CDATA_DELIMITER_OPEN
)
;
m_cdataTagOpen
=
true
;
}
m_writer
.
write
(
c
)
;
}
else
if
(
isUTF16Surrogate
(
c
)
)
{
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
i
=
writeUTF16Surrogate
(
c
,
ch
,
i
,
end
)
;
}
else
{
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
m_writer
.
write
(
"&#"
)
;
String
intStr
=
Integer
.
toString
(
(
int
)
c
)
;
m_writer
.
write
(
intStr
)
;
m_writer
.
write
(
';'
)
;
}
}
}
}
public
void
endNonEscaping
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_disableOutputEscapingStates
.
pop
(
)
;
}
public
void
startNonEscaping
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_disableOutputEscapingStates
.
push
(
true
)
;
}
protected
void
cdata
(
char
ch
[
]
,
int
start
,
final
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
final
int
old_start
=
start
;
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
m_ispreserve
=
true
;
if
(
shouldIndent
(
)
)
indent
(
)
;
boolean
writeCDataBrackets
=
(
(
(
length
>=
1
)
&&
escapingNotNeeded
(
ch
[
start
]
)
)
)
;
if
(
writeCDataBrackets
&&
!
m_cdataTagOpen
)
{
m_writer
.
write
(
CDATA_DELIMITER_OPEN
)
;
m_cdataTagOpen
=
true
;
}
if
(
isEscapingDisabled
(
)
)
{
charactersRaw
(
ch
,
start
,
length
)
;
}
else
writeNormalizedChars
(
ch
,
start
,
length
,
true
)
;
if
(
writeCDataBrackets
)
{
if
(
ch
[
start
+
length
-
1
]
==
']'
)
closeCDATA
(
)
;
}
super
.
fireCDATAEvent
(
ch
,
old_start
,
length
)
;
}
catch
(
IOException
ioe
)
{
throw
new
org
.
xml
.
sax
.
SAXException
(
XMLMessages
.
createXMLMessage
(
XMLErrorResources
.
ER_OIERROR
,
null
)
,
ioe
)
;
}
}
private
boolean
isEscapingDisabled
(
)
{
return
m_disableOutputEscapingStates
.
peekOrFalse
(
)
;
}
protected
void
charactersRaw
(
char
ch
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_inEntityRef
)
return
;
try
{
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
m_ispreserve
=
true
;
m_writer
.
write
(
ch
,
start
,
length
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
public
void
characters
(
char
chars
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
0
==
length
)
{
super
.
fireCharEvent
(
chars
,
start
,
length
)
;
return
;
}
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
else
if
(
m_needToCallStartDocument
)
{
startDocumentInternal
(
)
;
}
if
(
m_cdataStartCalled
||
m_cdataSectionStates
.
peekOrFalse
(
)
)
{
cdata
(
chars
,
start
,
length
)
;
return
;
}
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
if
(
m_disableOutputEscapingStates
.
peekOrFalse
(
)
||
(
!
m_escaping
)
)
{
charactersRaw
(
chars
,
start
,
length
)
;
super
.
fireCharEvent
(
chars
,
start
,
length
)
;
return
;
}
if
(
m_startTagOpen
)
closeStartTag
(
)
;
int
startClean
=
start
;
int
lengthClean
=
0
;
int
end
=
start
+
length
;
boolean
checkWhite
=
true
;
final
int
maxCharacter
=
m_maxCharacter
;
final
BitSet
specialsMap
=
m_charInfo
.
m_specialsMap
;
try
{
for
(
int
i
=
start
;
i
<
end
;
i
++
)
{
char
ch
=
chars
[
i
]
;
if
(
checkWhite
&&
(
(
ch
>
0x20
)
||
!
(
(
ch
==
0x20
)
||
(
ch
==
0x09
)
||
(
ch
==
0xD
)
||
(
ch
==
0xA
)
)
)
)
{
m_ispreserve
=
true
;
checkWhite
=
false
;
}
if
(
(
(
(
ch
<
127
)
&&
(
0x20
<=
ch
||
(
0x0A
==
ch
||
0x0D
==
ch
||
0x09
==
ch
)
)
)
&&
(
!
specialsMap
.
get
(
ch
)
)
)
||
(
'"'
==
ch
)
)
{
lengthClean
++
;
}
else
if
(
(
escapingNotNeeded
(
ch
)
&&
(
!
specialsMap
.
get
(
ch
)
)
)
||
(
'"'
==
ch
)
)
{
lengthClean
++
;
}
else
{
if
(
lengthClean
>
0
)
{
m_writer
.
write
(
chars
,
startClean
,
lengthClean
)
;
lengthClean
=
0
;
}
if
(
CharInfo
.
S_LINEFEED
==
ch
)
{
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
startClean
=
i
+
1
;
}
else
{
startClean
=
accumDefaultEscape
(
m_writer
,
ch
,
i
,
chars
,
end
,
false
)
;
i
=
startClean
-
1
;
}
}
}
if
(
lengthClean
>
0
)
{
m_writer
.
write
(
chars
,
startClean
,
lengthClean
)
;
}
m_isprevtext
=
true
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
super
.
fireCharEvent
(
chars
,
start
,
length
)
;
}
public
void
characters
(
String
s
)
throws
org
.
xml
.
sax
.
SAXException
{
characters
(
s
.
toCharArray
(
)
,
0
,
s
.
length
(
)
)
;
}
protected
int
accumDefaultEscape
(
Writer
writer
,
char
ch
,
int
i
,
char
[
]
chars
,
int
len
,
boolean
escLF
)
throws
IOException
{
int
pos
=
accumDefaultEntity
(
writer
,
ch
,
i
,
chars
,
len
,
escLF
)
;
if
(
i
==
pos
)
{
pos
++
;
if
(
0xd800
<=
ch
&&
ch
<
0xdc00
)
{
int
next
;
if
(
i
+
1
>=
len
)
{
throw
new
IOException
(
XMLMessages
.
createXMLMessage
(
XMLErrorResources
.
ER_INVALID_UTF16_SURROGATE
,
new
Object
[
]
{
Integer
.
toHexString
(
ch
)
}
)
)
;
}
else
{
next
=
chars
[
++
i
]
;
if
(
!
(
0xdc00
<=
next
&&
next
<
0xe000
)
)
throw
new
IOException
(
XMLMessages
.
createXMLMessage
(
XMLErrorResources
.
ER_INVALID_UTF16_SURROGATE
,
new
Object
[
]
{
Integer
.
toHexString
(
ch
)
+
" "
+
Integer
.
toHexString
(
next
)
}
)
)
;
next
=
(
(
ch
-
0xd800
)
<<
10
)
+
next
-
0xdc00
+
0x00010000
;
}
writer
.
write
(
"&#"
)
;
writer
.
write
(
Integer
.
toString
(
next
)
)
;
writer
.
write
(
";"
)
;
}
else
{
if
(
!
escapingNotNeeded
(
ch
)
||
(
m_charInfo
.
isSpecial
(
ch
)
)
)
{
writer
.
write
(
"&#"
)
;
writer
.
write
(
Integer
.
toString
(
ch
)
)
;
writer
.
write
(
";"
)
;
}
else
{
writer
.
write
(
ch
)
;
}
}
}
return
pos
;
}
public
void
startElement
(
String
namespaceURI
,
String
localName
,
String
name
,
Attributes
atts
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_inEntityRef
)
return
;
if
(
m_needToCallStartDocument
)
{
startDocumentInternal
(
)
;
m_needToCallStartDocument
=
false
;
}
else
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
try
{
if
(
(
true
==
m_needToOutputDocTypeDecl
)
&&
(
null
!=
getDoctypeSystem
(
)
)
)
{
outputDocTypeDecl
(
name
,
true
)
;
}
m_needToOutputDocTypeDecl
=
false
;
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
if
(
namespaceURI
!=
null
)
ensurePrefixIsDeclared
(
namespaceURI
,
name
)
;
m_elementLocalName
=
localName
;
m_elementURI
=
namespaceURI
;
m_elementName
=
name
;
m_ispreserve
=
false
;
if
(
shouldIndent
(
)
&&
m_startNewLine
)
{
indent
(
)
;
}
m_startNewLine
=
true
;
m_writer
.
write
(
'<'
)
;
m_writer
.
write
(
name
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
if
(
atts
!=
null
)
addAttributes
(
atts
)
;
m_startTagOpen
=
true
;
m_currentElemDepth
++
;
m_isprevtext
=
false
;
}
public
void
startElement
(
String
elementNamespaceURI
,
String
elementLocalName
,
String
elementName
)
throws
SAXException
{
startElement
(
elementNamespaceURI
,
elementLocalName
,
elementName
,
null
)
;
}
public
void
startElement
(
String
elementName
)
throws
SAXException
{
startElement
(
null
,
null
,
elementName
,
null
)
;
}
void
outputDocTypeDecl
(
String
name
,
boolean
closeDecl
)
throws
SAXException
{
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
try
{
m_writer
.
write
(
"<!DOCTYPE "
)
;
m_writer
.
write
(
name
)
;
String
doctypePublic
=
getDoctypePublic
(
)
;
if
(
null
!=
doctypePublic
)
{
m_writer
.
write
(
" PUBLIC \""
)
;
m_writer
.
write
(
doctypePublic
)
;
m_writer
.
write
(
'\"'
)
;
}
String
doctypeSystem
=
getDoctypeSystem
(
)
;
if
(
null
!=
doctypeSystem
)
{
if
(
null
==
doctypePublic
)
m_writer
.
write
(
" SYSTEM \""
)
;
else
m_writer
.
write
(
" \""
)
;
m_writer
.
write
(
doctypeSystem
)
;
if
(
closeDecl
)
{
m_writer
.
write
(
"\">"
)
;
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
closeDecl
=
false
;
}
else
m_writer
.
write
(
'\"'
)
;
}
boolean
dothis
=
false
;
if
(
dothis
)
{
if
(
closeDecl
)
{
m_writer
.
write
(
">"
)
;
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
}
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
public
void
processAttributes
(
)
throws
IOException
,
SAXException
{
super
.
fireStartElem
(
m_elementName
)
;
int
nAttrs
=
0
;
if
(
(
nAttrs
=
m_attributes
.
getLength
(
)
)
>
0
)
{
String
encoding
=
getEncoding
(
)
;
for
(
int
i
=
0
;
i
<
nAttrs
;
i
++
)
{
final
String
name
=
m_attributes
.
getQName
(
i
)
;
final
String
value
=
m_attributes
.
getValue
(
i
)
;
m_writer
.
write
(
' '
)
;
m_writer
.
write
(
name
)
;
m_writer
.
write
(
"=\""
)
;
writeAttrString
(
m_writer
,
value
,
encoding
)
;
m_writer
.
write
(
'\"'
)
;
}
m_attributes
.
clear
(
)
;
}
}
public
void
writeAttrString
(
Writer
writer
,
String
string
,
String
encoding
)
throws
IOException
{
final
char
[
]
stringChars
=
string
.
toCharArray
(
)
;
final
int
len
=
stringChars
.
length
;
for
(
int
i
=
0
;
i
<
len
;
i
++
)
{
char
ch
=
stringChars
[
i
]
;
if
(
escapingNotNeeded
(
ch
)
&&
(
!
m_charInfo
.
isSpecial
(
ch
)
)
)
{
writer
.
write
(
ch
)
;
}
else
{
if
(
(
CharInfo
.
S_CARRIAGERETURN
==
ch
)
&&
(
(
i
+
1
)
<
len
)
&&
(
CharInfo
.
S_LINEFEED
==
stringChars
[
i
+
1
]
)
)
{
i
++
;
ch
=
CharInfo
.
S_LINEFEED
;
}
accumDefaultEscape
(
writer
,
ch
,
i
,
stringChars
,
len
,
true
)
;
}
}
}
public
void
endElement
(
String
namespaceURI
,
String
localName
,
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_inEntityRef
)
return
;
m_prefixMap
.
popNamespaces
(
m_currentElemDepth
)
;
m_currentElemDepth
--
;
try
{
if
(
m_startTagOpen
)
{
processAttributes
(
)
;
if
(
m_spaceBeforeClose
)
m_writer
.
write
(
" />"
)
;
else
m_writer
.
write
(
"/>"
)
;
}
else
{
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
if
(
shouldIndent
(
)
)
indent
(
)
;
m_writer
.
write
(
'<'
)
;
m_writer
.
write
(
'/'
)
;
m_writer
.
write
(
name
)
;
m_writer
.
write
(
'>'
)
;
m_cdataSectionStates
.
pop
(
)
;
}
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
if
(
!
m_startTagOpen
)
{
m_ispreserve
=
m_preserves
.
isEmpty
(
)
?
false
:
m_preserves
.
pop
(
)
;
}
m_isprevtext
=
false
;
m_startTagOpen
=
false
;
super
.
fireEndElem
(
name
)
;
}
public
void
endElement
(
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
endElement
(
null
,
null
,
name
)
;
}
public
void
startPrefixMapping
(
String
prefix
,
String
uri
)
throws
org
.
xml
.
sax
.
SAXException
{
startPrefixMapping
(
prefix
,
uri
,
true
)
;
}
public
boolean
startPrefixMapping
(
String
prefix
,
String
uri
,
boolean
shouldFlush
)
throws
org
.
xml
.
sax
.
SAXException
{
boolean
pushed
;
int
pushDepth
;
if
(
shouldFlush
)
{
flushPending
(
)
;
pushDepth
=
m_currentElemDepth
+
1
;
}
else
{
pushDepth
=
m_currentElemDepth
;
}
pushed
=
m_prefixMap
.
pushNamespace
(
prefix
,
uri
,
pushDepth
)
;
if
(
pushed
)
{
String
name
;
if
(
EMPTYSTRING
.
equals
(
prefix
)
)
{
name
=
"xmlns"
;
addAttributeAlways
(
XMLNS_URI
,
prefix
,
name
,
"CDATA"
,
uri
)
;
}
else
{
if
(
!
EMPTYSTRING
.
equals
(
uri
)
)
{
name
=
"xmlns:"
+
prefix
;
addAttributeAlways
(
XMLNS_URI
,
prefix
,
name
,
"CDATA"
,
uri
)
;
}
}
}
return
pushed
;
}
public
void
comment
(
char
ch
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
int
start_old
=
start
;
if
(
m_inEntityRef
)
return
;
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
else
if
(
m_needToCallStartDocument
)
{
startDocumentInternal
(
)
;
m_needToCallStartDocument
=
false
;
}
try
{
if
(
shouldIndent
(
)
)
indent
(
)
;
final
int
limit
=
start
+
length
;
boolean
wasDash
=
false
;
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
m_writer
.
write
(
COMMENT_BEGIN
)
;
for
(
int
i
=
start
;
i
<
limit
;
i
++
)
{
if
(
wasDash
&&
ch
[
i
]
==
'-'
)
{
m_writer
.
write
(
ch
,
start
,
i
-
start
)
;
m_writer
.
write
(
" -"
)
;
start
=
i
+
1
;
}
wasDash
=
(
ch
[
i
]
==
'-'
)
;
}
if
(
length
>
0
)
{
final
int
remainingChars
=
(
limit
-
start
)
;
if
(
remainingChars
>
0
)
m_writer
.
write
(
ch
,
start
,
remainingChars
)
;
if
(
ch
[
limit
-
1
]
==
'-'
)
m_writer
.
write
(
' '
)
;
}
m_writer
.
write
(
COMMENT_END
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
m_startNewLine
=
true
;
super
.
fireCommentEvent
(
ch
,
start_old
,
length
)
;
}
public
void
endCDATA
(
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_cdataTagOpen
)
closeCDATA
(
)
;
m_cdataStartCalled
=
false
;
}
public
void
endDTD
(
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
if
(
m_needToOutputDocTypeDecl
)
{
outputDocTypeDecl
(
m_elementName
,
false
)
;
m_needToOutputDocTypeDecl
=
false
;
}
if
(
!
m_inDoctype
)
m_writer
.
write
(
"]>"
)
;
else
{
m_writer
.
write
(
'>'
)
;
}
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
}
public
void
endPrefixMapping
(
String
prefix
)
throws
org
.
xml
.
sax
.
SAXException
{
}
public
void
ignorableWhitespace
(
char
ch
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
0
==
length
)
return
;
characters
(
ch
,
start
,
length
)
;
}
public
void
skippedEntity
(
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
}
public
void
startCDATA
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_cdataStartCalled
=
true
;
}
public
void
startEntity
(
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
name
.
equals
(
"[dtd]"
)
)
m_inExternalDTD
=
true
;
m_inEntityRef
=
true
;
}
protected
void
closeStartTag
(
)
throws
SAXException
{
if
(
m_startTagOpen
)
{
try
{
processAttributes
(
)
;
m_writer
.
write
(
'>'
)
;
}
catch
(
IOException
e
)
{
throw
new
SAXException
(
e
)
;
}
pushCdataSectionState
(
)
;
m_isprevtext
=
false
;
m_preserves
.
push
(
m_ispreserve
)
;
m_startTagOpen
=
false
;
}
}
public
void
startDTD
(
String
name
,
String
publicId
,
String
systemId
)
throws
org
.
xml
.
sax
.
SAXException
{
setDoctypeSystem
(
systemId
)
;
setDoctypePublic
(
publicId
)
;
m_elementName
=
name
;
m_inDoctype
=
true
;
}
public
int
getIndentAmount
(
)
{
return
m_indentAmount
;
}
public
void
setIndentAmount
(
int
m_indentAmount
)
{
this
.
m_indentAmount
=
m_indentAmount
;
}
protected
boolean
shouldIndent
(
)
{
return
m_doIndent
&&
(
!
m_ispreserve
&&
!
m_isprevtext
)
;
}
private
void
setCdataSectionElements
(
String
key
,
Properties
props
)
{
String
s
=
props
.
getProperty
(
key
)
;
if
(
null
!=
s
)
{
Vector
v
=
new
Vector
(
)
;
int
l
=
s
.
length
(
)
;
boolean
inCurly
=
false
;
FastStringBuffer
buf
=
new
FastStringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
l
;
i
++
)
{
char
c
=
s
.
charAt
(
i
)
;
if
(
Character
.
isWhitespace
(
c
)
)
{
if
(
!
inCurly
)
{
if
(
buf
.
length
(
)
>
0
)
{
addCdataSectionElement
(
buf
.
toString
(
)
,
v
)
;
buf
.
reset
(
)
;
}
continue
;
}
}
else
if
(
'{'
==
c
)
inCurly
=
true
;
else
if
(
'}'
==
c
)
inCurly
=
false
;
buf
.
append
(
c
)
;
}
if
(
buf
.
length
(
)
>
0
)
{
addCdataSectionElement
(
buf
.
toString
(
)
,
v
)
;
buf
.
reset
(
)
;
}
setCdataSectionElements
(
v
)
;
}
}
private
void
addCdataSectionElement
(
String
URI_and_localName
,
Vector
v
)
{
StringTokenizer
tokenizer
=
new
StringTokenizer
(
URI_and_localName
,
"{}"
,
false
)
;
QName
qname
;
String
s1
=
tokenizer
.
nextToken
(
)
;
String
s2
=
tokenizer
.
hasMoreTokens
(
)
?
tokenizer
.
nextToken
(
)
:
null
;
if
(
null
==
s2
)
{
v
.
addElement
(
null
)
;
v
.
addElement
(
s1
)
;
}
else
{
v
.
addElement
(
s1
)
;
v
.
addElement
(
s2
)
;
}
}
public
void
setCdataSectionElements
(
Vector
URI_and_localNames
)
{
m_cdataSectionElements
=
URI_and_localNames
;
}
protected
String
ensureAttributesNamespaceIsDeclared
(
String
ns
,
String
localName
,
String
rawName
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
ns
!=
null
&&
ns
.
length
(
)
>
0
)
{
int
index
=
0
;
String
prefixFromRawName
=
(
index
=
rawName
.
indexOf
(
":"
)
)
<
0
?
""
:
rawName
.
substring
(
0
,
index
)
;
if
(
index
>
0
)
{
String
uri
=
m_prefixMap
.
lookupNamespace
(
prefixFromRawName
)
;
if
(
uri
!=
null
&&
uri
.
equals
(
ns
)
)
{
return
null
;
}
else
{
this
.
startPrefixMapping
(
prefixFromRawName
,
ns
,
false
)
;
this
.
addAttribute
(
"http://www.w3.org/2000/xmlns/"
,
prefixFromRawName
,
"xmlns:"
+
prefixFromRawName
,
"CDATA"
,
ns
)
;
return
prefixFromRawName
;
}
}
else
{
String
prefix
=
m_prefixMap
.
lookupPrefix
(
ns
)
;
if
(
prefix
==
null
)
{
prefix
=
m_prefixMap
.
generateNextPrefix
(
)
;
this
.
startPrefixMapping
(
prefix
,
ns
,
false
)
;
this
.
addAttribute
(
"http://www.w3.org/2000/xmlns/"
,
prefix
,
"xmlns:"
+
prefix
,
"CDATA"
,
ns
)
;
}
return
prefix
;
}
}
return
null
;
}
private
void
ensurePrefixIsDeclared
(
String
ns
,
String
rawName
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
ns
!=
null
&&
ns
.
length
(
)
>
0
)
{
int
index
;
String
prefix
=
(
index
=
rawName
.
indexOf
(
":"
)
)
<
0
?
""
:
rawName
.
substring
(
0
,
index
)
;
if
(
null
!=
prefix
)
{
String
foundURI
=
m_prefixMap
.
lookupNamespace
(
prefix
)
;
if
(
(
null
==
foundURI
)
||
!
foundURI
.
equals
(
ns
)
)
{
this
.
startPrefixMapping
(
prefix
,
ns
)
;
this
.
addAttributeAlways
(
"http://www.w3.org/2000/xmlns/"
,
prefix
,
"xmlns"
+
(
prefix
.
length
(
)
==
0
?
""
:
":"
)
+
prefix
,
"CDATA"
,
ns
)
;
}
}
}
}
public
void
flushPending
(
)
{
try
{
if
(
m_needToCallStartDocument
)
{
startDocumentInternal
(
)
;
m_needToCallStartDocument
=
false
;
}
if
(
m_startTagOpen
)
{
closeStartTag
(
)
;
m_startTagOpen
=
false
;
}
if
(
m_cdataTagOpen
)
{
closeCDATA
(
)
;
m_cdataTagOpen
=
false
;
}
}
catch
(
SAXException
e
)
{
}
}
public
void
setContentHandler
(
ContentHandler
ch
)
{
}
public
void
addAttributeAlways
(
String
uri
,
String
localName
,
String
rawName
,
String
type
,
String
value
)
{
int
index
;
index
=
m_attributes
.
getIndex
(
rawName
)
;
if
(
index
>=
0
)
{
String
old_value
=
null
;
if
(
m_tracer
!=
null
)
{
old_value
=
m_attributes
.
getValue
(
index
)
;
if
(
value
.
equals
(
old_value
)
)
old_value
=
null
;
}
m_attributes
.
setValue
(
index
,
value
)
;
if
(
old_value
!=
null
)
firePseudoAttributes
(
)
;
}
else
{
m_attributes
.
addAttribute
(
uri
,
localName
,
rawName
,
type
,
value
)
;
if
(
m_tracer
!=
null
)
firePseudoAttributes
(
)
;
}
}
protected
void
firePseudoAttributes
(
)
{
int
nAttrs
;
if
(
m_tracer
!=
null
&&
(
nAttrs
=
m_attributes
.
getLength
(
)
)
>
0
)
{
String
encoding
=
getEncoding
(
)
;
StringBuffer
sb
=
new
StringBuffer
(
)
;
java
.
io
.
Writer
writer
=
new
ToStream
.
WritertoStringBuffer
(
sb
)
;
try
{
for
(
int
i
=
0
;
i
<
nAttrs
;
i
++
)
{
final
String
name
=
m_attributes
.
getQName
(
i
)
;
final
String
value
=
m_attributes
.
getValue
(
i
)
;
sb
.
append
(
' '
)
;
sb
.
append
(
name
)
;
sb
.
append
(
"=\""
)
;
writeAttrString
(
writer
,
value
,
encoding
)
;
sb
.
append
(
'\"'
)
;
}
}
catch
(
IOException
ioe
)
{
}
char
ch
[
]
=
sb
.
toString
(
)
.
toCharArray
(
)
;
m_tracer
.
fireGenerateEvent
(
SerializerTrace
.
EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS
,
ch
,
0
,
ch
.
length
)
;
}
}
private
class
WritertoStringBuffer
extends
java
.
io
.
Writer
{
final
private
StringBuffer
m_stringbuf
;
WritertoStringBuffer
(
StringBuffer
sb
)
{
m_stringbuf
=
sb
;
}
public
void
write
(
char
[
]
arg0
,
int
arg1
,
int
arg2
)
throws
IOException
{
m_stringbuf
.
append
(
arg0
,
arg1
,
arg2
)
;
}
public
void
flush
(
)
throws
IOException
{
}
public
void
close
(
)
throws
IOException
{
}
public
void
write
(
int
i
)
{
m_stringbuf
.
append
(
(
char
)
i
)
;
}
public
void
write
(
String
s
)
{
m_stringbuf
.
append
(
s
)
;
}
}
public
void
setTransformer
(
Transformer
transformer
)
{
super
.
setTransformer
(
transformer
)
;
if
(
m_tracer
!=
null
&&
!
(
m_writer
instanceof
SerializerTraceWriter
)
)
m_writer
=
new
SerializerTraceWriter
(
m_writer
,
m_tracer
)
;
}
}
