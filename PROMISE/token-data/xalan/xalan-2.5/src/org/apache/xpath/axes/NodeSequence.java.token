package
org
.
apache
.
xpath
.
axes
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
xml
.
dtm
.
DTM
;
import
org
.
apache
.
xml
.
dtm
.
DTMFilter
;
import
org
.
apache
.
xml
.
dtm
.
DTMIterator
;
import
org
.
apache
.
xml
.
dtm
.
DTMManager
;
import
org
.
apache
.
xml
.
utils
.
NodeVector
;
import
org
.
apache
.
xpath
.
NodeSetDTM
;
import
org
.
apache
.
xpath
.
XPathContext
;
import
org
.
apache
.
xpath
.
objects
.
XObject
;
public
class
NodeSequence
extends
XObject
implements
DTMIterator
,
Cloneable
,
PathComponent
{
protected
int
m_last
=
-
1
;
protected
int
m_next
=
0
;
protected
NodeVector
getVector
(
)
{
return
(
NodeVector
)
m_obj
;
}
protected
void
SetVector
(
NodeVector
v
)
{
m_obj
=
v
;
}
public
boolean
hasCache
(
)
{
return
(
m_obj
!=
null
)
;
}
protected
DTMIterator
m_iter
;
public
final
void
setIter
(
DTMIterator
iter
)
{
m_iter
=
iter
;
}
public
final
DTMIterator
getContainedIter
(
)
{
return
m_iter
;
}
protected
DTMManager
m_dtmMgr
;
public
NodeSequence
(
DTMIterator
iter
,
int
context
,
XPathContext
xctxt
,
boolean
shouldCacheNodes
)
{
setIter
(
iter
)
;
setRoot
(
context
,
xctxt
)
;
setShouldCacheNodes
(
shouldCacheNodes
)
;
}
public
NodeSequence
(
Object
nodeVector
)
{
super
(
nodeVector
)
;
if
(
null
!=
nodeVector
)
{
assertion
(
nodeVector
instanceof
NodeVector
,
"Must have a NodeVector as the object for NodeSequence!"
)
;
if
(
nodeVector
instanceof
DTMIterator
)
{
setIter
(
(
DTMIterator
)
nodeVector
)
;
m_last
=
(
(
DTMIterator
)
nodeVector
)
.
getLength
(
)
;
}
}
}
public
NodeSequence
(
DTMManager
dtmMgr
)
{
super
(
new
NodeVector
(
)
)
;
m_last
=
0
;
m_dtmMgr
=
dtmMgr
;
}
public
NodeSequence
(
)
{
}
public
DTM
getDTM
(
int
nodeHandle
)
{
DTMManager
mgr
=
getDTMManager
(
)
;
if
(
null
!=
mgr
)
return
getDTMManager
(
)
.
getDTM
(
nodeHandle
)
;
else
{
assertion
(
false
,
"Can not get a DTM Unless a DTMManager has been set!"
)
;
return
null
;
}
}
public
DTMManager
getDTMManager
(
)
{
return
m_dtmMgr
;
}
public
int
getRoot
(
)
{
if
(
null
!=
m_iter
)
return
m_iter
.
getRoot
(
)
;
else
{
return
DTM
.
NULL
;
}
}
public
void
setRoot
(
int
nodeHandle
,
Object
environment
)
{
if
(
null
!=
m_iter
)
{
XPathContext
xctxt
=
(
XPathContext
)
environment
;
m_dtmMgr
=
xctxt
.
getDTMManager
(
)
;
m_iter
.
setRoot
(
nodeHandle
,
environment
)
;
if
(
!
m_iter
.
isDocOrdered
(
)
)
{
if
(
!
hasCache
(
)
)
setShouldCacheNodes
(
true
)
;
runTo
(
-
1
)
;
m_next
=
0
;
}
}
else
assertion
(
false
,
"Can not setRoot on a non-iterated NodeSequence!"
)
;
}
public
void
reset
(
)
{
m_next
=
0
;
}
public
int
getWhatToShow
(
)
{
return
hasCache
(
)
?
(
DTMFilter
.
SHOW_ALL
&
~
DTMFilter
.
SHOW_ENTITY_REFERENCE
)
:
m_iter
.
getWhatToShow
(
)
;
}
public
boolean
getExpandEntityReferences
(
)
{
if
(
null
!=
m_iter
)
return
m_iter
.
getExpandEntityReferences
(
)
;
else
return
true
;
}
public
int
nextNode
(
)
{
NodeVector
vec
=
getVector
(
)
;
if
(
null
!=
vec
)
{
if
(
m_next
<
vec
.
size
(
)
)
{
int
next
=
vec
.
elementAt
(
m_next
)
;
m_next
++
;
return
next
;
}
else
if
(
(
-
1
!=
m_last
)
||
(
null
==
m_iter
)
)
{
m_next
++
;
return
DTM
.
NULL
;
}
}
if
(
null
==
m_iter
)
return
DTM
.
NULL
;
int
next
=
m_iter
.
nextNode
(
)
;
if
(
DTM
.
NULL
!=
next
)
{
if
(
hasCache
(
)
)
{
if
(
m_iter
.
isDocOrdered
(
)
)
{
getVector
(
)
.
addElement
(
next
)
;
m_next
++
;
}
else
{
int
insertIndex
=
addNodeInDocOrder
(
next
)
;
if
(
insertIndex
>=
0
)
m_next
++
;
}
}
else
m_next
++
;
}
else
{
m_last
=
m_next
;
m_next
++
;
}
return
next
;
}
public
int
previousNode
(
)
{
if
(
hasCache
(
)
)
{
if
(
m_next
<=
0
)
return
DTM
.
NULL
;
else
{
m_next
--
;
return
item
(
m_next
)
;
}
}
else
{
int
n
=
m_iter
.
previousNode
(
)
;
m_next
=
m_iter
.
getCurrentPos
(
)
;
return
m_next
;
}
}
public
void
detach
(
)
{
if
(
null
!=
m_iter
)
m_iter
.
detach
(
)
;
super
.
detach
(
)
;
}
public
void
allowDetachToRelease
(
boolean
allowRelease
)
{
if
(
(
false
==
allowRelease
)
&&
!
hasCache
(
)
)
{
setShouldCacheNodes
(
true
)
;
}
if
(
null
!=
m_iter
)
m_iter
.
allowDetachToRelease
(
allowRelease
)
;
super
.
allowDetachToRelease
(
allowRelease
)
;
}
public
int
getCurrentNode
(
)
{
if
(
hasCache
(
)
)
{
int
currentIndex
=
m_next
-
1
;
NodeVector
vec
=
getVector
(
)
;
if
(
(
currentIndex
>=
0
)
&&
(
currentIndex
<
vec
.
size
(
)
)
)
return
vec
.
elementAt
(
currentIndex
)
;
else
return
DTM
.
NULL
;
}
if
(
null
!=
m_iter
)
{
return
m_iter
.
getCurrentNode
(
)
;
}
else
return
DTM
.
NULL
;
}
public
boolean
isFresh
(
)
{
return
(
0
==
m_next
)
;
}
public
void
setShouldCacheNodes
(
boolean
b
)
{
if
(
b
)
{
if
(
!
hasCache
(
)
)
{
SetVector
(
new
NodeVector
(
)
)
;
}
}
else
SetVector
(
null
)
;
}
public
boolean
isMutable
(
)
{
return
hasCache
(
)
;
}
public
int
getCurrentPos
(
)
{
return
m_next
;
}
public
void
runTo
(
int
index
)
{
int
n
;
if
(
-
1
==
index
)
{
int
pos
=
m_next
;
while
(
DTM
.
NULL
!=
(
n
=
nextNode
(
)
)
)
;
m_next
=
pos
;
}
else
if
(
m_next
==
index
)
{
return
;
}
else
if
(
hasCache
(
)
&&
m_next
<
getVector
(
)
.
size
(
)
)
{
m_next
=
index
;
}
else
if
(
(
null
==
getVector
(
)
)
&&
(
index
<
m_next
)
)
{
while
(
(
m_next
>=
index
)
&&
DTM
.
NULL
!=
(
n
=
previousNode
(
)
)
)
;
}
else
{
while
(
(
m_next
<
index
)
&&
DTM
.
NULL
!=
(
n
=
nextNode
(
)
)
)
;
}
}
public
void
setCurrentPos
(
int
i
)
{
runTo
(
i
)
;
}
public
int
item
(
int
index
)
{
setCurrentPos
(
index
)
;
int
n
=
nextNode
(
)
;
m_next
=
index
;
return
n
;
}
public
void
setItem
(
int
node
,
int
index
)
{
NodeVector
vec
=
getVector
(
)
;
if
(
null
!=
vec
)
{
vec
.
setElementAt
(
node
,
index
)
;
m_last
=
vec
.
size
(
)
;
}
else
m_iter
.
setItem
(
node
,
index
)
;
}
public
int
getLength
(
)
{
if
(
hasCache
(
)
)
{
if
(
m_iter
instanceof
NodeSetDTM
)
{
return
m_iter
.
getLength
(
)
;
}
if
(
-
1
==
m_last
)
{
int
pos
=
m_next
;
runTo
(
-
1
)
;
m_next
=
pos
;
}
return
m_last
;
}
else
{
return
(
-
1
==
m_last
)
?
(
m_last
=
m_iter
.
getLength
(
)
)
:
m_last
;
}
}
public
DTMIterator
cloneWithReset
(
)
throws
CloneNotSupportedException
{
NodeSequence
seq
=
(
NodeSequence
)
super
.
clone
(
)
;
seq
.
m_next
=
0
;
return
seq
;
}
public
Object
clone
(
)
throws
CloneNotSupportedException
{
return
super
.
clone
(
)
;
}
public
boolean
isDocOrdered
(
)
{
if
(
null
!=
m_iter
)
return
m_iter
.
isDocOrdered
(
)
;
else
return
true
;
}
public
int
getAxis
(
)
{
if
(
null
!=
m_iter
)
return
m_iter
.
getAxis
(
)
;
else
{
assertion
(
false
,
"Can not getAxis from a non-iterated node sequence!"
)
;
return
0
;
}
}
public
int
getAnalysisBits
(
)
{
if
(
(
null
!=
m_iter
)
&&
(
m_iter
instanceof
PathComponent
)
)
return
(
(
PathComponent
)
m_iter
)
.
getAnalysisBits
(
)
;
else
return
0
;
}
public
void
fixupVariables
(
Vector
vars
,
int
globalsSize
)
{
super
.
fixupVariables
(
vars
,
globalsSize
)
;
}
protected
int
addNodeInDocOrder
(
int
node
)
{
assertion
(
hasCache
(
)
,
"addNodeInDocOrder must be done on a mutable sequence!"
)
;
int
insertIndex
=
-
1
;
NodeVector
vec
=
getVector
(
)
;
int
size
=
vec
.
size
(
)
,
i
;
for
(
i
=
size
-
1
;
i
>=
0
;
i
--
)
{
int
child
=
vec
.
elementAt
(
i
)
;
if
(
child
==
node
)
{
i
=
-
2
;
break
;
}
DTM
dtm
=
m_dtmMgr
.
getDTM
(
node
)
;
if
(
!
dtm
.
isNodeAfter
(
node
,
child
)
)
{
break
;
}
}
if
(
i
!=
-
2
)
{
insertIndex
=
i
+
1
;
vec
.
insertElementAt
(
node
,
insertIndex
)
;
}
return
insertIndex
;
}
}
