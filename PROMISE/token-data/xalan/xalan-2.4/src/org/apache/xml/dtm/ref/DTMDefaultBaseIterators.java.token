package
org
.
apache
.
xml
.
dtm
.
ref
;
import
org
.
apache
.
xml
.
dtm
.
*
;
import
javax
.
xml
.
transform
.
Source
;
import
org
.
apache
.
xml
.
utils
.
XMLStringFactory
;
import
org
.
apache
.
xalan
.
res
.
XSLTErrorResources
;
import
org
.
apache
.
xalan
.
res
.
XSLMessages
;
public
abstract
class
DTMDefaultBaseIterators
extends
DTMDefaultBaseTraversers
{
public
DTMDefaultBaseIterators
(
DTMManager
mgr
,
Source
source
,
int
dtmIdentity
,
DTMWSFilter
whiteSpaceFilter
,
XMLStringFactory
xstringfactory
,
boolean
doIndexing
)
{
super
(
mgr
,
source
,
dtmIdentity
,
whiteSpaceFilter
,
xstringfactory
,
doIndexing
)
;
}
public
DTMAxisIterator
getTypedAxisIterator
(
int
axis
,
int
type
)
{
DTMAxisIterator
iterator
=
null
;
{
switch
(
axis
)
{
case
Axis
.
SELF
:
iterator
=
new
TypedSingletonIterator
(
type
)
;
break
;
case
Axis
.
CHILD
:
iterator
=
new
TypedChildrenIterator
(
type
)
;
break
;
case
Axis
.
PARENT
:
return
(
new
ParentIterator
(
)
.
setNodeType
(
type
)
)
;
case
Axis
.
ANCESTOR
:
return
(
new
TypedAncestorIterator
(
type
)
)
;
case
Axis
.
ANCESTORORSELF
:
return
(
(
new
TypedAncestorIterator
(
type
)
)
.
includeSelf
(
)
)
;
case
Axis
.
ATTRIBUTE
:
return
(
new
TypedAttributeIterator
(
type
)
)
;
case
Axis
.
DESCENDANT
:
iterator
=
new
TypedDescendantIterator
(
type
)
;
break
;
case
Axis
.
DESCENDANTORSELF
:
iterator
=
(
new
TypedDescendantIterator
(
type
)
)
.
includeSelf
(
)
;
break
;
case
Axis
.
FOLLOWING
:
iterator
=
new
TypedFollowingIterator
(
type
)
;
break
;
case
Axis
.
PRECEDING
:
iterator
=
new
TypedPrecedingIterator
(
type
)
;
break
;
case
Axis
.
FOLLOWINGSIBLING
:
iterator
=
new
TypedFollowingSiblingIterator
(
type
)
;
break
;
case
Axis
.
PRECEDINGSIBLING
:
iterator
=
new
TypedPrecedingSiblingIterator
(
type
)
;
break
;
case
Axis
.
NAMESPACE
:
iterator
=
new
TypedNamespaceIterator
(
type
)
;
break
;
case
Axis
.
ROOT
:
iterator
=
new
TypedRootIterator
(
type
)
;
break
;
default
:
throw
new
DTMException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED
,
new
Object
[
]
{
Axis
.
names
[
axis
]
}
)
)
;
}
}
return
(
iterator
)
;
}
public
DTMAxisIterator
getAxisIterator
(
final
int
axis
)
{
DTMAxisIterator
iterator
=
null
;
switch
(
axis
)
{
case
Axis
.
SELF
:
iterator
=
new
SingletonIterator
(
)
;
break
;
case
Axis
.
CHILD
:
iterator
=
new
ChildrenIterator
(
)
;
break
;
case
Axis
.
PARENT
:
return
(
new
ParentIterator
(
)
)
;
case
Axis
.
ANCESTOR
:
return
(
new
AncestorIterator
(
)
)
;
case
Axis
.
ANCESTORORSELF
:
return
(
(
new
AncestorIterator
(
)
)
.
includeSelf
(
)
)
;
case
Axis
.
ATTRIBUTE
:
return
(
new
AttributeIterator
(
)
)
;
case
Axis
.
DESCENDANT
:
iterator
=
new
DescendantIterator
(
)
;
break
;
case
Axis
.
DESCENDANTORSELF
:
iterator
=
(
new
DescendantIterator
(
)
)
.
includeSelf
(
)
;
break
;
case
Axis
.
FOLLOWING
:
iterator
=
new
FollowingIterator
(
)
;
break
;
case
Axis
.
PRECEDING
:
iterator
=
new
PrecedingIterator
(
)
;
break
;
case
Axis
.
FOLLOWINGSIBLING
:
iterator
=
new
FollowingSiblingIterator
(
)
;
break
;
case
Axis
.
PRECEDINGSIBLING
:
iterator
=
new
PrecedingSiblingIterator
(
)
;
break
;
case
Axis
.
NAMESPACE
:
iterator
=
new
NamespaceIterator
(
)
;
break
;
case
Axis
.
ROOT
:
iterator
=
new
RootIterator
(
)
;
break
;
default
:
throw
new
DTMException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_ITERATOR_AXIS_NOT_IMPLEMENTED
,
new
Object
[
]
{
Axis
.
names
[
axis
]
}
)
)
;
}
return
(
iterator
)
;
}
private
abstract
class
InternalAxisIteratorBase
extends
DTMAxisIteratorBase
{
protected
int
_currentNode
;
public
void
setMark
(
)
{
_markedNode
=
_currentNode
;
}
public
void
gotoMark
(
)
{
_currentNode
=
_markedNode
;
}
}
private
final
class
ChildrenIterator
extends
InternalAxisIteratorBase
{
public
DTMAxisIterator
setStartNode
(
final
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
node
;
_currentNode
=
NOTPROCESSED
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
_currentNode
=
(
NOTPROCESSED
==
_currentNode
)
?
getFirstChild
(
_startNode
)
:
getNextSibling
(
_currentNode
)
;
return
returnNode
(
_currentNode
)
;
}
}
private
final
class
ParentIterator
extends
InternalAxisIteratorBase
{
private
int
_nodeType
=
-
1
;
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
node
;
_currentNode
=
getParent
(
node
)
;
return
resetPosition
(
)
;
}
return
this
;
}
public
DTMAxisIterator
setNodeType
(
final
int
type
)
{
_nodeType
=
type
;
return
this
;
}
public
int
next
(
)
{
int
result
=
_currentNode
;
if
(
(
_nodeType
!=
-
1
)
&&
(
getExpandedTypeID
(
_currentNode
)
!=
_nodeType
)
)
result
=
END
;
else
result
=
_currentNode
;
_currentNode
=
END
;
return
returnNode
(
result
)
;
}
}
private
final
class
TypedChildrenIterator
extends
InternalAxisIteratorBase
{
private
final
int
_nodeType
;
public
TypedChildrenIterator
(
int
nodeType
)
{
_nodeType
=
nodeType
;
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
node
;
_currentNode
=
NOTPROCESSED
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
for
(
int
node
=
(
NOTPROCESSED
==
_currentNode
)
?
getFirstChild
(
_startNode
)
:
getNextSibling
(
_currentNode
)
;
node
!=
END
;
node
=
getNextSibling
(
node
)
)
{
if
(
getExpandedTypeID
(
node
)
==
_nodeType
)
{
_currentNode
=
node
;
return
returnNode
(
node
)
;
}
}
return
END
;
}
}
private
final
class
NamespaceChildrenIterator
extends
InternalAxisIteratorBase
{
private
final
int
_nsType
;
public
NamespaceChildrenIterator
(
final
int
type
)
{
_nsType
=
type
;
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
node
;
_currentNode
=
NOTPROCESSED
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
for
(
int
node
=
(
NOTPROCESSED
==
_currentNode
)
?
getFirstChild
(
_startNode
)
:
getNextSibling
(
_currentNode
)
;
node
!=
END
;
node
=
getNextSibling
(
node
)
)
{
if
(
getNamespaceType
(
node
)
==
_nsType
)
{
_currentNode
=
node
;
return
returnNode
(
node
)
;
}
}
return
END
;
}
}
private
class
NamespaceIterator
extends
InternalAxisIteratorBase
{
public
NamespaceIterator
(
)
{
super
(
)
;
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
node
;
_currentNode
=
getFirstNamespaceNode
(
node
,
true
)
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
int
node
=
_currentNode
;
if
(
DTM
.
NULL
!=
node
)
_currentNode
=
getNextNamespaceNode
(
_startNode
,
node
,
true
)
;
return
returnNode
(
node
)
;
}
}
private
class
TypedNamespaceIterator
extends
NamespaceIterator
{
private
final
int
_nodeType
;
public
TypedNamespaceIterator
(
int
nodeType
)
{
super
(
)
;
_nodeType
=
nodeType
;
}
public
int
next
(
)
{
for
(
int
node
=
super
.
next
(
)
;
node
!=
END
;
node
=
super
.
next
(
)
)
{
if
(
getExpandedTypeID
(
node
)
==
_nodeType
)
{
_currentNode
=
node
;
return
returnNode
(
node
)
;
}
}
return
END
;
}
}
private
class
RootIterator
extends
InternalAxisIteratorBase
{
public
RootIterator
(
)
{
super
(
)
;
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
getDocumentRoot
(
node
)
;
_currentNode
=
NULL
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
if
(
_startNode
==
_currentNode
)
return
NULL
;
_currentNode
=
_startNode
;
return
returnNode
(
_startNode
)
;
}
}
private
class
TypedRootIterator
extends
RootIterator
{
private
final
int
_nodeType
;
public
TypedRootIterator
(
int
nodeType
)
{
super
(
)
;
_nodeType
=
nodeType
;
}
public
int
next
(
)
{
for
(
int
node
=
super
.
next
(
)
;
node
!=
END
;
node
=
super
.
next
(
)
)
{
if
(
getExpandedTypeID
(
node
)
==
_nodeType
)
{
_currentNode
=
node
;
return
returnNode
(
node
)
;
}
}
return
END
;
}
}
private
final
class
NamespaceAttributeIterator
extends
InternalAxisIteratorBase
{
private
final
int
_nsType
;
public
NamespaceAttributeIterator
(
int
nsType
)
{
super
(
)
;
_nsType
=
nsType
;
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
node
;
_currentNode
=
getFirstNamespaceNode
(
node
,
false
)
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
int
node
=
_currentNode
;
if
(
DTM
.
NULL
!=
node
)
_currentNode
=
getNextNamespaceNode
(
_startNode
,
node
,
false
)
;
return
returnNode
(
node
)
;
}
}
private
class
FollowingSiblingIterator
extends
InternalAxisIteratorBase
{
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_currentNode
=
_startNode
=
node
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
return
returnNode
(
_currentNode
=
getNextSibling
(
_currentNode
)
)
;
}
}
private
final
class
TypedFollowingSiblingIterator
extends
FollowingSiblingIterator
{
private
final
int
_nodeType
;
public
TypedFollowingSiblingIterator
(
int
type
)
{
_nodeType
=
type
;
}
public
int
next
(
)
{
int
node
;
while
(
(
node
=
super
.
next
(
)
)
!=
NULL
&&
getExpandedTypeID
(
node
)
!=
_nodeType
)
{
}
return
node
;
}
}
private
final
class
AttributeIterator
extends
InternalAxisIteratorBase
{
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
node
;
_currentNode
=
getFirstAttribute
(
node
)
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
final
int
node
=
_currentNode
;
_currentNode
=
getNextAttribute
(
node
)
;
return
returnNode
(
node
)
;
}
}
private
final
class
TypedAttributeIterator
extends
InternalAxisIteratorBase
{
private
final
int
_nodeType
;
public
TypedAttributeIterator
(
int
nodeType
)
{
_nodeType
=
nodeType
;
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
node
;
for
(
node
=
getFirstAttribute
(
node
)
;
node
!=
END
;
node
=
getNextAttribute
(
node
)
)
{
if
(
getExpandedTypeID
(
node
)
==
_nodeType
)
break
;
}
_currentNode
=
node
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
final
int
node
=
_currentNode
;
_currentNode
=
NULL
;
return
returnNode
(
node
)
;
}
}
private
class
PrecedingSiblingIterator
extends
InternalAxisIteratorBase
{
public
boolean
isReverse
(
)
{
return
true
;
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
node
;
if
(
node
==
NULL
)
{
_currentNode
=
node
;
return
resetPosition
(
)
;
}
int
type
=
m_expandedNameTable
.
getType
(
getExpandedTypeID
(
node
)
)
;
if
(
ExpandedNameTable
.
ATTRIBUTE
==
type
||
ExpandedNameTable
.
NAMESPACE
==
type
)
{
_currentNode
=
node
;
}
else
{
_currentNode
=
getParent
(
node
)
;
if
(
NULL
!=
_currentNode
)
_currentNode
=
getFirstChild
(
_currentNode
)
;
else
_currentNode
=
node
;
}
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
if
(
_currentNode
==
_startNode
)
{
return
NULL
;
}
else
{
final
int
node
=
_currentNode
;
_currentNode
=
getNextSibling
(
node
)
;
return
returnNode
(
node
)
;
}
}
}
private
final
class
TypedPrecedingSiblingIterator
extends
PrecedingSiblingIterator
{
private
final
int
_nodeType
;
public
TypedPrecedingSiblingIterator
(
int
type
)
{
_nodeType
=
type
;
}
public
int
next
(
)
{
int
node
;
while
(
(
node
=
super
.
next
(
)
)
!=
NULL
&&
getExpandedTypeID
(
node
)
!=
_nodeType
)
{
}
return
node
;
}
}
private
class
PrecedingIterator
extends
InternalAxisIteratorBase
{
private
final
int
_maxAncestors
=
8
;
private
int
[
]
_stack
=
new
int
[
_maxAncestors
]
;
private
int
_sp
,
_oldsp
;
public
boolean
isReverse
(
)
{
return
true
;
}
public
DTMAxisIterator
cloneIterator
(
)
{
_isRestartable
=
false
;
try
{
final
PrecedingIterator
clone
=
(
PrecedingIterator
)
super
.
clone
(
)
;
final
int
[
]
stackCopy
=
new
int
[
_stack
.
length
]
;
System
.
arraycopy
(
_stack
,
0
,
stackCopy
,
0
,
_stack
.
length
)
;
clone
.
_stack
=
stackCopy
;
return
clone
;
}
catch
(
CloneNotSupportedException
e
)
{
throw
new
DTMException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_ITERATOR_CLONE_NOT_SUPPORTED
,
null
)
)
;
}
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
node
=
makeNodeIdentity
(
node
)
;
int
parent
,
index
;
_startNode
=
node
;
_stack
[
index
=
0
]
=
node
;
parent
=
node
;
while
(
(
parent
=
_parent
(
parent
)
)
!=
NULL
)
{
if
(
++
index
==
_stack
.
length
)
{
final
int
[
]
stack
=
new
int
[
index
+
4
]
;
System
.
arraycopy
(
_stack
,
0
,
stack
,
0
,
index
)
;
_stack
=
stack
;
}
_stack
[
index
]
=
parent
;
}
if
(
index
>
0
)
--
index
;
_currentNode
=
_stack
[
index
]
;
_oldsp
=
_sp
=
index
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
for
(
++
_currentNode
;
_sp
>=
0
;
++
_currentNode
)
{
if
(
_currentNode
<
_stack
[
_sp
]
)
{
if
(
_type
(
_currentNode
)
!=
ATTRIBUTE_NODE
&&
_type
(
_currentNode
)
!=
NAMESPACE_NODE
)
return
returnNode
(
makeNodeHandle
(
_currentNode
)
)
;
}
else
--
_sp
;
}
return
NULL
;
}
public
DTMAxisIterator
reset
(
)
{
_sp
=
_oldsp
;
return
resetPosition
(
)
;
}
}
private
final
class
TypedPrecedingIterator
extends
PrecedingIterator
{
private
final
int
_nodeType
;
public
TypedPrecedingIterator
(
int
type
)
{
_nodeType
=
type
;
}
public
int
next
(
)
{
int
node
;
while
(
(
node
=
super
.
next
(
)
)
!=
NULL
&&
getExpandedTypeID
(
node
)
!=
_nodeType
)
{
}
return
node
;
}
}
private
class
FollowingIterator
extends
InternalAxisIteratorBase
{
DTMAxisTraverser
m_traverser
;
public
FollowingIterator
(
)
{
m_traverser
=
getAxisTraverser
(
Axis
.
FOLLOWING
)
;
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
_startNode
=
node
;
_currentNode
=
m_traverser
.
first
(
node
)
;
return
resetPosition
(
)
;
}
return
this
;
}
public
int
next
(
)
{
int
node
=
_currentNode
;
_currentNode
=
m_traverser
.
next
(
_startNode
,
_currentNode
)
;
return
returnNode
(
node
)
;
}
}
private
final
class
TypedFollowingIterator
extends
FollowingIterator
{
private
final
int
_nodeType
;
public
TypedFollowingIterator
(
int
type
)
{
_nodeType
=
type
;
}
public
int
next
(
)
{
int
node
;
while
(
(
node
=
super
.
next
(
)
)
!=
NULL
&&
getExpandedTypeID
(
node
)
!=
_nodeType
)
{
}
return
returnNode
(
node
)
;
}
}
private
class
AncestorIterator
extends
InternalAxisIteratorBase
{
org
.
apache
.
xml
.
utils
.
NodeVector
m_ancestors
=
new
org
.
apache
.
xml
.
utils
.
NodeVector
(
)
;
int
m_ancestorsPos
;
int
m_realStartNode
;
public
int
getStartNode
(
)
{
return
m_realStartNode
;
}
public
final
boolean
isReverse
(
)
{
return
true
;
}
public
int
getLast
(
)
{
return
(
_startNode
)
;
}
public
DTMAxisIterator
cloneIterator
(
)
{
_isRestartable
=
false
;
try
{
final
AncestorIterator
clone
=
(
AncestorIterator
)
super
.
clone
(
)
;
clone
.
_startNode
=
_startNode
;
return
clone
;
}
catch
(
CloneNotSupportedException
e
)
{
throw
new
DTMException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_ITERATOR_CLONE_NOT_SUPPORTED
,
null
)
)
;
}
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
m_realStartNode
=
node
;
if
(
_isRestartable
)
{
if
(
_includeSelf
)
_startNode
=
node
;
else
_startNode
=
getParent
(
node
)
;
node
=
_startNode
;
while
(
node
!=
END
)
{
m_ancestors
.
addElement
(
node
)
;
node
=
getParent
(
node
)
;
}
m_ancestorsPos
=
m_ancestors
.
size
(
)
-
1
;
_currentNode
=
(
m_ancestorsPos
>=
0
)
?
m_ancestors
.
elementAt
(
m_ancestorsPos
)
:
DTM
.
NULL
;
return
resetPosition
(
)
;
}
return
this
;
}
public
DTMAxisIterator
reset
(
)
{
m_ancestorsPos
=
m_ancestors
.
size
(
)
-
1
;
_currentNode
=
(
m_ancestorsPos
>=
0
)
?
m_ancestors
.
elementAt
(
m_ancestorsPos
)
:
DTM
.
NULL
;
return
resetPosition
(
)
;
}
public
int
next
(
)
{
int
next
=
_currentNode
;
int
pos
=
--
m_ancestorsPos
;
_currentNode
=
(
pos
>=
0
)
?
m_ancestors
.
elementAt
(
m_ancestorsPos
)
:
DTM
.
NULL
;
return
returnNode
(
next
)
;
}
}
private
final
class
TypedAncestorIterator
extends
AncestorIterator
{
private
final
int
_nodeType
;
public
TypedAncestorIterator
(
int
type
)
{
_nodeType
=
type
;
}
public
int
next
(
)
{
int
node
;
while
(
(
node
=
super
.
next
(
)
)
!=
NULL
)
{
if
(
getExpandedTypeID
(
node
)
==
_nodeType
)
return
returnNode
(
node
)
;
}
return
(
NULL
)
;
}
public
int
getLast
(
)
{
int
last
=
NULL
;
int
curr
=
_startNode
;
while
(
curr
!=
NULL
)
{
if
(
getExpandedTypeID
(
curr
)
==
_nodeType
)
last
=
curr
;
curr
=
getParent
(
curr
)
;
}
return
(
last
)
;
}
}
private
class
DescendantIterator
extends
InternalAxisIteratorBase
{
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isRestartable
)
{
node
=
makeNodeIdentity
(
node
)
;
_startNode
=
node
;
if
(
_includeSelf
)
node
--
;
_currentNode
=
node
;
return
resetPosition
(
)
;
}
return
this
;
}
protected
boolean
isDescendant
(
int
identity
)
{
return
(
_startNode
==
identity
)
||
_parent
(
identity
)
>=
_startNode
;
}
public
int
next
(
)
{
while
(
true
)
{
int
node
=
++
_currentNode
;
int
type
=
_type
(
node
)
;
if
(
NULL
==
type
||
!
isDescendant
(
node
)
)
return
END
;
if
(
ATTRIBUTE_NODE
==
type
||
NAMESPACE_NODE
==
type
)
continue
;
return
returnNode
(
makeNodeHandle
(
node
)
)
;
}
}
}
private
final
class
TypedDescendantIterator
extends
DescendantIterator
{
private
final
int
_nodeType
;
public
TypedDescendantIterator
(
int
nodeType
)
{
_nodeType
=
nodeType
;
}
public
int
next
(
)
{
int
node
;
while
(
(
node
=
super
.
next
(
)
)
!=
NULL
&&
getExpandedTypeID
(
node
)
!=
_nodeType
)
{
}
return
node
;
}
}
private
class
NthDescendantIterator
extends
DescendantIterator
{
int
_pos
;
public
NthDescendantIterator
(
int
pos
)
{
_pos
=
pos
;
}
public
int
next
(
)
{
int
node
;
while
(
(
node
=
super
.
next
(
)
)
!=
END
)
{
node
=
makeNodeIdentity
(
node
)
;
int
parent
=
_parent
(
node
)
;
int
child
=
_firstch
(
parent
)
;
int
pos
=
0
;
do
{
int
type
=
_type
(
child
)
;
if
(
ELEMENT_NODE
==
type
)
pos
++
;
}
while
(
(
pos
<
_pos
)
&&
(
child
=
_nextsib
(
child
)
)
!=
END
)
;
if
(
node
==
child
)
return
node
;
}
return
(
END
)
;
}
}
private
class
SingletonIterator
extends
InternalAxisIteratorBase
{
private
boolean
_isConstant
;
public
SingletonIterator
(
)
{
this
(
Integer
.
MIN_VALUE
,
false
)
;
}
public
SingletonIterator
(
int
node
)
{
this
(
node
,
false
)
;
}
public
SingletonIterator
(
int
node
,
boolean
constant
)
{
_currentNode
=
_startNode
=
node
;
_isConstant
=
constant
;
}
public
DTMAxisIterator
setStartNode
(
int
node
)
{
if
(
_isConstant
)
{
_currentNode
=
_startNode
;
return
resetPosition
(
)
;
}
else
if
(
_isRestartable
)
{
if
(
_currentNode
==
Integer
.
MIN_VALUE
)
{
_currentNode
=
_startNode
=
node
;
}
return
resetPosition
(
)
;
}
return
this
;
}
public
DTMAxisIterator
reset
(
)
{
if
(
_isConstant
)
{
_currentNode
=
_startNode
;
return
resetPosition
(
)
;
}
else
{
final
boolean
temp
=
_isRestartable
;
_isRestartable
=
true
;
setStartNode
(
_startNode
)
;
_isRestartable
=
temp
;
}
return
this
;
}
public
int
next
(
)
{
final
int
result
=
_currentNode
;
_currentNode
=
END
;
return
returnNode
(
result
)
;
}
}
private
final
class
TypedSingletonIterator
extends
SingletonIterator
{
private
final
int
_nodeType
;
public
TypedSingletonIterator
(
int
nodeType
)
{
_nodeType
=
nodeType
;
}
public
int
next
(
)
{
final
int
result
=
super
.
next
(
)
;
return
getExpandedTypeID
(
result
)
==
_nodeType
?
result
:
NULL
;
}
}
}
