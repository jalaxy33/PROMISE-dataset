package
org
.
apache
.
xml
.
utils
.
synthetic
;
import
org
.
apache
.
xml
.
utils
.
synthetic
.
SynthesisException
;
import
org
.
apache
.
xml
.
utils
.
synthetic
.
reflection
.
Constructor
;
import
org
.
apache
.
xml
.
utils
.
synthetic
.
reflection
.
Method
;
import
org
.
apache
.
xml
.
utils
.
synthetic
.
reflection
.
Field
;
import
java
.
lang
.
reflect
.
Modifier
;
public
class
Class
extends
Object
implements
java
.
io
.
Serializable
{
private
static
java
.
util
.
Hashtable
global_classtable
=
new
java
.
util
.
Hashtable
(
)
;
private
java
.
lang
.
String
name
;
private
java
.
lang
.
Class
realclass
=
null
;
private
int
modifiers
;
private
boolean
isInterface
=
false
;
private
Class
superclass
=
null
;
private
Class
declaringclass
=
null
;
private
Class
[
]
interfaces
=
new
Class
[
0
]
;
private
Class
[
]
allclasses
=
new
Class
[
0
]
;
private
Class
[
]
declaredclasses
=
new
Class
[
0
]
;
private
Constructor
[
]
allconstructors
=
new
Constructor
[
0
]
;
private
Constructor
[
]
declaredconstructors
=
new
Constructor
[
0
]
;
private
Method
[
]
allmethods
=
new
Method
[
0
]
;
private
Method
[
]
declaredmethods
=
new
Method
[
0
]
;
private
Field
[
]
allfields
=
new
Field
[
0
]
;
private
Field
[
]
declaredfields
=
new
Field
[
0
]
;
private
Class
[
]
innerclasses
=
new
Class
[
0
]
;
Class
(
java
.
lang
.
Class
realclass
)
{
this
(
realclass
.
getName
(
)
)
;
try
{
setRealClass
(
realclass
)
;
}
catch
(
SynthesisException
e
)
{
e
.
printStackTrace
(
)
;
}
}
Class
(
String
fullname
)
{
this
.
name
=
fullname
;
global_classtable
.
put
(
fullname
,
this
)
;
}
public
static
Class
forClass
(
java
.
lang
.
Class
cls
)
{
if
(
cls
==
null
)
return
null
;
Class
ret
=
(
Class
)
(
global_classtable
.
get
(
cls
.
getName
(
)
)
)
;
if
(
null
==
ret
)
ret
=
new
Class
(
cls
)
;
return
ret
;
}
public
Class
forNameInContext
(
String
classname
)
throws
ClassNotFoundException
{
for
(
int
i
=
innerclasses
.
length
-
1
;
i
>=
0
;
--
i
)
{
if
(
classname
.
equals
(
innerclasses
[
i
]
.
getShortName
(
)
)
)
return
innerclasses
[
i
]
;
}
return
forName
(
classname
)
;
}
public
static
Class
forName
(
String
className
)
throws
ClassNotFoundException
{
if
(
className
.
endsWith
(
"]"
)
)
{
StringBuffer
arrayname
=
new
StringBuffer
(
)
;
for
(
int
i
=
className
.
indexOf
(
'['
)
;
i
!=
-
1
;
i
=
className
.
indexOf
(
'['
,
i
+
1
)
)
{
arrayname
.
append
(
'['
)
;
}
String
classname
=
className
.
substring
(
0
,
className
.
indexOf
(
'['
)
)
;
if
(
"byte"
.
equals
(
classname
)
)
arrayname
.
append
(
'B'
)
;
else
if
(
"char"
.
equals
(
classname
)
)
arrayname
.
append
(
'C'
)
;
else
if
(
"double"
.
equals
(
classname
)
)
arrayname
.
append
(
'D'
)
;
else
if
(
"float"
.
equals
(
classname
)
)
arrayname
.
append
(
'F'
)
;
else
if
(
"int"
.
equals
(
classname
)
)
arrayname
.
append
(
'I'
)
;
else
if
(
"long"
.
equals
(
classname
)
)
arrayname
.
append
(
'J'
)
;
else
if
(
"short"
.
equals
(
classname
)
)
arrayname
.
append
(
'S'
)
;
else
if
(
"boolean"
.
equals
(
classname
)
)
arrayname
.
append
(
'Z'
)
;
else
arrayname
.
append
(
'L'
)
.
append
(
classname
)
.
append
(
';'
)
;
return
forName
(
arrayname
.
toString
(
)
)
;
}
Class
ret
=
(
Class
)
(
global_classtable
.
get
(
className
)
)
;
if
(
null
==
ret
)
{
if
(
"boolean"
.
equals
(
className
)
)
{
ret
=
new
Class
(
className
)
;
ret
.
realclass
=
java
.
lang
.
Boolean
.
TYPE
;
}
else
if
(
"byte"
.
equals
(
className
)
)
{
ret
=
new
Class
(
className
)
;
ret
.
realclass
=
java
.
lang
.
Byte
.
TYPE
;
}
else
if
(
"char"
.
equals
(
className
)
)
{
ret
=
new
Class
(
className
)
;
ret
.
realclass
=
java
.
lang
.
Character
.
TYPE
;
}
else
if
(
"short"
.
equals
(
className
)
)
{
ret
=
new
Class
(
className
)
;
ret
.
realclass
=
java
.
lang
.
Short
.
TYPE
;
}
else
if
(
"int"
.
equals
(
className
)
)
{
ret
=
new
Class
(
className
)
;
ret
.
realclass
=
java
.
lang
.
Integer
.
TYPE
;
}
else
if
(
"long"
.
equals
(
className
)
)
{
ret
=
new
Class
(
className
)
;
ret
.
realclass
=
java
.
lang
.
Long
.
TYPE
;
}
else
if
(
"float"
.
equals
(
className
)
)
{
ret
=
new
Class
(
className
)
;
ret
.
realclass
=
java
.
lang
.
Float
.
TYPE
;
}
else
if
(
"double"
.
equals
(
className
)
)
{
ret
=
new
Class
(
className
)
;
ret
.
realclass
=
java
.
lang
.
Double
.
TYPE
;
}
else
if
(
"void"
.
equals
(
className
)
)
{
ret
=
new
Class
(
className
)
;
ret
.
realclass
=
java
.
lang
.
Class
.
forName
(
"java.lang.Object"
)
;
}
else
ret
=
new
Class
(
java
.
lang
.
Class
.
forName
(
className
)
)
;
}
return
ret
;
}
public
static
Class
declareClass
(
String
className
)
throws
SynthesisException
{
Class
ret
=
(
Class
)
(
global_classtable
.
get
(
className
)
)
;
if
(
null
==
ret
)
ret
=
new
Class
(
className
)
;
if
(
ret
.
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
return
ret
;
}
public
static
Class
reallyDeclareClass
(
String
className
)
{
Class
ret
=
(
Class
)
(
global_classtable
.
get
(
className
)
)
;
if
(
null
!=
ret
)
global_classtable
.
remove
(
ret
)
;
ret
=
new
Class
(
className
)
;
return
ret
;
}
public
Class
[
]
getClasses
(
)
{
if
(
realclass
!=
null
&&
allclasses
==
null
)
{
java
.
lang
.
Class
[
]
realDE
=
realclass
.
getClasses
(
)
;
allclasses
=
new
Class
[
realDE
.
length
]
;
for
(
int
i
=
0
;
i
<
realDE
.
length
;
++
i
)
{
allclasses
[
i
]
=
forClass
(
realDE
[
i
]
)
;
}
}
return
allclasses
;
}
public
ClassLoader
getClassLoader
(
)
{
return
(
realclass
==
null
)
?
null
:
realclass
.
getClassLoader
(
)
;
}
public
Class
getComponentType
(
)
{
return
realclass
==
null
?
null
:
new
Class
(
realclass
.
getComponentType
(
)
)
;
}
public
Constructor
getConstructor
(
Class
parameterTypes
[
]
)
throws
NoSuchMethodException
,
SecurityException
,
SynthesisException
{
if
(
realclass
==
null
)
throw
new
SynthesisException
(
SynthesisException
.
UNREIFIED
)
;
java
.
lang
.
Class
[
]
real
=
new
java
.
lang
.
Class
[
parameterTypes
.
length
]
;
for
(
int
i
=
0
;
i
<
parameterTypes
.
length
;
++
i
)
{
if
(
(
real
[
i
]
=
parameterTypes
[
i
]
.
getRealClass
(
)
)
==
null
)
throw
new
SynthesisException
(
SynthesisException
.
UNREIFIED
)
;
}
return
new
Constructor
(
realclass
.
getConstructor
(
real
)
,
this
)
;
}
public
Constructor
[
]
getConstructors
(
)
throws
SecurityException
{
if
(
realclass
!=
null
&&
allconstructors
==
null
)
{
java
.
lang
.
reflect
.
Constructor
[
]
realDC
=
realclass
.
getConstructors
(
)
;
allconstructors
=
new
Constructor
[
realDC
.
length
]
;
for
(
int
i
=
0
;
i
<
realDC
.
length
;
++
i
)
{
allconstructors
[
i
]
=
new
Constructor
(
realDC
[
i
]
,
this
)
;
}
}
return
allconstructors
;
}
public
Class
[
]
getDeclaredClasses
(
)
throws
SecurityException
{
if
(
realclass
!=
null
&&
declaredclasses
==
null
)
{
java
.
lang
.
Class
[
]
realDE
=
realclass
.
getDeclaredClasses
(
)
;
declaredclasses
=
new
Class
[
realDE
.
length
]
;
for
(
int
i
=
0
;
i
<
realDE
.
length
;
++
i
)
{
declaredclasses
[
i
]
=
forClass
(
realDE
[
i
]
)
;
if
(
!
realDE
[
i
]
.
isInterface
(
)
)
superclass
=
declaredclasses
[
i
]
;
}
}
return
declaredclasses
;
}
public
void
addExtends
(
Class
newclass
)
throws
SynthesisException
{
if
(
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
Class
[
]
scratch
=
new
Class
[
declaredclasses
.
length
+
1
]
;
System
.
arraycopy
(
declaredclasses
,
0
,
scratch
,
0
,
declaredclasses
.
length
)
;
scratch
[
declaredclasses
.
length
]
=
newclass
;
declaredclasses
=
scratch
;
}
public
Constructor
getDeclaredConstructor
(
Class
parameterTypes
[
]
)
throws
NoSuchMethodException
,
SecurityException
{
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
Constructor
declareConstructor
(
)
throws
SynthesisException
{
if
(
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
Constructor
newctor
=
new
Constructor
(
this
)
;
Constructor
[
]
scratch
=
new
Constructor
[
declaredconstructors
.
length
+
1
]
;
System
.
arraycopy
(
declaredconstructors
,
0
,
scratch
,
0
,
declaredconstructors
.
length
)
;
scratch
[
declaredconstructors
.
length
]
=
newctor
;
declaredconstructors
=
scratch
;
scratch
=
new
Constructor
[
allconstructors
.
length
+
1
]
;
System
.
arraycopy
(
allconstructors
,
0
,
scratch
,
0
,
allconstructors
.
length
)
;
scratch
[
allconstructors
.
length
]
=
newctor
;
allconstructors
=
scratch
;
return
newctor
;
}
public
Class
declareInterface
(
Class
newifce
)
throws
SynthesisException
{
if
(
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
if
(
!
newifce
.
isInterface
(
)
)
throw
new
SynthesisException
(
SynthesisException
.
SYNTAX
,
newifce
.
getName
(
)
+
" isn't an interface"
)
;
Class
[
]
scratch
=
new
Class
[
interfaces
.
length
+
1
]
;
System
.
arraycopy
(
interfaces
,
0
,
scratch
,
0
,
interfaces
.
length
)
;
scratch
[
interfaces
.
length
]
=
newifce
;
interfaces
=
scratch
;
scratch
=
new
Class
[
allclasses
.
length
+
1
]
;
System
.
arraycopy
(
allclasses
,
0
,
scratch
,
0
,
allclasses
.
length
)
;
scratch
[
allclasses
.
length
]
=
newifce
;
allclasses
=
scratch
;
return
newifce
;
}
public
Constructor
[
]
getDeclaredConstructors
(
)
throws
SecurityException
{
if
(
realclass
!=
null
&&
declaredconstructors
==
null
)
{
java
.
lang
.
reflect
.
Constructor
[
]
realDC
=
realclass
.
getDeclaredConstructors
(
)
;
declaredconstructors
=
new
Constructor
[
realDC
.
length
]
;
for
(
int
i
=
0
;
i
<
realDC
.
length
;
++
i
)
{
declaredconstructors
[
i
]
=
new
Constructor
(
realDC
[
i
]
,
this
)
;
}
}
return
declaredconstructors
;
}
public
Field
getDeclaredField
(
String
name
)
throws
NoSuchFieldException
,
SecurityException
{
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
Field
declareField
(
String
name
)
throws
SynthesisException
{
if
(
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
Field
newfield
=
new
Field
(
name
,
this
)
;
Field
[
]
scratch
=
new
Field
[
declaredfields
.
length
+
1
]
;
System
.
arraycopy
(
declaredfields
,
0
,
scratch
,
0
,
declaredfields
.
length
)
;
scratch
[
declaredfields
.
length
]
=
newfield
;
declaredfields
=
scratch
;
scratch
=
new
Field
[
allfields
.
length
+
1
]
;
System
.
arraycopy
(
allfields
,
0
,
scratch
,
0
,
allfields
.
length
)
;
scratch
[
allfields
.
length
]
=
newfield
;
allfields
=
scratch
;
return
newfield
;
}
public
Field
[
]
getDeclaredFields
(
)
throws
SecurityException
{
if
(
realclass
!=
null
&&
declaredfields
==
null
)
{
java
.
lang
.
reflect
.
Field
[
]
realDF
=
realclass
.
getDeclaredFields
(
)
;
declaredfields
=
new
Field
[
realDF
.
length
]
;
for
(
int
i
=
0
;
i
<
realDF
.
length
;
++
i
)
{
declaredfields
[
i
]
=
new
Field
(
realDF
[
i
]
,
this
)
;
}
}
return
declaredfields
;
}
public
Method
getDeclaredMethod
(
String
name
,
Class
parameterTypes
[
]
)
throws
NoSuchMethodException
,
SecurityException
{
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
Method
declareMethod
(
String
name
)
throws
SynthesisException
{
if
(
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
Method
newMethod
=
new
Method
(
name
,
this
)
;
Method
[
]
scratch
=
new
Method
[
declaredmethods
.
length
+
1
]
;
System
.
arraycopy
(
declaredmethods
,
0
,
scratch
,
0
,
declaredmethods
.
length
)
;
scratch
[
declaredmethods
.
length
]
=
newMethod
;
declaredmethods
=
scratch
;
scratch
=
new
Method
[
allmethods
.
length
+
1
]
;
System
.
arraycopy
(
allmethods
,
0
,
scratch
,
0
,
allmethods
.
length
)
;
scratch
[
allmethods
.
length
]
=
newMethod
;
allmethods
=
scratch
;
return
newMethod
;
}
public
Method
[
]
getDeclaredMethods
(
)
throws
SecurityException
{
if
(
realclass
!=
null
&&
declaredmethods
==
null
)
{
java
.
lang
.
reflect
.
Method
[
]
realDM
=
realclass
.
getDeclaredMethods
(
)
;
declaredmethods
=
new
Method
[
realDM
.
length
]
;
for
(
int
i
=
0
;
i
<
realDM
.
length
;
++
i
)
{
declaredmethods
[
i
]
=
new
Method
(
realDM
[
i
]
,
this
)
;
}
}
return
declaredmethods
;
}
public
Class
getDeclaringClass
(
)
{
if
(
realclass
!=
null
&&
declaringclass
==
null
)
{
java
.
lang
.
Class
dc
=
realclass
.
getDeclaringClass
(
)
;
if
(
dc
==
null
)
declaringclass
=
null
;
else
declaringclass
=
forClass
(
dc
)
;
}
return
declaringclass
;
}
private
void
addInnerClass
(
Class
newclass
)
throws
SynthesisException
{
if
(
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
if
(
newclass
.
getDeclaringClass
(
)
!=
this
)
throw
new
SynthesisException
(
SynthesisException
.
WRONG_OWNER
)
;
Class
[
]
scratch
=
new
Class
[
innerclasses
.
length
+
1
]
;
System
.
arraycopy
(
innerclasses
,
0
,
scratch
,
0
,
innerclasses
.
length
)
;
scratch
[
innerclasses
.
length
]
=
newclass
;
innerclasses
=
scratch
;
}
public
Class
declareInnerClass
(
String
className
)
throws
SynthesisException
{
if
(
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
String
relativeName
=
getName
(
)
+
"$"
+
className
;
Class
newclass
=
(
Class
)
(
global_classtable
.
get
(
relativeName
)
)
;
if
(
newclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
SYNTAX
,
"Inner class "
+
name
+
" already exists"
)
;
newclass
=
new
Class
(
className
)
;
newclass
.
declaringclass
=
this
;
Class
[
]
scratch
=
new
Class
[
innerclasses
.
length
+
1
]
;
System
.
arraycopy
(
innerclasses
,
0
,
scratch
,
0
,
innerclasses
.
length
)
;
scratch
[
innerclasses
.
length
]
=
newclass
;
innerclasses
=
scratch
;
return
newclass
;
}
public
Class
[
]
getInnerClasses
(
)
{
return
innerclasses
;
}
public
Field
getField
(
String
name
)
throws
NoSuchFieldException
,
SecurityException
{
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
Field
[
]
getFields
(
)
throws
SecurityException
{
if
(
realclass
!=
null
&&
allfields
==
null
)
{
java
.
lang
.
reflect
.
Field
[
]
realDF
=
realclass
.
getFields
(
)
;
allfields
=
new
Field
[
realDF
.
length
]
;
for
(
int
i
=
0
;
i
<
realDF
.
length
;
++
i
)
{
allfields
[
i
]
=
new
Field
(
realDF
[
i
]
,
this
)
;
}
}
return
allfields
;
}
public
Class
[
]
getInterfaces
(
)
{
if
(
realclass
!=
null
&&
interfaces
==
null
)
{
java
.
lang
.
Class
[
]
realI
=
realclass
.
getInterfaces
(
)
;
interfaces
=
new
Class
[
realI
.
length
]
;
for
(
int
i
=
0
;
i
<
realI
.
length
;
++
i
)
{
interfaces
[
i
]
=
forClass
(
realI
[
i
]
)
;
}
}
return
interfaces
;
}
public
void
addImplements
(
Class
newclass
)
throws
SynthesisException
{
if
(
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
Class
[
]
scratch
=
new
Class
[
interfaces
.
length
+
1
]
;
System
.
arraycopy
(
interfaces
,
0
,
scratch
,
0
,
interfaces
.
length
)
;
scratch
[
interfaces
.
length
]
=
newclass
;
interfaces
=
scratch
;
}
public
Method
getMethod
(
String
name
,
Class
parameterTypes
[
]
)
throws
NoSuchMethodException
,
SecurityException
{
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
Method
[
]
getMethods
(
)
throws
SecurityException
{
if
(
realclass
!=
null
&&
allmethods
==
null
)
{
java
.
lang
.
reflect
.
Method
[
]
realDM
=
realclass
.
getMethods
(
)
;
allmethods
=
new
Method
[
realDM
.
length
]
;
for
(
int
i
=
0
;
i
<
realDM
.
length
;
++
i
)
{
allmethods
[
i
]
=
new
Method
(
realDM
[
i
]
,
this
)
;
}
}
return
allmethods
;
}
public
int
getModifiers
(
)
{
return
modifiers
;
}
public
void
setModifiers
(
int
modifiers
)
throws
SynthesisException
{
if
(
this
.
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
this
.
modifiers
=
modifiers
;
}
public
java
.
lang
.
String
getName
(
)
{
return
name
;
}
public
java
.
lang
.
String
getJavaName
(
)
{
if
(
name
.
charAt
(
0
)
!=
'['
)
return
name
;
int
count
=
name
.
lastIndexOf
(
'['
)
;
StringBuffer
jname
=
new
StringBuffer
(
name
.
substring
(
count
+
2
)
)
;
jname
.
setLength
(
jname
.
length
(
)
-
1
)
;
while
(
count
--
>=
0
)
{
jname
.
append
(
"[]"
)
;
}
return
jname
.
toString
(
)
;
}
public
java
.
lang
.
String
getShortName
(
)
{
int
start
=
name
.
lastIndexOf
(
"."
)
;
if
(
start
!=
0
||
name
.
charAt
(
0
)
==
'.'
)
++
start
;
if
(
declaringclass
!=
null
)
{
int
d
=
name
.
lastIndexOf
(
'$'
,
start
)
;
if
(
d
!=
0
)
start
=
d
+
1
;
}
return
name
.
substring
(
start
)
;
}
public
java
.
lang
.
String
getJavaShortName
(
)
{
String
shortname
=
getShortName
(
)
;
if
(
shortname
.
charAt
(
0
)
!=
'['
)
return
shortname
;
int
count
=
shortname
.
lastIndexOf
(
'['
)
;
StringBuffer
jname
=
new
StringBuffer
(
shortname
.
substring
(
count
+
2
)
)
;
jname
.
setLength
(
jname
.
length
(
)
-
1
)
;
while
(
count
--
>=
0
)
{
jname
.
append
(
"[]"
)
;
}
return
jname
.
toString
(
)
;
}
public
java
.
lang
.
String
getPackageName
(
)
{
int
start
=
name
.
lastIndexOf
(
"."
)
;
return
name
.
substring
(
0
,
start
)
;
}
public
java
.
lang
.
Class
getRealClass
(
)
{
return
realclass
;
}
public
void
setRealClass
(
java
.
lang
.
Class
realclass
)
throws
SynthesisException
{
if
(
this
.
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
this
.
realclass
=
realclass
;
this
.
modifiers
=
realclass
.
getModifiers
(
)
;
this
.
isInterface
=
realclass
.
isInterface
(
)
;
this
.
declaringclass
=
null
;
this
.
interfaces
=
null
;
this
.
declaredconstructors
=
null
;
this
.
allconstructors
=
null
;
this
.
declaredmethods
=
null
;
this
.
allmethods
=
null
;
this
.
declaredfields
=
null
;
this
.
allfields
=
null
;
this
.
declaredclasses
=
null
;
this
.
allclasses
=
null
;
this
.
superclass
=
null
;
}
public
void
setSuperClass
(
Class
superclass
)
throws
SynthesisException
{
if
(
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
this
.
superclass
=
superclass
;
}
public
void
setSuperClass
(
java
.
lang
.
Class
superclass
)
throws
ClassNotFoundException
,
SynthesisException
{
if
(
realclass
!=
null
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
this
.
superclass
=
Class
.
forClass
(
superclass
)
;
}
public
java
.
net
.
URL
getResource
(
String
name
)
{
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
java
.
io
.
InputStream
getResourceAsStream
(
String
name
)
{
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
Object
[
]
getSigners
(
)
{
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
Class
getSuperclass
(
)
{
if
(
realclass
!=
null
&&
superclass
==
null
)
{
superclass
=
forClass
(
realclass
.
getSuperclass
(
)
)
;
}
if
(
superclass
==
null
)
superclass
=
forClass
(
Object
.
class
)
;
return
superclass
;
}
public
boolean
isArray
(
)
{
return
realclass
!=
null
&&
realclass
.
isArray
(
)
;
}
public
boolean
isAssignableFrom
(
Class
cls
)
{
if
(
realclass
!=
null
&&
cls
.
realclass
!=
null
)
return
realclass
.
isAssignableFrom
(
cls
.
realclass
)
;
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
boolean
isAssignableFrom
(
java
.
lang
.
Class
cls
)
{
if
(
realclass
!=
null
)
return
realclass
.
isAssignableFrom
(
(
java
.
lang
.
Class
)
cls
)
;
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
boolean
isInstance
(
Object
obj
)
{
if
(
realclass
!=
null
)
return
realclass
.
isInstance
(
obj
)
;
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
boolean
isInterface
(
)
{
return
(
realclass
!=
null
)
?
realclass
.
isInterface
(
)
:
isInterface
;
}
public
void
isInterface
(
boolean
isInterface
)
throws
SynthesisException
{
if
(
realclass
==
null
)
this
.
isInterface
=
isInterface
;
else
if
(
realclass
.
isInterface
(
)
!=
isInterface
)
throw
new
SynthesisException
(
SynthesisException
.
REIFIED
)
;
}
public
boolean
isPrimitive
(
)
{
return
realclass
!=
null
&&
realclass
.
isPrimitive
(
)
;
}
public
Object
newInstance
(
)
throws
InstantiationException
,
IllegalAccessException
{
throw
new
java
.
lang
.
IllegalStateException
(
)
;
}
public
String
toString
(
)
{
if
(
realclass
!=
null
)
return
realclass
.
toString
(
)
;
else
if
(
isInterface
(
)
)
return
"interface "
+
name
;
else
return
"class "
+
name
;
}
public
void
toSource
(
java
.
io
.
OutputStream
out
,
int
depth
)
{
java
.
io
.
PrintWriter
writer
=
new
java
.
io
.
PrintWriter
(
out
)
;
toSource
(
writer
,
depth
)
;
}
public
void
toSource
(
java
.
io
.
PrintWriter
out
,
int
depth
)
{
String
tab
=
tabset
(
depth
)
;
if
(
realclass
!=
null
)
out
.
println
(
tab
+
"/** Code back-generated from a \"real\" Class; accuracy limited by reflection APIs. */"
)
;
else
out
.
println
(
tab
+
"/** Code generated via org.apache.xml.utils.synthetic.Class */"
)
;
if
(
getDeclaringClass
(
)
==
null
)
out
.
println
(
tab
+
"package "
+
getPackageName
(
)
+
";"
)
;
out
.
print
(
tab
+
Modifier
.
toString
(
getModifiers
(
)
)
)
;
if
(
isInterface
(
)
)
out
.
print
(
" interface "
)
;
else
out
.
print
(
" class "
)
;
out
.
println
(
getJavaShortName
(
)
)
;
if
(
superclass
!=
null
)
{
out
.
print
(
'\n'
+
tab
+
" extends "
+
superclass
.
getJavaName
(
)
)
;
}
Class
[
]
ext
=
getInterfaces
(
)
;
if
(
ext
!=
null
&
ext
.
length
>
0
)
{
out
.
print
(
'\n'
+
tab
+
(
isInterface
?
" extends "
:
" implements "
)
+
ext
[
0
]
.
getName
(
)
)
;
for
(
int
i
=
1
;
i
<
ext
.
length
;
++
i
)
{
out
.
print
(
", "
+
ext
[
i
]
.
getJavaName
(
)
)
;
}
out
.
print
(
"\n"
)
;
}
out
.
print
(
tab
+
"{\n"
)
;
tab
=
tabset
(
++
depth
)
;
Field
[
]
fields
=
null
;
try
{
fields
=
getDeclaredFields
(
)
;
}
catch
(
SecurityException
e
)
{
out
.
println
(
tab
+
"//SecurityException retrieving fields"
)
;
}
if
(
fields
!=
null
)
{
for
(
int
i
=
0
;
i
<
fields
.
length
;
++
i
)
{
out
.
println
(
tab
+
fields
[
i
]
.
toSource
(
)
)
;
}
}
Constructor
[
]
ctors
=
null
;
try
{
ctors
=
getDeclaredConstructors
(
)
;
}
catch
(
SecurityException
e
)
{
out
.
println
(
tab
+
"//SecurityException retrieving ctors"
)
;
}
if
(
ctors
!=
null
)
{
for
(
int
i
=
0
;
i
<
ctors
.
length
;
++
i
)
{
out
.
print
(
ctors
[
i
]
.
toSource
(
tab
)
)
;
}
}
Method
[
]
methods
=
null
;
try
{
methods
=
getDeclaredMethods
(
)
;
}
catch
(
SecurityException
e
)
{
out
.
println
(
tab
+
"//SecurityException retrieving methods"
)
;
}
if
(
methods
!=
null
)
{
for
(
int
i
=
0
;
i
<
methods
.
length
;
++
i
)
{
out
.
print
(
'\n'
)
;
out
.
print
(
methods
[
i
]
.
toSource
(
tab
)
)
;
}
}
Class
[
]
inners
=
getInnerClasses
(
)
;
if
(
inners
!=
null
)
{
for
(
int
i
=
0
;
i
<
inners
.
length
;
++
i
)
{
out
.
print
(
'\n'
)
;
inners
[
i
]
.
toSource
(
out
,
depth
)
;
}
}
tab
=
tabset
(
--
depth
)
;
out
.
print
(
tab
+
"}\n"
)
;
out
.
flush
(
)
;
}
private
String
tabset
(
int
depth
)
{
StringBuffer
t
=
new
StringBuffer
(
)
;
while
(
depth
--
>
0
)
{
t
.
append
(
"    "
)
;
}
return
t
.
toString
(
)
;
}
static
final
int
[
]
val
=
{
Modifier
.
ABSTRACT
,
Modifier
.
FINAL
,
Modifier
.
INTERFACE
,
Modifier
.
NATIVE
,
Modifier
.
PRIVATE
,
Modifier
.
PROTECTED
,
Modifier
.
PUBLIC
,
Modifier
.
STATIC
,
Modifier
.
SYNCHRONIZED
,
Modifier
.
TRANSIENT
,
Modifier
.
VOLATILE
}
;
static
final
String
[
]
kwd
=
{
"abstract"
,
"final"
,
"interface"
,
"native"
,
"private"
,
"protected"
,
"public"
,
"static"
,
"synchronized"
,
"transient"
,
"volatile"
}
;
static
public
int
modifierFromString
(
String
t
)
{
for
(
int
i
=
0
;
i
<
kwd
.
length
;
++
i
)
{
if
(
kwd
[
i
]
.
equals
(
t
)
)
return
val
[
i
]
;
}
return
0
;
}
static
public
int
modifiersFromString
(
String
s
)
{
int
mods
=
0
;
java
.
util
.
StringTokenizer
parts
=
new
java
.
util
.
StringTokenizer
(
s
)
;
while
(
parts
.
hasMoreTokens
(
)
)
{
String
t
=
parts
.
nextToken
(
)
;
mods
|=
modifierFromString
(
t
)
;
}
return
mods
;
}
}
