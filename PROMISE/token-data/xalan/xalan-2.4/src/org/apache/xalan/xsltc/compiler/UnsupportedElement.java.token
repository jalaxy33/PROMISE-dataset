package
org
.
apache
.
xalan
.
xsltc
.
compiler
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Vector
;
import
javax
.
xml
.
parsers
.
*
;
import
org
.
xml
.
sax
.
*
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
util
.
Type
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
util
.
ReferenceType
;
import
org
.
apache
.
bcel
.
generic
.
*
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
util
.
*
;
final
class
UnsupportedElement
extends
SyntaxTreeNode
{
private
Fallback
_fallback
=
null
;
private
ErrorMsg
_message
=
null
;
public
UnsupportedElement
(
String
uri
,
String
prefix
,
String
local
)
{
super
(
uri
,
prefix
,
local
)
;
}
public
void
setErrorMessage
(
ErrorMsg
message
)
{
_message
=
message
;
}
public
void
display
(
int
indent
)
{
indent
(
indent
)
;
Util
.
println
(
"Unsupported element = "
+
_qname
.
getNamespace
(
)
+
":"
+
_qname
.
getLocalPart
(
)
)
;
displayContents
(
indent
+
IndentIncrement
)
;
}
private
SyntaxTreeNode
findFallback
(
SyntaxTreeNode
root
)
{
if
(
root
==
null
)
return
null
;
if
(
root
instanceof
Fallback
)
return
(
(
Fallback
)
root
)
;
Vector
children
=
root
.
getContents
(
)
;
if
(
children
!=
null
)
{
final
int
count
=
children
.
size
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
{
SyntaxTreeNode
child
=
(
SyntaxTreeNode
)
children
.
elementAt
(
i
)
;
SyntaxTreeNode
node
=
findFallback
(
child
)
;
if
(
node
!=
null
)
return
node
;
}
}
return
null
;
}
public
void
parseContents
(
Parser
parser
)
{
_fallback
=
(
Fallback
)
findFallback
(
this
)
;
if
(
_fallback
!=
null
)
{
_fallback
.
activate
(
)
;
_fallback
.
parseContents
(
parser
)
;
}
}
public
Type
typeCheck
(
SymbolTable
stable
)
throws
TypeCheckError
{
if
(
_fallback
==
null
)
{
throw
new
TypeCheckError
(
_message
)
;
}
return
(
_fallback
.
typeCheck
(
stable
)
)
;
}
public
void
translate
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
)
{
if
(
_fallback
!=
null
)
_fallback
.
translate
(
classGen
,
methodGen
)
;
}
}
