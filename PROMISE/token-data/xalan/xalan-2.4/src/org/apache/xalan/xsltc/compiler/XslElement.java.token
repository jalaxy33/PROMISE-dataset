package
org
.
apache
.
xalan
.
xsltc
.
compiler
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
StringTokenizer
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
util
.
Type
;
import
org
.
apache
.
bcel
.
generic
.
*
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
util
.
*
;
final
class
XslElement
extends
Instruction
{
private
String
_prefix
;
private
boolean
_ignore
=
false
;
private
boolean
_isLiteralName
=
true
;
private
AttributeValueTemplate
_name
;
private
AttributeValueTemplate
_namespace
;
public
void
display
(
int
indent
)
{
indent
(
indent
)
;
Util
.
println
(
"Element "
+
_name
)
;
displayContents
(
indent
+
IndentIncrement
)
;
}
public
boolean
declaresDefaultNS
(
)
{
return
false
;
}
private
boolean
isLiteral
(
String
str
)
{
final
int
length
=
str
.
length
(
)
;
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
if
(
str
.
charAt
(
i
)
==
'{'
&&
str
.
charAt
(
i
+
1
)
!=
'{'
)
{
return
false
;
}
}
return
true
;
}
private
boolean
isLegalName
(
String
str
)
{
if
(
str
.
indexOf
(
' '
)
>
-
1
)
{
return
false
;
}
final
int
colon
=
str
.
indexOf
(
':'
)
;
if
(
colon
==
0
||
colon
==
str
.
length
(
)
-
1
)
{
return
false
;
}
final
char
first
=
str
.
charAt
(
0
)
;
if
(
!
Character
.
isLetter
(
first
)
&&
first
!=
'_'
)
{
return
false
;
}
return
true
;
}
public
void
parseContents
(
Parser
parser
)
{
final
SymbolTable
stable
=
parser
.
getSymbolTable
(
)
;
String
name
=
getAttribute
(
"name"
)
;
if
(
name
==
EMPTYSTRING
)
{
ErrorMsg
msg
=
new
ErrorMsg
(
ErrorMsg
.
ILLEGAL_ELEM_NAME_ERR
,
name
,
this
)
;
parser
.
reportError
(
WARNING
,
msg
)
;
parseChildren
(
parser
)
;
_ignore
=
true
;
return
;
}
String
namespace
=
getAttribute
(
"namespace"
)
;
_isLiteralName
=
isLiteral
(
name
)
;
if
(
_isLiteralName
)
{
if
(
!
isLegalName
(
name
)
)
{
ErrorMsg
msg
=
new
ErrorMsg
(
ErrorMsg
.
ILLEGAL_ELEM_NAME_ERR
,
name
,
this
)
;
parser
.
reportError
(
WARNING
,
msg
)
;
parseChildren
(
parser
)
;
_ignore
=
true
;
return
;
}
final
QName
qname
=
parser
.
getQNameSafe
(
name
)
;
String
prefix
=
qname
.
getPrefix
(
)
;
String
local
=
qname
.
getLocalPart
(
)
;
if
(
prefix
==
null
)
{
prefix
=
EMPTYSTRING
;
}
if
(
!
hasAttribute
(
"namespace"
)
)
{
namespace
=
lookupNamespace
(
prefix
)
;
if
(
namespace
==
null
)
{
ErrorMsg
err
=
new
ErrorMsg
(
ErrorMsg
.
NAMESPACE_UNDEF_ERR
,
prefix
,
this
)
;
parser
.
reportError
(
WARNING
,
err
)
;
parseChildren
(
parser
)
;
_ignore
=
true
;
return
;
}
_prefix
=
prefix
;
_namespace
=
new
AttributeValueTemplate
(
namespace
,
parser
,
this
)
;
}
else
{
if
(
prefix
==
EMPTYSTRING
)
{
if
(
isLiteral
(
namespace
)
)
{
prefix
=
lookupPrefix
(
namespace
)
;
if
(
prefix
==
null
)
{
prefix
=
stable
.
generateNamespacePrefix
(
)
;
}
}
final
StringBuffer
newName
=
new
StringBuffer
(
prefix
)
;
if
(
prefix
!=
EMPTYSTRING
)
{
newName
.
append
(
':'
)
;
}
name
=
newName
.
append
(
local
)
.
toString
(
)
;
}
_prefix
=
prefix
;
_namespace
=
new
AttributeValueTemplate
(
namespace
,
parser
,
this
)
;
}
}
else
{
_namespace
=
(
namespace
==
EMPTYSTRING
)
?
null
:
new
AttributeValueTemplate
(
namespace
,
parser
,
this
)
;
}
_name
=
new
AttributeValueTemplate
(
name
,
parser
,
this
)
;
final
String
useSets
=
getAttribute
(
"use-attribute-sets"
)
;
if
(
useSets
.
length
(
)
>
0
)
{
setFirstElement
(
new
UseAttributeSets
(
useSets
,
parser
)
)
;
}
parseChildren
(
parser
)
;
}
public
Type
typeCheck
(
SymbolTable
stable
)
throws
TypeCheckError
{
if
(
!
_ignore
)
{
_name
.
typeCheck
(
stable
)
;
if
(
_namespace
!=
null
)
{
_namespace
.
typeCheck
(
stable
)
;
}
}
typeCheckContents
(
stable
)
;
return
Type
.
Void
;
}
public
void
translateLiteral
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
)
{
final
ConstantPoolGen
cpg
=
classGen
.
getConstantPool
(
)
;
final
InstructionList
il
=
methodGen
.
getInstructionList
(
)
;
if
(
!
_ignore
)
{
il
.
append
(
methodGen
.
loadHandler
(
)
)
;
_name
.
translate
(
classGen
,
methodGen
)
;
il
.
append
(
DUP2
)
;
il
.
append
(
methodGen
.
startElement
(
)
)
;
if
(
_namespace
!=
null
)
{
il
.
append
(
methodGen
.
loadHandler
(
)
)
;
il
.
append
(
new
PUSH
(
cpg
,
_prefix
)
)
;
_namespace
.
translate
(
classGen
,
methodGen
)
;
il
.
append
(
methodGen
.
namespace
(
)
)
;
}
}
translateContents
(
classGen
,
methodGen
)
;
if
(
!
_ignore
)
{
il
.
append
(
methodGen
.
endElement
(
)
)
;
}
}
public
void
translate
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
)
{
LocalVariableGen
local
=
null
;
final
ConstantPoolGen
cpg
=
classGen
.
getConstantPool
(
)
;
final
InstructionList
il
=
methodGen
.
getInstructionList
(
)
;
if
(
_isLiteralName
)
{
translateLiteral
(
classGen
,
methodGen
)
;
return
;
}
if
(
!
_ignore
)
{
il
.
append
(
methodGen
.
loadHandler
(
)
)
;
_name
.
translate
(
classGen
,
methodGen
)
;
il
.
append
(
DUP
)
;
final
int
getPrefix
=
cpg
.
addMethodref
(
BASIS_LIBRARY_CLASS
,
"getPrefix"
,
"("
+
STRING_SIG
+
")"
+
STRING_SIG
)
;
il
.
append
(
new
INVOKESTATIC
(
getPrefix
)
)
;
il
.
append
(
DUP
)
;
local
=
methodGen
.
addLocalVariable
(
"prefix"
,
org
.
apache
.
bcel
.
generic
.
Type
.
STRING
,
il
.
getEnd
(
)
,
null
)
;
il
.
append
(
new
ASTORE
(
local
.
getIndex
(
)
)
)
;
final
BranchHandle
ifNotNull
=
il
.
append
(
new
IFNONNULL
(
null
)
)
;
if
(
_namespace
!=
null
)
{
final
int
generatePrefix
=
cpg
.
addMethodref
(
BASIS_LIBRARY_CLASS
,
"generatePrefix"
,
"()"
+
STRING_SIG
)
;
il
.
append
(
new
INVOKESTATIC
(
generatePrefix
)
)
;
il
.
append
(
DUP
)
;
il
.
append
(
new
ASTORE
(
local
.
getIndex
(
)
)
)
;
final
int
makeQName
=
cpg
.
addMethodref
(
BASIS_LIBRARY_CLASS
,
"makeQName"
,
"("
+
STRING_SIG
+
STRING_SIG
+
")"
+
STRING_SIG
)
;
il
.
append
(
new
INVOKESTATIC
(
makeQName
)
)
;
}
ifNotNull
.
setTarget
(
il
.
append
(
DUP2
)
)
;
il
.
append
(
methodGen
.
startElement
(
)
)
;
if
(
_namespace
!=
null
)
{
il
.
append
(
methodGen
.
loadHandler
(
)
)
;
il
.
append
(
new
ALOAD
(
local
.
getIndex
(
)
)
)
;
_namespace
.
translate
(
classGen
,
methodGen
)
;
il
.
append
(
methodGen
.
namespace
(
)
)
;
}
else
{
il
.
append
(
new
ALOAD
(
local
.
getIndex
(
)
)
)
;
final
BranchHandle
ifNull
=
il
.
append
(
new
IFNULL
(
null
)
)
;
il
.
append
(
methodGen
.
loadHandler
(
)
)
;
il
.
append
(
new
ALOAD
(
local
.
getIndex
(
)
)
)
;
il
.
append
(
methodGen
.
loadDOM
(
)
)
;
il
.
append
(
methodGen
.
loadCurrentNode
(
)
)
;
il
.
append
(
new
ALOAD
(
local
.
getIndex
(
)
)
)
;
final
int
lookupNamespace
=
cpg
.
addInterfaceMethodref
(
DOM_INTF
,
"lookupNamespace"
,
"(I"
+
STRING_SIG
+
")"
+
STRING_SIG
)
;
il
.
append
(
new
INVOKEINTERFACE
(
lookupNamespace
,
3
)
)
;
il
.
append
(
methodGen
.
namespace
(
)
)
;
ifNull
.
setTarget
(
il
.
append
(
NOP
)
)
;
}
}
translateContents
(
classGen
,
methodGen
)
;
if
(
!
_ignore
)
{
il
.
append
(
methodGen
.
endElement
(
)
)
;
}
}
public
void
translateContents
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
)
{
final
int
n
=
elementCount
(
)
;
for
(
int
i
=
0
;
i
<
n
;
i
++
)
{
final
SyntaxTreeNode
item
=
(
SyntaxTreeNode
)
getContents
(
)
.
elementAt
(
i
)
;
if
(
_ignore
&&
item
instanceof
XslAttribute
)
continue
;
item
.
translate
(
classGen
,
methodGen
)
;
}
}
}
