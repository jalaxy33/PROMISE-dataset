package
org
.
apache
.
xalan
.
xsltc
.
dom
;
import
java
.
util
.
Enumeration
;
import
org
.
xml
.
sax
.
XMLReader
;
import
org
.
xml
.
sax
.
DTDHandler
;
import
org
.
xml
.
sax
.
ext
.
DeclHandler
;
import
org
.
xml
.
sax
.
SAXException
;
import
org
.
xml
.
sax
.
SAXNotRecognizedException
;
import
org
.
xml
.
sax
.
SAXNotSupportedException
;
import
org
.
apache
.
xalan
.
xsltc
.
*
;
import
org
.
apache
.
xalan
.
xsltc
.
runtime
.
AbstractTranslet
;
import
org
.
apache
.
xalan
.
xsltc
.
runtime
.
Hashtable
;
final
public
class
DTDMonitor
implements
DTDHandler
,
DeclHandler
{
private
final
static
String
EMPTYSTRING
=
""
;
private
final
static
String
ID_INDEX_NAME
=
"##id"
;
private
Hashtable
_idAttributes
=
new
Hashtable
(
)
;
private
Hashtable
_unparsedEntities
=
new
Hashtable
(
)
;
private
final
static
String
DECL_HANDLER_PROP
=
"http://xml.org/sax/properties/declaration-handler"
;
private
final
static
String
NO_DTD_SUPPORT_STR
=
"Your SAX parser does not handle DTD declarations"
;
public
DTDMonitor
(
)
{
}
public
DTDMonitor
(
XMLReader
reader
)
throws
RuntimeException
{
handleDTD
(
reader
)
;
}
public
void
handleDTD
(
XMLReader
reader
)
throws
RuntimeException
{
try
{
reader
.
setProperty
(
DECL_HANDLER_PROP
,
this
)
;
reader
.
setDTDHandler
(
this
)
;
}
catch
(
SAXNotRecognizedException
e
)
{
throw
(
new
RuntimeException
(
NO_DTD_SUPPORT_STR
)
)
;
}
catch
(
SAXNotSupportedException
e
)
{
throw
(
new
RuntimeException
(
NO_DTD_SUPPORT_STR
)
)
;
}
}
public
void
notationDecl
(
String
name
,
String
publicId
,
String
systemId
)
throws
SAXException
{
}
public
void
unparsedEntityDecl
(
String
name
,
String
publicId
,
String
systemId
,
String
notation
)
throws
SAXException
{
if
(
_unparsedEntities
.
containsKey
(
name
)
==
false
)
{
_unparsedEntities
.
put
(
name
,
systemId
)
;
}
}
public
Hashtable
getUnparsedEntityURIs
(
)
{
return
(
_unparsedEntities
)
;
}
public
void
attributeDecl
(
String
element
,
String
attribute
,
String
type
,
String
[
]
options
,
String
defaultValue
,
boolean
fixed
,
boolean
required
)
{
_idAttributes
.
put
(
element
,
"@"
+
attribute
)
;
}
public
void
attributeDecl
(
String
element
,
String
attribute
,
String
type
,
String
defaultValue
,
String
value
)
{
if
(
type
.
equals
(
"ID"
)
||
(
type
.
equals
(
"IDREF"
)
)
)
_idAttributes
.
put
(
element
,
"@"
+
attribute
)
;
}
public
void
elementDecl
(
String
element
,
String
model
)
{
}
public
void
externalEntityDecl
(
String
name
,
String
pid
,
String
sid
)
{
}
public
void
internalEntityDecl
(
String
name
,
String
value
)
{
}
private
final
String
getIdAttrName
(
String
elemtName
)
{
final
String
idAttrName
=
(
String
)
_idAttributes
.
get
(
elemtName
)
;
return
(
(
idAttrName
==
null
)
?
""
:
idAttrName
)
;
}
public
final
void
buildIdIndex
(
DOMImpl
dom
,
int
mask
,
AbstractTranslet
translet
)
{
int
node
,
attr
,
type
,
typeCache
;
translet
.
setIndexSize
(
dom
.
getSize
(
)
)
;
if
(
(
_idAttributes
==
null
)
||
(
_idAttributes
.
isEmpty
(
)
)
)
return
;
Enumeration
elements
=
_idAttributes
.
keys
(
)
;
if
(
elements
.
nextElement
(
)
instanceof
String
)
{
Hashtable
newAttributes
=
new
Hashtable
(
)
;
elements
=
_idAttributes
.
keys
(
)
;
while
(
elements
.
hasMoreElements
(
)
)
{
String
element
=
(
String
)
elements
.
nextElement
(
)
;
String
attribute
=
(
String
)
_idAttributes
.
get
(
element
)
;
int
elemType
=
dom
.
getGeneralizedType
(
element
)
;
int
attrType
=
dom
.
getGeneralizedType
(
attribute
)
;
newAttributes
.
put
(
new
Integer
(
elemType
)
,
new
Integer
(
attrType
)
)
;
}
_idAttributes
=
newAttributes
;
}
final
NodeIterator
iter
=
dom
.
getAxisIterator
(
Axis
.
DESCENDANT
)
;
iter
.
setStartNode
(
DOM
.
ROOTNODE
)
;
Integer
E
=
new
Integer
(
typeCache
=
0
)
;
Integer
A
=
null
;
while
(
(
node
=
iter
.
next
(
)
)
!=
NodeIterator
.
END
)
{
type
=
dom
.
getType
(
node
)
;
if
(
type
!=
typeCache
)
{
E
=
new
Integer
(
typeCache
=
type
)
;
A
=
(
Integer
)
_idAttributes
.
get
(
E
)
;
}
if
(
A
!=
null
)
{
if
(
(
attr
=
dom
.
getAttributeNode
(
A
.
intValue
(
)
,
node
)
)
!=
0
)
{
final
String
value
=
dom
.
getNodeValue
(
attr
)
;
translet
.
buildKeyIndex
(
ID_INDEX_NAME
,
mask
|
node
,
value
)
;
}
}
}
}
}
