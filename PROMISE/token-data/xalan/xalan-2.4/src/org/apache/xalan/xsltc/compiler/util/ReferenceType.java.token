package
org
.
apache
.
xalan
.
xsltc
.
compiler
.
util
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
util
.
Type
;
import
org
.
apache
.
bcel
.
generic
.
*
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
Parser
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
FlowList
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
Constants
;
public
final
class
ReferenceType
extends
Type
{
protected
ReferenceType
(
)
{
}
public
String
toString
(
)
{
return
"reference"
;
}
public
boolean
identicalTo
(
Type
other
)
{
return
this
==
other
;
}
public
String
toSignature
(
)
{
return
"Ljava/lang/Object;"
;
}
public
org
.
apache
.
bcel
.
generic
.
Type
toJCType
(
)
{
return
org
.
apache
.
bcel
.
generic
.
Type
.
OBJECT
;
}
public
void
translateTo
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
Type
type
)
{
if
(
type
==
Type
.
String
)
{
translateTo
(
classGen
,
methodGen
,
(
StringType
)
type
)
;
}
else
if
(
type
==
Type
.
Real
)
{
translateTo
(
classGen
,
methodGen
,
(
RealType
)
type
)
;
}
else
if
(
type
==
Type
.
Boolean
)
{
translateTo
(
classGen
,
methodGen
,
(
BooleanType
)
type
)
;
}
else
if
(
type
==
Type
.
NodeSet
)
{
translateTo
(
classGen
,
methodGen
,
(
NodeSetType
)
type
)
;
}
else
if
(
type
==
Type
.
Node
)
{
translateTo
(
classGen
,
methodGen
,
(
NodeType
)
type
)
;
}
else
if
(
type
==
Type
.
ResultTree
)
{
translateTo
(
classGen
,
methodGen
,
(
ResultTreeType
)
type
)
;
}
else
if
(
type
==
Type
.
Object
)
{
translateTo
(
classGen
,
methodGen
,
(
ObjectType
)
type
)
;
}
else
{
ErrorMsg
err
=
new
ErrorMsg
(
ErrorMsg
.
INTERNAL_ERR
,
type
.
toString
(
)
)
;
classGen
.
getParser
(
)
.
reportError
(
Constants
.
FATAL
,
err
)
;
}
}
public
void
translateTo
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
StringType
type
)
{
final
int
current
=
methodGen
.
getLocalIndex
(
"current"
)
;
ConstantPoolGen
cpg
=
classGen
.
getConstantPool
(
)
;
InstructionList
il
=
methodGen
.
getInstructionList
(
)
;
il
.
append
(
new
ILOAD
(
current
)
)
;
il
.
append
(
methodGen
.
loadDOM
(
)
)
;
final
int
stringF
=
cpg
.
addMethodref
(
BASIS_LIBRARY_CLASS
,
"stringF"
,
"("
+
OBJECT_SIG
+
NODE_SIG
+
DOM_INTF_SIG
+
")"
+
STRING_SIG
)
;
il
.
append
(
new
INVOKESTATIC
(
stringF
)
)
;
}
public
void
translateTo
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
RealType
type
)
{
final
ConstantPoolGen
cpg
=
classGen
.
getConstantPool
(
)
;
final
InstructionList
il
=
methodGen
.
getInstructionList
(
)
;
il
.
append
(
methodGen
.
loadDOM
(
)
)
;
int
index
=
cpg
.
addMethodref
(
BASIS_LIBRARY_CLASS
,
"numberF"
,
"("
+
OBJECT_SIG
+
DOM_INTF_SIG
+
")D"
)
;
il
.
append
(
new
INVOKESTATIC
(
index
)
)
;
}
public
void
translateTo
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
BooleanType
type
)
{
final
ConstantPoolGen
cpg
=
classGen
.
getConstantPool
(
)
;
final
InstructionList
il
=
methodGen
.
getInstructionList
(
)
;
int
index
=
cpg
.
addMethodref
(
BASIS_LIBRARY_CLASS
,
"booleanF"
,
"("
+
OBJECT_SIG
+
")Z"
)
;
il
.
append
(
new
INVOKESTATIC
(
index
)
)
;
}
public
void
translateTo
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
NodeSetType
type
)
{
final
ConstantPoolGen
cpg
=
classGen
.
getConstantPool
(
)
;
final
InstructionList
il
=
methodGen
.
getInstructionList
(
)
;
int
index
=
cpg
.
addMethodref
(
BASIS_LIBRARY_CLASS
,
"referenceToNodeSet"
,
"("
+
OBJECT_SIG
+
")"
+
NODE_ITERATOR_SIG
)
;
il
.
append
(
new
INVOKESTATIC
(
index
)
)
;
index
=
cpg
.
addInterfaceMethodref
(
NODE_ITERATOR
,
RESET
,
RESET_SIG
)
;
il
.
append
(
new
INVOKEINTERFACE
(
index
,
1
)
)
;
}
public
void
translateTo
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
NodeType
type
)
{
translateTo
(
classGen
,
methodGen
,
Type
.
NodeSet
)
;
Type
.
NodeSet
.
translateTo
(
classGen
,
methodGen
,
type
)
;
}
public
void
translateTo
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
ResultTreeType
type
)
{
final
ConstantPoolGen
cpg
=
classGen
.
getConstantPool
(
)
;
final
InstructionList
il
=
methodGen
.
getInstructionList
(
)
;
int
index
=
cpg
.
addMethodref
(
BASIS_LIBRARY_CLASS
,
"referenceToResultTree"
,
"("
+
OBJECT_SIG
+
")"
+
DOM_INTF_SIG
)
;
il
.
append
(
new
INVOKESTATIC
(
index
)
)
;
}
public
void
translateTo
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
ObjectType
type
)
{
methodGen
.
getInstructionList
(
)
.
append
(
NOP
)
;
}
public
void
translateTo
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
Class
clazz
)
{
if
(
clazz
.
getName
(
)
.
equals
(
"java.lang.Object"
)
)
{
methodGen
.
getInstructionList
(
)
.
append
(
NOP
)
;
}
else
{
ErrorMsg
err
=
new
ErrorMsg
(
ErrorMsg
.
DATA_CONVERSION_ERR
,
toString
(
)
,
clazz
.
getName
(
)
)
;
classGen
.
getParser
(
)
.
reportError
(
Constants
.
FATAL
,
err
)
;
}
}
public
void
translateFrom
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
Class
clazz
)
{
if
(
clazz
.
getName
(
)
.
equals
(
"java.lang.Object"
)
)
{
methodGen
.
getInstructionList
(
)
.
append
(
NOP
)
;
}
else
{
ErrorMsg
err
=
new
ErrorMsg
(
ErrorMsg
.
DATA_CONVERSION_ERR
,
toString
(
)
,
clazz
.
getName
(
)
)
;
classGen
.
getParser
(
)
.
reportError
(
Constants
.
FATAL
,
err
)
;
}
}
public
FlowList
translateToDesynthesized
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
,
BooleanType
type
)
{
InstructionList
il
=
methodGen
.
getInstructionList
(
)
;
translateTo
(
classGen
,
methodGen
,
type
)
;
return
new
FlowList
(
il
.
append
(
new
IFEQ
(
null
)
)
)
;
}
public
void
translateBox
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
)
{
}
public
void
translateUnBox
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
)
{
}
public
Instruction
LOAD
(
int
slot
)
{
return
new
ALOAD
(
slot
)
;
}
public
Instruction
STORE
(
int
slot
)
{
return
new
ASTORE
(
slot
)
;
}
}
