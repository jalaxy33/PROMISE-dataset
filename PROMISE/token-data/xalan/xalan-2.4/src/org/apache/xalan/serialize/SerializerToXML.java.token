package
org
.
apache
.
xalan
.
serialize
;
import
java
.
io
.
Writer
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Stack
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Properties
;
import
java
.
util
.
BitSet
;
import
org
.
xml
.
sax
.
*
;
import
org
.
xml
.
sax
.
ext
.
LexicalHandler
;
import
org
.
xml
.
sax
.
ext
.
DeclHandler
;
import
org
.
w3c
.
dom
.
Node
;
import
org
.
apache
.
xalan
.
serialize
.
Serializer
;
import
org
.
apache
.
xalan
.
serialize
.
DOMSerializer
;
import
org
.
apache
.
xml
.
utils
.
QName
;
import
org
.
apache
.
xalan
.
templates
.
OutputProperties
;
import
org
.
apache
.
xml
.
utils
.
BoolStack
;
import
org
.
apache
.
xml
.
utils
.
TreeWalker
;
import
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
;
import
org
.
apache
.
xml
.
utils
.
SystemIDResolver
;
import
org
.
apache
.
xalan
.
res
.
XSLTErrorResources
;
import
org
.
apache
.
xalan
.
res
.
XSLMessages
;
import
org
.
apache
.
xpath
.
res
.
XPATHErrorResources
;
import
javax
.
xml
.
transform
.
Result
;
import
javax
.
xml
.
transform
.
OutputKeys
;
public
class
SerializerToXML
implements
ContentHandler
,
LexicalHandler
,
DeclHandler
,
Serializer
,
DOMSerializer
{
protected
Writer
m_writer
=
null
;
boolean
m_shouldFlush
=
true
;
protected
String
m_encoding
=
null
;
static
boolean
javaEncodingIsISO
=
false
;
public
boolean
m_shouldNotWriteXMLHeader
=
false
;
public
String
m_version
=
null
;
protected
BoolStack
m_elemStack
=
new
BoolStack
(
)
;
protected
BoolStack
m_disableOutputEscapingStates
=
new
BoolStack
(
)
;
protected
BoolStack
m_cdataSectionStates
=
new
BoolStack
(
)
;
protected
Vector
m_cdataSectionNames
=
null
;
protected
boolean
m_inCData
=
false
;
protected
boolean
isEscapingDisabled
(
)
{
return
m_disableOutputEscapingStates
.
peekOrFalse
(
)
;
}
protected
boolean
isCDataSection
(
)
{
return
m_inCData
||
m_cdataSectionStates
.
peekOrFalse
(
)
;
}
protected
final
char
[
]
m_lineSep
=
System
.
getProperty
(
"line.separator"
)
.
toCharArray
(
)
;
protected
final
int
m_lineSepLen
=
m_lineSep
.
length
;
protected
final
void
outputLineSep
(
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
protected
boolean
m_ispreserve
=
false
;
protected
BoolStack
m_preserves
=
new
BoolStack
(
)
;
protected
boolean
m_isprevtext
=
false
;
protected
boolean
m_doIndent
=
false
;
protected
int
m_currentIndent
=
0
;
public
int
m_indentAmount
=
0
;
protected
int
level
=
0
;
boolean
m_startNewLine
;
boolean
m_needToOutputDocTypeDecl
=
true
;
String
m_doctypeSystem
;
String
m_doctypePublic
;
boolean
m_standalone
=
false
;
boolean
m_standaloneWasSpecified
=
false
;
String
m_mediatype
;
protected
boolean
m_inEntityRef
=
false
;
private
boolean
m_inDoctype
=
false
;
protected
static
CharInfo
m_xmlcharInfo
=
new
CharInfo
(
CharInfo
.
XML_ENTITIES_RESOURCE
)
;
protected
CharInfo
m_charInfo
;
private
static
Hashtable
m_charInfos
=
null
;
boolean
m_isUTF8
=
false
;
protected
int
m_maxCharacter
=
Encodings
.
getLastPrintable
(
)
;
public
boolean
m_spaceBeforeClose
=
false
;
protected
Properties
m_format
;
private
static
final
boolean
DEBUG
=
false
;
private
boolean
m_inExternalDTD
=
false
;
public
SerializerToXML
(
)
{
m_charInfo
=
m_xmlcharInfo
;
}
public
void
CopyFrom
(
SerializerToXML
xmlListener
)
{
m_writer
=
xmlListener
.
m_writer
;
m_encoding
=
xmlListener
.
m_encoding
;
javaEncodingIsISO
=
xmlListener
.
javaEncodingIsISO
;
m_shouldNotWriteXMLHeader
=
xmlListener
.
m_shouldNotWriteXMLHeader
;
m_elemStack
=
xmlListener
.
m_elemStack
;
m_ispreserve
=
xmlListener
.
m_ispreserve
;
m_preserves
=
xmlListener
.
m_preserves
;
m_isprevtext
=
xmlListener
.
m_isprevtext
;
m_doIndent
=
xmlListener
.
m_doIndent
;
m_currentIndent
=
xmlListener
.
m_currentIndent
;
m_indentAmount
=
xmlListener
.
m_indentAmount
;
level
=
xmlListener
.
level
;
m_startNewLine
=
xmlListener
.
m_startNewLine
;
m_needToOutputDocTypeDecl
=
xmlListener
.
m_needToOutputDocTypeDecl
;
m_doctypeSystem
=
xmlListener
.
m_doctypeSystem
;
m_doctypePublic
=
xmlListener
.
m_doctypePublic
;
m_standalone
=
xmlListener
.
m_standalone
;
m_mediatype
=
xmlListener
.
m_mediatype
;
m_maxCharacter
=
xmlListener
.
m_maxCharacter
;
m_spaceBeforeClose
=
xmlListener
.
m_spaceBeforeClose
;
m_inCData
=
xmlListener
.
m_inCData
;
m_pos
=
0
;
}
public
synchronized
void
init
(
Writer
writer
,
Properties
format
)
{
init
(
writer
,
format
,
false
)
;
}
private
synchronized
void
init
(
Writer
writer
,
Properties
format
,
boolean
shouldFlush
)
{
m_shouldFlush
=
shouldFlush
;
m_writer
=
writer
;
m_format
=
format
;
m_cdataSectionNames
=
OutputProperties
.
getQNameProperties
(
OutputKeys
.
CDATA_SECTION_ELEMENTS
,
format
)
;
m_indentAmount
=
OutputProperties
.
getIntProperty
(
OutputProperties
.
S_KEY_INDENT_AMOUNT
,
format
)
;
m_doIndent
=
OutputProperties
.
getBooleanProperty
(
OutputKeys
.
INDENT
,
format
)
;
m_shouldNotWriteXMLHeader
=
OutputProperties
.
getBooleanProperty
(
OutputKeys
.
OMIT_XML_DECLARATION
,
format
)
;
m_doctypeSystem
=
format
.
getProperty
(
OutputKeys
.
DOCTYPE_SYSTEM
)
;
m_doctypePublic
=
format
.
getProperty
(
OutputKeys
.
DOCTYPE_PUBLIC
)
;
m_standaloneWasSpecified
=
(
null
!=
format
.
get
(
OutputKeys
.
STANDALONE
)
)
;
m_standalone
=
OutputProperties
.
getBooleanProperty
(
OutputKeys
.
STANDALONE
,
format
)
;
m_mediatype
=
format
.
getProperty
(
OutputKeys
.
MEDIA_TYPE
)
;
if
(
null
!=
m_doctypePublic
)
{
if
(
m_doctypePublic
.
startsWith
(
"-//W3C//DTD XHTML"
)
)
m_spaceBeforeClose
=
true
;
}
if
(
null
==
m_encoding
)
m_encoding
=
Encodings
.
getMimeEncoding
(
format
.
getProperty
(
OutputKeys
.
ENCODING
)
)
;
m_isUTF8
=
m_encoding
.
equals
(
Encodings
.
DEFAULT_MIME_ENCODING
)
;
m_maxCharacter
=
Encodings
.
getLastPrintable
(
m_encoding
)
;
String
entitiesFileName
=
(
String
)
format
.
get
(
OutputProperties
.
S_KEY_ENTITIES
)
;
if
(
null
!=
entitiesFileName
)
{
try
{
m_charInfo
=
null
;
if
(
null
==
m_charInfos
)
{
synchronized
(
m_xmlcharInfo
)
{
if
(
null
==
m_charInfos
)
m_charInfos
=
new
Hashtable
(
)
;
}
}
else
{
m_charInfo
=
(
CharInfo
)
m_charInfos
.
get
(
entitiesFileName
)
;
}
if
(
null
==
m_charInfo
)
{
try
{
m_charInfo
=
new
CharInfo
(
entitiesFileName
)
;
}
catch
(
Exception
e
)
{
m_charInfo
=
null
;
}
}
if
(
null
==
m_charInfo
)
{
String
absoluteEntitiesFileName
;
if
(
entitiesFileName
.
indexOf
(
':'
)
<
0
)
{
absoluteEntitiesFileName
=
SystemIDResolver
.
getAbsoluteURIFromRelative
(
entitiesFileName
)
;
}
else
{
absoluteEntitiesFileName
=
SystemIDResolver
.
getAbsoluteURI
(
entitiesFileName
,
null
)
;
}
m_charInfo
=
new
CharInfo
(
absoluteEntitiesFileName
)
;
m_charInfos
.
put
(
entitiesFileName
,
m_charInfo
)
;
}
}
catch
(
javax
.
xml
.
transform
.
TransformerException
te
)
{
throw
new
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
(
te
)
;
}
}
}
public
synchronized
void
init
(
OutputStream
output
,
Properties
format
)
throws
UnsupportedEncodingException
{
if
(
null
==
format
)
{
OutputProperties
op
=
new
OutputProperties
(
Method
.
XML
)
;
format
=
op
.
getProperties
(
)
;
}
m_encoding
=
Encodings
.
getMimeEncoding
(
format
.
getProperty
(
OutputKeys
.
ENCODING
)
)
;
if
(
m_encoding
.
equalsIgnoreCase
(
"UTF-8"
)
)
{
m_isUTF8
=
true
;
if
(
output
instanceof
java
.
io
.
BufferedOutputStream
)
{
init
(
new
WriterToUTF8
(
output
)
,
format
,
true
)
;
}
else
if
(
output
instanceof
java
.
io
.
FileOutputStream
)
{
init
(
new
WriterToUTF8Buffered
(
output
)
,
format
,
true
)
;
}
else
{
init
(
new
WriterToUTF8
(
output
)
,
format
,
true
)
;
}
}
else
if
(
m_encoding
.
equals
(
"WINDOWS-1250"
)
||
m_encoding
.
equals
(
"US-ASCII"
)
||
m_encoding
.
equals
(
"ASCII"
)
)
{
init
(
new
WriterToASCI
(
output
)
,
format
,
true
)
;
}
else
{
Writer
osw
;
try
{
osw
=
Encodings
.
getWriter
(
output
,
m_encoding
)
;
}
catch
(
UnsupportedEncodingException
uee
)
{
System
.
out
.
println
(
"Warning: encoding \""
+
m_encoding
+
"\" not supported"
+
", using "
+
Encodings
.
DEFAULT_MIME_ENCODING
)
;
m_encoding
=
Encodings
.
DEFAULT_MIME_ENCODING
;
osw
=
Encodings
.
getWriter
(
output
,
m_encoding
)
;
}
m_maxCharacter
=
Encodings
.
getLastPrintable
(
m_encoding
)
;
init
(
osw
,
format
,
true
)
;
}
}
public
void
setDocumentLocator
(
Locator
locator
)
{
}
void
outputDocTypeDecl
(
String
name
,
boolean
closeDecl
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
final
Writer
writer
=
m_writer
;
writer
.
write
(
"<!DOCTYPE "
)
;
writer
.
write
(
name
)
;
if
(
null
!=
m_doctypePublic
)
{
writer
.
write
(
" PUBLIC \""
)
;
writer
.
write
(
m_doctypePublic
)
;
writer
.
write
(
'\"'
)
;
}
if
(
null
!=
m_doctypeSystem
)
{
if
(
null
==
m_doctypePublic
)
writer
.
write
(
" SYSTEM \""
)
;
else
writer
.
write
(
" \""
)
;
writer
.
write
(
m_doctypeSystem
)
;
if
(
closeDecl
)
{
writer
.
write
(
"\">"
)
;
writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
;
}
else
writer
.
write
(
'\"'
)
;
}
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
void
outputEntityDecl
(
String
name
,
String
value
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
final
Writer
writer
=
m_writer
;
writer
.
write
(
"<!ENTITY "
)
;
writer
.
write
(
name
)
;
writer
.
write
(
" \""
)
;
writer
.
write
(
value
)
;
writer
.
write
(
"\">"
)
;
writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
public
void
startDocument
(
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_inEntityRef
)
return
;
m_needToOutputDocTypeDecl
=
true
;
m_startNewLine
=
false
;
if
(
m_shouldNotWriteXMLHeader
==
false
)
{
String
encoding
=
Encodings
.
getMimeEncoding
(
m_encoding
)
;
String
version
=
(
null
==
m_version
)
?
"1.0"
:
m_version
;
String
standalone
;
if
(
m_standaloneWasSpecified
)
{
standalone
=
" standalone=\""
+
(
m_standalone
?
"yes"
:
"no"
)
+
"\""
;
}
else
{
standalone
=
""
;
}
try
{
final
Writer
writer
=
m_writer
;
writer
.
write
(
"<?xml version=\""
)
;
writer
.
write
(
version
)
;
writer
.
write
(
"\" encoding=\""
)
;
writer
.
write
(
encoding
)
;
writer
.
write
(
'\"'
)
;
writer
.
write
(
standalone
)
;
writer
.
write
(
"?>"
)
;
writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
}
public
void
endDocument
(
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_doIndent
&&
!
m_isprevtext
)
{
outputLineSep
(
)
;
}
flushWriter
(
)
;
}
public
void
startDTD
(
String
name
,
String
publicId
,
String
systemId
)
throws
org
.
xml
.
sax
.
SAXException
{
m_doctypeSystem
=
systemId
;
m_doctypePublic
=
publicId
;
if
(
(
true
==
m_needToOutputDocTypeDecl
)
)
{
outputDocTypeDecl
(
name
,
false
)
;
}
m_needToOutputDocTypeDecl
=
false
;
m_inDoctype
=
true
;
}
public
void
endDTD
(
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
if
(
!
m_inDoctype
)
m_writer
.
write
(
"]>"
)
;
else
{
m_writer
.
write
(
'>'
)
;
}
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
public
void
startPrefixMapping
(
String
prefix
,
String
uri
)
throws
org
.
xml
.
sax
.
SAXException
{
}
public
void
endPrefixMapping
(
String
prefix
)
throws
org
.
xml
.
sax
.
SAXException
{
}
protected
static
final
boolean
subPartMatch
(
String
p
,
String
t
)
{
return
(
p
==
t
)
||
(
(
null
!=
p
)
&&
(
p
.
equals
(
t
)
)
)
;
}
protected
void
pushState
(
String
namespaceURI
,
String
localName
,
Vector
qnames
,
BoolStack
state
)
{
boolean
b
;
if
(
null
!=
qnames
)
{
b
=
false
;
if
(
(
null
!=
namespaceURI
)
&&
namespaceURI
.
length
(
)
==
0
)
namespaceURI
=
null
;
int
nElems
=
qnames
.
size
(
)
;
for
(
int
i
=
0
;
i
<
nElems
;
i
++
)
{
QName
q
=
(
QName
)
qnames
.
elementAt
(
i
)
;
if
(
q
.
getLocalName
(
)
.
equals
(
localName
)
&&
subPartMatch
(
namespaceURI
,
q
.
getNamespaceURI
(
)
)
)
{
b
=
true
;
break
;
}
}
}
else
{
b
=
state
.
peekOrFalse
(
)
;
}
state
.
push
(
b
)
;
}
public
void
startElement
(
String
namespaceURI
,
String
localName
,
String
name
,
Attributes
atts
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
DEBUG
)
{
System
.
out
.
println
(
"SerializerToXML - startElement: "
+
namespaceURI
+
", "
+
localName
)
;
int
n
=
atts
.
getLength
(
)
;
for
(
int
i
=
0
;
i
<
n
;
i
++
)
{
System
.
out
.
println
(
"atts["
+
i
+
"]: "
+
atts
.
getQName
(
i
)
+
" = "
+
atts
.
getValue
(
i
)
)
;
}
if
(
null
==
namespaceURI
)
{
(
new
RuntimeException
(
localName
+
" has a null namespace!"
)
)
.
printStackTrace
(
)
;
}
}
if
(
m_inEntityRef
)
return
;
if
(
(
true
==
m_needToOutputDocTypeDecl
)
&&
(
null
!=
m_doctypeSystem
)
)
{
outputDocTypeDecl
(
name
,
true
)
;
}
m_needToOutputDocTypeDecl
=
false
;
writeParentTagEnd
(
)
;
pushState
(
namespaceURI
,
localName
,
m_cdataSectionNames
,
m_cdataSectionStates
)
;
m_ispreserve
=
false
;
if
(
shouldIndent
(
)
&&
m_startNewLine
)
{
indent
(
m_currentIndent
)
;
}
m_startNewLine
=
true
;
try
{
m_writer
.
write
(
'<'
)
;
m_writer
.
write
(
name
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
int
nAttrs
=
atts
.
getLength
(
)
;
for
(
int
i
=
0
;
i
<
nAttrs
;
i
++
)
{
processAttribute
(
atts
.
getQName
(
i
)
,
atts
.
getValue
(
i
)
)
;
}
openElementForChildren
(
)
;
m_currentIndent
+=
m_indentAmount
;
m_isprevtext
=
false
;
}
protected
void
writeParentTagEnd
(
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
!
m_elemStack
.
peekOrTrue
(
)
)
{
try
{
m_writer
.
write
(
'>'
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
m_isprevtext
=
false
;
m_elemStack
.
setTop
(
true
)
;
m_preserves
.
push
(
m_ispreserve
)
;
}
}
protected
void
openElementForChildren
(
)
{
m_elemStack
.
push
(
false
)
;
}
protected
boolean
childNodesWereAdded
(
)
{
return
m_elemStack
.
isEmpty
(
)
?
false
:
m_elemStack
.
pop
(
)
;
}
public
void
endElement
(
String
namespaceURI
,
String
localName
,
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_inEntityRef
)
return
;
m_currentIndent
-=
m_indentAmount
;
boolean
hasChildNodes
=
childNodesWereAdded
(
)
;
try
{
final
Writer
writer
=
m_writer
;
if
(
hasChildNodes
)
{
if
(
shouldIndent
(
)
)
indent
(
m_currentIndent
)
;
writer
.
write
(
'<'
)
;
writer
.
write
(
'/'
)
;
writer
.
write
(
name
)
;
writer
.
write
(
'>'
)
;
}
else
{
if
(
m_spaceBeforeClose
)
writer
.
write
(
" />"
)
;
else
writer
.
write
(
"/>"
)
;
}
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
if
(
hasChildNodes
)
{
m_ispreserve
=
m_preserves
.
isEmpty
(
)
?
false
:
m_preserves
.
pop
(
)
;
}
m_isprevtext
=
false
;
m_cdataSectionStates
.
pop
(
)
;
}
protected
void
processAttribute
(
String
name
,
String
value
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
final
Writer
writer
=
m_writer
;
writer
.
write
(
' '
)
;
writer
.
write
(
name
)
;
writer
.
write
(
"=\""
)
;
writeAttrString
(
value
,
m_encoding
)
;
writer
.
write
(
'\"'
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
public
void
startNonEscaping
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_disableOutputEscapingStates
.
push
(
true
)
;
}
public
void
endNonEscaping
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_disableOutputEscapingStates
.
pop
(
)
;
}
public
void
startPreserving
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_preserves
.
push
(
true
)
;
m_ispreserve
=
true
;
}
public
void
endPreserving
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_ispreserve
=
m_preserves
.
isEmpty
(
)
?
false
:
m_preserves
.
pop
(
)
;
}
public
void
processingInstruction
(
String
target
,
String
data
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_inEntityRef
)
return
;
if
(
target
.
equals
(
Result
.
PI_DISABLE_OUTPUT_ESCAPING
)
)
{
startNonEscaping
(
)
;
}
else
if
(
target
.
equals
(
Result
.
PI_ENABLE_OUTPUT_ESCAPING
)
)
{
endNonEscaping
(
)
;
}
else
{
try
{
final
Writer
writer
=
m_writer
;
writeParentTagEnd
(
)
;
if
(
shouldIndent
(
)
)
indent
(
m_currentIndent
)
;
writer
.
write
(
'<'
)
;
writer
.
write
(
'?'
)
;
writer
.
write
(
target
)
;
if
(
data
.
length
(
)
>
0
&&
!
Character
.
isSpaceChar
(
data
.
charAt
(
0
)
)
)
writer
.
write
(
' '
)
;
int
indexOfQLT
=
data
.
indexOf
(
"?>"
)
;
if
(
indexOfQLT
>=
0
)
{
if
(
indexOfQLT
>
0
)
{
writer
.
write
(
data
.
substring
(
0
,
indexOfQLT
)
)
;
}
writer
.
write
(
"? >"
)
;
if
(
(
indexOfQLT
+
2
)
<
data
.
length
(
)
)
{
writer
.
write
(
data
.
substring
(
indexOfQLT
+
2
)
)
;
}
}
else
{
writer
.
write
(
data
)
;
}
writer
.
write
(
'?'
)
;
writer
.
write
(
'>'
)
;
if
(
m_elemStack
.
isEmpty
(
)
)
writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
m_startNewLine
=
true
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
}
public
void
comment
(
char
ch
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_inEntityRef
)
return
;
writeParentTagEnd
(
)
;
if
(
shouldIndent
(
)
)
indent
(
m_currentIndent
)
;
try
{
final
Writer
writer
=
m_writer
;
writer
.
write
(
"<!--"
)
;
writer
.
write
(
ch
,
start
,
length
)
;
writer
.
write
(
"-->"
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
m_startNewLine
=
true
;
}
public
void
startCDATA
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_inCData
=
true
;
}
public
void
endCDATA
(
)
throws
org
.
xml
.
sax
.
SAXException
{
m_inCData
=
false
;
}
public
void
cdata
(
char
ch
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
writeParentTagEnd
(
)
;
m_ispreserve
=
true
;
if
(
shouldIndent
(
)
)
indent
(
m_currentIndent
)
;
boolean
writeCDataBrackets
=
(
(
(
length
>=
1
)
&&
canConvert
(
ch
[
start
]
)
)
)
;
if
(
writeCDataBrackets
)
{
m_writer
.
write
(
"<![CDATA["
)
;
}
if
(
isEscapingDisabled
(
)
)
{
charactersRaw
(
ch
,
start
,
length
)
;
}
else
writeNormalizedChars
(
ch
,
start
,
length
,
true
)
;
if
(
writeCDataBrackets
)
{
m_writer
.
write
(
"]]>"
)
;
}
}
catch
(
IOException
ioe
)
{
throw
new
org
.
xml
.
sax
.
SAXException
(
XSLMessages
.
createXPATHMessage
(
XPATHErrorResources
.
ER_OIERROR
,
null
)
,
ioe
)
;
}
}
protected
int
m_pos
=
0
;
protected
final
void
accum
(
char
b
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
m_writer
.
write
(
b
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
protected
final
void
accum
(
char
chars
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
m_writer
.
write
(
chars
,
start
,
length
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
protected
final
void
accum
(
String
s
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
m_writer
.
write
(
s
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
public
final
void
flushWriter
(
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
null
!=
m_writer
)
{
try
{
if
(
m_writer
instanceof
WriterToUTF8Buffered
)
{
if
(
m_shouldFlush
)
(
(
WriterToUTF8Buffered
)
m_writer
)
.
flush
(
)
;
else
(
(
WriterToUTF8Buffered
)
m_writer
)
.
flushBuffer
(
)
;
}
if
(
m_writer
instanceof
WriterToUTF8
)
{
if
(
m_shouldFlush
)
m_writer
.
flush
(
)
;
}
else
if
(
m_writer
instanceof
WriterToASCI
)
{
if
(
m_shouldFlush
)
m_writer
.
flush
(
)
;
}
else
{
m_writer
.
flush
(
)
;
}
}
catch
(
IOException
ioe
)
{
throw
new
org
.
xml
.
sax
.
SAXException
(
ioe
)
;
}
}
}
public
void
characters
(
char
chars
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
0
==
length
)
return
;
if
(
m_inCData
||
m_cdataSectionStates
.
peekOrFalse
(
)
)
{
cdata
(
chars
,
start
,
length
)
;
return
;
}
try
{
if
(
m_disableOutputEscapingStates
.
peekOrFalse
(
)
)
{
charactersRaw
(
chars
,
start
,
length
)
;
return
;
}
final
Writer
writer
=
m_writer
;
if
(
!
m_elemStack
.
peekOrTrue
(
)
)
{
writer
.
write
(
'>'
)
;
m_isprevtext
=
false
;
m_elemStack
.
setTop
(
true
)
;
m_preserves
.
push
(
m_ispreserve
)
;
}
int
startClean
=
start
;
int
lengthClean
=
0
;
int
end
=
start
+
length
;
boolean
checkWhite
=
true
;
final
int
maxCharacter
=
m_maxCharacter
;
final
BitSet
specialsMap
=
m_charInfo
.
m_specialsMap
;
for
(
int
i
=
start
;
i
<
end
;
i
++
)
{
char
ch
=
chars
[
i
]
;
if
(
checkWhite
&&
(
(
ch
>
0x20
)
||
!
(
(
ch
==
0x20
)
||
(
ch
==
0x09
)
||
(
ch
==
0xD
)
||
(
ch
==
0xA
)
)
)
)
{
m_ispreserve
=
true
;
checkWhite
=
false
;
}
if
(
(
canConvert
(
ch
)
&&
(
!
specialsMap
.
get
(
ch
)
)
)
||
(
'"'
==
ch
)
)
{
lengthClean
++
;
}
else
{
if
(
lengthClean
>
0
)
{
writer
.
write
(
chars
,
startClean
,
lengthClean
)
;
lengthClean
=
0
;
}
if
(
CharInfo
.
S_LINEFEED
==
ch
)
{
writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
startClean
=
i
+
1
;
}
else
{
startClean
=
accumDefaultEscape
(
ch
,
i
,
chars
,
end
,
false
)
;
i
=
startClean
-
1
;
}
}
}
if
(
lengthClean
>
0
)
{
writer
.
write
(
chars
,
startClean
,
lengthClean
)
;
}
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
m_isprevtext
=
true
;
}
public
void
charactersRaw
(
char
ch
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
if
(
m_inEntityRef
)
return
;
writeParentTagEnd
(
)
;
m_ispreserve
=
true
;
m_writer
.
write
(
ch
,
start
,
length
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
static
final
boolean
isUTF16Surrogate
(
char
c
)
{
return
(
c
&
0xFC00
)
==
0xD800
;
}
int
getURF16SurrogateValue
(
char
c
,
char
ch
[
]
,
int
i
,
int
end
)
throws
org
.
xml
.
sax
.
SAXException
{
int
next
;
if
(
i
+
1
>=
end
)
{
throw
new
org
.
xml
.
sax
.
SAXException
(
XSLMessages
.
createXPATHMessage
(
XPATHErrorResources
.
ER_INVALID_UTF16_SURROGATE
,
new
Object
[
]
{
Integer
.
toHexString
(
(
int
)
c
)
}
)
)
;
}
else
{
next
=
ch
[
++
i
]
;
if
(
!
(
0xdc00
<=
next
&&
next
<
0xe000
)
)
throw
new
org
.
xml
.
sax
.
SAXException
(
XSLMessages
.
createXPATHMessage
(
XPATHErrorResources
.
ER_INVALID_UTF16_SURROGATE
,
new
Object
[
]
{
Integer
.
toHexString
(
(
int
)
c
)
+
" "
+
Integer
.
toHexString
(
next
)
}
)
)
;
next
=
(
(
c
-
0xd800
)
<<
10
)
+
next
-
0xdc00
+
0x00010000
;
}
return
next
;
}
protected
int
writeUTF16Surrogate
(
char
c
,
char
ch
[
]
,
int
i
,
int
end
)
throws
IOException
,
org
.
xml
.
sax
.
SAXException
{
int
surrogateValue
=
getURF16SurrogateValue
(
c
,
ch
,
i
,
end
)
;
i
++
;
m_writer
.
write
(
'&'
)
;
m_writer
.
write
(
'#'
)
;
m_writer
.
write
(
Integer
.
toString
(
surrogateValue
)
)
;
m_writer
.
write
(
';'
)
;
return
i
;
}
void
writeNormalizedChars
(
char
ch
[
]
,
int
start
,
int
length
,
boolean
isCData
)
throws
IOException
,
org
.
xml
.
sax
.
SAXException
{
int
end
=
start
+
length
;
for
(
int
i
=
start
;
i
<
end
;
i
++
)
{
char
c
=
ch
[
i
]
;
if
(
CharInfo
.
S_LINEFEED
==
c
)
{
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
else
if
(
isCData
&&
(
!
canConvert
(
c
)
)
)
{
if
(
i
!=
0
)
m_writer
.
write
(
"]]>"
)
;
if
(
isUTF16Surrogate
(
c
)
)
{
i
=
writeUTF16Surrogate
(
c
,
ch
,
i
,
end
)
;
}
else
{
m_writer
.
write
(
"&#"
)
;
String
intStr
=
Integer
.
toString
(
(
int
)
c
)
;
m_writer
.
write
(
intStr
)
;
m_writer
.
write
(
';'
)
;
}
if
(
(
i
!=
0
)
&&
(
i
<
(
end
-
1
)
)
)
m_writer
.
write
(
"<![CDATA["
)
;
}
else
if
(
isCData
&&
(
(
i
<
(
end
-
2
)
)
&&
(
']'
==
c
)
&&
(
']'
==
ch
[
i
+
1
]
)
&&
(
'>'
==
ch
[
i
+
2
]
)
)
)
{
m_writer
.
write
(
"]]]]><![CDATA[>"
)
;
i
+=
2
;
}
else
{
if
(
canConvert
(
c
)
)
{
m_writer
.
write
(
c
)
;
}
else
if
(
isUTF16Surrogate
(
c
)
)
{
i
=
writeUTF16Surrogate
(
c
,
ch
,
i
,
end
)
;
}
else
{
m_writer
.
write
(
"&#"
)
;
String
intStr
=
Integer
.
toString
(
(
int
)
c
)
;
m_writer
.
write
(
intStr
)
;
m_writer
.
write
(
';'
)
;
}
}
}
}
public
void
ignorableWhitespace
(
char
ch
[
]
,
int
start
,
int
length
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
0
==
length
)
return
;
characters
(
ch
,
start
,
length
)
;
}
public
void
skippedEntity
(
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
}
public
void
startEntity
(
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
name
.
equals
(
"[dtd]"
)
)
m_inExternalDTD
=
true
;
m_inEntityRef
=
true
;
}
public
void
endEntity
(
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
name
.
equals
(
"[dtd]"
)
)
m_inExternalDTD
=
false
;
m_inEntityRef
=
false
;
}
public
void
entityReference
(
String
name
)
throws
org
.
xml
.
sax
.
SAXException
{
writeParentTagEnd
(
)
;
if
(
shouldIndent
(
)
)
indent
(
m_currentIndent
)
;
try
{
final
Writer
writer
=
m_writer
;
writer
.
write
(
"&"
)
;
writer
.
write
(
name
)
;
writer
.
write
(
";"
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
public
void
elementDecl
(
String
name
,
String
model
)
throws
SAXException
{
if
(
m_inExternalDTD
)
return
;
try
{
final
Writer
writer
=
m_writer
;
if
(
m_inDoctype
)
{
writer
.
write
(
" ["
)
;
writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
m_inDoctype
=
false
;
}
writer
.
write
(
"<!ELEMENT "
)
;
writer
.
write
(
name
)
;
writer
.
write
(
' '
)
;
writer
.
write
(
model
)
;
writer
.
write
(
'>'
)
;
writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
private
String
m_elemName
=
""
;
public
void
attributeDecl
(
String
eName
,
String
aName
,
String
type
,
String
valueDefault
,
String
value
)
throws
SAXException
{
if
(
m_inExternalDTD
)
return
;
try
{
final
Writer
writer
=
m_writer
;
if
(
m_inDoctype
)
{
writer
.
write
(
" ["
)
;
writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
m_inDoctype
=
false
;
}
writer
.
write
(
"<!ATTLIST "
)
;
writer
.
write
(
eName
)
;
writer
.
write
(
" "
)
;
writer
.
write
(
aName
)
;
writer
.
write
(
" "
)
;
writer
.
write
(
type
)
;
if
(
valueDefault
!=
null
)
{
writer
.
write
(
" "
)
;
writer
.
write
(
valueDefault
)
;
}
writer
.
write
(
">"
)
;
writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
public
void
internalEntityDecl
(
String
name
,
String
value
)
throws
SAXException
{
if
(
m_inExternalDTD
)
return
;
try
{
if
(
m_inDoctype
)
{
m_writer
.
write
(
" ["
)
;
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
m_inDoctype
=
false
;
}
outputEntityDecl
(
name
,
value
)
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
public
void
externalEntityDecl
(
String
name
,
String
publicId
,
String
systemId
)
throws
SAXException
{
}
protected
int
accumDefaultEntity
(
char
ch
,
int
i
,
char
[
]
chars
,
int
len
,
boolean
escLF
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
if
(
!
escLF
&&
CharInfo
.
S_LINEFEED
==
ch
)
{
m_writer
.
write
(
m_lineSep
,
0
,
m_lineSepLen
)
;
}
else
{
if
(
m_charInfo
.
isSpecial
(
ch
)
)
{
String
entityRef
=
m_charInfo
.
getEntityNameForChar
(
ch
)
;
if
(
null
!=
entityRef
)
{
final
Writer
writer
=
m_writer
;
writer
.
write
(
'&'
)
;
writer
.
write
(
entityRef
)
;
writer
.
write
(
';'
)
;
}
else
return
i
;
}
else
return
i
;
}
return
i
+
1
;
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
protected
int
accumDefaultEscape
(
char
ch
,
int
i
,
char
[
]
chars
,
int
len
,
boolean
escLF
)
throws
org
.
xml
.
sax
.
SAXException
{
int
pos
=
accumDefaultEntity
(
ch
,
i
,
chars
,
len
,
escLF
)
;
if
(
i
==
pos
)
{
pos
++
;
try
{
if
(
0xd800
<=
ch
&&
ch
<
0xdc00
)
{
int
next
;
if
(
i
+
1
>=
len
)
{
throw
new
org
.
xml
.
sax
.
SAXException
(
XSLMessages
.
createXPATHMessage
(
XPATHErrorResources
.
ER_INVALID_UTF16_SURROGATE
,
new
Object
[
]
{
Integer
.
toHexString
(
ch
)
}
)
)
;
}
else
{
next
=
chars
[
++
i
]
;
if
(
!
(
0xdc00
<=
next
&&
next
<
0xe000
)
)
throw
new
org
.
xml
.
sax
.
SAXException
(
XSLMessages
.
createXPATHMessage
(
XPATHErrorResources
.
ER_INVALID_UTF16_SURROGATE
,
new
Object
[
]
{
Integer
.
toHexString
(
ch
)
+
" "
+
Integer
.
toHexString
(
next
)
}
)
)
;
next
=
(
(
ch
-
0xd800
)
<<
10
)
+
next
-
0xdc00
+
0x00010000
;
}
m_writer
.
write
(
"&#"
)
;
m_writer
.
write
(
Integer
.
toString
(
next
)
)
;
m_writer
.
write
(
";"
)
;
}
else
{
if
(
!
canConvert
(
ch
)
||
(
m_charInfo
.
isSpecial
(
ch
)
)
)
{
m_writer
.
write
(
"&#"
)
;
m_writer
.
write
(
Integer
.
toString
(
ch
)
)
;
m_writer
.
write
(
";"
)
;
}
else
{
m_writer
.
write
(
ch
)
;
}
}
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
return
pos
;
}
Object
m_charToByteConverter
=
null
;
java
.
lang
.
reflect
.
Method
m_canConvertMeth
;
boolean
m_triedToGetConverter
=
false
;
public
boolean
canConvert
(
char
ch
)
{
if
(
ch
<
127
)
{
if
(
ch
>=
0x20
||
(
0x0A
==
ch
||
0x0D
==
ch
||
0x09
==
ch
)
)
return
true
;
else
return
false
;
}
if
(
null
==
m_charToByteConverter
&&
false
==
m_triedToGetConverter
)
{
m_triedToGetConverter
=
true
;
try
{
m_charToByteConverter
=
Encodings
.
getCharToByteConverter
(
m_encoding
)
;
if
(
null
!=
m_charToByteConverter
)
{
Class
argsTypes
[
]
=
new
Class
[
1
]
;
argsTypes
[
0
]
=
Character
.
TYPE
;
Class
convClass
=
m_charToByteConverter
.
getClass
(
)
;
m_canConvertMeth
=
convClass
.
getMethod
(
"canConvert"
,
argsTypes
)
;
}
}
catch
(
Exception
e
)
{
System
.
err
.
println
(
"Warning: "
+
e
.
getMessage
(
)
)
;
}
}
if
(
null
!=
m_charToByteConverter
)
{
try
{
Object
args
[
]
=
new
Object
[
1
]
;
args
[
0
]
=
new
Character
(
ch
)
;
Boolean
bool
=
(
Boolean
)
m_canConvertMeth
.
invoke
(
m_charToByteConverter
,
args
)
;
return
bool
.
booleanValue
(
)
?
!
Character
.
isISOControl
(
ch
)
:
false
;
}
catch
(
java
.
lang
.
reflect
.
InvocationTargetException
ite
)
{
System
.
err
.
println
(
"Warning: InvocationTargetException in canConvert!"
)
;
}
catch
(
java
.
lang
.
IllegalAccessException
iae
)
{
System
.
err
.
println
(
"Warning: IllegalAccessException in canConvert!"
)
;
}
}
return
(
ch
<=
m_maxCharacter
)
;
}
public
void
writeAttrString
(
String
string
,
String
encoding
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
final
char
[
]
stringChars
=
string
.
toCharArray
(
)
;
final
int
len
=
stringChars
.
length
;
final
Writer
writer
=
m_writer
;
for
(
int
i
=
0
;
i
<
len
;
i
++
)
{
char
ch
=
stringChars
[
i
]
;
if
(
canConvert
(
ch
)
&&
(
!
m_charInfo
.
isSpecial
(
ch
)
)
)
{
writer
.
write
(
ch
)
;
}
else
{
if
(
(
CharInfo
.
S_CARRIAGERETURN
==
ch
)
&&
(
(
i
+
1
)
<
len
)
&&
(
CharInfo
.
S_LINEFEED
==
stringChars
[
i
+
1
]
)
)
{
i
++
;
ch
=
CharInfo
.
S_LINEFEED
;
}
accumDefaultEscape
(
ch
,
i
,
stringChars
,
len
,
true
)
;
}
}
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
protected
boolean
shouldIndent
(
)
{
return
m_doIndent
&&
(
!
m_ispreserve
&&
!
m_isprevtext
)
;
}
public
void
printSpace
(
int
n
)
throws
org
.
xml
.
sax
.
SAXException
{
try
{
for
(
int
i
=
0
;
i
<
n
;
i
++
)
{
m_writer
.
write
(
' '
)
;
}
}
catch
(
IOException
ioe
)
{
throw
new
SAXException
(
ioe
)
;
}
}
public
void
indent
(
int
n
)
throws
org
.
xml
.
sax
.
SAXException
{
if
(
m_startNewLine
)
outputLineSep
(
)
;
if
(
m_doIndent
)
{
printSpace
(
n
)
;
}
}
public
void
setOutputStream
(
OutputStream
output
)
{
try
{
init
(
output
,
m_format
)
;
}
catch
(
UnsupportedEncodingException
uee
)
{
}
}
public
OutputStream
getOutputStream
(
)
{
if
(
m_writer
instanceof
WriterToUTF8Buffered
)
return
(
(
WriterToUTF8Buffered
)
m_writer
)
.
getOutputStream
(
)
;
if
(
m_writer
instanceof
WriterToUTF8
)
return
(
(
WriterToUTF8
)
m_writer
)
.
getOutputStream
(
)
;
else
if
(
m_writer
instanceof
WriterToASCI
)
return
(
(
WriterToASCI
)
m_writer
)
.
getOutputStream
(
)
;
else
return
null
;
}
public
void
setWriter
(
Writer
writer
)
{
m_writer
=
writer
;
}
public
Writer
getWriter
(
)
{
return
m_writer
;
}
public
void
setOutputFormat
(
Properties
format
)
{
boolean
shouldFlush
=
m_shouldFlush
;
init
(
m_writer
,
format
,
false
)
;
m_shouldFlush
=
shouldFlush
;
}
public
Properties
getOutputFormat
(
)
{
return
m_format
;
}
public
ContentHandler
asContentHandler
(
)
throws
IOException
{
return
this
;
}
public
DOMSerializer
asDOMSerializer
(
)
throws
IOException
{
return
this
;
}
public
boolean
reset
(
)
{
return
false
;
}
public
void
serialize
(
Node
node
)
throws
IOException
{
try
{
TreeWalker
walker
=
new
TreeWalker
(
this
,
new
org
.
apache
.
xpath
.
DOM2Helper
(
)
)
;
walker
.
traverse
(
node
)
;
}
catch
(
org
.
xml
.
sax
.
SAXException
se
)
{
throw
new
WrappedRuntimeException
(
se
)
;
}
}
}
