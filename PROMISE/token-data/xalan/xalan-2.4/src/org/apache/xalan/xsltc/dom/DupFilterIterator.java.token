package
org
.
apache
.
xalan
.
xsltc
.
dom
;
import
org
.
apache
.
xalan
.
xsltc
.
DOM
;
import
org
.
apache
.
xalan
.
xsltc
.
NodeIterator
;
import
org
.
apache
.
xalan
.
xsltc
.
TransletException
;
public
final
class
DupFilterIterator
extends
NodeIteratorBase
{
private
final
static
int
INIT_DATA_SIZE
=
16
;
private
final
NodeIterator
_source
;
private
int
[
]
_data
=
null
;
private
int
_last
=
0
;
private
int
_current
=
0
;
public
DupFilterIterator
(
NodeIterator
source
)
{
_source
=
source
;
if
(
source
instanceof
KeyIndex
)
setStartNode
(
DOM
.
ROOTNODE
)
;
}
public
int
next
(
)
{
return
_current
<
_last
?
_data
[
_current
++
]
:
END
;
}
public
NodeIterator
setStartNode
(
int
node
)
{
int
i
,
j
;
if
(
(
_source
instanceof
KeyIndex
)
&&
(
_data
!=
null
)
)
return
this
;
if
(
(
_data
==
null
)
||
(
node
!=
_startNode
)
)
{
_startNode
=
node
;
_last
=
0
;
_source
.
setStartNode
(
node
)
;
_data
=
new
int
[
INIT_DATA_SIZE
]
;
while
(
(
node
=
_source
.
next
(
)
)
!=
END
)
{
if
(
_last
==
_data
.
length
)
{
int
[
]
newArray
=
new
int
[
_data
.
length
*
2
]
;
System
.
arraycopy
(
_data
,
0
,
newArray
,
0
,
_last
)
;
_data
=
newArray
;
}
for
(
i
=
0
;
i
<
_last
;
i
++
)
{
if
(
_data
[
i
]
==
node
)
{
break
;
}
else
if
(
_data
[
i
]
>
node
)
{
for
(
j
=
_last
++
;
j
>
i
;
j
--
)
_data
[
j
]
=
_data
[
j
-
1
]
;
_data
[
i
]
=
node
;
break
;
}
}
if
(
i
==
_last
)
_data
[
_last
++
]
=
node
;
}
}
_current
=
0
;
return
this
;
}
public
int
getPosition
(
)
{
return
(
_current
)
;
}
public
int
getLast
(
)
{
return
_last
;
}
public
void
setMark
(
)
{
_source
.
setMark
(
)
;
_markedNode
=
_current
;
}
public
void
gotoMark
(
)
{
_source
.
gotoMark
(
)
;
_current
=
_markedNode
;
}
public
NodeIterator
reset
(
)
{
_current
=
0
;
return
(
this
)
;
}
}
