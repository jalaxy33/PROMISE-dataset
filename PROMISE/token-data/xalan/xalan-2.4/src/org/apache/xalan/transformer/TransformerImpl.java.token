package
org
.
apache
.
xalan
.
transformer
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
StringWriter
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
NoSuchElementException
;
import
java
.
util
.
Properties
;
import
java
.
util
.
Stack
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Vector
;
import
javax
.
xml
.
parsers
.
DocumentBuilder
;
import
javax
.
xml
.
transform
.
ErrorListener
;
import
javax
.
xml
.
transform
.
OutputKeys
;
import
javax
.
xml
.
transform
.
Result
;
import
javax
.
xml
.
transform
.
Source
;
import
javax
.
xml
.
transform
.
Transformer
;
import
javax
.
xml
.
transform
.
TransformerException
;
import
javax
.
xml
.
transform
.
URIResolver
;
import
javax
.
xml
.
transform
.
dom
.
DOMResult
;
import
javax
.
xml
.
transform
.
sax
.
SAXResult
;
import
javax
.
xml
.
transform
.
stream
.
StreamResult
;
import
org
.
apache
.
xalan
.
processor
.
TransformerFactoryImpl
;
import
org
.
apache
.
xalan
.
res
.
XSLMessages
;
import
org
.
apache
.
xalan
.
res
.
XSLTErrorResources
;
import
org
.
apache
.
xalan
.
serialize
.
Method
;
import
org
.
apache
.
xalan
.
serialize
.
Serializer
;
import
org
.
apache
.
xalan
.
serialize
.
SerializerFactory
;
import
org
.
apache
.
xalan
.
templates
.
AVT
;
import
org
.
apache
.
xalan
.
templates
.
Constants
;
import
org
.
apache
.
xalan
.
templates
.
ElemAttributeSet
;
import
org
.
apache
.
xalan
.
templates
.
ElemForEach
;
import
org
.
apache
.
xalan
.
templates
.
ElemSort
;
import
org
.
apache
.
xalan
.
templates
.
ElemTemplate
;
import
org
.
apache
.
xalan
.
templates
.
ElemTemplateElement
;
import
org
.
apache
.
xalan
.
templates
.
ElemTextLiteral
;
import
org
.
apache
.
xalan
.
templates
.
ElemVariable
;
import
org
.
apache
.
xalan
.
templates
.
OutputProperties
;
import
org
.
apache
.
xalan
.
templates
.
Stylesheet
;
import
org
.
apache
.
xalan
.
templates
.
StylesheetComposed
;
import
org
.
apache
.
xalan
.
templates
.
StylesheetRoot
;
import
org
.
apache
.
xalan
.
templates
.
WhiteSpaceInfo
;
import
org
.
apache
.
xalan
.
templates
.
XUnresolvedVariable
;
import
org
.
apache
.
xalan
.
trace
.
TraceManager
;
import
org
.
apache
.
xml
.
dtm
.
DTM
;
import
org
.
apache
.
xml
.
dtm
.
DTMIterator
;
import
org
.
apache
.
xml
.
dtm
.
DTMManager
;
import
org
.
apache
.
xml
.
dtm
.
DTMWSFilter
;
import
org
.
apache
.
xml
.
utils
.
BoolStack
;
import
org
.
apache
.
xml
.
utils
.
DOMBuilder
;
import
org
.
apache
.
xml
.
utils
.
NodeVector
;
import
org
.
apache
.
xml
.
utils
.
ObjectPool
;
import
org
.
apache
.
xml
.
utils
.
QName
;
import
org
.
apache
.
xml
.
utils
.
SAXSourceLocator
;
import
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
;
import
org
.
apache
.
xpath
.
Arg
;
import
org
.
apache
.
xpath
.
DOMHelper
;
import
org
.
apache
.
xpath
.
VariableStack
;
import
org
.
apache
.
xpath
.
XPathContext
;
import
org
.
apache
.
xpath
.
objects
.
XObject
;
import
org
.
w3c
.
dom
.
Document
;
import
org
.
w3c
.
dom
.
DocumentFragment
;
import
org
.
w3c
.
dom
.
Node
;
import
org
.
w3c
.
dom
.
Text
;
import
org
.
xml
.
sax
.
ContentHandler
;
import
org
.
xml
.
sax
.
SAXException
;
import
org
.
xml
.
sax
.
SAXNotRecognizedException
;
import
org
.
xml
.
sax
.
SAXNotSupportedException
;
import
org
.
xml
.
sax
.
SAXParseException
;
import
org
.
xml
.
sax
.
ext
.
DeclHandler
;
import
org
.
xml
.
sax
.
ext
.
LexicalHandler
;
import
org
.
apache
.
xpath
.
ExtensionsProvider
;
import
org
.
apache
.
xalan
.
extensions
.
ExtensionsTable
;
public
class
TransformerImpl
extends
Transformer
implements
Runnable
,
DTMWSFilter
,
ExtensionsProvider
{
private
Boolean
m_reentryGuard
=
new
Boolean
(
true
)
;
private
java
.
io
.
FileOutputStream
m_outputStream
=
null
;
private
boolean
m_parserEventsOnMain
=
true
;
private
Thread
m_transformThread
;
private
String
m_urlOfSource
=
null
;
private
Result
m_outputTarget
=
null
;
private
OutputProperties
m_outputFormat
;
private
Serializer
m_serializer
;
ContentHandler
m_inputContentHandler
;
private
ContentHandler
m_outputContentHandler
=
null
;
DocumentBuilder
m_docBuilder
=
null
;
private
ObjectPool
m_textResultHandlerObjectPool
=
new
ObjectPool
(
"org.apache.xalan.transformer.ResultTreeHandler"
)
;
private
ObjectPool
m_stringWriterObjectPool
=
new
ObjectPool
(
"java.io.StringWriter"
)
;
private
OutputProperties
m_textformat
=
new
OutputProperties
(
Method
.
Text
)
;
ElemTemplateElement
[
]
m_currentTemplateElements
=
new
ElemTemplateElement
[
XPathContext
.
RECURSIONLIMIT
]
;
int
m_currentTemplateElementsTop
=
0
;
Stack
m_currentMatchTemplates
=
new
Stack
(
)
;
NodeVector
m_currentMatchedNodes
=
new
NodeVector
(
)
;
private
StylesheetRoot
m_stylesheetRoot
=
null
;
private
boolean
m_quietConflictWarnings
=
true
;
private
XPathContext
m_xcontext
;
private
StackGuard
m_stackGuard
;
private
ResultTreeHandler
m_resultTreeHandler
;
private
KeyManager
m_keyManager
=
new
KeyManager
(
)
;
Stack
m_attrSetStack
=
null
;
CountersTable
m_countersTable
=
null
;
BoolStack
m_currentTemplateRuleIsNull
=
new
BoolStack
(
)
;
private
MsgMgr
m_msgMgr
;
public
static
boolean
S_DEBUG
=
false
;
private
ErrorListener
m_errorHandler
=
new
org
.
apache
.
xml
.
utils
.
DefaultErrorHandler
(
)
;
private
TraceManager
m_traceManager
=
new
TraceManager
(
this
)
;
private
Exception
m_exceptionThrown
=
null
;
private
Source
m_xmlSource
;
private
int
m_doc
;
private
boolean
m_isTransformDone
=
false
;
private
boolean
m_hasBeenReset
=
false
;
private
boolean
m_shouldReset
=
true
;
public
void
setShouldReset
(
boolean
shouldReset
)
{
m_shouldReset
=
shouldReset
;
}
private
Stack
m_modes
=
new
Stack
(
)
;
public
TransformerImpl
(
StylesheetRoot
stylesheet
)
{
setStylesheet
(
stylesheet
)
;
setXPathContext
(
new
XPathContext
(
this
)
)
;
getXPathContext
(
)
.
setNamespaceContext
(
stylesheet
)
;
m_stackGuard
=
new
StackGuard
(
this
)
;
}
private
ExtensionsTable
m_extensionsTable
=
null
;
public
ExtensionsTable
getExtensionsTable
(
)
{
return
m_extensionsTable
;
}
void
setExtensionsTable
(
StylesheetRoot
sroot
)
throws
javax
.
xml
.
transform
.
TransformerException
{
try
{
if
(
sroot
.
getExtensions
(
)
!=
null
)
m_extensionsTable
=
new
ExtensionsTable
(
sroot
)
;
}
catch
(
javax
.
xml
.
transform
.
TransformerException
te
)
{
te
.
printStackTrace
(
)
;
}
}
public
boolean
functionAvailable
(
String
ns
,
String
funcName
)
throws
javax
.
xml
.
transform
.
TransformerException
{
return
getExtensionsTable
(
)
.
functionAvailable
(
ns
,
funcName
)
;
}
public
boolean
elementAvailable
(
String
ns
,
String
elemName
)
throws
javax
.
xml
.
transform
.
TransformerException
{
return
getExtensionsTable
(
)
.
elementAvailable
(
ns
,
elemName
)
;
}
public
Object
extFunction
(
String
ns
,
String
funcName
,
Vector
argVec
,
Object
methodKey
)
throws
javax
.
xml
.
transform
.
TransformerException
{
return
getExtensionsTable
(
)
.
extFunction
(
ns
,
funcName
,
argVec
,
methodKey
,
getXPathContext
(
)
.
getExpressionContext
(
)
)
;
}
public
void
reset
(
)
{
if
(
!
m_hasBeenReset
&&
m_shouldReset
)
{
m_hasBeenReset
=
true
;
if
(
this
.
m_outputStream
!=
null
)
{
try
{
m_outputStream
.
close
(
)
;
}
catch
(
java
.
io
.
IOException
ioe
)
{
}
}
m_outputStream
=
null
;
m_countersTable
=
null
;
m_xcontext
.
reset
(
)
;
m_xcontext
.
getVarStack
(
)
.
reset
(
)
;
resetUserParameters
(
)
;
int
n
=
m_currentTemplateElements
.
length
;
for
(
int
i
=
0
;
i
<
n
;
i
++
)
{
m_currentTemplateElements
[
i
]
=
null
;
}
m_currentTemplateElementsTop
=
0
;
m_currentMatchTemplates
.
removeAllElements
(
)
;
m_currentMatchedNodes
.
removeAllElements
(
)
;
m_resultTreeHandler
=
null
;
m_outputTarget
=
null
;
m_keyManager
=
new
KeyManager
(
)
;
m_attrSetStack
=
null
;
m_countersTable
=
null
;
m_currentTemplateRuleIsNull
=
new
BoolStack
(
)
;
m_xmlSource
=
null
;
m_doc
=
DTM
.
NULL
;
m_isTransformDone
=
false
;
m_transformThread
=
null
;
m_xcontext
.
getSourceTreeManager
(
)
.
reset
(
)
;
}
}
public
boolean
getProperty
(
String
property
)
{
return
false
;
}
public
void
setProperty
(
String
property
,
Object
value
)
{
}
public
boolean
isParserEventsOnMain
(
)
{
return
m_parserEventsOnMain
;
}
public
Thread
getTransformThread
(
)
{
return
m_transformThread
;
}
public
void
setTransformThread
(
Thread
t
)
{
m_transformThread
=
t
;
}
private
boolean
m_hasTransformThreadErrorCatcher
=
false
;
public
boolean
hasTransformThreadErrorCatcher
(
)
{
return
m_hasTransformThreadErrorCatcher
;
}
public
void
transform
(
Source
source
)
throws
TransformerException
{
transform
(
source
,
true
)
;
}
public
void
transform
(
Source
source
,
boolean
shouldRelease
)
throws
TransformerException
{
try
{
String
base
=
source
.
getSystemId
(
)
;
if
(
null
==
base
)
{
base
=
m_stylesheetRoot
.
getBaseIdentifier
(
)
;
}
if
(
null
==
base
)
{
String
currentDir
=
""
;
try
{
currentDir
=
System
.
getProperty
(
"user.dir"
)
;
}
catch
(
SecurityException
se
)
{
}
if
(
currentDir
.
startsWith
(
java
.
io
.
File
.
separator
)
)
base
=
"file://"
+
currentDir
;
else
base
=
"file:///"
+
currentDir
;
base
=
base
+
java
.
io
.
File
.
separatorChar
+
source
.
getClass
(
)
.
getName
(
)
;
}
setBaseURLOfSource
(
base
)
;
DTMManager
mgr
=
m_xcontext
.
getDTMManager
(
)
;
DTM
dtm
=
mgr
.
getDTM
(
source
,
false
,
this
,
true
,
true
)
;
dtm
.
setDocumentBaseURI
(
base
)
;
boolean
hardDelete
=
true
;
try
{
this
.
transformNode
(
dtm
.
getDocument
(
)
)
;
}
finally
{
if
(
shouldRelease
)
mgr
.
release
(
dtm
,
hardDelete
)
;
}
Exception
e
=
getExceptionThrown
(
)
;
if
(
null
!=
e
)
{
if
(
e
instanceof
javax
.
xml
.
transform
.
TransformerException
)
{
throw
(
javax
.
xml
.
transform
.
TransformerException
)
e
;
}
else
if
(
e
instanceof
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
)
{
fatalError
(
(
(
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
)
e
)
.
getException
(
)
)
;
}
else
{
throw
new
javax
.
xml
.
transform
.
TransformerException
(
e
)
;
}
}
else
if
(
null
!=
m_resultTreeHandler
)
{
m_resultTreeHandler
.
endDocument
(
)
;
}
}
catch
(
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
wre
)
{
Throwable
throwable
=
wre
.
getException
(
)
;
while
(
throwable
instanceof
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
)
{
throwable
=
(
(
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
)
throwable
)
.
getException
(
)
;
}
fatalError
(
throwable
)
;
}
catch
(
org
.
xml
.
sax
.
SAXParseException
spe
)
{
fatalError
(
spe
)
;
}
catch
(
org
.
xml
.
sax
.
SAXException
se
)
{
m_errorHandler
.
fatalError
(
new
TransformerException
(
se
)
)
;
}
finally
{
m_hasTransformThreadErrorCatcher
=
false
;
reset
(
)
;
}
}
private
void
fatalError
(
Throwable
throwable
)
throws
TransformerException
{
if
(
throwable
instanceof
org
.
xml
.
sax
.
SAXParseException
)
m_errorHandler
.
fatalError
(
new
TransformerException
(
throwable
.
getMessage
(
)
,
new
SAXSourceLocator
(
(
org
.
xml
.
sax
.
SAXParseException
)
throwable
)
)
)
;
else
m_errorHandler
.
fatalError
(
new
TransformerException
(
throwable
)
)
;
}
public
String
getBaseURLOfSource
(
)
{
return
m_urlOfSource
;
}
public
void
setBaseURLOfSource
(
String
base
)
{
m_urlOfSource
=
base
;
}
public
Result
getOutputTarget
(
)
{
return
m_outputTarget
;
}
public
void
setOutputTarget
(
Result
outputTarget
)
{
m_outputTarget
=
outputTarget
;
}
public
String
getOutputProperty
(
String
qnameString
)
throws
IllegalArgumentException
{
String
value
=
null
;
OutputProperties
props
=
getOutputFormat
(
)
;
value
=
props
.
getProperty
(
qnameString
)
;
if
(
null
==
value
)
{
if
(
!
props
.
isLegalPropertyKey
(
qnameString
)
)
throw
new
IllegalArgumentException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_OUTPUT_PROPERTY_NOT_RECOGNIZED
,
new
Object
[
]
{
qnameString
}
)
)
;
}
return
value
;
}
public
String
getOutputPropertyNoDefault
(
String
qnameString
)
throws
IllegalArgumentException
{
String
value
=
null
;
OutputProperties
props
=
getOutputFormat
(
)
;
value
=
(
String
)
props
.
getProperties
(
)
.
get
(
qnameString
)
;
if
(
null
==
value
)
{
if
(
!
props
.
isLegalPropertyKey
(
qnameString
)
)
throw
new
IllegalArgumentException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_OUTPUT_PROPERTY_NOT_RECOGNIZED
,
new
Object
[
]
{
qnameString
}
)
)
;
}
return
value
;
}
public
void
setOutputProperty
(
String
name
,
String
value
)
throws
IllegalArgumentException
{
synchronized
(
m_reentryGuard
)
{
if
(
null
==
m_outputFormat
)
{
m_outputFormat
=
(
OutputProperties
)
getStylesheet
(
)
.
getOutputComposed
(
)
.
clone
(
)
;
}
if
(
!
m_outputFormat
.
isLegalPropertyKey
(
name
)
)
throw
new
IllegalArgumentException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_OUTPUT_PROPERTY_NOT_RECOGNIZED
,
new
Object
[
]
{
name
}
)
)
;
m_outputFormat
.
setProperty
(
name
,
value
)
;
}
}
public
void
setOutputProperties
(
Properties
oformat
)
{
synchronized
(
m_reentryGuard
)
{
if
(
null
!=
oformat
)
{
String
method
=
(
String
)
oformat
.
get
(
OutputKeys
.
METHOD
)
;
if
(
null
!=
method
)
m_outputFormat
=
new
OutputProperties
(
method
)
;
else
if
(
m_outputFormat
==
null
)
m_outputFormat
=
new
OutputProperties
(
)
;
}
if
(
null
!=
oformat
)
{
m_outputFormat
.
copyFrom
(
oformat
)
;
}
m_outputFormat
.
copyFrom
(
m_stylesheetRoot
.
getOutputProperties
(
)
)
;
}
}
public
Properties
getOutputProperties
(
)
{
return
(
Properties
)
getOutputFormat
(
)
.
getProperties
(
)
.
clone
(
)
;
}
public
ContentHandler
createResultContentHandler
(
Result
outputTarget
)
throws
TransformerException
{
return
createResultContentHandler
(
outputTarget
,
getOutputFormat
(
)
)
;
}
public
ContentHandler
createResultContentHandler
(
Result
outputTarget
,
OutputProperties
format
)
throws
TransformerException
{
ContentHandler
handler
=
null
;
org
.
w3c
.
dom
.
Node
outputNode
=
null
;
if
(
outputTarget
instanceof
DOMResult
)
{
outputNode
=
(
(
DOMResult
)
outputTarget
)
.
getNode
(
)
;
org
.
w3c
.
dom
.
Document
doc
;
short
type
;
if
(
null
!=
outputNode
)
{
type
=
outputNode
.
getNodeType
(
)
;
doc
=
(
org
.
w3c
.
dom
.
Node
.
DOCUMENT_NODE
==
type
)
?
(
org
.
w3c
.
dom
.
Document
)
outputNode
:
outputNode
.
getOwnerDocument
(
)
;
}
else
{
doc
=
org
.
apache
.
xpath
.
DOMHelper
.
createDocument
(
)
;
outputNode
=
doc
;
type
=
outputNode
.
getNodeType
(
)
;
(
(
DOMResult
)
outputTarget
)
.
setNode
(
outputNode
)
;
}
handler
=
(
org
.
w3c
.
dom
.
Node
.
DOCUMENT_FRAGMENT_NODE
==
type
)
?
new
DOMBuilder
(
doc
,
(
org
.
w3c
.
dom
.
DocumentFragment
)
outputNode
)
:
new
DOMBuilder
(
doc
,
outputNode
)
;
}
else
if
(
outputTarget
instanceof
SAXResult
)
{
handler
=
(
(
SAXResult
)
outputTarget
)
.
getHandler
(
)
;
if
(
null
==
handler
)
throw
new
IllegalArgumentException
(
"handler can not be null for a SAXResult"
)
;
}
else
if
(
outputTarget
instanceof
StreamResult
)
{
StreamResult
sresult
=
(
StreamResult
)
outputTarget
;
String
method
=
format
.
getProperty
(
OutputKeys
.
METHOD
)
;
try
{
Serializer
serializer
=
SerializerFactory
.
getSerializer
(
format
.
getProperties
(
)
)
;
if
(
null
!=
sresult
.
getWriter
(
)
)
serializer
.
setWriter
(
sresult
.
getWriter
(
)
)
;
else
if
(
null
!=
sresult
.
getOutputStream
(
)
)
serializer
.
setOutputStream
(
sresult
.
getOutputStream
(
)
)
;
else
if
(
null
!=
sresult
.
getSystemId
(
)
)
{
String
fileURL
=
sresult
.
getSystemId
(
)
;
if
(
fileURL
.
startsWith
(
"file:///"
)
)
{
if
(
fileURL
.
substring
(
8
)
.
indexOf
(
":"
)
>
0
)
fileURL
=
fileURL
.
substring
(
8
)
;
else
fileURL
=
fileURL
.
substring
(
7
)
;
}
m_outputStream
=
new
java
.
io
.
FileOutputStream
(
fileURL
)
;
serializer
.
setOutputStream
(
m_outputStream
)
;
}
else
throw
new
TransformerException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_NO_OUTPUT_SPECIFIED
,
null
)
)
;
handler
=
serializer
.
asContentHandler
(
)
;
this
.
setSerializer
(
serializer
)
;
}
catch
(
UnsupportedEncodingException
uee
)
{
throw
new
TransformerException
(
uee
)
;
}
catch
(
IOException
ioe
)
{
throw
new
TransformerException
(
ioe
)
;
}
}
else
{
throw
new
TransformerException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_CANNOT_TRANSFORM_TO_RESULT_TYPE
,
new
Object
[
]
{
outputTarget
.
getClass
(
)
.
getName
(
)
}
)
)
;
}
return
handler
;
}
public
void
transform
(
Source
xmlSource
,
Result
outputTarget
)
throws
TransformerException
{
transform
(
xmlSource
,
outputTarget
,
true
)
;
}
public
void
transform
(
Source
xmlSource
,
Result
outputTarget
,
boolean
shouldRelease
)
throws
TransformerException
{
synchronized
(
m_reentryGuard
)
{
ContentHandler
handler
=
createResultContentHandler
(
outputTarget
)
;
m_outputTarget
=
outputTarget
;
this
.
setContentHandler
(
handler
)
;
transform
(
xmlSource
,
shouldRelease
)
;
}
}
public
void
transformNode
(
int
node
,
Result
outputTarget
)
throws
TransformerException
{
ContentHandler
handler
=
createResultContentHandler
(
outputTarget
)
;
m_outputTarget
=
outputTarget
;
this
.
setContentHandler
(
handler
)
;
transformNode
(
node
)
;
}
public
void
transformNode
(
int
node
)
throws
TransformerException
{
setExtensionsTable
(
getStylesheet
(
)
)
;
synchronized
(
m_outputContentHandler
)
{
m_hasBeenReset
=
false
;
XPathContext
xctxt
=
getXPathContext
(
)
;
DTM
dtm
=
xctxt
.
getDTM
(
node
)
;
try
{
pushGlobalVars
(
node
)
;
StylesheetRoot
stylesheet
=
this
.
getStylesheet
(
)
;
int
n
=
stylesheet
.
getGlobalImportCount
(
)
;
for
(
int
i
=
0
;
i
<
n
;
i
++
)
{
StylesheetComposed
imported
=
stylesheet
.
getGlobalImport
(
i
)
;
int
includedCount
=
imported
.
getIncludeCountComposed
(
)
;
for
(
int
j
=
-
1
;
j
<
includedCount
;
j
++
)
{
Stylesheet
included
=
imported
.
getIncludeComposed
(
j
)
;
included
.
runtimeInit
(
this
)
;
for
(
ElemTemplateElement
child
=
included
.
getFirstChildElem
(
)
;
child
!=
null
;
child
=
child
.
getNextSiblingElem
(
)
)
{
child
.
runtimeInit
(
this
)
;
}
}
}
DTMIterator
dtmIter
=
new
org
.
apache
.
xpath
.
axes
.
SelfIteratorNoPredicate
(
)
;
dtmIter
.
setRoot
(
node
,
xctxt
)
;
xctxt
.
pushContextNodeList
(
dtmIter
)
;
try
{
this
.
applyTemplateToNode
(
null
,
null
,
node
)
;
}
finally
{
xctxt
.
popContextNodeList
(
)
;
}
if
(
null
!=
m_resultTreeHandler
)
{
m_resultTreeHandler
.
endDocument
(
)
;
}
}
catch
(
Exception
se
)
{
while
(
se
instanceof
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
)
{
Exception
e
=
(
(
org
.
apache
.
xml
.
utils
.
WrappedRuntimeException
)
se
)
.
getException
(
)
;
if
(
null
!=
e
)
se
=
e
;
}
if
(
null
!=
m_resultTreeHandler
)
{
try
{
if
(
se
instanceof
org
.
xml
.
sax
.
SAXParseException
)
m_resultTreeHandler
.
fatalError
(
(
org
.
xml
.
sax
.
SAXParseException
)
se
)
;
else
if
(
se
instanceof
TransformerException
)
{
TransformerException
te
=
(
(
TransformerException
)
se
)
;
SAXSourceLocator
sl
=
new
SAXSourceLocator
(
te
.
getLocator
(
)
)
;
m_resultTreeHandler
.
fatalError
(
new
org
.
xml
.
sax
.
SAXParseException
(
te
.
getMessage
(
)
,
sl
,
te
)
)
;
}
else
{
m_resultTreeHandler
.
fatalError
(
new
org
.
xml
.
sax
.
SAXParseException
(
se
.
getMessage
(
)
,
new
SAXSourceLocator
(
)
,
se
)
)
;
}
}
catch
(
Exception
e
)
{
}
}
if
(
se
instanceof
TransformerException
)
{
m_errorHandler
.
fatalError
(
(
TransformerException
)
se
)
;
}
else
if
(
se
instanceof
org
.
xml
.
sax
.
SAXParseException
)
{
m_errorHandler
.
fatalError
(
new
TransformerException
(
se
.
getMessage
(
)
,
new
SAXSourceLocator
(
(
org
.
xml
.
sax
.
SAXParseException
)
se
)
,
se
)
)
;
}
else
{
m_errorHandler
.
fatalError
(
new
TransformerException
(
se
)
)
;
}
}
finally
{
this
.
reset
(
)
;
}
}
}
public
ContentHandler
getInputContentHandler
(
)
{
return
getInputContentHandler
(
false
)
;
}
public
ContentHandler
getInputContentHandler
(
boolean
doDocFrag
)
{
if
(
null
==
m_inputContentHandler
)
{
m_inputContentHandler
=
new
TransformerHandlerImpl
(
this
,
doDocFrag
,
m_urlOfSource
)
;
}
return
m_inputContentHandler
;
}
public
DeclHandler
getInputDeclHandler
(
)
{
if
(
m_inputContentHandler
instanceof
DeclHandler
)
return
(
DeclHandler
)
m_inputContentHandler
;
else
return
null
;
}
public
LexicalHandler
getInputLexicalHandler
(
)
{
if
(
m_inputContentHandler
instanceof
LexicalHandler
)
return
(
LexicalHandler
)
m_inputContentHandler
;
else
return
null
;
}
public
void
setOutputFormat
(
OutputProperties
oformat
)
{
m_outputFormat
=
oformat
;
}
public
OutputProperties
getOutputFormat
(
)
{
OutputProperties
format
=
(
null
==
m_outputFormat
)
?
getStylesheet
(
)
.
getOutputComposed
(
)
:
m_outputFormat
;
return
format
;
}
public
Serializer
getSerializer
(
)
{
return
m_serializer
;
}
public
void
setSerializer
(
Serializer
s
)
{
m_serializer
=
s
;
}
public
void
setParameter
(
String
name
,
String
namespace
,
Object
value
)
{
VariableStack
varstack
=
getXPathContext
(
)
.
getVarStack
(
)
;
QName
qname
=
new
QName
(
namespace
,
name
)
;
XObject
xobject
=
XObject
.
create
(
value
,
getXPathContext
(
)
)
;
StylesheetRoot
sroot
=
m_stylesheetRoot
;
Vector
vars
=
sroot
.
getVariablesAndParamsComposed
(
)
;
int
i
=
vars
.
size
(
)
;
while
(
--
i
>=
0
)
{
ElemVariable
variable
=
(
ElemVariable
)
vars
.
elementAt
(
i
)
;
if
(
variable
.
getXSLToken
(
)
==
Constants
.
ELEMNAME_PARAMVARIABLE
&&
variable
.
getName
(
)
.
equals
(
qname
)
)
{
varstack
.
setGlobalVariable
(
i
,
xobject
)
;
}
}
}
Vector
m_userParams
;
public
void
setParameter
(
String
name
,
Object
value
)
{
StringTokenizer
tokenizer
=
new
StringTokenizer
(
name
,
"{}"
,
false
)
;
try
{
String
s1
=
tokenizer
.
nextToken
(
)
;
String
s2
=
tokenizer
.
hasMoreTokens
(
)
?
tokenizer
.
nextToken
(
)
:
null
;
if
(
null
==
m_userParams
)
m_userParams
=
new
Vector
(
)
;
if
(
null
==
s2
)
{
replaceOrPushUserParam
(
new
QName
(
s1
)
,
XObject
.
create
(
value
,
getXPathContext
(
)
)
)
;
setParameter
(
s1
,
null
,
value
)
;
}
else
{
replaceOrPushUserParam
(
new
QName
(
s1
,
s2
)
,
XObject
.
create
(
value
,
getXPathContext
(
)
)
)
;
setParameter
(
s2
,
s1
,
value
)
;
}
}
catch
(
java
.
util
.
NoSuchElementException
nsee
)
{
}
}
private
void
replaceOrPushUserParam
(
QName
qname
,
XObject
xval
)
{
int
n
=
m_userParams
.
size
(
)
;
for
(
int
i
=
n
-
1
;
i
>=
0
;
i
--
)
{
Arg
arg
=
(
Arg
)
m_userParams
.
elementAt
(
i
)
;
if
(
arg
.
getQName
(
)
.
equals
(
qname
)
)
{
m_userParams
.
setElementAt
(
new
Arg
(
qname
,
xval
,
true
)
,
i
)
;
return
;
}
}
m_userParams
.
addElement
(
new
Arg
(
qname
,
xval
,
true
)
)
;
}
public
Object
getParameter
(
String
name
)
{
try
{
QName
qname
=
QName
.
getQNameFromString
(
name
)
;
if
(
null
==
m_userParams
)
return
null
;
int
n
=
m_userParams
.
size
(
)
;
for
(
int
i
=
n
-
1
;
i
>=
0
;
i
--
)
{
Arg
arg
=
(
Arg
)
m_userParams
.
elementAt
(
i
)
;
if
(
arg
.
getQName
(
)
.
equals
(
qname
)
)
{
return
arg
.
getVal
(
)
.
object
(
)
;
}
}
return
null
;
}
catch
(
java
.
util
.
NoSuchElementException
nsee
)
{
return
null
;
}
}
private
void
resetUserParameters
(
)
{
try
{
if
(
null
==
m_userParams
)
return
;
int
n
=
m_userParams
.
size
(
)
;
for
(
int
i
=
n
-
1
;
i
>=
0
;
i
--
)
{
Arg
arg
=
(
Arg
)
m_userParams
.
elementAt
(
i
)
;
QName
name
=
arg
.
getQName
(
)
;
String
s1
=
name
.
getNamespace
(
)
;
String
s2
=
name
.
getLocalPart
(
)
;
setParameter
(
s2
,
s1
,
arg
.
getVal
(
)
.
object
(
)
)
;
}
}
catch
(
java
.
util
.
NoSuchElementException
nsee
)
{
}
}
public
void
setParameters
(
Properties
params
)
{
clearParameters
(
)
;
Enumeration
names
=
params
.
propertyNames
(
)
;
while
(
names
.
hasMoreElements
(
)
)
{
String
name
=
params
.
getProperty
(
(
String
)
names
.
nextElement
(
)
)
;
StringTokenizer
tokenizer
=
new
StringTokenizer
(
name
,
"{}"
,
false
)
;
try
{
String
s1
=
tokenizer
.
nextToken
(
)
;
String
s2
=
tokenizer
.
hasMoreTokens
(
)
?
tokenizer
.
nextToken
(
)
:
null
;
if
(
null
==
s2
)
setParameter
(
s1
,
null
,
params
.
getProperty
(
name
)
)
;
else
setParameter
(
s2
,
s1
,
params
.
getProperty
(
name
)
)
;
}
catch
(
java
.
util
.
NoSuchElementException
nsee
)
{
}
}
}
public
void
clearParameters
(
)
{
synchronized
(
m_reentryGuard
)
{
VariableStack
varstack
=
new
VariableStack
(
)
;
m_xcontext
.
setVarStack
(
varstack
)
;
m_userParams
=
null
;
}
}
protected
void
pushGlobalVars
(
int
contextNode
)
throws
TransformerException
{
XPathContext
xctxt
=
m_xcontext
;
VariableStack
vs
=
xctxt
.
getVarStack
(
)
;
StylesheetRoot
sr
=
getStylesheet
(
)
;
Vector
vars
=
sr
.
getVariablesAndParamsComposed
(
)
;
int
i
=
vars
.
size
(
)
;
vs
.
link
(
i
)
;
while
(
--
i
>=
0
)
{
ElemVariable
v
=
(
ElemVariable
)
vars
.
elementAt
(
i
)
;
XObject
xobj
=
new
XUnresolvedVariable
(
v
,
contextNode
,
this
,
vs
.
getStackFrame
(
)
,
0
,
true
)
;
if
(
null
==
vs
.
elementAt
(
i
)
)
vs
.
setGlobalVariable
(
i
,
xobj
)
;
}
}
public
void
setURIResolver
(
URIResolver
resolver
)
{
synchronized
(
m_reentryGuard
)
{
m_xcontext
.
getSourceTreeManager
(
)
.
setURIResolver
(
resolver
)
;
}
}
public
URIResolver
getURIResolver
(
)
{
return
m_xcontext
.
getSourceTreeManager
(
)
.
getURIResolver
(
)
;
}
public
void
setContentHandler
(
ContentHandler
handler
)
{
if
(
handler
==
null
)
{
throw
new
NullPointerException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_NULL_CONTENT_HANDLER
,
null
)
)
;
}
else
{
m_outputContentHandler
=
handler
;
if
(
null
==
m_resultTreeHandler
)
m_resultTreeHandler
=
new
ResultTreeHandler
(
this
,
handler
)
;
else
m_resultTreeHandler
.
setContentHandler
(
handler
)
;
}
}
public
ContentHandler
getContentHandler
(
)
{
return
m_outputContentHandler
;
}
public
int
transformToRTF
(
ElemTemplateElement
templateParent
)
throws
TransformerException
{
DTM
dtmFrag
=
m_xcontext
.
getRTFDTM
(
)
;
return
transformToRTF
(
templateParent
,
dtmFrag
)
;
}
public
int
transformToGlobalRTF
(
ElemTemplateElement
templateParent
)
throws
TransformerException
{
DTM
dtmFrag
=
m_xcontext
.
getGlobalRTFDTM
(
)
;
return
transformToRTF
(
templateParent
,
dtmFrag
)
;
}
private
int
transformToRTF
(
ElemTemplateElement
templateParent
,
DTM
dtmFrag
)
throws
TransformerException
{
XPathContext
xctxt
=
m_xcontext
;
ContentHandler
rtfHandler
=
dtmFrag
.
getContentHandler
(
)
;
int
resultFragment
;
ResultTreeHandler
savedRTreeHandler
=
this
.
m_resultTreeHandler
;
m_resultTreeHandler
=
new
ResultTreeHandler
(
this
,
rtfHandler
)
;
ResultTreeHandler
rth
=
m_resultTreeHandler
;
try
{
rth
.
startDocument
(
)
;
rth
.
flushPending
(
)
;
try
{
executeChildTemplates
(
templateParent
,
true
)
;
rth
.
flushPending
(
)
;
resultFragment
=
dtmFrag
.
getDocument
(
)
;
}
finally
{
rth
.
endDocument
(
)
;
}
}
catch
(
org
.
xml
.
sax
.
SAXException
se
)
{
throw
new
TransformerException
(
se
)
;
}
finally
{
this
.
m_resultTreeHandler
=
savedRTreeHandler
;
}
return
resultFragment
;
}
public
ObjectPool
getStringWriterPool
(
)
{
return
m_stringWriterObjectPool
;
}
public
String
transformToString
(
ElemTemplateElement
elem
)
throws
TransformerException
{
ElemTemplateElement
firstChild
=
elem
.
getFirstChildElem
(
)
;
if
(
null
==
firstChild
)
return
""
;
if
(
elem
.
hasTextLitOnly
(
)
&&
org
.
apache
.
xalan
.
processor
.
TransformerFactoryImpl
.
m_optimize
)
{
return
(
(
ElemTextLiteral
)
firstChild
)
.
getNodeValue
(
)
;
}
ResultTreeHandler
savedRTreeHandler
=
this
.
m_resultTreeHandler
;
StringWriter
sw
=
(
StringWriter
)
m_stringWriterObjectPool
.
getInstance
(
)
;
m_resultTreeHandler
=
(
ResultTreeHandler
)
m_textResultHandlerObjectPool
.
getInstance
(
)
;
Serializer
serializer
=
m_resultTreeHandler
.
getSerializer
(
)
;
try
{
if
(
null
==
serializer
)
{
serializer
=
SerializerFactory
.
getSerializer
(
m_textformat
.
getProperties
(
)
)
;
m_resultTreeHandler
.
setSerializer
(
serializer
)
;
serializer
.
setWriter
(
sw
)
;
ContentHandler
shandler
=
serializer
.
asContentHandler
(
)
;
m_resultTreeHandler
.
init
(
this
,
shandler
)
;
}
else
{
}
}
catch
(
IOException
ioe
)
{
throw
new
TransformerException
(
ioe
)
;
}
String
result
;
try
{
this
.
m_resultTreeHandler
.
startDocument
(
)
;
executeChildTemplates
(
elem
,
true
)
;
this
.
m_resultTreeHandler
.
endDocument
(
)
;
result
=
sw
.
toString
(
)
;
}
catch
(
org
.
xml
.
sax
.
SAXException
se
)
{
throw
new
TransformerException
(
se
)
;
}
finally
{
sw
.
getBuffer
(
)
.
setLength
(
0
)
;
try
{
sw
.
close
(
)
;
}
catch
(
Exception
ioe
)
{
}
m_stringWriterObjectPool
.
freeInstance
(
sw
)
;
m_textResultHandlerObjectPool
.
freeInstance
(
m_resultTreeHandler
)
;
m_resultTreeHandler
.
reset
(
)
;
m_resultTreeHandler
=
savedRTreeHandler
;
}
return
result
;
}
public
boolean
applyTemplateToNode
(
ElemTemplateElement
xslInstruction
,
ElemTemplate
template
,
int
child
)
throws
TransformerException
{
DTM
dtm
=
m_xcontext
.
getDTM
(
child
)
;
short
nodeType
=
dtm
.
getNodeType
(
child
)
;
boolean
isDefaultTextRule
=
false
;
if
(
null
==
template
)
{
int
maxImportLevel
,
endImportLevel
=
0
;
boolean
isApplyImports
=
(
(
xslInstruction
==
null
)
?
false
:
xslInstruction
.
getXSLToken
(
)
==
Constants
.
ELEMNAME_APPLY_IMPORTS
)
;
if
(
isApplyImports
)
{
maxImportLevel
=
xslInstruction
.
getStylesheetComposed
(
)
.
getImportCountComposed
(
)
-
1
;
endImportLevel
=
xslInstruction
.
getStylesheetComposed
(
)
.
getEndImportCountComposed
(
)
;
}
else
{
maxImportLevel
=
-
1
;
}
if
(
isApplyImports
&&
(
maxImportLevel
==
-
1
)
)
{
template
=
null
;
}
else
{
XPathContext
xctxt
=
m_xcontext
;
try
{
xctxt
.
pushNamespaceContext
(
xslInstruction
)
;
QName
mode
=
this
.
getMode
(
)
;
if
(
isApplyImports
)
template
=
m_stylesheetRoot
.
getTemplateComposed
(
xctxt
,
child
,
mode
,
maxImportLevel
,
endImportLevel
,
m_quietConflictWarnings
,
dtm
)
;
else
template
=
m_stylesheetRoot
.
getTemplateComposed
(
xctxt
,
child
,
mode
,
m_quietConflictWarnings
,
dtm
)
;
}
finally
{
xctxt
.
popNamespaceContext
(
)
;
}
}
if
(
null
==
template
)
{
switch
(
nodeType
)
{
case
DTM
.
DOCUMENT_FRAGMENT_NODE
:
case
DTM
.
ELEMENT_NODE
:
template
=
m_stylesheetRoot
.
getDefaultRule
(
)
;
break
;
case
DTM
.
CDATA_SECTION_NODE
:
case
DTM
.
TEXT_NODE
:
case
DTM
.
ATTRIBUTE_NODE
:
template
=
m_stylesheetRoot
.
getDefaultTextRule
(
)
;
isDefaultTextRule
=
true
;
break
;
case
DTM
.
DOCUMENT_NODE
:
template
=
m_stylesheetRoot
.
getDefaultRootRule
(
)
;
break
;
default
:
return
false
;
}
}
}
try
{
pushElemTemplateElement
(
template
)
;
m_xcontext
.
pushCurrentNode
(
child
)
;
pushPairCurrentMatched
(
template
,
child
)
;
DTMIterator
cnl
=
new
org
.
apache
.
xpath
.
NodeSetDTM
(
child
,
m_xcontext
.
getDTMManager
(
)
)
;
m_xcontext
.
pushContextNodeList
(
cnl
)
;
if
(
isDefaultTextRule
)
{
switch
(
nodeType
)
{
case
DTM
.
CDATA_SECTION_NODE
:
case
DTM
.
TEXT_NODE
:
ClonerToResultTree
.
cloneToResultTree
(
child
,
nodeType
,
dtm
,
getResultTreeHandler
(
)
,
false
)
;
break
;
case
DTM
.
ATTRIBUTE_NODE
:
dtm
.
dispatchCharactersEvents
(
child
,
getResultTreeHandler
(
)
,
false
)
;
break
;
}
}
else
{
if
(
TransformerImpl
.
S_DEBUG
)
getTraceManager
(
)
.
fireTraceEvent
(
template
)
;
m_xcontext
.
setSAXLocator
(
template
)
;
m_xcontext
.
getVarStack
(
)
.
link
(
template
.
m_frameSize
)
;
executeChildTemplates
(
template
,
true
)
;
if
(
TransformerImpl
.
S_DEBUG
)
getTraceManager
(
)
.
fireTraceEndEvent
(
template
)
;
}
}
catch
(
org
.
xml
.
sax
.
SAXException
se
)
{
throw
new
TransformerException
(
se
)
;
}
finally
{
m_xcontext
.
getVarStack
(
)
.
unlink
(
)
;
m_xcontext
.
popCurrentNode
(
)
;
m_xcontext
.
popContextNodeList
(
)
;
popCurrentMatched
(
)
;
popElemTemplateElement
(
)
;
}
return
true
;
}
public
void
executeChildTemplates
(
ElemTemplateElement
elem
,
org
.
w3c
.
dom
.
Node
context
,
QName
mode
,
ContentHandler
handler
)
throws
TransformerException
{
XPathContext
xctxt
=
m_xcontext
;
try
{
if
(
null
!=
mode
)
pushMode
(
mode
)
;
xctxt
.
pushCurrentNode
(
xctxt
.
getDTMHandleFromNode
(
context
)
)
;
executeChildTemplates
(
elem
,
handler
)
;
}
finally
{
xctxt
.
popCurrentNode
(
)
;
if
(
null
!=
mode
)
popMode
(
)
;
}
}
public
void
executeChildTemplates
(
ElemTemplateElement
elem
,
ContentHandler
handler
)
throws
TransformerException
{
ResultTreeHandler
rth
=
this
.
getResultTreeHandler
(
)
;
ContentHandler
savedRTHHandler
=
rth
.
getContentHandler
(
)
;
ContentHandler
savedHandler
=
this
.
getContentHandler
(
)
;
try
{
getResultTreeHandler
(
)
.
flushPending
(
)
;
this
.
setContentHandler
(
handler
)
;
executeChildTemplates
(
elem
,
true
)
;
}
catch
(
org
.
xml
.
sax
.
SAXException
se
)
{
throw
new
TransformerException
(
se
)
;
}
finally
{
this
.
setContentHandler
(
savedHandler
)
;
rth
.
setContentHandler
(
savedRTHHandler
)
;
}
}
public
void
executeChildTemplates
(
ElemTemplateElement
elem
,
boolean
shouldAddAttrs
)
throws
TransformerException
{
ElemTemplateElement
t
=
elem
.
getFirstChildElem
(
)
;
if
(
null
==
t
)
return
;
if
(
elem
.
hasTextLitOnly
(
)
&&
org
.
apache
.
xalan
.
processor
.
TransformerFactoryImpl
.
m_optimize
)
{
char
[
]
chars
=
(
(
ElemTextLiteral
)
t
)
.
getChars
(
)
;
try
{
this
.
pushElemTemplateElement
(
t
)
;
m_resultTreeHandler
.
characters
(
chars
,
0
,
chars
.
length
)
;
}
catch
(
SAXException
se
)
{
throw
new
TransformerException
(
se
)
;
}
finally
{
this
.
popElemTemplateElement
(
)
;
}
return
;
}
XPathContext
xctxt
=
m_xcontext
;
xctxt
.
pushSAXLocatorNull
(
)
;
int
currentTemplateElementsTop
=
m_currentTemplateElementsTop
;
m_currentTemplateElementsTop
++
;
try
{
for
(
;
t
!=
null
;
t
=
t
.
getNextSiblingElem
(
)
)
{
if
(
!
shouldAddAttrs
&&
t
.
getXSLToken
(
)
==
Constants
.
ELEMNAME_ATTRIBUTE
)
continue
;
xctxt
.
setSAXLocator
(
t
)
;
m_currentTemplateElements
[
currentTemplateElementsTop
]
=
t
;
t
.
execute
(
this
)
;
}
}
catch
(
RuntimeException
re
)
{
TransformerException
te
=
new
TransformerException
(
re
)
;
te
.
setLocator
(
t
)
;
throw
te
;
}
finally
{
m_currentTemplateElementsTop
--
;
xctxt
.
popSAXLocator
(
)
;
}
}
public
Vector
processSortKeys
(
ElemForEach
foreach
,
int
sourceNodeContext
)
throws
TransformerException
{
Vector
keys
=
null
;
XPathContext
xctxt
=
m_xcontext
;
int
nElems
=
foreach
.
getSortElemCount
(
)
;
if
(
nElems
>
0
)
keys
=
new
Vector
(
)
;
for
(
int
i
=
0
;
i
<
nElems
;
i
++
)
{
ElemSort
sort
=
foreach
.
getSortElem
(
i
)
;
if
(
TransformerImpl
.
S_DEBUG
)
getTraceManager
(
)
.
fireTraceEvent
(
sort
)
;
String
langString
=
(
null
!=
sort
.
getLang
(
)
)
?
sort
.
getLang
(
)
.
evaluate
(
xctxt
,
sourceNodeContext
,
foreach
)
:
null
;
String
dataTypeString
=
sort
.
getDataType
(
)
.
evaluate
(
xctxt
,
sourceNodeContext
,
foreach
)
;
if
(
dataTypeString
.
indexOf
(
":"
)
>=
0
)
System
.
out
.
println
(
"TODO: Need to write the hooks for QNAME sort data type"
)
;
else
if
(
!
(
dataTypeString
.
equalsIgnoreCase
(
Constants
.
ATTRVAL_DATATYPE_TEXT
)
)
&&
!
(
dataTypeString
.
equalsIgnoreCase
(
Constants
.
ATTRVAL_DATATYPE_NUMBER
)
)
)
foreach
.
error
(
XSLTErrorResources
.
ER_ILLEGAL_ATTRIBUTE_VALUE
,
new
Object
[
]
{
Constants
.
ATTRNAME_DATATYPE
,
dataTypeString
}
)
;
boolean
treatAsNumbers
=
(
(
null
!=
dataTypeString
)
&&
dataTypeString
.
equals
(
Constants
.
ATTRVAL_DATATYPE_NUMBER
)
)
?
true
:
false
;
String
orderString
=
sort
.
getOrder
(
)
.
evaluate
(
xctxt
,
sourceNodeContext
,
foreach
)
;
if
(
!
(
orderString
.
equalsIgnoreCase
(
Constants
.
ATTRVAL_ORDER_ASCENDING
)
)
&&
!
(
orderString
.
equalsIgnoreCase
(
Constants
.
ATTRVAL_ORDER_DESCENDING
)
)
)
foreach
.
error
(
XSLTErrorResources
.
ER_ILLEGAL_ATTRIBUTE_VALUE
,
new
Object
[
]
{
Constants
.
ATTRNAME_ORDER
,
orderString
}
)
;
boolean
descending
=
(
(
null
!=
orderString
)
&&
orderString
.
equals
(
Constants
.
ATTRVAL_ORDER_DESCENDING
)
)
?
true
:
false
;
AVT
caseOrder
=
sort
.
getCaseOrder
(
)
;
boolean
caseOrderUpper
;
if
(
null
!=
caseOrder
)
{
String
caseOrderString
=
caseOrder
.
evaluate
(
xctxt
,
sourceNodeContext
,
foreach
)
;
if
(
!
(
caseOrderString
.
equalsIgnoreCase
(
Constants
.
ATTRVAL_CASEORDER_UPPER
)
)
&&
!
(
caseOrderString
.
equalsIgnoreCase
(
Constants
.
ATTRVAL_CASEORDER_LOWER
)
)
)
foreach
.
error
(
XSLTErrorResources
.
ER_ILLEGAL_ATTRIBUTE_VALUE
,
new
Object
[
]
{
Constants
.
ATTRNAME_CASEORDER
,
caseOrderString
}
)
;
caseOrderUpper
=
(
(
null
!=
caseOrderString
)
&&
caseOrderString
.
equals
(
Constants
.
ATTRVAL_CASEORDER_UPPER
)
)
?
true
:
false
;
}
else
{
caseOrderUpper
=
false
;
}
keys
.
addElement
(
new
NodeSortKey
(
this
,
sort
.
getSelect
(
)
,
treatAsNumbers
,
descending
,
langString
,
caseOrderUpper
,
foreach
)
)
;
if
(
TransformerImpl
.
S_DEBUG
)
getTraceManager
(
)
.
fireTraceEndEvent
(
sort
)
;
}
return
keys
;
}
public
Vector
getElementCallstack
(
)
{
Vector
elems
=
new
Vector
(
)
;
int
nStackSize
=
m_currentTemplateElementsTop
;
for
(
int
i
=
0
;
i
<
nStackSize
;
i
++
)
{
ElemTemplateElement
elem
=
m_currentTemplateElements
[
i
]
;
if
(
null
!=
elem
)
{
elems
.
addElement
(
elem
)
;
}
}
return
elems
;
}
public
int
getCurrentTemplateElementsCount
(
)
{
return
m_currentTemplateElementsTop
;
}
public
ElemTemplateElement
[
]
getCurrentTemplateElements
(
)
{
return
m_currentTemplateElements
;
}
public
void
pushElemTemplateElement
(
ElemTemplateElement
elem
)
{
m_currentTemplateElements
[
m_currentTemplateElementsTop
++
]
=
elem
;
}
public
void
popElemTemplateElement
(
)
{
m_currentTemplateElementsTop
--
;
}
public
void
setCurrentElement
(
ElemTemplateElement
e
)
{
m_currentTemplateElements
[
m_currentTemplateElementsTop
-
1
]
=
e
;
}
public
ElemTemplateElement
getCurrentElement
(
)
{
return
(
m_currentTemplateElementsTop
>
0
)
?
m_currentTemplateElements
[
m_currentTemplateElementsTop
-
1
]
:
null
;
}
public
int
getCurrentNode
(
)
{
return
m_xcontext
.
getCurrentNode
(
)
;
}
public
Vector
getTemplateCallstack
(
)
{
Vector
elems
=
new
Vector
(
)
;
int
nStackSize
=
m_currentTemplateElementsTop
;
for
(
int
i
=
0
;
i
<
nStackSize
;
i
++
)
{
ElemTemplateElement
elem
=
m_currentTemplateElements
[
i
]
;
if
(
null
!=
elem
&&
(
elem
.
getXSLToken
(
)
!=
Constants
.
ELEMNAME_TEMPLATE
)
)
{
elems
.
addElement
(
elem
)
;
}
}
return
elems
;
}
public
ElemTemplate
getCurrentTemplate
(
)
{
ElemTemplateElement
elem
=
getCurrentElement
(
)
;
while
(
(
null
!=
elem
)
&&
(
elem
.
getXSLToken
(
)
!=
Constants
.
ELEMNAME_TEMPLATE
)
)
{
elem
=
elem
.
getParentElem
(
)
;
}
return
(
ElemTemplate
)
elem
;
}
public
void
pushPairCurrentMatched
(
ElemTemplateElement
template
,
int
child
)
{
m_currentMatchTemplates
.
push
(
template
)
;
m_currentMatchedNodes
.
push
(
child
)
;
}
public
void
popCurrentMatched
(
)
{
m_currentMatchTemplates
.
pop
(
)
;
m_currentMatchedNodes
.
pop
(
)
;
}
public
ElemTemplate
getMatchedTemplate
(
)
{
return
(
ElemTemplate
)
m_currentMatchTemplates
.
peek
(
)
;
}
public
int
getMatchedNode
(
)
{
return
m_currentMatchedNodes
.
peepTail
(
)
;
}
public
DTMIterator
getContextNodeList
(
)
{
try
{
DTMIterator
cnl
=
m_xcontext
.
getContextNodeList
(
)
;
return
(
cnl
==
null
)
?
null
:
(
DTMIterator
)
cnl
.
cloneWithReset
(
)
;
}
catch
(
CloneNotSupportedException
cnse
)
{
return
null
;
}
}
public
Transformer
getTransformer
(
)
{
return
this
;
}
public
void
setStylesheet
(
StylesheetRoot
stylesheetRoot
)
{
m_stylesheetRoot
=
stylesheetRoot
;
}
public
final
StylesheetRoot
getStylesheet
(
)
{
return
m_stylesheetRoot
;
}
public
boolean
getQuietConflictWarnings
(
)
{
return
m_quietConflictWarnings
;
}
public
void
setQuietConflictWarnings
(
boolean
b
)
{
m_quietConflictWarnings
=
b
;
}
public
void
setXPathContext
(
XPathContext
xcontext
)
{
m_xcontext
=
xcontext
;
}
public
final
XPathContext
getXPathContext
(
)
{
return
m_xcontext
;
}
public
StackGuard
getStackGuard
(
)
{
return
m_stackGuard
;
}
public
int
getRecursionLimit
(
)
{
return
m_stackGuard
.
getRecursionLimit
(
)
;
}
public
void
setRecursionLimit
(
int
limit
)
{
m_stackGuard
.
setRecursionLimit
(
limit
)
;
}
public
ResultTreeHandler
getResultTreeHandler
(
)
{
return
m_resultTreeHandler
;
}
public
KeyManager
getKeyManager
(
)
{
return
m_keyManager
;
}
public
boolean
isRecursiveAttrSet
(
ElemAttributeSet
attrSet
)
{
if
(
null
==
m_attrSetStack
)
{
m_attrSetStack
=
new
Stack
(
)
;
}
if
(
!
m_attrSetStack
.
empty
(
)
)
{
int
loc
=
m_attrSetStack
.
search
(
attrSet
)
;
if
(
loc
>
-
1
)
{
return
true
;
}
}
return
false
;
}
public
void
pushElemAttributeSet
(
ElemAttributeSet
attrSet
)
{
m_attrSetStack
.
push
(
attrSet
)
;
}
public
void
popElemAttributeSet
(
)
{
m_attrSetStack
.
pop
(
)
;
}
public
CountersTable
getCountersTable
(
)
{
if
(
null
==
m_countersTable
)
m_countersTable
=
new
CountersTable
(
)
;
return
m_countersTable
;
}
public
boolean
currentTemplateRuleIsNull
(
)
{
return
(
(
!
m_currentTemplateRuleIsNull
.
isEmpty
(
)
)
&&
(
m_currentTemplateRuleIsNull
.
peek
(
)
==
true
)
)
;
}
public
void
pushCurrentTemplateRuleIsNull
(
boolean
b
)
{
m_currentTemplateRuleIsNull
.
push
(
b
)
;
}
public
void
popCurrentTemplateRuleIsNull
(
)
{
m_currentTemplateRuleIsNull
.
pop
(
)
;
}
public
MsgMgr
getMsgMgr
(
)
{
if
(
null
==
m_msgMgr
)
m_msgMgr
=
new
MsgMgr
(
this
)
;
return
m_msgMgr
;
}
public
void
setErrorListener
(
ErrorListener
listener
)
throws
IllegalArgumentException
{
synchronized
(
m_reentryGuard
)
{
if
(
listener
==
null
)
throw
new
IllegalArgumentException
(
XSLMessages
.
createMessage
(
XSLTErrorResources
.
ER_NULL_ERROR_HANDLER
,
null
)
)
;
m_errorHandler
=
listener
;
}
}
public
ErrorListener
getErrorListener
(
)
{
return
m_errorHandler
;
}
public
TraceManager
getTraceManager
(
)
{
return
m_traceManager
;
}
public
boolean
getFeature
(
String
name
)
throws
SAXNotRecognizedException
,
SAXNotSupportedException
{
if
(
"http://xml.org/trax/features/sax/input"
.
equals
(
name
)
)
return
true
;
else
if
(
"http://xml.org/trax/features/dom/input"
.
equals
(
name
)
)
return
true
;
throw
new
SAXNotRecognizedException
(
name
)
;
}
public
QName
getMode
(
)
{
return
m_modes
.
isEmpty
(
)
?
null
:
(
QName
)
m_modes
.
peek
(
)
;
}
public
void
pushMode
(
QName
mode
)
{
m_modes
.
push
(
mode
)
;
}
public
void
popMode
(
)
{
m_modes
.
pop
(
)
;
}
public
static
class
ThreadControler
{
public
Thread
run
(
Runnable
task
,
int
priority
)
{
Thread
t
=
new
Thread
(
task
)
;
t
.
start
(
)
;
return
t
;
}
public
void
waitThread
(
Thread
worker
,
Runnable
task
)
throws
InterruptedException
{
worker
.
join
(
)
;
}
}
static
ThreadControler
tpool
=
new
ThreadControler
(
)
;
public
static
void
setThreadControler
(
ThreadControler
tp
)
{
tpool
=
tp
;
}
public
void
runTransformThread
(
int
priority
)
{
Thread
t
=
tpool
.
run
(
this
,
priority
)
;
this
.
setTransformThread
(
t
)
;
}
public
void
runTransformThread
(
)
{
tpool
.
run
(
this
,
-
1
)
;
}
public
static
void
runTransformThread
(
Runnable
runnable
)
{
tpool
.
run
(
runnable
,
-
1
)
;
}
public
void
waitTransformThread
(
)
throws
SAXException
{
Thread
transformThread
=
this
.
getTransformThread
(
)
;
if
(
null
!=
transformThread
)
{
try
{
tpool
.
waitThread
(
transformThread
,
this
)
;
if
(
!
this
.
hasTransformThreadErrorCatcher
(
)
)
{
Exception
e
=
this
.
getExceptionThrown
(
)
;
if
(
null
!=
e
)
{
e
.
printStackTrace
(
)
;
throw
new
org
.
xml
.
sax
.
SAXException
(
e
)
;
}
}
this
.
setTransformThread
(
null
)
;
}
catch
(
InterruptedException
ie
)
{
}
}
}
public
Exception
getExceptionThrown
(
)
{
return
m_exceptionThrown
;
}
public
void
setExceptionThrown
(
Exception
e
)
{
m_exceptionThrown
=
e
;
}
public
void
setSourceTreeDocForThread
(
int
doc
)
{
m_doc
=
doc
;
}
public
void
setXMLSource
(
Source
source
)
{
m_xmlSource
=
source
;
}
public
boolean
isTransformDone
(
)
{
synchronized
(
this
)
{
return
m_isTransformDone
;
}
}
public
void
setIsTransformDone
(
boolean
done
)
{
synchronized
(
this
)
{
m_isTransformDone
=
done
;
}
}
void
postExceptionFromThread
(
Exception
e
)
{
ContentHandler
ch
=
getContentHandler
(
)
;
m_isTransformDone
=
true
;
m_exceptionThrown
=
e
;
;
synchronized
(
this
)
{
notifyAll
(
)
;
}
}
public
void
run
(
)
{
m_hasBeenReset
=
false
;
try
{
try
{
m_isTransformDone
=
false
;
transformNode
(
m_doc
)
;
}
catch
(
Exception
e
)
{
if
(
null
!=
m_transformThread
)
postExceptionFromThread
(
e
)
;
else
throw
new
RuntimeException
(
e
.
getMessage
(
)
)
;
}
finally
{
m_isTransformDone
=
true
;
if
(
m_inputContentHandler
instanceof
TransformerHandlerImpl
)
{
(
(
TransformerHandlerImpl
)
m_inputContentHandler
)
.
clearCoRoutine
(
)
;
}
}
}
catch
(
Exception
e
)
{
if
(
null
!=
m_transformThread
)
postExceptionFromThread
(
e
)
;
else
throw
new
RuntimeException
(
e
.
getMessage
(
)
)
;
}
}
public
TransformSnapshot
getSnapshot
(
)
{
return
new
TransformSnapshotImpl
(
this
)
;
}
public
void
executeFromSnapshot
(
TransformSnapshot
ts
)
throws
TransformerException
{
ElemTemplateElement
template
=
getMatchedTemplate
(
)
;
int
child
=
getMatchedNode
(
)
;
pushElemTemplateElement
(
template
)
;
m_xcontext
.
pushCurrentNode
(
child
)
;
this
.
executeChildTemplates
(
template
,
true
)
;
}
public
void
resetToStylesheet
(
TransformSnapshot
ts
)
{
(
(
TransformSnapshotImpl
)
ts
)
.
apply
(
this
)
;
}
public
void
stopTransformation
(
)
{
}
public
short
getShouldStripSpace
(
int
elementHandle
,
DTM
dtm
)
{
try
{
org
.
apache
.
xalan
.
templates
.
WhiteSpaceInfo
info
=
m_stylesheetRoot
.
getWhiteSpaceInfo
(
m_xcontext
,
elementHandle
,
dtm
)
;
if
(
null
==
info
)
{
return
DTMWSFilter
.
INHERIT
;
}
else
{
return
info
.
getShouldStripSpace
(
)
?
DTMWSFilter
.
STRIP
:
DTMWSFilter
.
NOTSTRIP
;
}
}
catch
(
TransformerException
se
)
{
return
DTMWSFilter
.
INHERIT
;
}
}
}
