package
org
.
apache
.
xalan
.
templates
;
import
org
.
apache
.
xml
.
dtm
.
DTM
;
import
javax
.
xml
.
transform
.
TransformerException
;
import
org
.
apache
.
xml
.
utils
.
QName
;
import
org
.
apache
.
xalan
.
res
.
XSLTErrorResources
;
import
org
.
apache
.
xalan
.
res
.
XSLMessages
;
import
org
.
apache
.
xalan
.
transformer
.
TransformerImpl
;
import
org
.
apache
.
xalan
.
transformer
.
ResultTreeHandler
;
import
org
.
apache
.
xpath
.
XPathContext
;
import
org
.
xml
.
sax
.
SAXException
;
public
class
ElemAttribute
extends
ElemElement
{
public
int
getXSLToken
(
)
{
return
Constants
.
ELEMNAME_ATTRIBUTE
;
}
public
String
getNodeName
(
)
{
return
Constants
.
ELEMNAME_ATTRIBUTE_STRING
;
}
public
void
execute
(
TransformerImpl
transformer
)
throws
TransformerException
{
ResultTreeHandler
rhandler
=
transformer
.
getResultTreeHandler
(
)
;
if
(
!
rhandler
.
isElementPending
(
)
)
{
if
(
TransformerImpl
.
S_DEBUG
)
transformer
.
getTraceManager
(
)
.
fireTraceEvent
(
this
)
;
XPathContext
xctxt
=
transformer
.
getXPathContext
(
)
;
int
sourceNode
=
xctxt
.
getCurrentNode
(
)
;
String
attrName
=
m_name_avt
.
evaluate
(
xctxt
,
sourceNode
,
this
)
;
transformer
.
getMsgMgr
(
)
.
warn
(
this
,
XSLTErrorResources
.
WG_ILLEGAL_ATTRIBUTE
,
new
Object
[
]
{
attrName
}
)
;
if
(
TransformerImpl
.
S_DEBUG
)
transformer
.
getTraceManager
(
)
.
fireTraceEndEvent
(
this
)
;
return
;
}
super
.
execute
(
transformer
)
;
}
protected
String
resolvePrefix
(
ResultTreeHandler
rhandler
,
String
prefix
,
String
nodeNamespace
)
throws
TransformerException
{
if
(
null
!=
prefix
&&
(
prefix
.
length
(
)
==
0
||
prefix
.
equals
(
"xmlns"
)
)
)
{
prefix
=
rhandler
.
getPrefix
(
nodeNamespace
)
;
if
(
null
==
prefix
||
prefix
.
length
(
)
==
0
||
prefix
.
equals
(
"xmlns"
)
)
{
if
(
nodeNamespace
.
length
(
)
>
0
)
{
prefix
=
rhandler
.
getNewUniqueNSPrefix
(
)
;
}
else
prefix
=
""
;
}
}
return
prefix
;
}
protected
boolean
validateNodeName
(
String
nodeName
)
{
if
(
null
==
nodeName
)
return
false
;
if
(
nodeName
.
equals
(
"xmlns"
)
)
return
false
;
return
super
.
validateNodeName
(
nodeName
)
;
}
void
constructNode
(
String
nodeName
,
String
prefix
,
String
nodeNamespace
,
TransformerImpl
transformer
)
throws
TransformerException
{
if
(
null
!=
nodeName
&&
nodeName
.
length
(
)
>
0
)
{
ResultTreeHandler
rhandler
=
transformer
.
getResultTreeHandler
(
)
;
if
(
prefix
!=
null
&&
prefix
.
length
(
)
>
0
)
{
try
{
rhandler
.
startPrefixMapping
(
prefix
,
nodeNamespace
,
false
)
;
}
catch
(
SAXException
se
)
{
throw
new
TransformerException
(
se
)
;
}
}
String
val
=
transformer
.
transformToString
(
this
)
;
String
localName
=
QName
.
getLocalPart
(
nodeName
)
;
rhandler
.
addAttribute
(
nodeNamespace
,
localName
,
nodeName
,
"CDATA"
,
val
)
;
}
}
public
ElemTemplateElement
appendChild
(
ElemTemplateElement
newChild
)
{
int
type
=
(
(
ElemTemplateElement
)
newChild
)
.
getXSLToken
(
)
;
switch
(
type
)
{
case
Constants
.
ELEMNAME_TEXTLITERALRESULT
:
case
Constants
.
ELEMNAME_APPLY_TEMPLATES
:
case
Constants
.
ELEMNAME_APPLY_IMPORTS
:
case
Constants
.
ELEMNAME_CALLTEMPLATE
:
case
Constants
.
ELEMNAME_FOREACH
:
case
Constants
.
ELEMNAME_VALUEOF
:
case
Constants
.
ELEMNAME_COPY_OF
:
case
Constants
.
ELEMNAME_NUMBER
:
case
Constants
.
ELEMNAME_CHOOSE
:
case
Constants
.
ELEMNAME_IF
:
case
Constants
.
ELEMNAME_TEXT
:
case
Constants
.
ELEMNAME_COPY
:
case
Constants
.
ELEMNAME_VARIABLE
:
case
Constants
.
ELEMNAME_MESSAGE
:
break
;
default
:
error
(
XSLTErrorResources
.
ER_CANNOT_ADD
,
new
Object
[
]
{
newChild
.
getNodeName
(
)
,
this
.
getNodeName
(
)
}
)
;
}
return
super
.
appendChild
(
newChild
)
;
}
public
void
setName
(
AVT
v
)
{
if
(
v
.
isSimple
(
)
)
{
if
(
v
.
getSimpleString
(
)
.
equals
(
"xmlns"
)
)
{
throw
new
IllegalArgumentException
(
)
;
}
}
super
.
setName
(
v
)
;
}
}
