package
org
.
apache
.
xalan
.
extensions
;
import
java
.
util
.
Vector
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
lang
.
reflect
.
Modifier
;
import
java
.
lang
.
reflect
.
Constructor
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
io
.
IOException
;
import
org
.
apache
.
xalan
.
transformer
.
TransformerImpl
;
import
org
.
apache
.
xalan
.
templates
.
Stylesheet
;
import
org
.
apache
.
xalan
.
templates
.
ElemTemplateElement
;
import
org
.
apache
.
xml
.
utils
.
QName
;
import
org
.
apache
.
xpath
.
objects
.
XObject
;
import
javax
.
xml
.
transform
.
TransformerException
;
public
class
ExtensionHandlerJavaClass
extends
ExtensionHandlerJava
{
private
Class
m_classObj
=
null
;
private
Object
m_defaultInstance
=
null
;
public
ExtensionHandlerJavaClass
(
String
namespaceUri
,
String
scriptLang
,
String
className
)
{
super
(
namespaceUri
,
scriptLang
,
className
)
;
try
{
m_classObj
=
getClassForName
(
className
)
;
}
catch
(
ClassNotFoundException
e
)
{
}
}
public
boolean
isFunctionAvailable
(
String
function
)
{
Method
[
]
methods
=
m_classObj
.
getMethods
(
)
;
int
nMethods
=
methods
.
length
;
for
(
int
i
=
0
;
i
<
nMethods
;
i
++
)
{
if
(
methods
[
i
]
.
getName
(
)
.
equals
(
function
)
)
return
true
;
}
return
false
;
}
public
boolean
isElementAvailable
(
String
element
)
{
Method
[
]
methods
=
m_classObj
.
getMethods
(
)
;
int
nMethods
=
methods
.
length
;
for
(
int
i
=
0
;
i
<
nMethods
;
i
++
)
{
if
(
methods
[
i
]
.
getName
(
)
.
equals
(
element
)
)
{
Class
[
]
paramTypes
=
methods
[
i
]
.
getParameterTypes
(
)
;
if
(
(
paramTypes
.
length
==
2
)
&&
paramTypes
[
0
]
.
isAssignableFrom
(
org
.
apache
.
xalan
.
extensions
.
XSLProcessorContext
.
class
)
&&
paramTypes
[
1
]
.
isAssignableFrom
(
org
.
apache
.
xalan
.
templates
.
ElemExtensionCall
.
class
)
)
{
return
true
;
}
}
}
return
false
;
}
public
Object
callFunction
(
String
funcName
,
Vector
args
,
Object
methodKey
,
ExpressionContext
exprContext
)
throws
TransformerException
{
Object
[
]
methodArgs
;
Object
[
]
[
]
convertedArgs
;
Class
[
]
paramTypes
;
try
{
if
(
funcName
.
equals
(
"new"
)
)
{
methodArgs
=
new
Object
[
args
.
size
(
)
]
;
convertedArgs
=
new
Object
[
1
]
[
]
;
for
(
int
i
=
0
;
i
<
methodArgs
.
length
;
i
++
)
{
methodArgs
[
i
]
=
args
.
elementAt
(
i
)
;
}
Constructor
c
=
(
Constructor
)
getFromCache
(
methodKey
,
null
,
methodArgs
)
;
if
(
c
!=
null
)
{
try
{
paramTypes
=
c
.
getParameterTypes
(
)
;
MethodResolver
.
convertParams
(
methodArgs
,
convertedArgs
,
paramTypes
,
exprContext
)
;
return
c
.
newInstance
(
convertedArgs
[
0
]
)
;
}
catch
(
Exception
e
)
{
}
}
c
=
MethodResolver
.
getConstructor
(
m_classObj
,
methodArgs
,
convertedArgs
,
exprContext
)
;
putToCache
(
methodKey
,
null
,
methodArgs
,
c
)
;
return
c
.
newInstance
(
convertedArgs
[
0
]
)
;
}
else
{
int
resolveType
;
Object
targetObject
=
null
;
methodArgs
=
new
Object
[
args
.
size
(
)
]
;
convertedArgs
=
new
Object
[
1
]
[
]
;
for
(
int
i
=
0
;
i
<
methodArgs
.
length
;
i
++
)
{
methodArgs
[
i
]
=
args
.
elementAt
(
i
)
;
}
Method
m
=
(
Method
)
getFromCache
(
methodKey
,
null
,
methodArgs
)
;
if
(
m
!=
null
)
{
try
{
paramTypes
=
m
.
getParameterTypes
(
)
;
MethodResolver
.
convertParams
(
methodArgs
,
convertedArgs
,
paramTypes
,
exprContext
)
;
if
(
Modifier
.
isStatic
(
m
.
getModifiers
(
)
)
)
return
m
.
invoke
(
null
,
convertedArgs
[
0
]
)
;
else
{
int
nTargetArgs
=
convertedArgs
[
0
]
.
length
;
if
(
ExpressionContext
.
class
.
isAssignableFrom
(
paramTypes
[
0
]
)
)
nTargetArgs
--
;
if
(
methodArgs
.
length
<=
nTargetArgs
)
return
m
.
invoke
(
m_defaultInstance
,
convertedArgs
[
0
]
)
;
else
{
targetObject
=
methodArgs
[
0
]
;
if
(
targetObject
instanceof
XObject
)
targetObject
=
(
(
XObject
)
targetObject
)
.
object
(
)
;
return
m
.
invoke
(
targetObject
,
convertedArgs
[
0
]
)
;
}
}
}
catch
(
Exception
e
)
{
}
}
if
(
args
.
size
(
)
>
0
)
{
targetObject
=
methodArgs
[
0
]
;
if
(
targetObject
instanceof
XObject
)
targetObject
=
(
(
XObject
)
targetObject
)
.
object
(
)
;
if
(
m_classObj
.
isAssignableFrom
(
targetObject
.
getClass
(
)
)
)
resolveType
=
MethodResolver
.
DYNAMIC
;
else
resolveType
=
MethodResolver
.
STATIC_AND_INSTANCE
;
}
else
{
targetObject
=
null
;
resolveType
=
MethodResolver
.
STATIC_AND_INSTANCE
;
}
m
=
MethodResolver
.
getMethod
(
m_classObj
,
funcName
,
methodArgs
,
convertedArgs
,
exprContext
,
resolveType
)
;
putToCache
(
methodKey
,
null
,
methodArgs
,
m
)
;
if
(
MethodResolver
.
DYNAMIC
==
resolveType
)
return
m
.
invoke
(
targetObject
,
convertedArgs
[
0
]
)
;
else
{
if
(
Modifier
.
isStatic
(
m
.
getModifiers
(
)
)
)
return
m
.
invoke
(
null
,
convertedArgs
[
0
]
)
;
else
{
if
(
null
==
m_defaultInstance
)
{
m_defaultInstance
=
m_classObj
.
newInstance
(
)
;
}
return
m
.
invoke
(
m_defaultInstance
,
convertedArgs
[
0
]
)
;
}
}
}
}
catch
(
InvocationTargetException
ite
)
{
Throwable
realException
=
ite
.
getTargetException
(
)
;
if
(
realException
instanceof
Exception
)
throw
new
TransformerException
(
(
Exception
)
realException
)
;
else
throw
new
TransformerException
(
ite
)
;
}
catch
(
Exception
e
)
{
throw
new
TransformerException
(
e
)
;
}
}
public
void
processElement
(
String
localPart
,
ElemTemplateElement
element
,
TransformerImpl
transformer
,
Stylesheet
stylesheetTree
,
Object
methodKey
)
throws
TransformerException
,
IOException
{
Object
result
=
null
;
Method
m
=
(
Method
)
getFromCache
(
methodKey
,
null
,
null
)
;
if
(
null
==
m
)
{
try
{
m
=
MethodResolver
.
getElementMethod
(
m_classObj
,
localPart
)
;
if
(
(
null
==
m_defaultInstance
)
&&
!
Modifier
.
isStatic
(
m
.
getModifiers
(
)
)
)
m_defaultInstance
=
m_classObj
.
newInstance
(
)
;
}
catch
(
Exception
e
)
{
throw
new
TransformerException
(
e
.
getMessage
(
)
,
e
)
;
}
putToCache
(
methodKey
,
null
,
null
,
m
)
;
}
XSLProcessorContext
xpc
=
new
XSLProcessorContext
(
transformer
,
stylesheetTree
)
;
try
{
result
=
m
.
invoke
(
m_defaultInstance
,
new
Object
[
]
{
xpc
,
element
}
)
;
}
catch
(
InvocationTargetException
e
)
{
Throwable
targetException
=
e
.
getTargetException
(
)
;
if
(
targetException
!=
null
)
throw
new
TransformerException
(
targetException
.
getMessage
(
)
,
targetException
)
;
else
throw
new
TransformerException
(
e
.
getMessage
(
)
,
e
)
;
}
catch
(
Exception
e
)
{
throw
new
TransformerException
(
e
.
getMessage
(
)
,
e
)
;
}
if
(
result
!=
null
)
{
xpc
.
outputToResultTree
(
stylesheetTree
,
result
)
;
}
}
}
