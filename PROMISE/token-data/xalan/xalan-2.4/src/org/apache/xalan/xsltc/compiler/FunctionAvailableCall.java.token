package
org
.
apache
.
xalan
.
xsltc
.
compiler
;
import
java
.
util
.
Vector
;
import
java
.
lang
.
reflect
.
Modifier
;
import
java
.
lang
.
reflect
.
Method
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
util
.
Type
;
import
org
.
apache
.
bcel
.
generic
.
*
;
import
org
.
apache
.
xalan
.
xsltc
.
compiler
.
util
.
*
;
import
org
.
apache
.
xalan
.
xsltc
.
runtime
.
TransletLoader
;
final
class
FunctionAvailableCall
extends
FunctionCall
{
private
Expression
_arg
;
private
String
_nameOfFunct
=
null
;
private
String
_namespaceOfFunct
=
null
;
private
boolean
_isFunctionAvailable
=
false
;
public
FunctionAvailableCall
(
QName
fname
,
Vector
arguments
)
{
super
(
fname
,
arguments
)
;
_arg
=
(
Expression
)
arguments
.
elementAt
(
0
)
;
_type
=
null
;
if
(
_arg
instanceof
LiteralExpr
)
{
LiteralExpr
arg
=
(
LiteralExpr
)
_arg
;
_namespaceOfFunct
=
arg
.
getNamespace
(
)
;
_nameOfFunct
=
arg
.
getValue
(
)
;
if
(
_namespaceOfFunct
!=
null
&&
(
_namespaceOfFunct
.
startsWith
(
JAVA_EXT_XSLTC
)
||
_namespaceOfFunct
.
startsWith
(
JAVA_EXT_XALAN
)
)
)
{
_isFunctionAvailable
=
hasMethods
(
)
;
}
}
}
public
Type
typeCheck
(
SymbolTable
stable
)
throws
TypeCheckError
{
if
(
_type
!=
null
)
{
return
_type
;
}
if
(
_arg
instanceof
LiteralExpr
)
{
return
_type
=
Type
.
Boolean
;
}
ErrorMsg
err
=
new
ErrorMsg
(
ErrorMsg
.
NEED_LITERAL_ERR
,
"function-available"
,
this
)
;
throw
new
TypeCheckError
(
err
)
;
}
public
Object
evaluateAtCompileTime
(
)
{
return
getResult
(
)
?
Boolean
.
TRUE
:
Boolean
.
FALSE
;
}
private
String
getClassName
(
String
argValue
)
{
int
colonSep
=
argValue
.
indexOf
(
":"
)
;
if
(
colonSep
!=
-
1
)
{
argValue
=
argValue
.
substring
(
colonSep
+
1
)
;
}
int
lastDot
=
argValue
.
lastIndexOf
(
"."
)
;
if
(
lastDot
!=
-
1
)
{
argValue
=
argValue
.
substring
(
0
,
lastDot
)
;
}
return
argValue
;
}
private
String
getMethodName
(
String
argValue
)
{
int
lastDot
=
argValue
.
lastIndexOf
(
"."
)
;
if
(
lastDot
!=
-
1
)
{
argValue
=
argValue
.
substring
(
lastDot
+
1
)
;
}
return
argValue
;
}
private
String
getExternalFunctionName
(
)
{
int
colonIndex
=
_nameOfFunct
.
indexOf
(
":"
)
;
String
uri
=
_namespaceOfFunct
+
"."
+
_nameOfFunct
.
substring
(
colonIndex
+
1
)
;
try
{
return
getClassNameFromUri
(
uri
)
;
}
catch
(
TypeCheckError
e
)
{
return
null
;
}
}
private
boolean
hasMethods
(
)
{
LiteralExpr
arg
=
(
LiteralExpr
)
_arg
;
final
String
externalFunctName
=
getExternalFunctionName
(
)
;
if
(
externalFunctName
==
null
)
{
return
false
;
}
final
String
className
=
getClassName
(
externalFunctName
)
;
try
{
TransletLoader
loader
=
new
TransletLoader
(
)
;
final
Class
clazz
=
loader
.
loadClass
(
className
)
;
if
(
clazz
==
null
)
{
final
ErrorMsg
msg
=
new
ErrorMsg
(
ErrorMsg
.
CLASS_NOT_FOUND_ERR
,
className
)
;
getParser
(
)
.
reportError
(
Constants
.
ERROR
,
msg
)
;
}
else
{
final
String
methodName
=
getMethodName
(
externalFunctName
)
;
final
Method
[
]
methods
=
clazz
.
getDeclaredMethods
(
)
;
for
(
int
i
=
0
;
i
<
methods
.
length
;
i
++
)
{
final
int
mods
=
methods
[
i
]
.
getModifiers
(
)
;
if
(
Modifier
.
isPublic
(
mods
)
&&
Modifier
.
isStatic
(
mods
)
&&
methods
[
i
]
.
getName
(
)
.
equals
(
methodName
)
)
{
return
true
;
}
}
}
}
catch
(
ClassNotFoundException
e
)
{
final
ErrorMsg
msg
=
new
ErrorMsg
(
ErrorMsg
.
CLASS_NOT_FOUND_ERR
,
className
)
;
getParser
(
)
.
reportError
(
Constants
.
ERROR
,
msg
)
;
}
return
false
;
}
public
boolean
getResult
(
)
{
if
(
_nameOfFunct
==
null
)
{
return
false
;
}
if
(
_namespaceOfFunct
==
null
||
_namespaceOfFunct
.
equals
(
EMPTYSTRING
)
||
_namespaceOfFunct
.
equals
(
EXT_XALAN
)
||
_namespaceOfFunct
.
equals
(
TRANSLET_URI
)
)
{
final
Parser
parser
=
getParser
(
)
;
_isFunctionAvailable
=
parser
.
functionSupported
(
Util
.
getLocalName
(
_nameOfFunct
)
)
;
}
return
_isFunctionAvailable
;
}
public
void
translate
(
ClassGenerator
classGen
,
MethodGenerator
methodGen
)
{
final
ConstantPoolGen
cpg
=
classGen
.
getConstantPool
(
)
;
methodGen
.
getInstructionList
(
)
.
append
(
new
PUSH
(
cpg
,
getResult
(
)
)
)
;
}
}
