package
org
.
apache
.
xml
.
serializer
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Stack
;
import
org
.
xml
.
sax
.
ContentHandler
;
import
org
.
xml
.
sax
.
SAXException
;
public
class
NamespaceMappings
{
private
int
count
=
0
;
private
java
.
util
.
Stack
m_prefixStack
=
new
Stack
(
)
;
private
Hashtable
m_namespaces
=
new
Hashtable
(
)
;
private
Stack
m_nodeStack
=
new
Stack
(
)
;
private
static
final
String
EMPTYSTRING
=
""
;
private
static
final
String
XML_PREFIX
=
"xml"
;
public
NamespaceMappings
(
)
{
initNamespaces
(
)
;
}
private
void
initNamespaces
(
)
{
Stack
stack
;
m_namespaces
.
put
(
EMPTYSTRING
,
stack
=
new
Stack
(
)
)
;
stack
.
push
(
EMPTYSTRING
)
;
m_prefixStack
.
push
(
EMPTYSTRING
)
;
m_namespaces
.
put
(
XML_PREFIX
,
stack
=
new
Stack
(
)
)
;
stack
.
push
(
"http://www.w3.org/XML/1998/namespace"
)
;
m_prefixStack
.
push
(
XML_PREFIX
)
;
m_nodeStack
.
push
(
new
Integer
(
-
1
)
)
;
}
public
String
lookupNamespace
(
String
prefix
)
{
final
Stack
stack
=
(
Stack
)
m_namespaces
.
get
(
prefix
)
;
return
stack
!=
null
&&
!
stack
.
isEmpty
(
)
?
(
String
)
stack
.
peek
(
)
:
null
;
}
public
String
lookupPrefix
(
String
uri
)
{
String
foundPrefix
=
null
;
Enumeration
prefixes
=
m_namespaces
.
keys
(
)
;
while
(
prefixes
.
hasMoreElements
(
)
)
{
String
prefix
=
(
String
)
prefixes
.
nextElement
(
)
;
String
uri2
=
lookupNamespace
(
prefix
)
;
if
(
uri2
!=
null
&&
uri2
.
equals
(
uri
)
)
{
foundPrefix
=
prefix
;
break
;
}
}
return
foundPrefix
;
}
public
boolean
popNamespace
(
String
prefix
)
{
if
(
prefix
.
startsWith
(
XML_PREFIX
)
)
{
return
false
;
}
Stack
stack
;
if
(
(
stack
=
(
Stack
)
m_namespaces
.
get
(
prefix
)
)
!=
null
)
{
stack
.
pop
(
)
;
return
true
;
}
return
false
;
}
public
boolean
pushNamespace
(
String
prefix
,
String
uri
,
int
elemDepth
)
{
if
(
prefix
.
startsWith
(
XML_PREFIX
)
)
{
return
false
;
}
Stack
stack
;
if
(
(
stack
=
(
Stack
)
m_namespaces
.
get
(
prefix
)
)
==
null
)
{
m_namespaces
.
put
(
prefix
,
stack
=
new
Stack
(
)
)
;
}
if
(
!
stack
.
empty
(
)
&&
uri
.
equals
(
stack
.
peek
(
)
)
)
{
return
false
;
}
stack
.
push
(
uri
)
;
m_prefixStack
.
push
(
prefix
)
;
m_nodeStack
.
push
(
new
Integer
(
elemDepth
)
)
;
return
true
;
}
public
void
popNamespaces
(
int
elemDepth
,
ContentHandler
saxHandler
)
{
while
(
true
)
{
if
(
m_nodeStack
.
isEmpty
(
)
)
return
;
Integer
i
=
(
Integer
)
(
m_nodeStack
.
peek
(
)
)
;
if
(
i
.
intValue
(
)
<
elemDepth
)
return
;
m_nodeStack
.
pop
(
)
;
final
String
prefix
=
(
String
)
m_prefixStack
.
pop
(
)
;
popNamespace
(
prefix
)
;
if
(
saxHandler
!=
null
)
{
try
{
saxHandler
.
endPrefixMapping
(
prefix
)
;
}
catch
(
SAXException
e
)
{
}
}
}
}
public
String
generateNextPrefix
(
)
{
return
"ns"
+
(
count
++
)
;
}
public
Object
clone
(
)
throws
CloneNotSupportedException
{
NamespaceMappings
clone
=
new
NamespaceMappings
(
)
;
clone
.
m_prefixStack
=
(
Stack
)
m_prefixStack
.
clone
(
)
;
clone
.
m_nodeStack
=
(
Stack
)
m_nodeStack
.
clone
(
)
;
clone
.
m_namespaces
=
(
Hashtable
)
m_namespaces
.
clone
(
)
;
clone
.
count
=
count
;
return
clone
;
}
public
final
void
reset
(
)
{
this
.
count
=
0
;
this
.
m_namespaces
.
clear
(
)
;
this
.
m_nodeStack
.
clear
(
)
;
this
.
m_prefixStack
.
clear
(
)
;
initNamespaces
(
)
;
}
}
