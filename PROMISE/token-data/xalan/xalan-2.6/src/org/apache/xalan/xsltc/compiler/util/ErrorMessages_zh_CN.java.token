package
org
.
apache
.
xalan
.
xsltc
.
compiler
.
util
;
import
java
.
util
.
ListResourceBundle
;
public
class
ErrorMessages_zh_CN
extends
ListResourceBundle
{
private
static
final
String
[
]
[
]
m_errorMessages
=
{
{
ErrorMsg
.
MULTIPLE_STYLESHEET_ERR
,
"同一文件中定义了多个样式表。"
}
,
{
ErrorMsg
.
TEMPLATE_REDEF_ERR
,
"此样式表中已经定义了模板“{0}”。"
}
,
{
ErrorMsg
.
TEMPLATE_UNDEF_ERR
,
"此样式表中未定义模板“{0}”。"
}
,
{
ErrorMsg
.
VARIABLE_REDEF_ERR
,
"同一作用域中多次定义了变量“{0}”。"
}
,
{
ErrorMsg
.
VARIABLE_UNDEF_ERR
,
"未定义变量或参数“{0}”。"
}
,
{
ErrorMsg
.
CLASS_NOT_FOUND_ERR
,
"找不到类“{0}”。"
}
,
{
ErrorMsg
.
METHOD_NOT_FOUND_ERR
,
"找不到外部方法“{0}”（必须是 public）。"
}
,
{
ErrorMsg
.
ARGUMENT_CONVERSION_ERR
,
"无法将调用中的自变量／返回类型转换为方法“{0}”"
}
,
{
ErrorMsg
.
FILE_NOT_FOUND_ERR
,
"找不到文件或 URI“{0}”。"
}
,
{
ErrorMsg
.
INVALID_URI_ERR
,
"URI“{0}”无效。"
}
,
{
ErrorMsg
.
FILE_ACCESS_ERR
,
"无法打开文件或 URI“{0}”。"
}
,
{
ErrorMsg
.
MISSING_ROOT_ERR
,
"期望出现 <xsl:stylesheet> 或 <xsl:transform> 元素。"
}
,
{
ErrorMsg
.
NAMESPACE_UNDEF_ERR
,
"未说明名称空间前缀“{0}”。"
}
,
{
ErrorMsg
.
FUNCTION_RESOLVE_ERR
,
"无法解析对函数“{0}”的调用。"
}
,
{
ErrorMsg
.
NEED_LITERAL_ERR
,
"“{0}”的自变量必须是文字字符串。"
}
,
{
ErrorMsg
.
XPATH_PARSER_ERR
,
"分析 XPath 表达式“{0}”时出错。"
}
,
{
ErrorMsg
.
REQUIRED_ATTR_ERR
,
"缺少必需的属性“{0}”。"
}
,
{
ErrorMsg
.
ILLEGAL_CHAR_ERR
,
"XPath 表达式中的字符“{0}”非法。"
}
,
{
ErrorMsg
.
ILLEGAL_PI_ERR
,
"处理指令的名称“{0}”非法。"
}
,
{
ErrorMsg
.
STRAY_ATTRIBUTE_ERR
,
"属性“{0}”在元素外。"
}
,
{
ErrorMsg
.
ILLEGAL_ATTRIBUTE_ERR
,
"属性“{0}”非法。"
}
,
{
ErrorMsg
.
CIRCULAR_INCLUDE_ERR
,
"循环 import／include。已装入样式表“{0}”。"
}
,
{
ErrorMsg
.
RESULT_TREE_SORT_ERR
,
"无法排序结果树片段（<xsl:sort> 元素被忽略）。必须在创建结果树时对节点进行排序。"
}
,
{
ErrorMsg
.
SYMBOLS_REDEF_ERR
,
"已经定义了十进制格式的“{0}”。"
}
,
{
ErrorMsg
.
XSL_VERSION_ERR
,
"XSLTC 不支持 XSL 版本“{0}”。"
}
,
{
ErrorMsg
.
CIRCULAR_VARIABLE_ERR
,
"“{0}”中存在循环变量／参数引用。"
}
,
{
ErrorMsg
.
ILLEGAL_BINARY_OP_ERR
,
"二进制表达式的运算符未知。"
}
,
{
ErrorMsg
.
ILLEGAL_ARG_ERR
,
"函数调用的自变量非法。"
}
,
{
ErrorMsg
.
DOCUMENT_ARG_ERR
,
"函数 document() 的第二个自变量必须是节点集。"
}
,
{
ErrorMsg
.
MISSING_WHEN_ERR
,
"<xsl:choose> 中至少要有一个 <xsl:when> 元素。"
}
,
{
ErrorMsg
.
MULTIPLE_OTHERWISE_ERR
,
"<xsl:choose> 中只允许有一个 <xsl:otherwise> 元素。"
}
,
{
ErrorMsg
.
STRAY_OTHERWISE_ERR
,
"<xsl:otherwise> 只能在 <xsl:choose> 中使用。"
}
,
{
ErrorMsg
.
STRAY_WHEN_ERR
,
"<xsl:when> 只能在 <xsl:choose> 中使用。"
}
,
{
ErrorMsg
.
WHEN_ELEMENT_ERR
,
"<xsl:choose> 中只允许使用 <xsl:when> 和 <xsl:otherwise>。"
}
,
{
ErrorMsg
.
UNNAMED_ATTRIBSET_ERR
,
"<xsl:attribute-set> 缺少“name”属性。"
}
,
{
ErrorMsg
.
ILLEGAL_CHILD_ERR
,
"子元素非法。"
}
,
{
ErrorMsg
.
ILLEGAL_ELEM_NAME_ERR
,
"不能调用元素“{0}”"
}
,
{
ErrorMsg
.
ILLEGAL_ATTR_NAME_ERR
,
"不能调用属性“{0}”"
}
,
{
ErrorMsg
.
ILLEGAL_TEXT_NODE_ERR
,
"文本数据在顶级 <xsl:stylesheet> 元素外。"
}
,
{
ErrorMsg
.
SAX_PARSER_CONFIG_ERR
,
"JAXP 解析器没有正确配置"
}
,
{
ErrorMsg
.
INTERNAL_ERR
,
"不可恢复的 XSLTC 内部错误：“{0}”"
}
,
{
ErrorMsg
.
UNSUPPORTED_XSL_ERR
,
"不受支持的 XSL 元素“{0}”。"
}
,
{
ErrorMsg
.
UNSUPPORTED_EXT_ERR
,
"未被识别的 XSLTC 扩展名“{0}”。"
}
,
{
ErrorMsg
.
MISSING_XSLT_URI_ERR
,
"输入文档不是样式表（XSL 名称空间没有在根元素中说明）。"
}
,
{
ErrorMsg
.
MISSING_XSLT_TARGET_ERR
,
"找不到样式表目标“{0}”。"
}
,
{
ErrorMsg
.
NOT_IMPLEMENTED_ERR
,
"没有实现：“{0}”。"
}
,
{
ErrorMsg
.
NOT_STYLESHEET_ERR
,
"输入文档不包含 XSL 样式表。"
}
,
{
ErrorMsg
.
ELEMENT_PARSE_ERR
,
"无法分析元素“{0}”"
}
,
{
ErrorMsg
.
KEY_USE_ATTR_ERR
,
"<key> 的 use 属性必须是 node、node-set、string 或 number。"
}
,
{
ErrorMsg
.
OUTPUT_VERSION_ERR
,
"输出 XML 文档的版本应当是 1.0"
}
,
{
ErrorMsg
.
ILLEGAL_RELAT_OP_ERR
,
"关系表达式的运算符未知"
}
,
{
ErrorMsg
.
ATTRIBSET_UNDEF_ERR
,
"试图使用不存在的属性集“{0}”。"
}
,
{
ErrorMsg
.
ATTR_VAL_TEMPLATE_ERR
,
"无法分析属性值模板“{0}”。"
}
,
{
ErrorMsg
.
UNKNOWN_SIG_TYPE_ERR
,
"类“{0}”的签名中的数据类型未知。"
}
,
{
ErrorMsg
.
DATA_CONVERSION_ERR
,
"无法将数据类型“{0}”转换成“{1}”。"
}
,
{
ErrorMsg
.
NO_TRANSLET_CLASS_ERR
,
"此 Templates 不包含有效的 translet 类定义。"
}
,
{
ErrorMsg
.
NO_MAIN_TRANSLET_ERR
,
"此 Templates 不包含名为“{0}”的类。"
}
,
{
ErrorMsg
.
TRANSLET_CLASS_ERR
,
"无法装入 translet 类“{0}”。"
}
,
{
ErrorMsg
.
TRANSLET_OBJECT_ERR
,
"Translet 类已装入，但无法创建 translet 实例。"
}
,
{
ErrorMsg
.
ERROR_LISTENER_NULL_ERR
,
"试图将“{0}”的 ErrorListener 设置为 null"
}
,
{
ErrorMsg
.
JAXP_UNKNOWN_SOURCE_ERR
,
"XSLTC 只支持 StreamSource、SAXSource 和 DOMSource"
}
,
{
ErrorMsg
.
JAXP_NO_SOURCE_ERR
,
"传递给“{0}”的 Source 对象没有内容。"
}
,
{
ErrorMsg
.
JAXP_COMPILE_ERR
,
"无法编译样式表"
}
,
{
ErrorMsg
.
JAXP_INVALID_ATTR_ERR
,
"TransformerFactory 无法识别属性“{0}”。"
}
,
{
ErrorMsg
.
JAXP_SET_RESULT_ERR
,
"setResult() 必须在 startDocument() 之前调用。"
}
,
{
ErrorMsg
.
JAXP_NO_TRANSLET_ERR
,
"Transformer 没有封装的 translet 对象。"
}
,
{
ErrorMsg
.
JAXP_NO_HANDLER_ERR
,
"没有为转换结果定义输出处理程序。"
}
,
{
ErrorMsg
.
JAXP_NO_RESULT_ERR
,
"传递给“{0}”的 Result 对象无效。"
}
,
{
ErrorMsg
.
JAXP_UNKNOWN_PROP_ERR
,
"试图访问无效的 Transformer 属性“{0}”。"
}
,
{
ErrorMsg
.
SAX2DOM_ADAPTER_ERR
,
"无法创建 SAX2DOM 适配器：“{0}”。"
}
,
{
ErrorMsg
.
XSLTC_SOURCE_ERR
,
"没有设置 systemId 就调用 XSLTCSource.build()。"
}
,
{
ErrorMsg
.
COMPILE_STDIN_ERR
,
"-i 选项必须与 -o 选项一起使用。"
}
,
{
ErrorMsg
.
COMPILE_USAGE_STR
,
"SYNOPSIS\n java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n [-d <directory>] [-j <jarfile>] [-p <package>]\n [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\n OPTIONS\n -o <output>    将名称 <output> 指定给生成的 translet。\n缺省情况下，translet 名称\n 来自 <stylesheet> 的名称。\n 如果编译多个样式表，则忽略此选项。\n-d <directory> 指定 translet 的目标目录\n -j <jarfile>   将 translet 类封装成命名为 <jarfile>\n 的 jar 文件\n -p <package>   为所有生成的 translet 类\n指定软件包名称前缀。\n-n             启用模板内嵌（平均缺省\n行为更佳）。\n-x             打开额外的调试消息输出\n -s             禁止调用 System.exit\n -u             将 <stylesheet> 自变量解释为 URL\n -i             强制编译器从 stdin 读入样式表\n -v             打印编译器的版本\n -h             打印此用法语句\n"
}
,
{
ErrorMsg
.
TRANSFORM_USAGE_STR
,
"SYNOPSIS \n java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}\n <class> [<param1>=<value1> ...]\n\n 使用 translet <class> 来转换指定为 <document> 的\nXML 文档。translet <class> 要么在\n 用户的 CLASSPATH 中，要么在任意指定的 <jarfile> 中。\n选项\n -j <jarfile>    指定装入 translet 的 jarfile\n -x              打开附加的调试消息输出\n -s              禁止调用 System.exit\n -n <iterations> 运行转换过程 <iterations> 次并\n 显示概要分析信息\n -u <document_url> 将 XML 输入文档指定为 URL\n"
}
,
{
ErrorMsg
.
STRAY_SORT_ERR
,
"<xsl:sort> 只能在 <xsl:for-each> 或 <xsl:apply-templates> 中使用。"
}
,
{
ErrorMsg
.
UNSUPPORTED_ENCODING
,
"此 JVM 不支持输出编码“{0}”。"
}
,
{
ErrorMsg
.
SYNTAX_ERR
,
"“{0}”中的语法错误。"
}
,
{
ErrorMsg
.
CONSTRUCTOR_NOT_FOUND
,
"找不到外部构造函数“{0}”。"
}
,
{
ErrorMsg
.
NO_JAVA_FUNCT_THIS_REF
,
"非 static Java 函数“{0}”的第一个自变量不是有效的对象参考。"
}
,
{
ErrorMsg
.
TYPE_CHECK_ERR
,
"检查表达式“{0}”的类型时出错。"
}
,
{
ErrorMsg
.
TYPE_CHECK_UNK_LOC_ERR
,
"检查未知位置的表达式类型时出错。"
}
,
{
ErrorMsg
.
ILLEGAL_CMDLINE_OPTION_ERR
,
"命令行选项“{0}”无效。"
}
,
{
ErrorMsg
.
CMDLINE_OPT_MISSING_ARG_ERR
,
"命令行选项“{0}”缺少必需的自变量。"
}
,
{
ErrorMsg
.
WARNING_PLUS_WRAPPED_MSG
,
"警告：“{0}”\n       ：{1}"
}
,
{
ErrorMsg
.
WARNING_MSG
,
"警告：“{0}”"
}
,
{
ErrorMsg
.
FATAL_ERR_PLUS_WRAPPED_MSG
,
"致命错误：“{0}”\n           ：{1}"
}
,
{
ErrorMsg
.
FATAL_ERR_MSG
,
"致命错误：“{0}”"
}
,
{
ErrorMsg
.
ERROR_PLUS_WRAPPED_MSG
,
"错误：“{0}”\n     ：{1}"
}
,
{
ErrorMsg
.
ERROR_MSG
,
"错误：“{0}”"
}
,
{
ErrorMsg
.
TRANSFORM_WITH_TRANSLET_STR
,
"使用 translet“{0}”转换"
}
,
{
ErrorMsg
.
TRANSFORM_WITH_JAR_STR
,
"使用 translet“{0}”从 jar 文件“{1}”转换"
}
,
{
ErrorMsg
.
COULD_NOT_CREATE_TRANS_FACT
,
"无法创建 TransformerFactory 类“{0}”的实例。"
}
,
{
ErrorMsg
.
COMPILER_ERROR_KEY
,
"编译器错误："
}
,
{
ErrorMsg
.
COMPILER_WARNING_KEY
,
"编译器警告："
}
,
{
ErrorMsg
.
RUNTIME_ERROR_KEY
,
"Translet 错误："
}
}
;
public
Object
[
]
[
]
getContents
(
)
{
return
m_errorMessages
;
}
}
