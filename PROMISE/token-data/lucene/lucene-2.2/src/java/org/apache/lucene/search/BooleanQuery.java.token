package
org
.
apache
.
lucene
.
search
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
util
.
ToStringUtils
;
import
org
.
apache
.
lucene
.
search
.
BooleanClause
.
Occur
;
import
java
.
io
.
IOException
;
import
java
.
util
.
*
;
public
class
BooleanQuery
extends
Query
{
private
static
int
maxClauseCount
=
1024
;
public
static
class
TooManyClauses
extends
RuntimeException
{
public
TooManyClauses
(
)
{
}
public
String
getMessage
(
)
{
return
"maxClauseCount is set to "
+
maxClauseCount
;
}
}
public
static
int
getMaxClauseCount
(
)
{
return
maxClauseCount
;
}
public
static
void
setMaxClauseCount
(
int
maxClauseCount
)
{
if
(
maxClauseCount
<
1
)
throw
new
IllegalArgumentException
(
"maxClauseCount must be >= 1"
)
;
BooleanQuery
.
maxClauseCount
=
maxClauseCount
;
}
private
ArrayList
clauses
=
new
ArrayList
(
)
;
private
boolean
disableCoord
;
public
BooleanQuery
(
)
{
}
public
BooleanQuery
(
boolean
disableCoord
)
{
this
.
disableCoord
=
disableCoord
;
}
public
boolean
isCoordDisabled
(
)
{
return
disableCoord
;
}
public
Similarity
getSimilarity
(
Searcher
searcher
)
{
Similarity
result
=
super
.
getSimilarity
(
searcher
)
;
if
(
disableCoord
)
{
result
=
new
SimilarityDelegator
(
result
)
{
public
float
coord
(
int
overlap
,
int
maxOverlap
)
{
return
1.0f
;
}
}
;
}
return
result
;
}
public
void
setMinimumNumberShouldMatch
(
int
min
)
{
this
.
minNrShouldMatch
=
min
;
}
protected
int
minNrShouldMatch
=
0
;
public
int
getMinimumNumberShouldMatch
(
)
{
return
minNrShouldMatch
;
}
public
void
add
(
Query
query
,
BooleanClause
.
Occur
occur
)
{
add
(
new
BooleanClause
(
query
,
occur
)
)
;
}
public
void
add
(
BooleanClause
clause
)
{
if
(
clauses
.
size
(
)
>=
maxClauseCount
)
throw
new
TooManyClauses
(
)
;
clauses
.
add
(
clause
)
;
}
public
BooleanClause
[
]
getClauses
(
)
{
return
(
BooleanClause
[
]
)
clauses
.
toArray
(
new
BooleanClause
[
clauses
.
size
(
)
]
)
;
}
public
List
clauses
(
)
{
return
clauses
;
}
private
class
BooleanWeight
implements
Weight
{
protected
Similarity
similarity
;
protected
Vector
weights
=
new
Vector
(
)
;
public
BooleanWeight
(
Searcher
searcher
)
throws
IOException
{
this
.
similarity
=
getSimilarity
(
searcher
)
;
for
(
int
i
=
0
;
i
<
clauses
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
get
(
i
)
;
weights
.
add
(
c
.
getQuery
(
)
.
createWeight
(
searcher
)
)
;
}
}
public
Query
getQuery
(
)
{
return
BooleanQuery
.
this
;
}
public
float
getValue
(
)
{
return
getBoost
(
)
;
}
public
float
sumOfSquaredWeights
(
)
throws
IOException
{
float
sum
=
0.0f
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
get
(
i
)
;
Weight
w
=
(
Weight
)
weights
.
elementAt
(
i
)
;
float
s
=
w
.
sumOfSquaredWeights
(
)
;
if
(
!
c
.
isProhibited
(
)
)
sum
+=
s
;
}
sum
*=
getBoost
(
)
*
getBoost
(
)
;
return
sum
;
}
public
void
normalize
(
float
norm
)
{
norm
*=
getBoost
(
)
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
get
(
i
)
;
Weight
w
=
(
Weight
)
weights
.
elementAt
(
i
)
;
w
.
normalize
(
norm
)
;
}
}
public
Scorer
scorer
(
IndexReader
reader
)
throws
IOException
{
BooleanScorer2
result
=
new
BooleanScorer2
(
similarity
,
minNrShouldMatch
,
allowDocsOutOfOrder
)
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
get
(
i
)
;
Weight
w
=
(
Weight
)
weights
.
elementAt
(
i
)
;
Scorer
subScorer
=
w
.
scorer
(
reader
)
;
if
(
subScorer
!=
null
)
result
.
add
(
subScorer
,
c
.
isRequired
(
)
,
c
.
isProhibited
(
)
)
;
else
if
(
c
.
isRequired
(
)
)
return
null
;
}
return
result
;
}
public
Explanation
explain
(
IndexReader
reader
,
int
doc
)
throws
IOException
{
final
int
minShouldMatch
=
BooleanQuery
.
this
.
getMinimumNumberShouldMatch
(
)
;
ComplexExplanation
sumExpl
=
new
ComplexExplanation
(
)
;
sumExpl
.
setDescription
(
"sum of:"
)
;
int
coord
=
0
;
int
maxCoord
=
0
;
float
sum
=
0.0f
;
boolean
fail
=
false
;
int
shouldMatchCount
=
0
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
get
(
i
)
;
Weight
w
=
(
Weight
)
weights
.
elementAt
(
i
)
;
Explanation
e
=
w
.
explain
(
reader
,
doc
)
;
if
(
!
c
.
isProhibited
(
)
)
maxCoord
++
;
if
(
e
.
isMatch
(
)
)
{
if
(
!
c
.
isProhibited
(
)
)
{
sumExpl
.
addDetail
(
e
)
;
sum
+=
e
.
getValue
(
)
;
coord
++
;
}
else
{
Explanation
r
=
new
Explanation
(
0.0f
,
"match on prohibited clause ("
+
c
.
getQuery
(
)
.
toString
(
)
+
")"
)
;
r
.
addDetail
(
e
)
;
sumExpl
.
addDetail
(
r
)
;
fail
=
true
;
}
if
(
c
.
getOccur
(
)
.
equals
(
Occur
.
SHOULD
)
)
shouldMatchCount
++
;
}
else
if
(
c
.
isRequired
(
)
)
{
Explanation
r
=
new
Explanation
(
0.0f
,
"no match on required clause ("
+
c
.
getQuery
(
)
.
toString
(
)
+
")"
)
;
r
.
addDetail
(
e
)
;
sumExpl
.
addDetail
(
r
)
;
fail
=
true
;
}
}
if
(
fail
)
{
sumExpl
.
setMatch
(
Boolean
.
FALSE
)
;
sumExpl
.
setValue
(
0.0f
)
;
sumExpl
.
setDescription
(
"Failure to meet condition(s) of required/prohibited clause(s)"
)
;
return
sumExpl
;
}
else
if
(
shouldMatchCount
<
minShouldMatch
)
{
sumExpl
.
setMatch
(
Boolean
.
FALSE
)
;
sumExpl
.
setValue
(
0.0f
)
;
sumExpl
.
setDescription
(
"Failure to match minimum number "
+
"of optional clauses: "
+
minShouldMatch
)
;
return
sumExpl
;
}
sumExpl
.
setMatch
(
0
<
coord
?
Boolean
.
TRUE
:
Boolean
.
FALSE
)
;
sumExpl
.
setValue
(
sum
)
;
float
coordFactor
=
similarity
.
coord
(
coord
,
maxCoord
)
;
if
(
coordFactor
==
1.0f
)
return
sumExpl
;
else
{
ComplexExplanation
result
=
new
ComplexExplanation
(
sumExpl
.
isMatch
(
)
,
sum
*
coordFactor
,
"product of:"
)
;
result
.
addDetail
(
sumExpl
)
;
result
.
addDetail
(
new
Explanation
(
coordFactor
,
"coord("
+
coord
+
"/"
+
maxCoord
+
")"
)
)
;
return
result
;
}
}
}
private
static
boolean
allowDocsOutOfOrder
=
false
;
public
static
void
setAllowDocsOutOfOrder
(
boolean
allow
)
{
allowDocsOutOfOrder
=
allow
;
}
public
static
boolean
getAllowDocsOutOfOrder
(
)
{
return
allowDocsOutOfOrder
;
}
public
static
void
setUseScorer14
(
boolean
use14
)
{
setAllowDocsOutOfOrder
(
use14
)
;
}
public
static
boolean
getUseScorer14
(
)
{
return
getAllowDocsOutOfOrder
(
)
;
}
protected
Weight
createWeight
(
Searcher
searcher
)
throws
IOException
{
return
new
BooleanWeight
(
searcher
)
;
}
public
Query
rewrite
(
IndexReader
reader
)
throws
IOException
{
if
(
clauses
.
size
(
)
==
1
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
get
(
0
)
;
if
(
!
c
.
isProhibited
(
)
)
{
Query
query
=
c
.
getQuery
(
)
.
rewrite
(
reader
)
;
if
(
getBoost
(
)
!=
1.0f
)
{
if
(
query
==
c
.
getQuery
(
)
)
query
=
(
Query
)
query
.
clone
(
)
;
query
.
setBoost
(
getBoost
(
)
*
query
.
getBoost
(
)
)
;
}
return
query
;
}
}
BooleanQuery
clone
=
null
;
for
(
int
i
=
0
;
i
<
clauses
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
get
(
i
)
;
Query
query
=
c
.
getQuery
(
)
.
rewrite
(
reader
)
;
if
(
query
!=
c
.
getQuery
(
)
)
{
if
(
clone
==
null
)
clone
=
(
BooleanQuery
)
this
.
clone
(
)
;
clone
.
clauses
.
set
(
i
,
new
BooleanClause
(
query
,
c
.
getOccur
(
)
)
)
;
}
}
if
(
clone
!=
null
)
{
return
clone
;
}
else
return
this
;
}
public
void
extractTerms
(
Set
terms
)
{
for
(
Iterator
i
=
clauses
.
iterator
(
)
;
i
.
hasNext
(
)
;
)
{
BooleanClause
clause
=
(
BooleanClause
)
i
.
next
(
)
;
clause
.
getQuery
(
)
.
extractTerms
(
terms
)
;
}
}
public
Object
clone
(
)
{
BooleanQuery
clone
=
(
BooleanQuery
)
super
.
clone
(
)
;
clone
.
clauses
=
(
ArrayList
)
this
.
clauses
.
clone
(
)
;
return
clone
;
}
public
String
toString
(
String
field
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
boolean
needParens
=
(
getBoost
(
)
!=
1.0
)
||
(
getMinimumNumberShouldMatch
(
)
>
0
)
;
if
(
needParens
)
{
buffer
.
append
(
"("
)
;
}
for
(
int
i
=
0
;
i
<
clauses
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
get
(
i
)
;
if
(
c
.
isProhibited
(
)
)
buffer
.
append
(
"-"
)
;
else
if
(
c
.
isRequired
(
)
)
buffer
.
append
(
"+"
)
;
Query
subQuery
=
c
.
getQuery
(
)
;
if
(
subQuery
instanceof
BooleanQuery
)
{
buffer
.
append
(
"("
)
;
buffer
.
append
(
c
.
getQuery
(
)
.
toString
(
field
)
)
;
buffer
.
append
(
")"
)
;
}
else
buffer
.
append
(
c
.
getQuery
(
)
.
toString
(
field
)
)
;
if
(
i
!=
clauses
.
size
(
)
-
1
)
buffer
.
append
(
" "
)
;
}
if
(
needParens
)
{
buffer
.
append
(
")"
)
;
}
if
(
getMinimumNumberShouldMatch
(
)
>
0
)
{
buffer
.
append
(
'~'
)
;
buffer
.
append
(
getMinimumNumberShouldMatch
(
)
)
;
}
if
(
getBoost
(
)
!=
1.0f
)
{
buffer
.
append
(
ToStringUtils
.
boost
(
getBoost
(
)
)
)
;
}
return
buffer
.
toString
(
)
;
}
public
boolean
equals
(
Object
o
)
{
if
(
!
(
o
instanceof
BooleanQuery
)
)
return
false
;
BooleanQuery
other
=
(
BooleanQuery
)
o
;
return
(
this
.
getBoost
(
)
==
other
.
getBoost
(
)
)
&&
this
.
clauses
.
equals
(
other
.
clauses
)
&&
this
.
getMinimumNumberShouldMatch
(
)
==
other
.
getMinimumNumberShouldMatch
(
)
;
}
public
int
hashCode
(
)
{
return
Float
.
floatToIntBits
(
getBoost
(
)
)
^
clauses
.
hashCode
(
)
+
getMinimumNumberShouldMatch
(
)
;
}
}
