package
org
.
apache
.
lucene
.
store
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
RandomAccessFile
;
import
java
.
security
.
MessageDigest
;
import
java
.
security
.
NoSuchAlgorithmException
;
import
java
.
util
.
Hashtable
;
import
org
.
apache
.
lucene
.
index
.
IndexFileNameFilter
;
import
org
.
apache
.
lucene
.
index
.
IndexWriter
;
public
class
FSDirectory
extends
Directory
{
private
static
final
Hashtable
DIRECTORIES
=
new
Hashtable
(
)
;
private
static
boolean
disableLocks
=
false
;
public
static
void
setDisableLocks
(
boolean
doDisableLocks
)
{
FSDirectory
.
disableLocks
=
doDisableLocks
;
}
public
static
boolean
getDisableLocks
(
)
{
return
FSDirectory
.
disableLocks
;
}
public
static
final
String
LOCK_DIR
=
System
.
getProperty
(
"org.apache.lucene.lockDir"
,
System
.
getProperty
(
"java.io.tmpdir"
)
)
;
private
static
Class
IMPL
;
static
{
try
{
String
name
=
System
.
getProperty
(
"org.apache.lucene.FSDirectory.class"
,
FSDirectory
.
class
.
getName
(
)
)
;
IMPL
=
Class
.
forName
(
name
)
;
}
catch
(
ClassNotFoundException
e
)
{
throw
new
RuntimeException
(
"cannot load FSDirectory class: "
+
e
.
toString
(
)
,
e
)
;
}
catch
(
SecurityException
se
)
{
try
{
IMPL
=
Class
.
forName
(
FSDirectory
.
class
.
getName
(
)
)
;
}
catch
(
ClassNotFoundException
e
)
{
throw
new
RuntimeException
(
"cannot load default FSDirectory class: "
+
e
.
toString
(
)
,
e
)
;
}
}
}
private
static
MessageDigest
DIGESTER
;
static
{
try
{
DIGESTER
=
MessageDigest
.
getInstance
(
"MD5"
)
;
}
catch
(
NoSuchAlgorithmException
e
)
{
throw
new
RuntimeException
(
e
.
toString
(
)
,
e
)
;
}
}
private
byte
[
]
buffer
=
null
;
public
static
FSDirectory
getDirectory
(
String
path
)
throws
IOException
{
return
getDirectory
(
new
File
(
path
)
,
null
)
;
}
public
static
FSDirectory
getDirectory
(
String
path
,
LockFactory
lockFactory
)
throws
IOException
{
return
getDirectory
(
new
File
(
path
)
,
lockFactory
)
;
}
public
static
FSDirectory
getDirectory
(
File
file
)
throws
IOException
{
return
getDirectory
(
file
,
null
)
;
}
public
static
FSDirectory
getDirectory
(
File
file
,
LockFactory
lockFactory
)
throws
IOException
{
file
=
new
File
(
file
.
getCanonicalPath
(
)
)
;
if
(
file
.
exists
(
)
&&
!
file
.
isDirectory
(
)
)
throw
new
IOException
(
file
+
" not a directory"
)
;
if
(
!
file
.
exists
(
)
)
if
(
!
file
.
mkdirs
(
)
)
throw
new
IOException
(
"Cannot create directory: "
+
file
)
;
FSDirectory
dir
;
synchronized
(
DIRECTORIES
)
{
dir
=
(
FSDirectory
)
DIRECTORIES
.
get
(
file
)
;
if
(
dir
==
null
)
{
try
{
dir
=
(
FSDirectory
)
IMPL
.
newInstance
(
)
;
}
catch
(
Exception
e
)
{
throw
new
RuntimeException
(
"cannot load FSDirectory class: "
+
e
.
toString
(
)
,
e
)
;
}
dir
.
init
(
file
,
lockFactory
)
;
DIRECTORIES
.
put
(
file
,
dir
)
;
}
else
{
if
(
lockFactory
!=
null
&&
lockFactory
!=
dir
.
getLockFactory
(
)
)
{
throw
new
IOException
(
"Directory was previously created with a different LockFactory instance; please pass null as the lockFactory instance and use setLockFactory to change it"
)
;
}
}
}
synchronized
(
dir
)
{
dir
.
refCount
++
;
}
return
dir
;
}
public
static
FSDirectory
getDirectory
(
String
path
,
boolean
create
)
throws
IOException
{
return
getDirectory
(
new
File
(
path
)
,
create
)
;
}
public
static
FSDirectory
getDirectory
(
File
file
,
boolean
create
)
throws
IOException
{
FSDirectory
dir
=
getDirectory
(
file
,
null
)
;
if
(
create
)
{
dir
.
create
(
)
;
}
return
dir
;
}
private
void
create
(
)
throws
IOException
{
if
(
directory
.
exists
(
)
)
{
String
[
]
files
=
directory
.
list
(
IndexFileNameFilter
.
getFilter
(
)
)
;
if
(
files
==
null
)
throw
new
IOException
(
"cannot read directory "
+
directory
.
getAbsolutePath
(
)
+
": list() returned null"
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
File
file
=
new
File
(
directory
,
files
[
i
]
)
;
if
(
!
file
.
delete
(
)
)
throw
new
IOException
(
"Cannot delete "
+
file
)
;
}
}
lockFactory
.
clearLock
(
IndexWriter
.
WRITE_LOCK_NAME
)
;
}
private
File
directory
=
null
;
private
int
refCount
;
protected
FSDirectory
(
)
{
}
;
private
void
init
(
File
path
,
LockFactory
lockFactory
)
throws
IOException
{
directory
=
path
;
boolean
doClearLockID
=
false
;
if
(
lockFactory
==
null
)
{
if
(
disableLocks
)
{
lockFactory
=
NoLockFactory
.
getNoLockFactory
(
)
;
}
else
{
String
lockClassName
=
System
.
getProperty
(
"org.apache.lucene.store.FSDirectoryLockFactoryClass"
)
;
if
(
lockClassName
!=
null
&&
!
lockClassName
.
equals
(
""
)
)
{
Class
c
;
try
{
c
=
Class
.
forName
(
lockClassName
)
;
}
catch
(
ClassNotFoundException
e
)
{
throw
new
IOException
(
"unable to find LockClass "
+
lockClassName
)
;
}
try
{
lockFactory
=
(
LockFactory
)
c
.
newInstance
(
)
;
}
catch
(
IllegalAccessException
e
)
{
throw
new
IOException
(
"IllegalAccessException when instantiating LockClass "
+
lockClassName
)
;
}
catch
(
InstantiationException
e
)
{
throw
new
IOException
(
"InstantiationException when instantiating LockClass "
+
lockClassName
)
;
}
catch
(
ClassCastException
e
)
{
throw
new
IOException
(
"unable to cast LockClass "
+
lockClassName
+
" instance to a LockFactory"
)
;
}
if
(
lockFactory
instanceof
NativeFSLockFactory
)
{
(
(
NativeFSLockFactory
)
lockFactory
)
.
setLockDir
(
path
)
;
}
else
if
(
lockFactory
instanceof
SimpleFSLockFactory
)
{
(
(
SimpleFSLockFactory
)
lockFactory
)
.
setLockDir
(
path
)
;
}
}
else
{
lockFactory
=
new
SimpleFSLockFactory
(
path
)
;
doClearLockID
=
true
;
}
}
}
setLockFactory
(
lockFactory
)
;
if
(
doClearLockID
)
{
lockFactory
.
setLockPrefix
(
null
)
;
}
}
public
String
[
]
list
(
)
{
return
directory
.
list
(
IndexFileNameFilter
.
getFilter
(
)
)
;
}
public
boolean
fileExists
(
String
name
)
{
File
file
=
new
File
(
directory
,
name
)
;
return
file
.
exists
(
)
;
}
public
long
fileModified
(
String
name
)
{
File
file
=
new
File
(
directory
,
name
)
;
return
file
.
lastModified
(
)
;
}
public
static
long
fileModified
(
File
directory
,
String
name
)
{
File
file
=
new
File
(
directory
,
name
)
;
return
file
.
lastModified
(
)
;
}
public
void
touchFile
(
String
name
)
{
File
file
=
new
File
(
directory
,
name
)
;
file
.
setLastModified
(
System
.
currentTimeMillis
(
)
)
;
}
public
long
fileLength
(
String
name
)
{
File
file
=
new
File
(
directory
,
name
)
;
return
file
.
length
(
)
;
}
public
void
deleteFile
(
String
name
)
throws
IOException
{
File
file
=
new
File
(
directory
,
name
)
;
if
(
!
file
.
delete
(
)
)
throw
new
IOException
(
"Cannot delete "
+
file
)
;
}
public
synchronized
void
renameFile
(
String
from
,
String
to
)
throws
IOException
{
File
old
=
new
File
(
directory
,
from
)
;
File
nu
=
new
File
(
directory
,
to
)
;
if
(
nu
.
exists
(
)
)
if
(
!
nu
.
delete
(
)
)
throw
new
IOException
(
"Cannot delete "
+
nu
)
;
if
(
!
old
.
renameTo
(
nu
)
)
{
java
.
io
.
InputStream
in
=
null
;
java
.
io
.
OutputStream
out
=
null
;
try
{
in
=
new
FileInputStream
(
old
)
;
out
=
new
FileOutputStream
(
nu
)
;
if
(
buffer
==
null
)
{
buffer
=
new
byte
[
1024
]
;
}
int
len
;
while
(
(
len
=
in
.
read
(
buffer
)
)
>=
0
)
{
out
.
write
(
buffer
,
0
,
len
)
;
}
old
.
delete
(
)
;
}
catch
(
IOException
ioe
)
{
IOException
newExc
=
new
IOException
(
"Cannot rename "
+
old
+
" to "
+
nu
)
;
newExc
.
initCause
(
ioe
)
;
throw
newExc
;
}
finally
{
try
{
if
(
in
!=
null
)
{
try
{
in
.
close
(
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
"Cannot close input stream: "
+
e
.
toString
(
)
,
e
)
;
}
}
}
finally
{
if
(
out
!=
null
)
{
try
{
out
.
close
(
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
"Cannot close output stream: "
+
e
.
toString
(
)
,
e
)
;
}
}
}
}
}
}
public
IndexOutput
createOutput
(
String
name
)
throws
IOException
{
File
file
=
new
File
(
directory
,
name
)
;
if
(
file
.
exists
(
)
&&
!
file
.
delete
(
)
)
throw
new
IOException
(
"Cannot overwrite: "
+
file
)
;
return
new
FSIndexOutput
(
file
)
;
}
public
IndexInput
openInput
(
String
name
)
throws
IOException
{
return
new
FSIndexInput
(
new
File
(
directory
,
name
)
)
;
}
public
IndexInput
openInput
(
String
name
,
int
bufferSize
)
throws
IOException
{
return
new
FSIndexInput
(
new
File
(
directory
,
name
)
,
bufferSize
)
;
}
private
static
final
char
[
]
HEX_DIGITS
=
{
'0'
,
'1'
,
'2'
,
'3'
,
'4'
,
'5'
,
'6'
,
'7'
,
'8'
,
'9'
,
'a'
,
'b'
,
'c'
,
'd'
,
'e'
,
'f'
}
;
public
String
getLockID
(
)
{
String
dirName
;
try
{
dirName
=
directory
.
getCanonicalPath
(
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
e
.
toString
(
)
,
e
)
;
}
byte
digest
[
]
;
synchronized
(
DIGESTER
)
{
digest
=
DIGESTER
.
digest
(
dirName
.
getBytes
(
)
)
;
}
StringBuffer
buf
=
new
StringBuffer
(
)
;
buf
.
append
(
"lucene-"
)
;
for
(
int
i
=
0
;
i
<
digest
.
length
;
i
++
)
{
int
b
=
digest
[
i
]
;
buf
.
append
(
HEX_DIGITS
[
(
b
>
>
4
)
&
0xf
]
)
;
buf
.
append
(
HEX_DIGITS
[
b
&
0xf
]
)
;
}
return
buf
.
toString
(
)
;
}
public
synchronized
void
close
(
)
{
if
(
--
refCount
<=
0
)
{
synchronized
(
DIRECTORIES
)
{
DIRECTORIES
.
remove
(
directory
)
;
}
}
}
public
File
getFile
(
)
{
return
directory
;
}
public
String
toString
(
)
{
return
this
.
getClass
(
)
.
getName
(
)
+
"@"
+
directory
;
}
protected
static
class
FSIndexInput
extends
BufferedIndexInput
{
private
static
class
Descriptor
extends
RandomAccessFile
{
private
boolean
isOpen
;
long
position
;
final
long
length
;
public
Descriptor
(
File
file
,
String
mode
)
throws
IOException
{
super
(
file
,
mode
)
;
isOpen
=
true
;
length
=
length
(
)
;
}
public
void
close
(
)
throws
IOException
{
if
(
isOpen
)
{
isOpen
=
false
;
super
.
close
(
)
;
}
}
protected
void
finalize
(
)
throws
Throwable
{
try
{
close
(
)
;
}
finally
{
super
.
finalize
(
)
;
}
}
}
private
final
Descriptor
file
;
boolean
isClone
;
public
FSIndexInput
(
File
path
)
throws
IOException
{
this
(
path
,
BufferedIndexInput
.
BUFFER_SIZE
)
;
}
public
FSIndexInput
(
File
path
,
int
bufferSize
)
throws
IOException
{
super
(
bufferSize
)
;
file
=
new
Descriptor
(
path
,
"r"
)
;
}
protected
void
readInternal
(
byte
[
]
b
,
int
offset
,
int
len
)
throws
IOException
{
synchronized
(
file
)
{
long
position
=
getFilePointer
(
)
;
if
(
position
!=
file
.
position
)
{
file
.
seek
(
position
)
;
file
.
position
=
position
;
}
int
total
=
0
;
do
{
int
i
=
file
.
read
(
b
,
offset
+
total
,
len
-
total
)
;
if
(
i
==
-
1
)
throw
new
IOException
(
"read past EOF"
)
;
file
.
position
+=
i
;
total
+=
i
;
}
while
(
total
<
len
)
;
}
}
public
void
close
(
)
throws
IOException
{
if
(
!
isClone
)
file
.
close
(
)
;
}
protected
void
seekInternal
(
long
position
)
{
}
public
long
length
(
)
{
return
file
.
length
;
}
public
Object
clone
(
)
{
FSIndexInput
clone
=
(
FSIndexInput
)
super
.
clone
(
)
;
clone
.
isClone
=
true
;
return
clone
;
}
boolean
isFDValid
(
)
throws
IOException
{
return
file
.
getFD
(
)
.
valid
(
)
;
}
}
protected
static
class
FSIndexOutput
extends
BufferedIndexOutput
{
RandomAccessFile
file
=
null
;
private
boolean
isOpen
;
public
FSIndexOutput
(
File
path
)
throws
IOException
{
file
=
new
RandomAccessFile
(
path
,
"rw"
)
;
isOpen
=
true
;
}
public
void
flushBuffer
(
byte
[
]
b
,
int
offset
,
int
size
)
throws
IOException
{
file
.
write
(
b
,
offset
,
size
)
;
}
public
void
close
(
)
throws
IOException
{
if
(
isOpen
)
{
super
.
close
(
)
;
file
.
close
(
)
;
isOpen
=
false
;
}
}
public
void
seek
(
long
pos
)
throws
IOException
{
super
.
seek
(
pos
)
;
file
.
seek
(
pos
)
;
}
public
long
length
(
)
throws
IOException
{
return
file
.
length
(
)
;
}
}
}
