package
org
.
apache
.
lucene
.
search
.
spans
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Comparator
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
class
NearSpansOrdered
implements
Spans
{
private
final
int
allowedSlop
;
private
boolean
firstTime
=
true
;
private
boolean
more
=
false
;
private
final
Spans
[
]
subSpans
;
private
boolean
inSameDoc
=
false
;
private
int
matchDoc
=
-
1
;
private
int
matchStart
=
-
1
;
private
int
matchEnd
=
-
1
;
private
final
Spans
[
]
subSpansByDoc
;
private
final
Comparator
spanDocComparator
=
new
Comparator
(
)
{
public
int
compare
(
Object
o1
,
Object
o2
)
{
return
(
(
Spans
)
o1
)
.
doc
(
)
-
(
(
Spans
)
o2
)
.
doc
(
)
;
}
}
;
private
SpanNearQuery
query
;
public
NearSpansOrdered
(
SpanNearQuery
spanNearQuery
,
IndexReader
reader
)
throws
IOException
{
if
(
spanNearQuery
.
getClauses
(
)
.
length
<
2
)
{
throw
new
IllegalArgumentException
(
"Less than 2 clauses: "
+
spanNearQuery
)
;
}
allowedSlop
=
spanNearQuery
.
getSlop
(
)
;
SpanQuery
[
]
clauses
=
spanNearQuery
.
getClauses
(
)
;
subSpans
=
new
Spans
[
clauses
.
length
]
;
subSpansByDoc
=
new
Spans
[
clauses
.
length
]
;
for
(
int
i
=
0
;
i
<
clauses
.
length
;
i
++
)
{
subSpans
[
i
]
=
clauses
[
i
]
.
getSpans
(
reader
)
;
subSpansByDoc
[
i
]
=
subSpans
[
i
]
;
}
query
=
spanNearQuery
;
}
public
int
doc
(
)
{
return
matchDoc
;
}
public
int
start
(
)
{
return
matchStart
;
}
public
int
end
(
)
{
return
matchEnd
;
}
public
boolean
next
(
)
throws
IOException
{
if
(
firstTime
)
{
firstTime
=
false
;
for
(
int
i
=
0
;
i
<
subSpans
.
length
;
i
++
)
{
if
(
!
subSpans
[
i
]
.
next
(
)
)
{
more
=
false
;
return
false
;
}
}
more
=
true
;
}
return
advanceAfterOrdered
(
)
;
}
public
boolean
skipTo
(
int
target
)
throws
IOException
{
if
(
firstTime
)
{
firstTime
=
false
;
for
(
int
i
=
0
;
i
<
subSpans
.
length
;
i
++
)
{
if
(
!
subSpans
[
i
]
.
skipTo
(
target
)
)
{
more
=
false
;
return
false
;
}
}
more
=
true
;
}
else
if
(
more
&&
(
subSpans
[
0
]
.
doc
(
)
<
target
)
)
{
if
(
subSpans
[
0
]
.
skipTo
(
target
)
)
{
inSameDoc
=
false
;
}
else
{
more
=
false
;
return
false
;
}
}
return
advanceAfterOrdered
(
)
;
}
private
boolean
advanceAfterOrdered
(
)
throws
IOException
{
while
(
more
&&
(
inSameDoc
||
toSameDoc
(
)
)
)
{
if
(
stretchToOrder
(
)
&&
shrinkToAfterShortestMatch
(
)
)
{
return
true
;
}
}
return
false
;
}
private
boolean
toSameDoc
(
)
throws
IOException
{
Arrays
.
sort
(
subSpansByDoc
,
spanDocComparator
)
;
int
firstIndex
=
0
;
int
maxDoc
=
subSpansByDoc
[
subSpansByDoc
.
length
-
1
]
.
doc
(
)
;
while
(
subSpansByDoc
[
firstIndex
]
.
doc
(
)
!=
maxDoc
)
{
if
(
!
subSpansByDoc
[
firstIndex
]
.
skipTo
(
maxDoc
)
)
{
more
=
false
;
inSameDoc
=
false
;
return
false
;
}
maxDoc
=
subSpansByDoc
[
firstIndex
]
.
doc
(
)
;
if
(
++
firstIndex
==
subSpansByDoc
.
length
)
{
firstIndex
=
0
;
}
}
for
(
int
i
=
0
;
i
<
subSpansByDoc
.
length
;
i
++
)
{
assert
(
subSpansByDoc
[
i
]
.
doc
(
)
==
maxDoc
)
:
" NearSpansOrdered.toSameDoc() spans "
+
subSpansByDoc
[
0
]
+
"\n at doc "
+
subSpansByDoc
[
i
]
.
doc
(
)
+
", but should be at "
+
maxDoc
;
}
inSameDoc
=
true
;
return
true
;
}
static
final
boolean
docSpansOrdered
(
Spans
spans1
,
Spans
spans2
)
{
assert
spans1
.
doc
(
)
==
spans2
.
doc
(
)
:
"doc1 "
+
spans1
.
doc
(
)
+
" != doc2 "
+
spans2
.
doc
(
)
;
int
start1
=
spans1
.
start
(
)
;
int
start2
=
spans2
.
start
(
)
;
return
(
start1
==
start2
)
?
(
spans1
.
end
(
)
<
spans2
.
end
(
)
)
:
(
start1
<
start2
)
;
}
private
static
final
boolean
docSpansOrdered
(
int
start1
,
int
end1
,
int
start2
,
int
end2
)
{
return
(
start1
==
start2
)
?
(
end1
<
end2
)
:
(
start1
<
start2
)
;
}
private
boolean
stretchToOrder
(
)
throws
IOException
{
matchDoc
=
subSpans
[
0
]
.
doc
(
)
;
for
(
int
i
=
1
;
inSameDoc
&&
(
i
<
subSpans
.
length
)
;
i
++
)
{
while
(
!
docSpansOrdered
(
subSpans
[
i
-
1
]
,
subSpans
[
i
]
)
)
{
if
(
!
subSpans
[
i
]
.
next
(
)
)
{
inSameDoc
=
false
;
more
=
false
;
break
;
}
else
if
(
matchDoc
!=
subSpans
[
i
]
.
doc
(
)
)
{
inSameDoc
=
false
;
break
;
}
}
}
return
inSameDoc
;
}
private
boolean
shrinkToAfterShortestMatch
(
)
throws
IOException
{
matchStart
=
subSpans
[
subSpans
.
length
-
1
]
.
start
(
)
;
matchEnd
=
subSpans
[
subSpans
.
length
-
1
]
.
end
(
)
;
int
matchSlop
=
0
;
int
lastStart
=
matchStart
;
int
lastEnd
=
matchEnd
;
for
(
int
i
=
subSpans
.
length
-
2
;
i
>=
0
;
i
--
)
{
Spans
prevSpans
=
subSpans
[
i
]
;
int
prevStart
=
prevSpans
.
start
(
)
;
int
prevEnd
=
prevSpans
.
end
(
)
;
while
(
true
)
{
if
(
!
prevSpans
.
next
(
)
)
{
inSameDoc
=
false
;
more
=
false
;
break
;
}
else
if
(
matchDoc
!=
prevSpans
.
doc
(
)
)
{
inSameDoc
=
false
;
break
;
}
else
{
int
ppStart
=
prevSpans
.
start
(
)
;
int
ppEnd
=
prevSpans
.
end
(
)
;
if
(
!
docSpansOrdered
(
ppStart
,
ppEnd
,
lastStart
,
lastEnd
)
)
{
break
;
}
else
{
prevStart
=
ppStart
;
prevEnd
=
ppEnd
;
}
}
}
assert
prevStart
<=
matchStart
;
if
(
matchStart
>
prevEnd
)
{
matchSlop
+=
(
matchStart
-
prevEnd
)
;
}
matchStart
=
prevStart
;
lastStart
=
prevStart
;
lastEnd
=
prevEnd
;
}
return
matchSlop
<=
allowedSlop
;
}
public
String
toString
(
)
{
return
getClass
(
)
.
getName
(
)
+
"("
+
query
.
toString
(
)
+
")@"
+
(
firstTime
?
"START"
:
(
more
?
(
doc
(
)
+
":"
+
start
(
)
+
"-"
+
end
(
)
)
:
"END"
)
)
;
}
}
