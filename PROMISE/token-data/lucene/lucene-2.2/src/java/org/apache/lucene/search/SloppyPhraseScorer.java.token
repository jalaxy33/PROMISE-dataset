package
org
.
apache
.
lucene
.
search
;
import
org
.
apache
.
lucene
.
index
.
TermPositions
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Comparator
;
import
java
.
util
.
HashMap
;
final
class
SloppyPhraseScorer
extends
PhraseScorer
{
private
int
slop
;
private
PhrasePositions
repeats
[
]
;
private
boolean
checkedRepeats
;
SloppyPhraseScorer
(
Weight
weight
,
TermPositions
[
]
tps
,
int
[
]
offsets
,
Similarity
similarity
,
int
slop
,
byte
[
]
norms
)
{
super
(
weight
,
tps
,
offsets
,
similarity
,
norms
)
;
this
.
slop
=
slop
;
}
protected
final
float
phraseFreq
(
)
throws
IOException
{
int
end
=
initPhrasePositions
(
)
;
float
freq
=
0.0f
;
boolean
done
=
(
end
<
0
)
;
while
(
!
done
)
{
PhrasePositions
pp
=
(
PhrasePositions
)
pq
.
pop
(
)
;
int
start
=
pp
.
position
;
int
next
=
(
(
PhrasePositions
)
pq
.
top
(
)
)
.
position
;
boolean
tpsDiffer
=
true
;
for
(
int
pos
=
start
;
pos
<=
next
||
!
tpsDiffer
;
pos
=
pp
.
position
)
{
if
(
pos
<=
next
&&
tpsDiffer
)
start
=
pos
;
if
(
!
pp
.
nextPosition
(
)
)
{
done
=
true
;
break
;
}
tpsDiffer
=
!
pp
.
repeats
||
termPositionsDiffer
(
pp
)
;
}
int
matchLength
=
end
-
start
;
if
(
matchLength
<=
slop
)
freq
+=
getSimilarity
(
)
.
sloppyFreq
(
matchLength
)
;
if
(
pp
.
position
>
end
)
end
=
pp
.
position
;
pq
.
put
(
pp
)
;
}
return
freq
;
}
private
int
initPhrasePositions
(
)
throws
IOException
{
int
end
=
0
;
if
(
checkedRepeats
&&
repeats
==
null
)
{
pq
.
clear
(
)
;
for
(
PhrasePositions
pp
=
first
;
pp
!=
null
;
pp
=
pp
.
next
)
{
pp
.
firstPosition
(
)
;
if
(
pp
.
position
>
end
)
end
=
pp
.
position
;
pq
.
put
(
pp
)
;
}
return
end
;
}
for
(
PhrasePositions
pp
=
first
;
pp
!=
null
;
pp
=
pp
.
next
)
pp
.
firstPosition
(
)
;
if
(
!
checkedRepeats
)
{
checkedRepeats
=
true
;
HashMap
m
=
null
;
for
(
PhrasePositions
pp
=
first
;
pp
!=
null
;
pp
=
pp
.
next
)
{
int
tpPos
=
pp
.
position
+
pp
.
offset
;
for
(
PhrasePositions
pp2
=
pp
.
next
;
pp2
!=
null
;
pp2
=
pp2
.
next
)
{
int
tpPos2
=
pp2
.
position
+
pp2
.
offset
;
if
(
tpPos2
==
tpPos
)
{
if
(
m
==
null
)
m
=
new
HashMap
(
)
;
pp
.
repeats
=
true
;
pp2
.
repeats
=
true
;
m
.
put
(
pp
,
null
)
;
m
.
put
(
pp2
,
null
)
;
}
}
}
if
(
m
!=
null
)
repeats
=
(
PhrasePositions
[
]
)
m
.
keySet
(
)
.
toArray
(
new
PhrasePositions
[
0
]
)
;
}
if
(
repeats
!=
null
)
{
Arrays
.
sort
(
repeats
,
new
Comparator
(
)
{
public
int
compare
(
Object
x
,
Object
y
)
{
return
(
(
PhrasePositions
)
y
)
.
offset
-
(
(
PhrasePositions
)
x
)
.
offset
;
}
}
)
;
for
(
int
i
=
0
;
i
<
repeats
.
length
;
i
++
)
{
PhrasePositions
pp
=
repeats
[
i
]
;
while
(
!
termPositionsDiffer
(
pp
)
)
{
if
(
!
pp
.
nextPosition
(
)
)
return
-
1
;
}
}
}
pq
.
clear
(
)
;
for
(
PhrasePositions
pp
=
first
;
pp
!=
null
;
pp
=
pp
.
next
)
{
if
(
pp
.
position
>
end
)
end
=
pp
.
position
;
pq
.
put
(
pp
)
;
}
return
end
;
}
private
boolean
termPositionsDiffer
(
PhrasePositions
pp
)
{
int
tpPos
=
pp
.
position
+
pp
.
offset
;
for
(
int
i
=
0
;
i
<
repeats
.
length
;
i
++
)
{
PhrasePositions
pp2
=
repeats
[
i
]
;
if
(
pp2
==
pp
)
continue
;
int
tpPos2
=
pp2
.
position
+
pp2
.
offset
;
if
(
tpPos2
==
tpPos
)
return
false
;
}
return
true
;
}
}
