package
org
.
apache
.
lucene
.
analysis
;
import
org
.
apache
.
lucene
.
index
.
Payload
;
import
org
.
apache
.
lucene
.
index
.
TermPositions
;
public
class
Token
implements
Cloneable
{
String
termText
;
int
startOffset
;
int
endOffset
;
String
type
=
"word"
;
Payload
payload
;
private
int
positionIncrement
=
1
;
public
Token
(
String
text
,
int
start
,
int
end
)
{
termText
=
text
;
startOffset
=
start
;
endOffset
=
end
;
}
public
Token
(
String
text
,
int
start
,
int
end
,
String
typ
)
{
termText
=
text
;
startOffset
=
start
;
endOffset
=
end
;
type
=
typ
;
}
public
void
setPositionIncrement
(
int
positionIncrement
)
{
if
(
positionIncrement
<
0
)
throw
new
IllegalArgumentException
(
"Increment must be zero or greater: "
+
positionIncrement
)
;
this
.
positionIncrement
=
positionIncrement
;
}
public
int
getPositionIncrement
(
)
{
return
positionIncrement
;
}
public
void
setTermText
(
String
text
)
{
termText
=
text
;
}
public
final
String
termText
(
)
{
return
termText
;
}
public
final
int
startOffset
(
)
{
return
startOffset
;
}
public
final
int
endOffset
(
)
{
return
endOffset
;
}
public
final
String
type
(
)
{
return
type
;
}
public
void
setPayload
(
Payload
payload
)
{
this
.
payload
=
payload
;
}
public
Payload
getPayload
(
)
{
return
this
.
payload
;
}
public
String
toString
(
)
{
StringBuffer
sb
=
new
StringBuffer
(
)
;
sb
.
append
(
"("
+
termText
+
","
+
startOffset
+
","
+
endOffset
)
;
if
(
!
type
.
equals
(
"word"
)
)
sb
.
append
(
",type="
+
type
)
;
if
(
positionIncrement
!=
1
)
sb
.
append
(
",posIncr="
+
positionIncrement
)
;
sb
.
append
(
")"
)
;
return
sb
.
toString
(
)
;
}
public
Object
clone
(
)
{
try
{
return
super
.
clone
(
)
;
}
catch
(
CloneNotSupportedException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
}
