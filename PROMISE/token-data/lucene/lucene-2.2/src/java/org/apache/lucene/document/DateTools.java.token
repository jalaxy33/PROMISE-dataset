package
org
.
apache
.
lucene
.
document
;
import
java
.
text
.
ParseException
;
import
java
.
text
.
SimpleDateFormat
;
import
java
.
util
.
Calendar
;
import
java
.
util
.
Date
;
import
java
.
util
.
TimeZone
;
public
class
DateTools
{
private
final
static
TimeZone
GMT
=
TimeZone
.
getTimeZone
(
"GMT"
)
;
private
static
final
SimpleDateFormat
YEAR_FORMAT
=
new
SimpleDateFormat
(
"yyyy"
)
;
private
static
final
SimpleDateFormat
MONTH_FORMAT
=
new
SimpleDateFormat
(
"yyyyMM"
)
;
private
static
final
SimpleDateFormat
DAY_FORMAT
=
new
SimpleDateFormat
(
"yyyyMMdd"
)
;
private
static
final
SimpleDateFormat
HOUR_FORMAT
=
new
SimpleDateFormat
(
"yyyyMMddHH"
)
;
private
static
final
SimpleDateFormat
MINUTE_FORMAT
=
new
SimpleDateFormat
(
"yyyyMMddHHmm"
)
;
private
static
final
SimpleDateFormat
SECOND_FORMAT
=
new
SimpleDateFormat
(
"yyyyMMddHHmmss"
)
;
private
static
final
SimpleDateFormat
MILLISECOND_FORMAT
=
new
SimpleDateFormat
(
"yyyyMMddHHmmssSSS"
)
;
static
{
YEAR_FORMAT
.
setTimeZone
(
GMT
)
;
MONTH_FORMAT
.
setTimeZone
(
GMT
)
;
DAY_FORMAT
.
setTimeZone
(
GMT
)
;
HOUR_FORMAT
.
setTimeZone
(
GMT
)
;
MINUTE_FORMAT
.
setTimeZone
(
GMT
)
;
SECOND_FORMAT
.
setTimeZone
(
GMT
)
;
MILLISECOND_FORMAT
.
setTimeZone
(
GMT
)
;
}
private
DateTools
(
)
{
}
public
static
String
dateToString
(
Date
date
,
Resolution
resolution
)
{
return
timeToString
(
date
.
getTime
(
)
,
resolution
)
;
}
public
static
String
timeToString
(
long
time
,
Resolution
resolution
)
{
Calendar
cal
=
Calendar
.
getInstance
(
GMT
)
;
cal
.
setTime
(
new
Date
(
round
(
time
,
resolution
)
)
)
;
String
result
;
if
(
resolution
==
Resolution
.
YEAR
)
{
synchronized
(
YEAR_FORMAT
)
{
result
=
YEAR_FORMAT
.
format
(
cal
.
getTime
(
)
)
;
}
}
else
if
(
resolution
==
Resolution
.
MONTH
)
{
synchronized
(
MONTH_FORMAT
)
{
result
=
MONTH_FORMAT
.
format
(
cal
.
getTime
(
)
)
;
}
}
else
if
(
resolution
==
Resolution
.
DAY
)
{
synchronized
(
DAY_FORMAT
)
{
result
=
DAY_FORMAT
.
format
(
cal
.
getTime
(
)
)
;
}
}
else
if
(
resolution
==
Resolution
.
HOUR
)
{
synchronized
(
HOUR_FORMAT
)
{
result
=
HOUR_FORMAT
.
format
(
cal
.
getTime
(
)
)
;
}
}
else
if
(
resolution
==
Resolution
.
MINUTE
)
{
synchronized
(
MINUTE_FORMAT
)
{
result
=
MINUTE_FORMAT
.
format
(
cal
.
getTime
(
)
)
;
}
}
else
if
(
resolution
==
Resolution
.
SECOND
)
{
synchronized
(
SECOND_FORMAT
)
{
result
=
SECOND_FORMAT
.
format
(
cal
.
getTime
(
)
)
;
}
}
else
if
(
resolution
==
Resolution
.
MILLISECOND
)
{
synchronized
(
MILLISECOND_FORMAT
)
{
result
=
MILLISECOND_FORMAT
.
format
(
cal
.
getTime
(
)
)
;
}
}
else
{
throw
new
IllegalArgumentException
(
"unknown resolution "
+
resolution
)
;
}
return
result
;
}
public
static
long
stringToTime
(
String
dateString
)
throws
ParseException
{
return
stringToDate
(
dateString
)
.
getTime
(
)
;
}
public
static
Date
stringToDate
(
String
dateString
)
throws
ParseException
{
Date
date
;
if
(
dateString
.
length
(
)
==
4
)
{
synchronized
(
YEAR_FORMAT
)
{
date
=
YEAR_FORMAT
.
parse
(
dateString
)
;
}
}
else
if
(
dateString
.
length
(
)
==
6
)
{
synchronized
(
MONTH_FORMAT
)
{
date
=
MONTH_FORMAT
.
parse
(
dateString
)
;
}
}
else
if
(
dateString
.
length
(
)
==
8
)
{
synchronized
(
DAY_FORMAT
)
{
date
=
DAY_FORMAT
.
parse
(
dateString
)
;
}
}
else
if
(
dateString
.
length
(
)
==
10
)
{
synchronized
(
HOUR_FORMAT
)
{
date
=
HOUR_FORMAT
.
parse
(
dateString
)
;
}
}
else
if
(
dateString
.
length
(
)
==
12
)
{
synchronized
(
MINUTE_FORMAT
)
{
date
=
MINUTE_FORMAT
.
parse
(
dateString
)
;
}
}
else
if
(
dateString
.
length
(
)
==
14
)
{
synchronized
(
SECOND_FORMAT
)
{
date
=
SECOND_FORMAT
.
parse
(
dateString
)
;
}
}
else
if
(
dateString
.
length
(
)
==
17
)
{
synchronized
(
MILLISECOND_FORMAT
)
{
date
=
MILLISECOND_FORMAT
.
parse
(
dateString
)
;
}
}
else
{
throw
new
ParseException
(
"Input is not valid date string: "
+
dateString
,
0
)
;
}
return
date
;
}
public
static
Date
round
(
Date
date
,
Resolution
resolution
)
{
return
new
Date
(
round
(
date
.
getTime
(
)
,
resolution
)
)
;
}
public
static
long
round
(
long
time
,
Resolution
resolution
)
{
Calendar
cal
=
Calendar
.
getInstance
(
GMT
)
;
cal
.
setTime
(
new
Date
(
time
)
)
;
if
(
resolution
==
Resolution
.
YEAR
)
{
cal
.
set
(
Calendar
.
MONTH
,
0
)
;
cal
.
set
(
Calendar
.
DAY_OF_MONTH
,
1
)
;
cal
.
set
(
Calendar
.
HOUR_OF_DAY
,
0
)
;
cal
.
set
(
Calendar
.
MINUTE
,
0
)
;
cal
.
set
(
Calendar
.
SECOND
,
0
)
;
cal
.
set
(
Calendar
.
MILLISECOND
,
0
)
;
}
else
if
(
resolution
==
Resolution
.
MONTH
)
{
cal
.
set
(
Calendar
.
DAY_OF_MONTH
,
1
)
;
cal
.
set
(
Calendar
.
HOUR_OF_DAY
,
0
)
;
cal
.
set
(
Calendar
.
MINUTE
,
0
)
;
cal
.
set
(
Calendar
.
SECOND
,
0
)
;
cal
.
set
(
Calendar
.
MILLISECOND
,
0
)
;
}
else
if
(
resolution
==
Resolution
.
DAY
)
{
cal
.
set
(
Calendar
.
HOUR_OF_DAY
,
0
)
;
cal
.
set
(
Calendar
.
MINUTE
,
0
)
;
cal
.
set
(
Calendar
.
SECOND
,
0
)
;
cal
.
set
(
Calendar
.
MILLISECOND
,
0
)
;
}
else
if
(
resolution
==
Resolution
.
HOUR
)
{
cal
.
set
(
Calendar
.
MINUTE
,
0
)
;
cal
.
set
(
Calendar
.
SECOND
,
0
)
;
cal
.
set
(
Calendar
.
MILLISECOND
,
0
)
;
}
else
if
(
resolution
==
Resolution
.
MINUTE
)
{
cal
.
set
(
Calendar
.
SECOND
,
0
)
;
cal
.
set
(
Calendar
.
MILLISECOND
,
0
)
;
}
else
if
(
resolution
==
Resolution
.
SECOND
)
{
cal
.
set
(
Calendar
.
MILLISECOND
,
0
)
;
}
else
if
(
resolution
==
Resolution
.
MILLISECOND
)
{
}
else
{
throw
new
IllegalArgumentException
(
"unknown resolution "
+
resolution
)
;
}
return
cal
.
getTime
(
)
.
getTime
(
)
;
}
public
static
class
Resolution
{
public
static
final
Resolution
YEAR
=
new
Resolution
(
"year"
)
;
public
static
final
Resolution
MONTH
=
new
Resolution
(
"month"
)
;
public
static
final
Resolution
DAY
=
new
Resolution
(
"day"
)
;
public
static
final
Resolution
HOUR
=
new
Resolution
(
"hour"
)
;
public
static
final
Resolution
MINUTE
=
new
Resolution
(
"minute"
)
;
public
static
final
Resolution
SECOND
=
new
Resolution
(
"second"
)
;
public
static
final
Resolution
MILLISECOND
=
new
Resolution
(
"millisecond"
)
;
private
String
resolution
;
private
Resolution
(
)
{
}
private
Resolution
(
String
resolution
)
{
this
.
resolution
=
resolution
;
}
public
String
toString
(
)
{
return
resolution
;
}
}
}
