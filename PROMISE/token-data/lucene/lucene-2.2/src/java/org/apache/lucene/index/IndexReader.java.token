package
org
.
apache
.
lucene
.
index
;
import
org
.
apache
.
lucene
.
document
.
Document
;
import
org
.
apache
.
lucene
.
document
.
FieldSelector
;
import
org
.
apache
.
lucene
.
search
.
Similarity
;
import
org
.
apache
.
lucene
.
store
.
Directory
;
import
org
.
apache
.
lucene
.
store
.
FSDirectory
;
import
org
.
apache
.
lucene
.
store
.
IndexInput
;
import
org
.
apache
.
lucene
.
store
.
Lock
;
import
org
.
apache
.
lucene
.
store
.
LockObtainFailedException
;
import
org
.
apache
.
lucene
.
store
.
AlreadyClosedException
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
public
abstract
class
IndexReader
{
public
static
final
class
FieldOption
{
private
String
option
;
private
FieldOption
(
)
{
}
private
FieldOption
(
String
option
)
{
this
.
option
=
option
;
}
public
String
toString
(
)
{
return
this
.
option
;
}
public
static
final
FieldOption
ALL
=
new
FieldOption
(
"ALL"
)
;
public
static
final
FieldOption
INDEXED
=
new
FieldOption
(
"INDEXED"
)
;
public
static
final
FieldOption
STORES_PAYLOADS
=
new
FieldOption
(
"STORES_PAYLOADS"
)
;
public
static
final
FieldOption
UNINDEXED
=
new
FieldOption
(
"UNINDEXED"
)
;
public
static
final
FieldOption
INDEXED_WITH_TERMVECTOR
=
new
FieldOption
(
"INDEXED_WITH_TERMVECTOR"
)
;
public
static
final
FieldOption
INDEXED_NO_TERMVECTOR
=
new
FieldOption
(
"INDEXED_NO_TERMVECTOR"
)
;
public
static
final
FieldOption
TERMVECTOR
=
new
FieldOption
(
"TERMVECTOR"
)
;
public
static
final
FieldOption
TERMVECTOR_WITH_POSITION
=
new
FieldOption
(
"TERMVECTOR_WITH_POSITION"
)
;
public
static
final
FieldOption
TERMVECTOR_WITH_OFFSET
=
new
FieldOption
(
"TERMVECTOR_WITH_OFFSET"
)
;
public
static
final
FieldOption
TERMVECTOR_WITH_POSITION_OFFSET
=
new
FieldOption
(
"TERMVECTOR_WITH_POSITION_OFFSET"
)
;
}
protected
IndexReader
(
Directory
directory
)
{
this
.
directory
=
directory
;
}
IndexReader
(
Directory
directory
,
SegmentInfos
segmentInfos
,
boolean
closeDirectory
)
{
init
(
directory
,
segmentInfos
,
closeDirectory
,
true
)
;
}
void
init
(
Directory
directory
,
SegmentInfos
segmentInfos
,
boolean
closeDirectory
,
boolean
directoryOwner
)
{
this
.
directory
=
directory
;
this
.
segmentInfos
=
segmentInfos
;
this
.
directoryOwner
=
directoryOwner
;
this
.
closeDirectory
=
closeDirectory
;
}
private
Directory
directory
;
private
boolean
directoryOwner
;
private
boolean
closeDirectory
;
private
IndexDeletionPolicy
deletionPolicy
;
private
boolean
closed
;
protected
final
void
ensureOpen
(
)
throws
AlreadyClosedException
{
if
(
closed
)
{
throw
new
AlreadyClosedException
(
"this IndexReader is closed"
)
;
}
}
private
SegmentInfos
segmentInfos
;
private
Lock
writeLock
;
private
boolean
stale
;
private
boolean
hasChanges
;
private
boolean
rollbackHasChanges
;
private
SegmentInfos
rollbackSegmentInfos
;
public
static
IndexReader
open
(
String
path
)
throws
CorruptIndexException
,
IOException
{
return
open
(
FSDirectory
.
getDirectory
(
path
)
,
true
,
null
)
;
}
public
static
IndexReader
open
(
File
path
)
throws
CorruptIndexException
,
IOException
{
return
open
(
FSDirectory
.
getDirectory
(
path
)
,
true
,
null
)
;
}
public
static
IndexReader
open
(
final
Directory
directory
)
throws
CorruptIndexException
,
IOException
{
return
open
(
directory
,
false
,
null
)
;
}
public
static
IndexReader
open
(
final
Directory
directory
,
IndexDeletionPolicy
deletionPolicy
)
throws
CorruptIndexException
,
IOException
{
return
open
(
directory
,
false
,
deletionPolicy
)
;
}
private
static
IndexReader
open
(
final
Directory
directory
,
final
boolean
closeDirectory
,
final
IndexDeletionPolicy
deletionPolicy
)
throws
CorruptIndexException
,
IOException
{
return
(
IndexReader
)
new
SegmentInfos
.
FindSegmentsFile
(
directory
)
{
protected
Object
doBody
(
String
segmentFileName
)
throws
CorruptIndexException
,
IOException
{
SegmentInfos
infos
=
new
SegmentInfos
(
)
;
infos
.
read
(
directory
,
segmentFileName
)
;
IndexReader
reader
;
if
(
infos
.
size
(
)
==
1
)
{
reader
=
SegmentReader
.
get
(
infos
,
infos
.
info
(
0
)
,
closeDirectory
)
;
}
else
{
IndexReader
[
]
readers
=
new
IndexReader
[
infos
.
size
(
)
]
;
for
(
int
i
=
infos
.
size
(
)
-
1
;
i
>=
0
;
i
--
)
{
try
{
readers
[
i
]
=
SegmentReader
.
get
(
infos
.
info
(
i
)
)
;
}
catch
(
IOException
e
)
{
for
(
i
++
;
i
<
infos
.
size
(
)
;
i
++
)
{
readers
[
i
]
.
close
(
)
;
}
throw
e
;
}
}
reader
=
new
MultiReader
(
directory
,
infos
,
closeDirectory
,
readers
)
;
}
reader
.
deletionPolicy
=
deletionPolicy
;
return
reader
;
}
}
.
run
(
)
;
}
public
Directory
directory
(
)
{
ensureOpen
(
)
;
return
directory
;
}
public
static
long
lastModified
(
String
directory
)
throws
CorruptIndexException
,
IOException
{
return
lastModified
(
new
File
(
directory
)
)
;
}
public
static
long
lastModified
(
File
fileDirectory
)
throws
CorruptIndexException
,
IOException
{
return
(
(
Long
)
new
SegmentInfos
.
FindSegmentsFile
(
fileDirectory
)
{
public
Object
doBody
(
String
segmentFileName
)
{
return
new
Long
(
FSDirectory
.
fileModified
(
fileDirectory
,
segmentFileName
)
)
;
}
}
.
run
(
)
)
.
longValue
(
)
;
}
public
static
long
lastModified
(
final
Directory
directory2
)
throws
CorruptIndexException
,
IOException
{
return
(
(
Long
)
new
SegmentInfos
.
FindSegmentsFile
(
directory2
)
{
public
Object
doBody
(
String
segmentFileName
)
throws
IOException
{
return
new
Long
(
directory2
.
fileModified
(
segmentFileName
)
)
;
}
}
.
run
(
)
)
.
longValue
(
)
;
}
public
static
long
getCurrentVersion
(
String
directory
)
throws
CorruptIndexException
,
IOException
{
return
getCurrentVersion
(
new
File
(
directory
)
)
;
}
public
static
long
getCurrentVersion
(
File
directory
)
throws
CorruptIndexException
,
IOException
{
Directory
dir
=
FSDirectory
.
getDirectory
(
directory
)
;
long
version
=
getCurrentVersion
(
dir
)
;
dir
.
close
(
)
;
return
version
;
}
public
static
long
getCurrentVersion
(
Directory
directory
)
throws
CorruptIndexException
,
IOException
{
return
SegmentInfos
.
readCurrentVersion
(
directory
)
;
}
public
long
getVersion
(
)
{
ensureOpen
(
)
;
return
segmentInfos
.
getVersion
(
)
;
}
public
boolean
isCurrent
(
)
throws
CorruptIndexException
,
IOException
{
ensureOpen
(
)
;
return
SegmentInfos
.
readCurrentVersion
(
directory
)
==
segmentInfos
.
getVersion
(
)
;
}
public
boolean
isOptimized
(
)
{
ensureOpen
(
)
;
return
segmentInfos
.
size
(
)
==
1
&&
hasDeletions
(
)
==
false
;
}
abstract
public
TermFreqVector
[
]
getTermFreqVectors
(
int
docNumber
)
throws
IOException
;
abstract
public
TermFreqVector
getTermFreqVector
(
int
docNumber
,
String
field
)
throws
IOException
;
public
static
boolean
indexExists
(
String
directory
)
{
return
indexExists
(
new
File
(
directory
)
)
;
}
public
static
boolean
indexExists
(
File
directory
)
{
return
SegmentInfos
.
getCurrentSegmentGeneration
(
directory
.
list
(
)
)
!=
-
1
;
}
public
static
boolean
indexExists
(
Directory
directory
)
throws
IOException
{
return
SegmentInfos
.
getCurrentSegmentGeneration
(
directory
)
!=
-
1
;
}
public
abstract
int
numDocs
(
)
;
public
abstract
int
maxDoc
(
)
;
public
Document
document
(
int
n
)
throws
CorruptIndexException
,
IOException
{
ensureOpen
(
)
;
return
document
(
n
,
null
)
;
}
public
abstract
Document
document
(
int
n
,
FieldSelector
fieldSelector
)
throws
CorruptIndexException
,
IOException
;
public
abstract
boolean
isDeleted
(
int
n
)
;
public
abstract
boolean
hasDeletions
(
)
;
public
boolean
hasNorms
(
String
field
)
throws
IOException
{
ensureOpen
(
)
;
return
norms
(
field
)
!=
null
;
}
public
abstract
byte
[
]
norms
(
String
field
)
throws
IOException
;
public
abstract
void
norms
(
String
field
,
byte
[
]
bytes
,
int
offset
)
throws
IOException
;
public
final
synchronized
void
setNorm
(
int
doc
,
String
field
,
byte
value
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
if
(
directoryOwner
)
acquireWriteLock
(
)
;
hasChanges
=
true
;
doSetNorm
(
doc
,
field
,
value
)
;
}
protected
abstract
void
doSetNorm
(
int
doc
,
String
field
,
byte
value
)
throws
CorruptIndexException
,
IOException
;
public
void
setNorm
(
int
doc
,
String
field
,
float
value
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
setNorm
(
doc
,
field
,
Similarity
.
encodeNorm
(
value
)
)
;
}
public
abstract
TermEnum
terms
(
)
throws
IOException
;
public
abstract
TermEnum
terms
(
Term
t
)
throws
IOException
;
public
abstract
int
docFreq
(
Term
t
)
throws
IOException
;
public
TermDocs
termDocs
(
Term
term
)
throws
IOException
{
ensureOpen
(
)
;
TermDocs
termDocs
=
termDocs
(
)
;
termDocs
.
seek
(
term
)
;
return
termDocs
;
}
public
abstract
TermDocs
termDocs
(
)
throws
IOException
;
public
TermPositions
termPositions
(
Term
term
)
throws
IOException
{
ensureOpen
(
)
;
TermPositions
termPositions
=
termPositions
(
)
;
termPositions
.
seek
(
term
)
;
return
termPositions
;
}
public
abstract
TermPositions
termPositions
(
)
throws
IOException
;
private
void
acquireWriteLock
(
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
if
(
stale
)
throw
new
StaleReaderException
(
"IndexReader out of date and no longer valid for delete, undelete, or setNorm operations"
)
;
if
(
writeLock
==
null
)
{
Lock
writeLock
=
directory
.
makeLock
(
IndexWriter
.
WRITE_LOCK_NAME
)
;
if
(
!
writeLock
.
obtain
(
IndexWriter
.
WRITE_LOCK_TIMEOUT
)
)
throw
new
LockObtainFailedException
(
"Index locked for write: "
+
writeLock
)
;
this
.
writeLock
=
writeLock
;
if
(
SegmentInfos
.
readCurrentVersion
(
directory
)
>
segmentInfos
.
getVersion
(
)
)
{
stale
=
true
;
this
.
writeLock
.
release
(
)
;
this
.
writeLock
=
null
;
throw
new
StaleReaderException
(
"IndexReader out of date and no longer valid for delete, undelete, or setNorm operations"
)
;
}
}
}
public
final
synchronized
void
deleteDocument
(
int
docNum
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
if
(
directoryOwner
)
acquireWriteLock
(
)
;
hasChanges
=
true
;
doDelete
(
docNum
)
;
}
protected
abstract
void
doDelete
(
int
docNum
)
throws
CorruptIndexException
,
IOException
;
public
final
int
deleteDocuments
(
Term
term
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
TermDocs
docs
=
termDocs
(
term
)
;
if
(
docs
==
null
)
return
0
;
int
n
=
0
;
try
{
while
(
docs
.
next
(
)
)
{
deleteDocument
(
docs
.
doc
(
)
)
;
n
++
;
}
}
finally
{
docs
.
close
(
)
;
}
return
n
;
}
public
final
synchronized
void
undeleteAll
(
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
if
(
directoryOwner
)
acquireWriteLock
(
)
;
hasChanges
=
true
;
doUndeleteAll
(
)
;
}
protected
abstract
void
doUndeleteAll
(
)
throws
CorruptIndexException
,
IOException
;
void
startCommit
(
)
{
if
(
directoryOwner
)
{
rollbackSegmentInfos
=
(
SegmentInfos
)
segmentInfos
.
clone
(
)
;
}
rollbackHasChanges
=
hasChanges
;
}
void
rollbackCommit
(
)
{
if
(
directoryOwner
)
{
for
(
int
i
=
0
;
i
<
segmentInfos
.
size
(
)
;
i
++
)
{
segmentInfos
.
info
(
i
)
.
reset
(
rollbackSegmentInfos
.
info
(
i
)
)
;
}
rollbackSegmentInfos
=
null
;
}
hasChanges
=
rollbackHasChanges
;
}
protected
final
synchronized
void
commit
(
)
throws
IOException
{
if
(
hasChanges
)
{
if
(
directoryOwner
)
{
IndexFileDeleter
deleter
=
new
IndexFileDeleter
(
directory
,
deletionPolicy
==
null
?
new
KeepOnlyLastCommitDeletionPolicy
(
)
:
deletionPolicy
,
segmentInfos
,
null
)
;
startCommit
(
)
;
boolean
success
=
false
;
try
{
doCommit
(
)
;
segmentInfos
.
write
(
directory
)
;
success
=
true
;
}
finally
{
if
(
!
success
)
{
rollbackCommit
(
)
;
deleter
.
refresh
(
)
;
}
}
deleter
.
checkpoint
(
segmentInfos
,
true
)
;
if
(
writeLock
!=
null
)
{
writeLock
.
release
(
)
;
writeLock
=
null
;
}
}
else
doCommit
(
)
;
}
hasChanges
=
false
;
}
protected
abstract
void
doCommit
(
)
throws
IOException
;
public
final
synchronized
void
close
(
)
throws
IOException
{
if
(
!
closed
)
{
commit
(
)
;
doClose
(
)
;
if
(
directoryOwner
)
closed
=
true
;
if
(
closeDirectory
)
directory
.
close
(
)
;
}
}
protected
abstract
void
doClose
(
)
throws
IOException
;
protected
void
finalize
(
)
throws
Throwable
{
try
{
if
(
writeLock
!=
null
)
{
writeLock
.
release
(
)
;
writeLock
=
null
;
}
}
finally
{
super
.
finalize
(
)
;
}
}
public
abstract
Collection
getFieldNames
(
FieldOption
fldOption
)
;
public
static
boolean
isLocked
(
Directory
directory
)
throws
IOException
{
return
directory
.
makeLock
(
IndexWriter
.
WRITE_LOCK_NAME
)
.
isLocked
(
)
;
}
public
static
boolean
isLocked
(
String
directory
)
throws
IOException
{
Directory
dir
=
FSDirectory
.
getDirectory
(
directory
)
;
boolean
result
=
isLocked
(
dir
)
;
dir
.
close
(
)
;
return
result
;
}
public
static
void
unlock
(
Directory
directory
)
throws
IOException
{
directory
.
makeLock
(
IndexWriter
.
WRITE_LOCK_NAME
)
.
release
(
)
;
}
public
static
void
main
(
String
[
]
args
)
{
String
filename
=
null
;
boolean
extract
=
false
;
for
(
int
i
=
0
;
i
<
args
.
length
;
++
i
)
{
if
(
args
[
i
]
.
equals
(
"-extract"
)
)
{
extract
=
true
;
}
else
if
(
filename
==
null
)
{
filename
=
args
[
i
]
;
}
}
if
(
filename
==
null
)
{
System
.
out
.
println
(
"Usage: org.apache.lucene.index.IndexReader [-extract] <cfsfile>"
)
;
return
;
}
Directory
dir
=
null
;
CompoundFileReader
cfr
=
null
;
try
{
File
file
=
new
File
(
filename
)
;
String
dirname
=
file
.
getAbsoluteFile
(
)
.
getParent
(
)
;
filename
=
file
.
getName
(
)
;
dir
=
FSDirectory
.
getDirectory
(
dirname
)
;
cfr
=
new
CompoundFileReader
(
dir
,
filename
)
;
String
[
]
files
=
cfr
.
list
(
)
;
Arrays
.
sort
(
files
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
++
i
)
{
long
len
=
cfr
.
fileLength
(
files
[
i
]
)
;
if
(
extract
)
{
System
.
out
.
println
(
"extract "
+
files
[
i
]
+
" with "
+
len
+
" bytes to local directory..."
)
;
IndexInput
ii
=
cfr
.
openInput
(
files
[
i
]
)
;
FileOutputStream
f
=
new
FileOutputStream
(
files
[
i
]
)
;
byte
[
]
buffer
=
new
byte
[
1024
]
;
int
chunk
=
buffer
.
length
;
while
(
len
>
0
)
{
final
int
bufLen
=
(
int
)
Math
.
min
(
chunk
,
len
)
;
ii
.
readBytes
(
buffer
,
0
,
bufLen
)
;
f
.
write
(
buffer
,
0
,
bufLen
)
;
len
-=
bufLen
;
}
f
.
close
(
)
;
ii
.
close
(
)
;
}
else
System
.
out
.
println
(
files
[
i
]
+
": "
+
len
+
" bytes"
)
;
}
}
catch
(
IOException
ioe
)
{
ioe
.
printStackTrace
(
)
;
}
finally
{
try
{
if
(
dir
!=
null
)
dir
.
close
(
)
;
if
(
cfr
!=
null
)
cfr
.
close
(
)
;
}
catch
(
IOException
ioe
)
{
ioe
.
printStackTrace
(
)
;
}
}
}
}
