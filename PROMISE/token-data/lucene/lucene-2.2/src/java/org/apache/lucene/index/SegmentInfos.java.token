package
org
.
apache
.
lucene
.
index
;
import
org
.
apache
.
lucene
.
store
.
Directory
;
import
org
.
apache
.
lucene
.
store
.
IndexInput
;
import
org
.
apache
.
lucene
.
store
.
IndexOutput
;
import
java
.
io
.
File
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
IOException
;
import
java
.
io
.
PrintStream
;
import
java
.
util
.
Vector
;
final
class
SegmentInfos
extends
Vector
{
public
static
final
int
FORMAT
=
-
1
;
public
static
final
int
FORMAT_LOCKLESS
=
-
2
;
public
static
final
int
FORMAT_SINGLE_NORM_FILE
=
-
3
;
private
static
final
int
CURRENT_FORMAT
=
FORMAT_SINGLE_NORM_FILE
;
public
int
counter
=
0
;
private
long
version
=
System
.
currentTimeMillis
(
)
;
private
long
generation
=
0
;
private
long
lastGeneration
=
0
;
private
static
PrintStream
infoStream
;
public
final
SegmentInfo
info
(
int
i
)
{
return
(
SegmentInfo
)
elementAt
(
i
)
;
}
public
static
long
getCurrentSegmentGeneration
(
String
[
]
files
)
{
if
(
files
==
null
)
{
return
-
1
;
}
long
max
=
-
1
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
String
file
=
files
[
i
]
;
if
(
file
.
startsWith
(
IndexFileNames
.
SEGMENTS
)
&&
!
file
.
equals
(
IndexFileNames
.
SEGMENTS_GEN
)
)
{
long
gen
=
generationFromSegmentsFileName
(
file
)
;
if
(
gen
>
max
)
{
max
=
gen
;
}
}
}
return
max
;
}
public
static
long
getCurrentSegmentGeneration
(
Directory
directory
)
throws
IOException
{
String
[
]
files
=
directory
.
list
(
)
;
if
(
files
==
null
)
throw
new
IOException
(
"cannot read directory "
+
directory
+
": list() returned null"
)
;
return
getCurrentSegmentGeneration
(
files
)
;
}
public
static
String
getCurrentSegmentFileName
(
String
[
]
files
)
throws
IOException
{
return
IndexFileNames
.
fileNameFromGeneration
(
IndexFileNames
.
SEGMENTS
,
""
,
getCurrentSegmentGeneration
(
files
)
)
;
}
public
static
String
getCurrentSegmentFileName
(
Directory
directory
)
throws
IOException
{
return
IndexFileNames
.
fileNameFromGeneration
(
IndexFileNames
.
SEGMENTS
,
""
,
getCurrentSegmentGeneration
(
directory
)
)
;
}
public
String
getCurrentSegmentFileName
(
)
{
return
IndexFileNames
.
fileNameFromGeneration
(
IndexFileNames
.
SEGMENTS
,
""
,
lastGeneration
)
;
}
public
static
long
generationFromSegmentsFileName
(
String
fileName
)
{
if
(
fileName
.
equals
(
IndexFileNames
.
SEGMENTS
)
)
{
return
0
;
}
else
if
(
fileName
.
startsWith
(
IndexFileNames
.
SEGMENTS
)
)
{
return
Long
.
parseLong
(
fileName
.
substring
(
1
+
IndexFileNames
.
SEGMENTS
.
length
(
)
)
,
Character
.
MAX_RADIX
)
;
}
else
{
throw
new
IllegalArgumentException
(
"fileName \""
+
fileName
+
"\" is not a segments file"
)
;
}
}
public
String
getNextSegmentFileName
(
)
{
long
nextGeneration
;
if
(
generation
==
-
1
)
{
nextGeneration
=
1
;
}
else
{
nextGeneration
=
generation
+
1
;
}
return
IndexFileNames
.
fileNameFromGeneration
(
IndexFileNames
.
SEGMENTS
,
""
,
nextGeneration
)
;
}
public
final
void
read
(
Directory
directory
,
String
segmentFileName
)
throws
CorruptIndexException
,
IOException
{
boolean
success
=
false
;
IndexInput
input
=
directory
.
openInput
(
segmentFileName
)
;
generation
=
generationFromSegmentsFileName
(
segmentFileName
)
;
lastGeneration
=
generation
;
try
{
int
format
=
input
.
readInt
(
)
;
if
(
format
<
0
)
{
if
(
format
<
CURRENT_FORMAT
)
throw
new
CorruptIndexException
(
"Unknown format version: "
+
format
)
;
version
=
input
.
readLong
(
)
;
counter
=
input
.
readInt
(
)
;
}
else
{
counter
=
format
;
}
for
(
int
i
=
input
.
readInt
(
)
;
i
>
0
;
i
--
)
{
addElement
(
new
SegmentInfo
(
directory
,
format
,
input
)
)
;
}
if
(
format
>=
0
)
{
if
(
input
.
getFilePointer
(
)
>=
input
.
length
(
)
)
version
=
System
.
currentTimeMillis
(
)
;
else
version
=
input
.
readLong
(
)
;
}
success
=
true
;
}
finally
{
input
.
close
(
)
;
if
(
!
success
)
{
clear
(
)
;
}
}
}
public
final
void
read
(
Directory
directory
)
throws
CorruptIndexException
,
IOException
{
generation
=
lastGeneration
=
-
1
;
new
FindSegmentsFile
(
directory
)
{
protected
Object
doBody
(
String
segmentFileName
)
throws
CorruptIndexException
,
IOException
{
read
(
directory
,
segmentFileName
)
;
return
null
;
}
}
.
run
(
)
;
}
public
final
void
write
(
Directory
directory
)
throws
IOException
{
String
segmentFileName
=
getNextSegmentFileName
(
)
;
if
(
generation
==
-
1
)
{
generation
=
1
;
}
else
{
generation
++
;
}
IndexOutput
output
=
directory
.
createOutput
(
segmentFileName
)
;
boolean
success
=
false
;
try
{
output
.
writeInt
(
CURRENT_FORMAT
)
;
output
.
writeLong
(
++
version
)
;
output
.
writeInt
(
counter
)
;
output
.
writeInt
(
size
(
)
)
;
for
(
int
i
=
0
;
i
<
size
(
)
;
i
++
)
{
info
(
i
)
.
write
(
output
)
;
}
}
finally
{
try
{
output
.
close
(
)
;
success
=
true
;
}
finally
{
if
(
!
success
)
{
directory
.
deleteFile
(
segmentFileName
)
;
}
}
}
try
{
output
=
directory
.
createOutput
(
IndexFileNames
.
SEGMENTS_GEN
)
;
try
{
output
.
writeInt
(
FORMAT_LOCKLESS
)
;
output
.
writeLong
(
generation
)
;
output
.
writeLong
(
generation
)
;
}
finally
{
output
.
close
(
)
;
}
}
catch
(
IOException
e
)
{
}
lastGeneration
=
generation
;
}
public
Object
clone
(
)
{
SegmentInfos
sis
=
(
SegmentInfos
)
super
.
clone
(
)
;
for
(
int
i
=
0
;
i
<
sis
.
size
(
)
;
i
++
)
{
sis
.
setElementAt
(
(
(
SegmentInfo
)
sis
.
elementAt
(
i
)
)
.
clone
(
)
,
i
)
;
}
return
sis
;
}
public
long
getVersion
(
)
{
return
version
;
}
public
long
getGeneration
(
)
{
return
generation
;
}
public
static
long
readCurrentVersion
(
Directory
directory
)
throws
CorruptIndexException
,
IOException
{
return
(
(
Long
)
new
FindSegmentsFile
(
directory
)
{
protected
Object
doBody
(
String
segmentFileName
)
throws
CorruptIndexException
,
IOException
{
IndexInput
input
=
directory
.
openInput
(
segmentFileName
)
;
int
format
=
0
;
long
version
=
0
;
try
{
format
=
input
.
readInt
(
)
;
if
(
format
<
0
)
{
if
(
format
<
CURRENT_FORMAT
)
throw
new
CorruptIndexException
(
"Unknown format version: "
+
format
)
;
version
=
input
.
readLong
(
)
;
}
}
finally
{
input
.
close
(
)
;
}
if
(
format
<
0
)
return
new
Long
(
version
)
;
SegmentInfos
sis
=
new
SegmentInfos
(
)
;
sis
.
read
(
directory
,
segmentFileName
)
;
return
new
Long
(
sis
.
getVersion
(
)
)
;
}
}
.
run
(
)
)
.
longValue
(
)
;
}
public
static
void
setInfoStream
(
PrintStream
infoStream
)
{
SegmentInfos
.
infoStream
=
infoStream
;
}
private
static
int
defaultGenFileRetryCount
=
10
;
private
static
int
defaultGenFileRetryPauseMsec
=
50
;
private
static
int
defaultGenLookaheadCount
=
10
;
public
static
void
setDefaultGenFileRetryCount
(
int
count
)
{
defaultGenFileRetryCount
=
count
;
}
public
static
int
getDefaultGenFileRetryCount
(
)
{
return
defaultGenFileRetryCount
;
}
public
static
void
setDefaultGenFileRetryPauseMsec
(
int
msec
)
{
defaultGenFileRetryPauseMsec
=
msec
;
}
public
static
int
getDefaultGenFileRetryPauseMsec
(
)
{
return
defaultGenFileRetryPauseMsec
;
}
public
static
void
setDefaultGenLookaheadCount
(
int
count
)
{
defaultGenLookaheadCount
=
count
;
}
public
static
int
getDefaultGenLookahedCount
(
)
{
return
defaultGenLookaheadCount
;
}
public
static
PrintStream
getInfoStream
(
)
{
return
infoStream
;
}
private
static
void
message
(
String
message
)
{
if
(
infoStream
!=
null
)
{
infoStream
.
println
(
Thread
.
currentThread
(
)
.
getName
(
)
+
": "
+
message
)
;
}
}
public
abstract
static
class
FindSegmentsFile
{
File
fileDirectory
;
Directory
directory
;
public
FindSegmentsFile
(
File
directory
)
{
this
.
fileDirectory
=
directory
;
}
public
FindSegmentsFile
(
Directory
directory
)
{
this
.
directory
=
directory
;
}
public
Object
run
(
)
throws
CorruptIndexException
,
IOException
{
String
segmentFileName
=
null
;
long
lastGen
=
-
1
;
long
gen
=
0
;
int
genLookaheadCount
=
0
;
IOException
exc
=
null
;
boolean
retry
=
false
;
int
method
=
0
;
while
(
true
)
{
String
[
]
files
=
null
;
if
(
0
==
method
)
{
if
(
directory
!=
null
)
{
files
=
directory
.
list
(
)
;
if
(
files
==
null
)
throw
new
FileNotFoundException
(
"cannot read directory "
+
directory
+
": list() returned null"
)
;
}
else
{
files
=
fileDirectory
.
list
(
)
;
if
(
files
==
null
)
throw
new
FileNotFoundException
(
"cannot read directory "
+
fileDirectory
+
": list() returned null"
)
;
}
gen
=
getCurrentSegmentGeneration
(
files
)
;
if
(
gen
==
-
1
)
{
String
s
=
""
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
s
+=
" "
+
files
[
i
]
;
}
throw
new
FileNotFoundException
(
"no segments* file found in "
+
directory
+
": files:"
+
s
)
;
}
}
if
(
1
==
method
||
(
0
==
method
&&
lastGen
==
gen
&&
retry
)
)
{
method
=
1
;
for
(
int
i
=
0
;
i
<
defaultGenFileRetryCount
;
i
++
)
{
IndexInput
genInput
=
null
;
try
{
genInput
=
directory
.
openInput
(
IndexFileNames
.
SEGMENTS_GEN
)
;
}
catch
(
IOException
e
)
{
message
(
"segments.gen open: IOException "
+
e
)
;
}
if
(
genInput
!=
null
)
{
try
{
int
version
=
genInput
.
readInt
(
)
;
if
(
version
==
FORMAT_LOCKLESS
)
{
long
gen0
=
genInput
.
readLong
(
)
;
long
gen1
=
genInput
.
readLong
(
)
;
message
(
"fallback check: "
+
gen0
+
"; "
+
gen1
)
;
if
(
gen0
==
gen1
)
{
if
(
gen0
>
gen
)
{
message
(
"fallback to '"
+
IndexFileNames
.
SEGMENTS_GEN
+
"' check: now try generation "
+
gen0
+
" > "
+
gen
)
;
gen
=
gen0
;
}
break
;
}
}
}
catch
(
IOException
err2
)
{
}
finally
{
genInput
.
close
(
)
;
}
}
try
{
Thread
.
sleep
(
defaultGenFileRetryPauseMsec
)
;
}
catch
(
InterruptedException
e
)
{
}
}
}
if
(
2
==
method
||
(
1
==
method
&&
lastGen
==
gen
&&
retry
)
)
{
method
=
2
;
if
(
genLookaheadCount
<
defaultGenLookaheadCount
)
{
gen
++
;
genLookaheadCount
++
;
message
(
"look ahead increment gen to "
+
gen
)
;
}
}
if
(
lastGen
==
gen
)
{
if
(
retry
)
{
throw
exc
;
}
else
{
retry
=
true
;
}
}
else
{
retry
=
false
;
}
lastGen
=
gen
;
segmentFileName
=
IndexFileNames
.
fileNameFromGeneration
(
IndexFileNames
.
SEGMENTS
,
""
,
gen
)
;
try
{
Object
v
=
doBody
(
segmentFileName
)
;
if
(
exc
!=
null
)
{
message
(
"success on "
+
segmentFileName
)
;
}
return
v
;
}
catch
(
IOException
err
)
{
if
(
exc
==
null
)
{
exc
=
err
;
}
message
(
"primary Exception on '"
+
segmentFileName
+
"': "
+
err
+
"'; will retry: retry="
+
retry
+
"; gen = "
+
gen
)
;
if
(
!
retry
&&
gen
>
1
)
{
String
prevSegmentFileName
=
IndexFileNames
.
fileNameFromGeneration
(
IndexFileNames
.
SEGMENTS
,
""
,
gen
-
1
)
;
if
(
directory
.
fileExists
(
prevSegmentFileName
)
)
{
message
(
"fallback to prior segment file '"
+
prevSegmentFileName
+
"'"
)
;
try
{
Object
v
=
doBody
(
prevSegmentFileName
)
;
if
(
exc
!=
null
)
{
message
(
"success on fallback "
+
prevSegmentFileName
)
;
}
return
v
;
}
catch
(
IOException
err2
)
{
message
(
"secondary Exception on '"
+
prevSegmentFileName
+
"': "
+
err2
+
"'; will retry"
)
;
}
}
}
}
}
}
protected
abstract
Object
doBody
(
String
segmentFileName
)
throws
CorruptIndexException
,
IOException
;
}
}
