package
org
.
apache
.
lucene
.
index
;
import
org
.
apache
.
lucene
.
index
.
IndexFileNames
;
import
org
.
apache
.
lucene
.
index
.
SegmentInfos
;
import
org
.
apache
.
lucene
.
index
.
SegmentInfo
;
import
org
.
apache
.
lucene
.
store
.
Directory
;
import
java
.
io
.
IOException
;
import
java
.
io
.
PrintStream
;
import
java
.
util
.
Map
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
final
class
IndexFileDeleter
{
private
List
deletable
;
private
Map
refCounts
=
new
HashMap
(
)
;
private
List
commits
=
new
ArrayList
(
)
;
private
List
lastFiles
=
new
ArrayList
(
)
;
private
List
commitsToDelete
=
new
ArrayList
(
)
;
private
PrintStream
infoStream
;
private
Directory
directory
;
private
IndexDeletionPolicy
policy
;
void
setInfoStream
(
PrintStream
infoStream
)
{
this
.
infoStream
=
infoStream
;
}
private
void
message
(
String
message
)
{
infoStream
.
println
(
this
+
" "
+
Thread
.
currentThread
(
)
.
getName
(
)
+
": "
+
message
)
;
}
public
IndexFileDeleter
(
Directory
directory
,
IndexDeletionPolicy
policy
,
SegmentInfos
segmentInfos
,
PrintStream
infoStream
)
throws
CorruptIndexException
,
IOException
{
this
.
infoStream
=
infoStream
;
this
.
policy
=
policy
;
this
.
directory
=
directory
;
long
currentGen
=
segmentInfos
.
getGeneration
(
)
;
IndexFileNameFilter
filter
=
IndexFileNameFilter
.
getFilter
(
)
;
String
[
]
files
=
directory
.
list
(
)
;
if
(
files
==
null
)
throw
new
IOException
(
"cannot read directory "
+
directory
+
": list() returned null"
)
;
CommitPoint
currentCommitPoint
=
null
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
String
fileName
=
files
[
i
]
;
if
(
filter
.
accept
(
null
,
fileName
)
&&
!
fileName
.
equals
(
IndexFileNames
.
SEGMENTS_GEN
)
)
{
getRefCount
(
fileName
)
;
if
(
fileName
.
startsWith
(
IndexFileNames
.
SEGMENTS
)
)
{
if
(
SegmentInfos
.
generationFromSegmentsFileName
(
fileName
)
<=
currentGen
)
{
if
(
infoStream
!=
null
)
{
message
(
"init: load commit \""
+
fileName
+
"\""
)
;
}
SegmentInfos
sis
=
new
SegmentInfos
(
)
;
sis
.
read
(
directory
,
fileName
)
;
CommitPoint
commitPoint
=
new
CommitPoint
(
sis
)
;
if
(
sis
.
getGeneration
(
)
==
segmentInfos
.
getGeneration
(
)
)
{
currentCommitPoint
=
commitPoint
;
}
commits
.
add
(
commitPoint
)
;
incRef
(
sis
,
true
)
;
}
}
}
}
if
(
currentCommitPoint
==
null
)
{
throw
new
CorruptIndexException
(
"failed to locate current segments_N file"
)
;
}
Collections
.
sort
(
commits
)
;
Iterator
it
=
refCounts
.
keySet
(
)
.
iterator
(
)
;
while
(
it
.
hasNext
(
)
)
{
String
fileName
=
(
String
)
it
.
next
(
)
;
RefCount
rc
=
(
RefCount
)
refCounts
.
get
(
fileName
)
;
if
(
0
==
rc
.
count
)
{
if
(
infoStream
!=
null
)
{
message
(
"init: removing unreferenced file \""
+
fileName
+
"\""
)
;
}
deleteFile
(
fileName
)
;
}
}
policy
.
onInit
(
commits
)
;
if
(
currentCommitPoint
.
deleted
)
{
checkpoint
(
segmentInfos
,
false
)
;
}
deleteCommits
(
)
;
}
private
void
deleteCommits
(
)
throws
IOException
{
int
size
=
commitsToDelete
.
size
(
)
;
if
(
size
>
0
)
{
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
CommitPoint
commit
=
(
CommitPoint
)
commitsToDelete
.
get
(
i
)
;
if
(
infoStream
!=
null
)
{
message
(
"deleteCommits: now remove commit \""
+
commit
.
getSegmentsFileName
(
)
+
"\""
)
;
}
int
size2
=
commit
.
files
.
size
(
)
;
for
(
int
j
=
0
;
j
<
size2
;
j
++
)
{
decRef
(
(
List
)
commit
.
files
.
get
(
j
)
)
;
}
decRef
(
commit
.
getSegmentsFileName
(
)
)
;
}
commitsToDelete
.
clear
(
)
;
size
=
commits
.
size
(
)
;
int
readFrom
=
0
;
int
writeTo
=
0
;
while
(
readFrom
<
size
)
{
CommitPoint
commit
=
(
CommitPoint
)
commits
.
get
(
readFrom
)
;
if
(
!
commit
.
deleted
)
{
if
(
writeTo
!=
readFrom
)
{
commits
.
set
(
writeTo
,
commits
.
get
(
readFrom
)
)
;
}
writeTo
++
;
}
readFrom
++
;
}
while
(
size
>
writeTo
)
{
commits
.
remove
(
size
-
1
)
;
size
--
;
}
}
}
public
void
refresh
(
)
throws
IOException
{
String
[
]
files
=
directory
.
list
(
)
;
if
(
files
==
null
)
throw
new
IOException
(
"cannot read directory "
+
directory
+
": list() returned null"
)
;
IndexFileNameFilter
filter
=
IndexFileNameFilter
.
getFilter
(
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
String
fileName
=
files
[
i
]
;
if
(
filter
.
accept
(
null
,
fileName
)
&&
!
refCounts
.
containsKey
(
fileName
)
&&
!
fileName
.
equals
(
IndexFileNames
.
SEGMENTS_GEN
)
)
{
if
(
infoStream
!=
null
)
{
message
(
"refresh: removing newly created unreferenced file \""
+
fileName
+
"\""
)
;
}
deleteFile
(
fileName
)
;
}
}
}
public
void
checkpoint
(
SegmentInfos
segmentInfos
,
boolean
isCommit
)
throws
IOException
{
if
(
infoStream
!=
null
)
{
message
(
"now checkpoint \""
+
segmentInfos
.
getCurrentSegmentFileName
(
)
+
"\" [isCommit = "
+
isCommit
+
"]"
)
;
}
if
(
deletable
!=
null
)
{
List
oldDeletable
=
deletable
;
deletable
=
null
;
int
size
=
oldDeletable
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
deleteFile
(
(
String
)
oldDeletable
.
get
(
i
)
)
;
}
}
incRef
(
segmentInfos
,
isCommit
)
;
if
(
isCommit
)
{
commits
.
add
(
new
CommitPoint
(
segmentInfos
)
)
;
policy
.
onCommit
(
commits
)
;
deleteCommits
(
)
;
}
int
size
=
lastFiles
.
size
(
)
;
if
(
size
>
0
)
{
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
decRef
(
(
List
)
lastFiles
.
get
(
i
)
)
;
}
lastFiles
.
clear
(
)
;
}
if
(
!
isCommit
)
{
size
=
segmentInfos
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
SegmentInfo
segmentInfo
=
segmentInfos
.
info
(
i
)
;
if
(
segmentInfo
.
dir
==
directory
)
{
lastFiles
.
add
(
segmentInfo
.
files
(
)
)
;
}
}
}
}
void
incRef
(
SegmentInfos
segmentInfos
,
boolean
isCommit
)
throws
IOException
{
int
size
=
segmentInfos
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
SegmentInfo
segmentInfo
=
segmentInfos
.
info
(
i
)
;
if
(
segmentInfo
.
dir
==
directory
)
{
incRef
(
segmentInfo
.
files
(
)
)
;
}
}
if
(
isCommit
)
{
getRefCount
(
segmentInfos
.
getCurrentSegmentFileName
(
)
)
.
IncRef
(
)
;
}
}
private
void
incRef
(
List
files
)
throws
IOException
{
int
size
=
files
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
String
fileName
=
(
String
)
files
.
get
(
i
)
;
RefCount
rc
=
getRefCount
(
fileName
)
;
if
(
infoStream
!=
null
)
{
message
(
"  IncRef \""
+
fileName
+
"\": pre-incr count is "
+
rc
.
count
)
;
}
rc
.
IncRef
(
)
;
}
}
private
void
decRef
(
List
files
)
throws
IOException
{
int
size
=
files
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
decRef
(
(
String
)
files
.
get
(
i
)
)
;
}
}
private
void
decRef
(
String
fileName
)
throws
IOException
{
RefCount
rc
=
getRefCount
(
fileName
)
;
if
(
infoStream
!=
null
)
{
message
(
"  DecRef \""
+
fileName
+
"\": pre-decr count is "
+
rc
.
count
)
;
}
if
(
0
==
rc
.
DecRef
(
)
)
{
deleteFile
(
fileName
)
;
refCounts
.
remove
(
fileName
)
;
}
}
void
decRef
(
SegmentInfos
segmentInfos
)
throws
IOException
{
final
int
size
=
segmentInfos
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
SegmentInfo
segmentInfo
=
segmentInfos
.
info
(
i
)
;
if
(
segmentInfo
.
dir
==
directory
)
{
decRef
(
segmentInfo
.
files
(
)
)
;
}
}
}
private
RefCount
getRefCount
(
String
fileName
)
{
RefCount
rc
;
if
(
!
refCounts
.
containsKey
(
fileName
)
)
{
rc
=
new
RefCount
(
)
;
refCounts
.
put
(
fileName
,
rc
)
;
}
else
{
rc
=
(
RefCount
)
refCounts
.
get
(
fileName
)
;
}
return
rc
;
}
private
void
deleteFile
(
String
fileName
)
throws
IOException
{
try
{
if
(
infoStream
!=
null
)
{
message
(
"delete \""
+
fileName
+
"\""
)
;
}
directory
.
deleteFile
(
fileName
)
;
}
catch
(
IOException
e
)
{
if
(
directory
.
fileExists
(
fileName
)
)
{
if
(
infoStream
!=
null
)
{
message
(
"IndexFileDeleter: unable to remove file \""
+
fileName
+
"\": "
+
e
.
toString
(
)
+
"; Will re-try later."
)
;
}
if
(
deletable
==
null
)
{
deletable
=
new
ArrayList
(
)
;
}
deletable
.
add
(
fileName
)
;
}
}
}
public
void
deleteDirect
(
Directory
otherDir
,
List
segments
)
throws
IOException
{
int
size
=
segments
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
List
filestoDelete
=
(
(
SegmentInfo
)
segments
.
get
(
i
)
)
.
files
(
)
;
int
size2
=
filestoDelete
.
size
(
)
;
for
(
int
j
=
0
;
j
<
size2
;
j
++
)
{
otherDir
.
deleteFile
(
(
String
)
filestoDelete
.
get
(
j
)
)
;
}
}
}
final
private
static
class
RefCount
{
int
count
;
final
private
int
IncRef
(
)
{
return
++
count
;
}
final
private
int
DecRef
(
)
{
return
--
count
;
}
}
final
private
class
CommitPoint
implements
Comparable
,
IndexCommitPoint
{
long
gen
;
List
files
;
String
segmentsFileName
;
boolean
deleted
;
public
CommitPoint
(
SegmentInfos
segmentInfos
)
throws
IOException
{
segmentsFileName
=
segmentInfos
.
getCurrentSegmentFileName
(
)
;
int
size
=
segmentInfos
.
size
(
)
;
files
=
new
ArrayList
(
size
)
;
gen
=
segmentInfos
.
getGeneration
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
SegmentInfo
segmentInfo
=
segmentInfos
.
info
(
i
)
;
if
(
segmentInfo
.
dir
==
directory
)
{
files
.
add
(
segmentInfo
.
files
(
)
)
;
}
}
}
public
String
getSegmentsFileName
(
)
{
return
segmentsFileName
;
}
public
void
delete
(
)
{
if
(
!
deleted
)
{
deleted
=
true
;
commitsToDelete
.
add
(
this
)
;
}
}
public
int
compareTo
(
Object
obj
)
{
CommitPoint
commit
=
(
CommitPoint
)
obj
;
if
(
gen
<
commit
.
gen
)
{
return
-
1
;
}
else
if
(
gen
>
commit
.
gen
)
{
return
1
;
}
else
{
return
0
;
}
}
}
}
