package
org
.
apache
.
lucene
.
search
.
payloads
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
index
.
Term
;
import
org
.
apache
.
lucene
.
index
.
TermPositions
;
import
org
.
apache
.
lucene
.
search
.
*
;
import
org
.
apache
.
lucene
.
search
.
spans
.
SpanScorer
;
import
org
.
apache
.
lucene
.
search
.
spans
.
SpanTermQuery
;
import
org
.
apache
.
lucene
.
search
.
spans
.
SpanWeight
;
import
org
.
apache
.
lucene
.
search
.
spans
.
TermSpans
;
import
java
.
io
.
IOException
;
public
class
BoostingTermQuery
extends
SpanTermQuery
{
public
BoostingTermQuery
(
Term
term
)
{
super
(
term
)
;
}
protected
Weight
createWeight
(
Searcher
searcher
)
throws
IOException
{
return
new
BoostingTermWeight
(
this
,
searcher
)
;
}
protected
class
BoostingTermWeight
extends
SpanWeight
implements
Weight
{
public
BoostingTermWeight
(
BoostingTermQuery
query
,
Searcher
searcher
)
throws
IOException
{
super
(
query
,
searcher
)
;
}
public
Scorer
scorer
(
IndexReader
reader
)
throws
IOException
{
return
new
BoostingSpanScorer
(
(
TermSpans
)
query
.
getSpans
(
reader
)
,
this
,
similarity
,
reader
.
norms
(
query
.
getField
(
)
)
)
;
}
class
BoostingSpanScorer
extends
SpanScorer
{
byte
[
]
payload
=
new
byte
[
256
]
;
private
TermPositions
positions
;
protected
float
payloadScore
;
private
int
payloadsSeen
;
public
BoostingSpanScorer
(
TermSpans
spans
,
Weight
weight
,
Similarity
similarity
,
byte
[
]
norms
)
throws
IOException
{
super
(
spans
,
weight
,
similarity
,
norms
)
;
positions
=
spans
.
getPositions
(
)
;
}
protected
boolean
setFreqCurrentDoc
(
)
throws
IOException
{
if
(
!
more
)
{
return
false
;
}
doc
=
spans
.
doc
(
)
;
freq
=
0.0f
;
payloadScore
=
0
;
payloadsSeen
=
0
;
Similarity
similarity1
=
getSimilarity
(
)
;
while
(
more
&&
doc
==
spans
.
doc
(
)
)
{
int
matchLength
=
spans
.
end
(
)
-
spans
.
start
(
)
;
freq
+=
similarity1
.
sloppyFreq
(
matchLength
)
;
processPayload
(
similarity1
)
;
more
=
spans
.
next
(
)
;
}
return
more
||
(
freq
!=
0
)
;
}
protected
void
processPayload
(
Similarity
similarity
)
throws
IOException
{
if
(
positions
.
isPayloadAvailable
(
)
)
{
payload
=
positions
.
getPayload
(
payload
,
0
)
;
payloadScore
+=
similarity
.
scorePayload
(
payload
,
0
,
positions
.
getPayloadLength
(
)
)
;
payloadsSeen
++
;
}
else
{
}
}
public
float
score
(
)
throws
IOException
{
return
super
.
score
(
)
*
(
payloadsSeen
>
0
?
(
payloadScore
/
payloadsSeen
)
:
1
)
;
}
public
Explanation
explain
(
final
int
doc
)
throws
IOException
{
Explanation
result
=
new
Explanation
(
)
;
Explanation
nonPayloadExpl
=
super
.
explain
(
doc
)
;
result
.
addDetail
(
nonPayloadExpl
)
;
Explanation
payloadBoost
=
new
Explanation
(
)
;
result
.
addDetail
(
payloadBoost
)
;
float
avgPayloadScore
=
payloadScore
/
payloadsSeen
;
payloadBoost
.
setValue
(
avgPayloadScore
)
;
payloadBoost
.
setDescription
(
"scorePayload(...)"
)
;
result
.
setValue
(
nonPayloadExpl
.
getValue
(
)
*
avgPayloadScore
)
;
result
.
setDescription
(
"btq, product of:"
)
;
return
result
;
}
}
}
public
boolean
equals
(
Object
o
)
{
if
(
!
(
o
instanceof
BoostingTermQuery
)
)
return
false
;
BoostingTermQuery
other
=
(
BoostingTermQuery
)
o
;
return
(
this
.
getBoost
(
)
==
other
.
getBoost
(
)
)
&&
this
.
term
.
equals
(
other
.
term
)
;
}
}
