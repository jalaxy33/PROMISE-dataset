package
org
.
apache
.
lucene
.
search
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Set
;
public
class
DisjunctionMaxQuery
extends
Query
{
private
ArrayList
disjuncts
=
new
ArrayList
(
)
;
private
float
tieBreakerMultiplier
=
0.0f
;
public
DisjunctionMaxQuery
(
float
tieBreakerMultiplier
)
{
this
.
tieBreakerMultiplier
=
tieBreakerMultiplier
;
}
public
DisjunctionMaxQuery
(
Collection
disjuncts
,
float
tieBreakerMultiplier
)
{
this
.
tieBreakerMultiplier
=
tieBreakerMultiplier
;
add
(
disjuncts
)
;
}
public
void
add
(
Query
query
)
{
disjuncts
.
add
(
query
)
;
}
public
void
add
(
Collection
disjuncts
)
{
this
.
disjuncts
.
addAll
(
disjuncts
)
;
}
public
Iterator
iterator
(
)
{
return
disjuncts
.
iterator
(
)
;
}
private
class
DisjunctionMaxWeight
implements
Weight
{
private
Searcher
searcher
;
private
ArrayList
weights
=
new
ArrayList
(
)
;
public
DisjunctionMaxWeight
(
Searcher
searcher
)
throws
IOException
{
this
.
searcher
=
searcher
;
for
(
int
i
=
0
;
i
<
disjuncts
.
size
(
)
;
i
++
)
weights
.
add
(
(
(
Query
)
disjuncts
.
get
(
i
)
)
.
createWeight
(
searcher
)
)
;
}
public
Query
getQuery
(
)
{
return
DisjunctionMaxQuery
.
this
;
}
public
float
getValue
(
)
{
return
getBoost
(
)
;
}
public
float
sumOfSquaredWeights
(
)
throws
IOException
{
float
max
=
0.0f
,
sum
=
0.0f
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
float
sub
=
(
(
Weight
)
weights
.
get
(
i
)
)
.
sumOfSquaredWeights
(
)
;
sum
+=
sub
;
max
=
Math
.
max
(
max
,
sub
)
;
}
return
(
(
(
sum
-
max
)
*
tieBreakerMultiplier
*
tieBreakerMultiplier
)
+
max
)
*
getBoost
(
)
*
getBoost
(
)
;
}
public
void
normalize
(
float
norm
)
{
norm
*=
getBoost
(
)
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
(
(
Weight
)
weights
.
get
(
i
)
)
.
normalize
(
norm
)
;
}
public
Scorer
scorer
(
IndexReader
reader
)
throws
IOException
{
DisjunctionMaxScorer
result
=
new
DisjunctionMaxScorer
(
tieBreakerMultiplier
,
getSimilarity
(
searcher
)
)
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
Weight
w
=
(
Weight
)
weights
.
get
(
i
)
;
Scorer
subScorer
=
w
.
scorer
(
reader
)
;
if
(
subScorer
==
null
)
return
null
;
result
.
add
(
subScorer
)
;
}
return
result
;
}
public
Explanation
explain
(
IndexReader
reader
,
int
doc
)
throws
IOException
{
if
(
disjuncts
.
size
(
)
==
1
)
return
(
(
Weight
)
weights
.
get
(
0
)
)
.
explain
(
reader
,
doc
)
;
ComplexExplanation
result
=
new
ComplexExplanation
(
)
;
float
max
=
0.0f
,
sum
=
0.0f
;
result
.
setDescription
(
tieBreakerMultiplier
==
0.0f
?
"max of:"
:
"max plus "
+
tieBreakerMultiplier
+
" times others of:"
)
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
Explanation
e
=
(
(
Weight
)
weights
.
get
(
i
)
)
.
explain
(
reader
,
doc
)
;
if
(
e
.
isMatch
(
)
)
{
result
.
setMatch
(
Boolean
.
TRUE
)
;
result
.
addDetail
(
e
)
;
sum
+=
e
.
getValue
(
)
;
max
=
Math
.
max
(
max
,
e
.
getValue
(
)
)
;
}
}
result
.
setValue
(
max
+
(
sum
-
max
)
*
tieBreakerMultiplier
)
;
return
result
;
}
}
protected
Weight
createWeight
(
Searcher
searcher
)
throws
IOException
{
return
new
DisjunctionMaxWeight
(
searcher
)
;
}
public
Query
rewrite
(
IndexReader
reader
)
throws
IOException
{
if
(
disjuncts
.
size
(
)
==
1
)
{
Query
singleton
=
(
Query
)
disjuncts
.
get
(
0
)
;
Query
result
=
singleton
.
rewrite
(
reader
)
;
if
(
getBoost
(
)
!=
1.0f
)
{
if
(
result
==
singleton
)
result
=
(
Query
)
result
.
clone
(
)
;
result
.
setBoost
(
getBoost
(
)
*
result
.
getBoost
(
)
)
;
}
return
result
;
}
DisjunctionMaxQuery
clone
=
null
;
for
(
int
i
=
0
;
i
<
disjuncts
.
size
(
)
;
i
++
)
{
Query
clause
=
(
Query
)
disjuncts
.
get
(
i
)
;
Query
rewrite
=
clause
.
rewrite
(
reader
)
;
if
(
rewrite
!=
clause
)
{
if
(
clone
==
null
)
clone
=
(
DisjunctionMaxQuery
)
this
.
clone
(
)
;
clone
.
disjuncts
.
set
(
i
,
rewrite
)
;
}
}
if
(
clone
!=
null
)
return
clone
;
else
return
this
;
}
public
Object
clone
(
)
{
DisjunctionMaxQuery
clone
=
(
DisjunctionMaxQuery
)
super
.
clone
(
)
;
clone
.
disjuncts
=
(
ArrayList
)
this
.
disjuncts
.
clone
(
)
;
return
clone
;
}
public
void
extractTerms
(
Set
terms
)
{
for
(
int
i
=
0
;
i
<
disjuncts
.
size
(
)
;
i
++
)
{
(
(
Query
)
disjuncts
.
get
(
i
)
)
.
extractTerms
(
terms
)
;
}
}
public
String
toString
(
String
field
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
buffer
.
append
(
"("
)
;
for
(
int
i
=
0
;
i
<
disjuncts
.
size
(
)
;
i
++
)
{
Query
subquery
=
(
Query
)
disjuncts
.
get
(
i
)
;
if
(
subquery
instanceof
BooleanQuery
)
{
buffer
.
append
(
"("
)
;
buffer
.
append
(
subquery
.
toString
(
field
)
)
;
buffer
.
append
(
")"
)
;
}
else
buffer
.
append
(
subquery
.
toString
(
field
)
)
;
if
(
i
!=
disjuncts
.
size
(
)
-
1
)
buffer
.
append
(
" | "
)
;
}
buffer
.
append
(
")"
)
;
if
(
tieBreakerMultiplier
!=
0.0f
)
{
buffer
.
append
(
"~"
)
;
buffer
.
append
(
tieBreakerMultiplier
)
;
}
if
(
getBoost
(
)
!=
1.0
)
{
buffer
.
append
(
"^"
)
;
buffer
.
append
(
getBoost
(
)
)
;
}
return
buffer
.
toString
(
)
;
}
public
boolean
equals
(
Object
o
)
{
if
(
!
(
o
instanceof
DisjunctionMaxQuery
)
)
return
false
;
DisjunctionMaxQuery
other
=
(
DisjunctionMaxQuery
)
o
;
return
this
.
getBoost
(
)
==
other
.
getBoost
(
)
&&
this
.
tieBreakerMultiplier
==
other
.
tieBreakerMultiplier
&&
this
.
disjuncts
.
equals
(
other
.
disjuncts
)
;
}
public
int
hashCode
(
)
{
return
Float
.
floatToIntBits
(
getBoost
(
)
)
+
Float
.
floatToIntBits
(
tieBreakerMultiplier
)
+
disjuncts
.
hashCode
(
)
;
}
}
