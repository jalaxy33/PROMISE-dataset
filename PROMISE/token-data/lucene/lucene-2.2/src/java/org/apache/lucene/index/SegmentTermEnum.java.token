package
org
.
apache
.
lucene
.
index
;
import
java
.
io
.
IOException
;
import
org
.
apache
.
lucene
.
store
.
IndexInput
;
final
class
SegmentTermEnum
extends
TermEnum
implements
Cloneable
{
private
IndexInput
input
;
FieldInfos
fieldInfos
;
long
size
;
long
position
=
-
1
;
private
TermBuffer
termBuffer
=
new
TermBuffer
(
)
;
private
TermBuffer
prevBuffer
=
new
TermBuffer
(
)
;
private
TermBuffer
scratch
;
private
TermInfo
termInfo
=
new
TermInfo
(
)
;
private
int
format
;
private
boolean
isIndex
=
false
;
long
indexPointer
=
0
;
int
indexInterval
;
int
skipInterval
;
int
maxSkipLevels
;
private
int
formatM1SkipInterval
;
SegmentTermEnum
(
IndexInput
i
,
FieldInfos
fis
,
boolean
isi
)
throws
CorruptIndexException
,
IOException
{
input
=
i
;
fieldInfos
=
fis
;
isIndex
=
isi
;
maxSkipLevels
=
1
;
int
firstInt
=
input
.
readInt
(
)
;
if
(
firstInt
>=
0
)
{
format
=
0
;
size
=
firstInt
;
indexInterval
=
128
;
skipInterval
=
Integer
.
MAX_VALUE
;
}
else
{
format
=
firstInt
;
if
(
format
<
TermInfosWriter
.
FORMAT
)
throw
new
CorruptIndexException
(
"Unknown format version:"
+
format
)
;
size
=
input
.
readLong
(
)
;
if
(
format
==
-
1
)
{
if
(
!
isIndex
)
{
indexInterval
=
input
.
readInt
(
)
;
formatM1SkipInterval
=
input
.
readInt
(
)
;
}
skipInterval
=
Integer
.
MAX_VALUE
;
}
else
{
indexInterval
=
input
.
readInt
(
)
;
skipInterval
=
input
.
readInt
(
)
;
if
(
format
==
-
3
)
{
maxSkipLevels
=
input
.
readInt
(
)
;
}
}
}
}
protected
Object
clone
(
)
{
SegmentTermEnum
clone
=
null
;
try
{
clone
=
(
SegmentTermEnum
)
super
.
clone
(
)
;
}
catch
(
CloneNotSupportedException
e
)
{
}
clone
.
input
=
(
IndexInput
)
input
.
clone
(
)
;
clone
.
termInfo
=
new
TermInfo
(
termInfo
)
;
clone
.
termBuffer
=
(
TermBuffer
)
termBuffer
.
clone
(
)
;
clone
.
prevBuffer
=
(
TermBuffer
)
prevBuffer
.
clone
(
)
;
clone
.
scratch
=
null
;
return
clone
;
}
final
void
seek
(
long
pointer
,
int
p
,
Term
t
,
TermInfo
ti
)
throws
IOException
{
input
.
seek
(
pointer
)
;
position
=
p
;
termBuffer
.
set
(
t
)
;
prevBuffer
.
reset
(
)
;
termInfo
.
set
(
ti
)
;
}
public
final
boolean
next
(
)
throws
IOException
{
if
(
position
++
>=
size
-
1
)
{
termBuffer
.
reset
(
)
;
return
false
;
}
prevBuffer
.
set
(
termBuffer
)
;
termBuffer
.
read
(
input
,
fieldInfos
)
;
termInfo
.
docFreq
=
input
.
readVInt
(
)
;
termInfo
.
freqPointer
+=
input
.
readVLong
(
)
;
termInfo
.
proxPointer
+=
input
.
readVLong
(
)
;
if
(
format
==
-
1
)
{
if
(
!
isIndex
)
{
if
(
termInfo
.
docFreq
>
formatM1SkipInterval
)
{
termInfo
.
skipOffset
=
input
.
readVInt
(
)
;
}
}
}
else
{
if
(
termInfo
.
docFreq
>=
skipInterval
)
termInfo
.
skipOffset
=
input
.
readVInt
(
)
;
}
if
(
isIndex
)
indexPointer
+=
input
.
readVLong
(
)
;
return
true
;
}
final
void
scanTo
(
Term
term
)
throws
IOException
{
if
(
scratch
==
null
)
scratch
=
new
TermBuffer
(
)
;
scratch
.
set
(
term
)
;
while
(
scratch
.
compareTo
(
termBuffer
)
>
0
&&
next
(
)
)
{
}
}
public
final
Term
term
(
)
{
return
termBuffer
.
toTerm
(
)
;
}
final
Term
prev
(
)
{
return
prevBuffer
.
toTerm
(
)
;
}
final
TermInfo
termInfo
(
)
{
return
new
TermInfo
(
termInfo
)
;
}
final
void
termInfo
(
TermInfo
ti
)
{
ti
.
set
(
termInfo
)
;
}
public
final
int
docFreq
(
)
{
return
termInfo
.
docFreq
;
}
final
long
freqPointer
(
)
{
return
termInfo
.
freqPointer
;
}
final
long
proxPointer
(
)
{
return
termInfo
.
proxPointer
;
}
public
final
void
close
(
)
throws
IOException
{
input
.
close
(
)
;
}
}
