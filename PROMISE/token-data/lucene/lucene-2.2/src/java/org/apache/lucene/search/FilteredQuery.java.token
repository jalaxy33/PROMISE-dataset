package
org
.
apache
.
lucene
.
search
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
util
.
ToStringUtils
;
import
java
.
io
.
IOException
;
import
java
.
util
.
BitSet
;
import
java
.
util
.
Set
;
public
class
FilteredQuery
extends
Query
{
Query
query
;
Filter
filter
;
public
FilteredQuery
(
Query
query
,
Filter
filter
)
{
this
.
query
=
query
;
this
.
filter
=
filter
;
}
protected
Weight
createWeight
(
final
Searcher
searcher
)
throws
IOException
{
final
Weight
weight
=
query
.
createWeight
(
searcher
)
;
final
Similarity
similarity
=
query
.
getSimilarity
(
searcher
)
;
return
new
Weight
(
)
{
private
float
value
;
public
float
getValue
(
)
{
return
value
;
}
public
float
sumOfSquaredWeights
(
)
throws
IOException
{
return
weight
.
sumOfSquaredWeights
(
)
*
getBoost
(
)
*
getBoost
(
)
;
}
public
void
normalize
(
float
v
)
{
weight
.
normalize
(
v
)
;
value
=
weight
.
getValue
(
)
*
getBoost
(
)
;
}
public
Explanation
explain
(
IndexReader
ir
,
int
i
)
throws
IOException
{
Explanation
inner
=
weight
.
explain
(
ir
,
i
)
;
if
(
getBoost
(
)
!=
1
)
{
Explanation
preBoost
=
inner
;
inner
=
new
Explanation
(
inner
.
getValue
(
)
*
getBoost
(
)
,
"product of:"
)
;
inner
.
addDetail
(
new
Explanation
(
getBoost
(
)
,
"boost"
)
)
;
inner
.
addDetail
(
preBoost
)
;
}
Filter
f
=
FilteredQuery
.
this
.
filter
;
BitSet
matches
=
f
.
bits
(
ir
)
;
if
(
matches
.
get
(
i
)
)
return
inner
;
Explanation
result
=
new
Explanation
(
0.0f
,
"failure to match filter: "
+
f
.
toString
(
)
)
;
result
.
addDetail
(
inner
)
;
return
result
;
}
public
Query
getQuery
(
)
{
return
FilteredQuery
.
this
;
}
public
Scorer
scorer
(
IndexReader
indexReader
)
throws
IOException
{
final
Scorer
scorer
=
weight
.
scorer
(
indexReader
)
;
final
BitSet
bitset
=
filter
.
bits
(
indexReader
)
;
return
new
Scorer
(
similarity
)
{
public
boolean
next
(
)
throws
IOException
{
do
{
if
(
!
scorer
.
next
(
)
)
{
return
false
;
}
}
while
(
!
bitset
.
get
(
scorer
.
doc
(
)
)
)
;
return
true
;
}
public
int
doc
(
)
{
return
scorer
.
doc
(
)
;
}
public
boolean
skipTo
(
int
i
)
throws
IOException
{
if
(
!
scorer
.
skipTo
(
i
)
)
{
return
false
;
}
while
(
!
bitset
.
get
(
scorer
.
doc
(
)
)
)
{
int
nextFiltered
=
bitset
.
nextSetBit
(
scorer
.
doc
(
)
+
1
)
;
if
(
nextFiltered
==
-
1
)
{
return
false
;
}
else
if
(
!
scorer
.
skipTo
(
nextFiltered
)
)
{
return
false
;
}
}
return
true
;
}
public
float
score
(
)
throws
IOException
{
return
getBoost
(
)
*
scorer
.
score
(
)
;
}
public
Explanation
explain
(
int
i
)
throws
IOException
{
Explanation
exp
=
scorer
.
explain
(
i
)
;
exp
.
setValue
(
getBoost
(
)
*
exp
.
getValue
(
)
)
;
if
(
bitset
.
get
(
i
)
)
exp
.
setDescription
(
"allowed by filter: "
+
exp
.
getDescription
(
)
)
;
else
exp
.
setDescription
(
"removed by filter: "
+
exp
.
getDescription
(
)
)
;
return
exp
;
}
}
;
}
}
;
}
public
Query
rewrite
(
IndexReader
reader
)
throws
IOException
{
Query
rewritten
=
query
.
rewrite
(
reader
)
;
if
(
rewritten
!=
query
)
{
FilteredQuery
clone
=
(
FilteredQuery
)
this
.
clone
(
)
;
clone
.
query
=
rewritten
;
return
clone
;
}
else
{
return
this
;
}
}
public
Query
getQuery
(
)
{
return
query
;
}
public
Filter
getFilter
(
)
{
return
filter
;
}
public
void
extractTerms
(
Set
terms
)
{
getQuery
(
)
.
extractTerms
(
terms
)
;
}
public
String
toString
(
String
s
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
buffer
.
append
(
"filtered("
)
;
buffer
.
append
(
query
.
toString
(
s
)
)
;
buffer
.
append
(
")->"
)
;
buffer
.
append
(
filter
)
;
buffer
.
append
(
ToStringUtils
.
boost
(
getBoost
(
)
)
)
;
return
buffer
.
toString
(
)
;
}
public
boolean
equals
(
Object
o
)
{
if
(
o
instanceof
FilteredQuery
)
{
FilteredQuery
fq
=
(
FilteredQuery
)
o
;
return
(
query
.
equals
(
fq
.
query
)
&&
filter
.
equals
(
fq
.
filter
)
&&
getBoost
(
)
==
fq
.
getBoost
(
)
)
;
}
return
false
;
}
public
int
hashCode
(
)
{
return
query
.
hashCode
(
)
^
filter
.
hashCode
(
)
+
Float
.
floatToRawIntBits
(
getBoost
(
)
)
;
}
}
