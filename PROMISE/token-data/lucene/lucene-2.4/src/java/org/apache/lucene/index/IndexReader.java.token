package
org
.
apache
.
lucene
.
index
;
import
org
.
apache
.
lucene
.
document
.
Document
;
import
org
.
apache
.
lucene
.
document
.
FieldSelector
;
import
org
.
apache
.
lucene
.
search
.
Similarity
;
import
org
.
apache
.
lucene
.
store
.
*
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Collection
;
public
abstract
class
IndexReader
{
final
static
boolean
READ_ONLY_DEFAULT
=
false
;
public
static
final
class
FieldOption
{
private
String
option
;
private
FieldOption
(
)
{
}
private
FieldOption
(
String
option
)
{
this
.
option
=
option
;
}
public
String
toString
(
)
{
return
this
.
option
;
}
public
static
final
FieldOption
ALL
=
new
FieldOption
(
"ALL"
)
;
public
static
final
FieldOption
INDEXED
=
new
FieldOption
(
"INDEXED"
)
;
public
static
final
FieldOption
STORES_PAYLOADS
=
new
FieldOption
(
"STORES_PAYLOADS"
)
;
public
static
final
FieldOption
OMIT_TF
=
new
FieldOption
(
"OMIT_TF"
)
;
public
static
final
FieldOption
UNINDEXED
=
new
FieldOption
(
"UNINDEXED"
)
;
public
static
final
FieldOption
INDEXED_WITH_TERMVECTOR
=
new
FieldOption
(
"INDEXED_WITH_TERMVECTOR"
)
;
public
static
final
FieldOption
INDEXED_NO_TERMVECTOR
=
new
FieldOption
(
"INDEXED_NO_TERMVECTOR"
)
;
public
static
final
FieldOption
TERMVECTOR
=
new
FieldOption
(
"TERMVECTOR"
)
;
public
static
final
FieldOption
TERMVECTOR_WITH_POSITION
=
new
FieldOption
(
"TERMVECTOR_WITH_POSITION"
)
;
public
static
final
FieldOption
TERMVECTOR_WITH_OFFSET
=
new
FieldOption
(
"TERMVECTOR_WITH_OFFSET"
)
;
public
static
final
FieldOption
TERMVECTOR_WITH_POSITION_OFFSET
=
new
FieldOption
(
"TERMVECTOR_WITH_POSITION_OFFSET"
)
;
}
private
boolean
closed
;
protected
boolean
hasChanges
;
private
volatile
int
refCount
;
synchronized
int
getRefCount
(
)
{
return
refCount
;
}
public
synchronized
void
incRef
(
)
{
assert
refCount
>
0
;
ensureOpen
(
)
;
refCount
++
;
}
public
synchronized
void
decRef
(
)
throws
IOException
{
assert
refCount
>
0
;
ensureOpen
(
)
;
if
(
refCount
==
1
)
{
commit
(
)
;
doClose
(
)
;
}
refCount
--
;
}
private
Directory
directory
;
protected
IndexReader
(
Directory
directory
)
{
this
(
)
;
this
.
directory
=
directory
;
}
protected
IndexReader
(
)
{
refCount
=
1
;
}
protected
final
void
ensureOpen
(
)
throws
AlreadyClosedException
{
if
(
refCount
<=
0
)
{
throw
new
AlreadyClosedException
(
"this IndexReader is closed"
)
;
}
}
public
static
IndexReader
open
(
String
path
)
throws
CorruptIndexException
,
IOException
{
return
open
(
FSDirectory
.
getDirectory
(
path
)
,
true
,
null
,
null
,
READ_ONLY_DEFAULT
)
;
}
public
static
IndexReader
open
(
File
path
)
throws
CorruptIndexException
,
IOException
{
return
open
(
FSDirectory
.
getDirectory
(
path
)
,
true
,
null
,
null
,
READ_ONLY_DEFAULT
)
;
}
public
static
IndexReader
open
(
final
Directory
directory
)
throws
CorruptIndexException
,
IOException
{
return
open
(
directory
,
false
,
null
,
null
,
READ_ONLY_DEFAULT
)
;
}
public
static
IndexReader
open
(
final
Directory
directory
,
boolean
readOnly
)
throws
CorruptIndexException
,
IOException
{
return
open
(
directory
,
false
,
null
,
null
,
readOnly
)
;
}
public
static
IndexReader
open
(
final
IndexCommit
commit
)
throws
CorruptIndexException
,
IOException
{
return
open
(
commit
.
getDirectory
(
)
,
false
,
null
,
commit
,
READ_ONLY_DEFAULT
)
;
}
public
static
IndexReader
open
(
final
Directory
directory
,
IndexDeletionPolicy
deletionPolicy
)
throws
CorruptIndexException
,
IOException
{
return
open
(
directory
,
false
,
deletionPolicy
,
null
,
READ_ONLY_DEFAULT
)
;
}
public
static
IndexReader
open
(
final
Directory
directory
,
IndexDeletionPolicy
deletionPolicy
,
boolean
readOnly
)
throws
CorruptIndexException
,
IOException
{
return
open
(
directory
,
false
,
deletionPolicy
,
null
,
readOnly
)
;
}
public
static
IndexReader
open
(
final
IndexCommit
commit
,
IndexDeletionPolicy
deletionPolicy
)
throws
CorruptIndexException
,
IOException
{
return
open
(
commit
.
getDirectory
(
)
,
false
,
deletionPolicy
,
commit
,
READ_ONLY_DEFAULT
)
;
}
public
static
IndexReader
open
(
final
IndexCommit
commit
,
IndexDeletionPolicy
deletionPolicy
,
boolean
readOnly
)
throws
CorruptIndexException
,
IOException
{
return
open
(
commit
.
getDirectory
(
)
,
false
,
deletionPolicy
,
commit
,
readOnly
)
;
}
private
static
IndexReader
open
(
final
Directory
directory
,
final
boolean
closeDirectory
,
final
IndexDeletionPolicy
deletionPolicy
,
final
IndexCommit
commit
,
final
boolean
readOnly
)
throws
CorruptIndexException
,
IOException
{
return
DirectoryIndexReader
.
open
(
directory
,
closeDirectory
,
deletionPolicy
,
commit
,
readOnly
)
;
}
public
synchronized
IndexReader
reopen
(
)
throws
CorruptIndexException
,
IOException
{
throw
new
UnsupportedOperationException
(
"This reader does not support reopen()."
)
;
}
public
Directory
directory
(
)
{
ensureOpen
(
)
;
if
(
null
!=
directory
)
{
return
directory
;
}
else
{
throw
new
UnsupportedOperationException
(
"This reader does not support this method."
)
;
}
}
public
static
long
lastModified
(
String
directory
)
throws
CorruptIndexException
,
IOException
{
return
lastModified
(
new
File
(
directory
)
)
;
}
public
static
long
lastModified
(
File
fileDirectory
)
throws
CorruptIndexException
,
IOException
{
return
(
(
Long
)
new
SegmentInfos
.
FindSegmentsFile
(
fileDirectory
)
{
public
Object
doBody
(
String
segmentFileName
)
{
return
new
Long
(
FSDirectory
.
fileModified
(
fileDirectory
,
segmentFileName
)
)
;
}
}
.
run
(
)
)
.
longValue
(
)
;
}
public
static
long
lastModified
(
final
Directory
directory2
)
throws
CorruptIndexException
,
IOException
{
return
(
(
Long
)
new
SegmentInfos
.
FindSegmentsFile
(
directory2
)
{
public
Object
doBody
(
String
segmentFileName
)
throws
IOException
{
return
new
Long
(
directory2
.
fileModified
(
segmentFileName
)
)
;
}
}
.
run
(
)
)
.
longValue
(
)
;
}
public
static
long
getCurrentVersion
(
String
directory
)
throws
CorruptIndexException
,
IOException
{
return
getCurrentVersion
(
new
File
(
directory
)
)
;
}
public
static
long
getCurrentVersion
(
File
directory
)
throws
CorruptIndexException
,
IOException
{
Directory
dir
=
FSDirectory
.
getDirectory
(
directory
)
;
long
version
=
getCurrentVersion
(
dir
)
;
dir
.
close
(
)
;
return
version
;
}
public
static
long
getCurrentVersion
(
Directory
directory
)
throws
CorruptIndexException
,
IOException
{
return
SegmentInfos
.
readCurrentVersion
(
directory
)
;
}
public
long
getVersion
(
)
{
throw
new
UnsupportedOperationException
(
"This reader does not support this method."
)
;
}
public
void
setTermInfosIndexDivisor
(
int
indexDivisor
)
throws
IllegalStateException
{
throw
new
UnsupportedOperationException
(
"This reader does not support this method."
)
;
}
public
int
getTermInfosIndexDivisor
(
)
{
throw
new
UnsupportedOperationException
(
"This reader does not support this method."
)
;
}
public
boolean
isCurrent
(
)
throws
CorruptIndexException
,
IOException
{
throw
new
UnsupportedOperationException
(
"This reader does not support this method."
)
;
}
public
boolean
isOptimized
(
)
{
throw
new
UnsupportedOperationException
(
"This reader does not support this method."
)
;
}
abstract
public
TermFreqVector
[
]
getTermFreqVectors
(
int
docNumber
)
throws
IOException
;
abstract
public
TermFreqVector
getTermFreqVector
(
int
docNumber
,
String
field
)
throws
IOException
;
abstract
public
void
getTermFreqVector
(
int
docNumber
,
String
field
,
TermVectorMapper
mapper
)
throws
IOException
;
abstract
public
void
getTermFreqVector
(
int
docNumber
,
TermVectorMapper
mapper
)
throws
IOException
;
public
static
boolean
indexExists
(
String
directory
)
{
return
indexExists
(
new
File
(
directory
)
)
;
}
public
static
boolean
indexExists
(
File
directory
)
{
return
SegmentInfos
.
getCurrentSegmentGeneration
(
directory
.
list
(
)
)
!=
-
1
;
}
public
static
boolean
indexExists
(
Directory
directory
)
throws
IOException
{
return
SegmentInfos
.
getCurrentSegmentGeneration
(
directory
)
!=
-
1
;
}
public
abstract
int
numDocs
(
)
;
public
abstract
int
maxDoc
(
)
;
public
int
numDeletedDocs
(
)
{
return
maxDoc
(
)
-
numDocs
(
)
;
}
public
Document
document
(
int
n
)
throws
CorruptIndexException
,
IOException
{
ensureOpen
(
)
;
return
document
(
n
,
null
)
;
}
public
abstract
Document
document
(
int
n
,
FieldSelector
fieldSelector
)
throws
CorruptIndexException
,
IOException
;
public
abstract
boolean
isDeleted
(
int
n
)
;
public
abstract
boolean
hasDeletions
(
)
;
public
boolean
hasNorms
(
String
field
)
throws
IOException
{
ensureOpen
(
)
;
return
norms
(
field
)
!=
null
;
}
public
abstract
byte
[
]
norms
(
String
field
)
throws
IOException
;
public
abstract
void
norms
(
String
field
,
byte
[
]
bytes
,
int
offset
)
throws
IOException
;
public
synchronized
void
setNorm
(
int
doc
,
String
field
,
byte
value
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
acquireWriteLock
(
)
;
hasChanges
=
true
;
doSetNorm
(
doc
,
field
,
value
)
;
}
protected
abstract
void
doSetNorm
(
int
doc
,
String
field
,
byte
value
)
throws
CorruptIndexException
,
IOException
;
public
void
setNorm
(
int
doc
,
String
field
,
float
value
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
setNorm
(
doc
,
field
,
Similarity
.
encodeNorm
(
value
)
)
;
}
public
abstract
TermEnum
terms
(
)
throws
IOException
;
public
abstract
TermEnum
terms
(
Term
t
)
throws
IOException
;
public
abstract
int
docFreq
(
Term
t
)
throws
IOException
;
public
TermDocs
termDocs
(
Term
term
)
throws
IOException
{
ensureOpen
(
)
;
TermDocs
termDocs
=
termDocs
(
)
;
termDocs
.
seek
(
term
)
;
return
termDocs
;
}
public
abstract
TermDocs
termDocs
(
)
throws
IOException
;
public
TermPositions
termPositions
(
Term
term
)
throws
IOException
{
ensureOpen
(
)
;
TermPositions
termPositions
=
termPositions
(
)
;
termPositions
.
seek
(
term
)
;
return
termPositions
;
}
public
abstract
TermPositions
termPositions
(
)
throws
IOException
;
public
synchronized
void
deleteDocument
(
int
docNum
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
acquireWriteLock
(
)
;
hasChanges
=
true
;
doDelete
(
docNum
)
;
}
protected
abstract
void
doDelete
(
int
docNum
)
throws
CorruptIndexException
,
IOException
;
public
int
deleteDocuments
(
Term
term
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
TermDocs
docs
=
termDocs
(
term
)
;
if
(
docs
==
null
)
return
0
;
int
n
=
0
;
try
{
while
(
docs
.
next
(
)
)
{
deleteDocument
(
docs
.
doc
(
)
)
;
n
++
;
}
}
finally
{
docs
.
close
(
)
;
}
return
n
;
}
public
synchronized
void
undeleteAll
(
)
throws
StaleReaderException
,
CorruptIndexException
,
LockObtainFailedException
,
IOException
{
ensureOpen
(
)
;
acquireWriteLock
(
)
;
hasChanges
=
true
;
doUndeleteAll
(
)
;
}
protected
abstract
void
doUndeleteAll
(
)
throws
CorruptIndexException
,
IOException
;
protected
synchronized
void
acquireWriteLock
(
)
throws
IOException
{
}
public
final
synchronized
void
flush
(
)
throws
IOException
{
ensureOpen
(
)
;
commit
(
)
;
}
protected
final
synchronized
void
commit
(
)
throws
IOException
{
if
(
hasChanges
)
{
doCommit
(
)
;
}
hasChanges
=
false
;
}
protected
abstract
void
doCommit
(
)
throws
IOException
;
public
final
synchronized
void
close
(
)
throws
IOException
{
if
(
!
closed
)
{
decRef
(
)
;
closed
=
true
;
}
}
protected
abstract
void
doClose
(
)
throws
IOException
;
public
abstract
Collection
getFieldNames
(
FieldOption
fldOption
)
;
public
static
boolean
isLocked
(
Directory
directory
)
throws
IOException
{
return
directory
.
makeLock
(
IndexWriter
.
WRITE_LOCK_NAME
)
.
isLocked
(
)
;
}
public
static
boolean
isLocked
(
String
directory
)
throws
IOException
{
Directory
dir
=
FSDirectory
.
getDirectory
(
directory
)
;
boolean
result
=
isLocked
(
dir
)
;
dir
.
close
(
)
;
return
result
;
}
public
static
void
unlock
(
Directory
directory
)
throws
IOException
{
directory
.
makeLock
(
IndexWriter
.
WRITE_LOCK_NAME
)
.
release
(
)
;
}
public
IndexCommit
getIndexCommit
(
)
throws
IOException
{
throw
new
UnsupportedOperationException
(
"This reader does not support this method."
)
;
}
public
static
void
main
(
String
[
]
args
)
{
String
filename
=
null
;
boolean
extract
=
false
;
for
(
int
i
=
0
;
i
<
args
.
length
;
++
i
)
{
if
(
args
[
i
]
.
equals
(
"-extract"
)
)
{
extract
=
true
;
}
else
if
(
filename
==
null
)
{
filename
=
args
[
i
]
;
}
}
if
(
filename
==
null
)
{
System
.
out
.
println
(
"Usage: org.apache.lucene.index.IndexReader [-extract] <cfsfile>"
)
;
return
;
}
Directory
dir
=
null
;
CompoundFileReader
cfr
=
null
;
try
{
File
file
=
new
File
(
filename
)
;
String
dirname
=
file
.
getAbsoluteFile
(
)
.
getParent
(
)
;
filename
=
file
.
getName
(
)
;
dir
=
FSDirectory
.
getDirectory
(
dirname
)
;
cfr
=
new
CompoundFileReader
(
dir
,
filename
)
;
String
[
]
files
=
cfr
.
list
(
)
;
Arrays
.
sort
(
files
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
++
i
)
{
long
len
=
cfr
.
fileLength
(
files
[
i
]
)
;
if
(
extract
)
{
System
.
out
.
println
(
"extract "
+
files
[
i
]
+
" with "
+
len
+
" bytes to local directory..."
)
;
IndexInput
ii
=
cfr
.
openInput
(
files
[
i
]
)
;
FileOutputStream
f
=
new
FileOutputStream
(
files
[
i
]
)
;
byte
[
]
buffer
=
new
byte
[
1024
]
;
int
chunk
=
buffer
.
length
;
while
(
len
>
0
)
{
final
int
bufLen
=
(
int
)
Math
.
min
(
chunk
,
len
)
;
ii
.
readBytes
(
buffer
,
0
,
bufLen
)
;
f
.
write
(
buffer
,
0
,
bufLen
)
;
len
-=
bufLen
;
}
f
.
close
(
)
;
ii
.
close
(
)
;
}
else
System
.
out
.
println
(
files
[
i
]
+
": "
+
len
+
" bytes"
)
;
}
}
catch
(
IOException
ioe
)
{
ioe
.
printStackTrace
(
)
;
}
finally
{
try
{
if
(
dir
!=
null
)
dir
.
close
(
)
;
if
(
cfr
!=
null
)
cfr
.
close
(
)
;
}
catch
(
IOException
ioe
)
{
ioe
.
printStackTrace
(
)
;
}
}
}
public
static
Collection
listCommits
(
Directory
dir
)
throws
IOException
{
return
DirectoryIndexReader
.
listCommits
(
dir
)
;
}
}
