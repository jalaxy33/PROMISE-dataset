package
org
.
apache
.
lucene
.
search
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ConcurrentModificationException
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Iterator
;
import
org
.
apache
.
lucene
.
document
.
Document
;
import
org
.
apache
.
lucene
.
index
.
CorruptIndexException
;
public
final
class
Hits
{
private
Weight
weight
;
private
Searcher
searcher
;
private
Filter
filter
=
null
;
private
Sort
sort
=
null
;
private
int
length
;
private
Vector
hitDocs
=
new
Vector
(
)
;
private
HitDoc
first
;
private
HitDoc
last
;
private
int
numDocs
=
0
;
private
int
maxDocs
=
200
;
private
int
nDeletions
;
private
int
lengthAtStart
;
private
int
nDeletedHits
=
0
;
boolean
debugCheckedForDeletions
=
false
;
Hits
(
Searcher
s
,
Query
q
,
Filter
f
)
throws
IOException
{
weight
=
q
.
weight
(
s
)
;
searcher
=
s
;
filter
=
f
;
nDeletions
=
countDeletions
(
s
)
;
getMoreDocs
(
50
)
;
lengthAtStart
=
length
;
}
Hits
(
Searcher
s
,
Query
q
,
Filter
f
,
Sort
o
)
throws
IOException
{
weight
=
q
.
weight
(
s
)
;
searcher
=
s
;
filter
=
f
;
sort
=
o
;
nDeletions
=
countDeletions
(
s
)
;
getMoreDocs
(
50
)
;
lengthAtStart
=
length
;
}
private
int
countDeletions
(
Searcher
s
)
throws
IOException
{
int
cnt
=
-
1
;
if
(
s
instanceof
IndexSearcher
)
{
cnt
=
s
.
maxDoc
(
)
-
(
(
IndexSearcher
)
s
)
.
getIndexReader
(
)
.
numDocs
(
)
;
}
return
cnt
;
}
private
final
void
getMoreDocs
(
int
min
)
throws
IOException
{
if
(
hitDocs
.
size
(
)
>
min
)
{
min
=
hitDocs
.
size
(
)
;
}
int
n
=
min
*
2
;
TopDocs
topDocs
=
(
sort
==
null
)
?
searcher
.
search
(
weight
,
filter
,
n
)
:
searcher
.
search
(
weight
,
filter
,
n
,
sort
)
;
length
=
topDocs
.
totalHits
;
ScoreDoc
[
]
scoreDocs
=
topDocs
.
scoreDocs
;
float
scoreNorm
=
1.0f
;
if
(
length
>
0
&&
topDocs
.
getMaxScore
(
)
>
1.0f
)
{
scoreNorm
=
1.0f
/
topDocs
.
getMaxScore
(
)
;
}
int
start
=
hitDocs
.
size
(
)
-
nDeletedHits
;
int
nDels2
=
countDeletions
(
searcher
)
;
debugCheckedForDeletions
=
false
;
if
(
nDeletions
<
0
||
nDels2
>
nDeletions
)
{
nDeletedHits
=
0
;
debugCheckedForDeletions
=
true
;
int
i2
=
0
;
for
(
int
i1
=
0
;
i1
<
hitDocs
.
size
(
)
&&
i2
<
scoreDocs
.
length
;
i1
++
)
{
int
id1
=
(
(
HitDoc
)
hitDocs
.
get
(
i1
)
)
.
id
;
int
id2
=
scoreDocs
[
i2
]
.
doc
;
if
(
id1
==
id2
)
{
i2
++
;
}
else
{
nDeletedHits
++
;
}
}
start
=
i2
;
}
int
end
=
scoreDocs
.
length
<
length
?
scoreDocs
.
length
:
length
;
length
+=
nDeletedHits
;
for
(
int
i
=
start
;
i
<
end
;
i
++
)
{
hitDocs
.
addElement
(
new
HitDoc
(
scoreDocs
[
i
]
.
score
*
scoreNorm
,
scoreDocs
[
i
]
.
doc
)
)
;
}
nDeletions
=
nDels2
;
}
public
final
int
length
(
)
{
return
length
;
}
public
final
Document
doc
(
int
n
)
throws
CorruptIndexException
,
IOException
{
HitDoc
hitDoc
=
hitDoc
(
n
)
;
remove
(
hitDoc
)
;
addToFront
(
hitDoc
)
;
if
(
numDocs
>
maxDocs
)
{
HitDoc
oldLast
=
last
;
remove
(
last
)
;
oldLast
.
doc
=
null
;
}
if
(
hitDoc
.
doc
==
null
)
{
hitDoc
.
doc
=
searcher
.
doc
(
hitDoc
.
id
)
;
}
return
hitDoc
.
doc
;
}
public
final
float
score
(
int
n
)
throws
IOException
{
return
hitDoc
(
n
)
.
score
;
}
public
final
int
id
(
int
n
)
throws
IOException
{
return
hitDoc
(
n
)
.
id
;
}
public
Iterator
iterator
(
)
{
return
new
HitIterator
(
this
)
;
}
private
final
HitDoc
hitDoc
(
int
n
)
throws
IOException
{
if
(
n
>=
lengthAtStart
)
{
throw
new
IndexOutOfBoundsException
(
"Not a valid hit number: "
+
n
)
;
}
if
(
n
>=
hitDocs
.
size
(
)
)
{
getMoreDocs
(
n
)
;
}
if
(
n
>=
length
)
{
throw
new
ConcurrentModificationException
(
"Not a valid hit number: "
+
n
)
;
}
return
(
HitDoc
)
hitDocs
.
elementAt
(
n
)
;
}
private
final
void
addToFront
(
HitDoc
hitDoc
)
{
if
(
first
==
null
)
{
last
=
hitDoc
;
}
else
{
first
.
prev
=
hitDoc
;
}
hitDoc
.
next
=
first
;
first
=
hitDoc
;
hitDoc
.
prev
=
null
;
numDocs
++
;
}
private
final
void
remove
(
HitDoc
hitDoc
)
{
if
(
hitDoc
.
doc
==
null
)
{
return
;
}
if
(
hitDoc
.
next
==
null
)
{
last
=
hitDoc
.
prev
;
}
else
{
hitDoc
.
next
.
prev
=
hitDoc
.
prev
;
}
if
(
hitDoc
.
prev
==
null
)
{
first
=
hitDoc
.
next
;
}
else
{
hitDoc
.
prev
.
next
=
hitDoc
.
next
;
}
numDocs
--
;
}
}
final
class
HitDoc
{
float
score
;
int
id
;
Document
doc
=
null
;
HitDoc
next
;
HitDoc
prev
;
HitDoc
(
float
s
,
int
i
)
{
score
=
s
;
id
=
i
;
}
}
