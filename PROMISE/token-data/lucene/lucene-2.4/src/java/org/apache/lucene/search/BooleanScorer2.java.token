package
org
.
apache
.
lucene
.
search
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
List
;
import
java
.
util
.
Iterator
;
class
BooleanScorer2
extends
Scorer
{
private
ArrayList
requiredScorers
=
new
ArrayList
(
)
;
private
ArrayList
optionalScorers
=
new
ArrayList
(
)
;
private
ArrayList
prohibitedScorers
=
new
ArrayList
(
)
;
private
class
Coordinator
{
int
maxCoord
=
0
;
private
float
[
]
coordFactors
=
null
;
void
init
(
)
{
coordFactors
=
new
float
[
maxCoord
+
1
]
;
Similarity
sim
=
getSimilarity
(
)
;
for
(
int
i
=
0
;
i
<=
maxCoord
;
i
++
)
{
coordFactors
[
i
]
=
sim
.
coord
(
i
,
maxCoord
)
;
}
}
int
nrMatchers
;
void
initDoc
(
)
{
nrMatchers
=
0
;
}
float
coordFactor
(
)
{
return
coordFactors
[
nrMatchers
]
;
}
}
private
final
Coordinator
coordinator
;
private
Scorer
countingSumScorer
=
null
;
private
final
int
minNrShouldMatch
;
private
boolean
allowDocsOutOfOrder
;
public
BooleanScorer2
(
Similarity
similarity
,
int
minNrShouldMatch
,
boolean
allowDocsOutOfOrder
)
{
super
(
similarity
)
;
if
(
minNrShouldMatch
<
0
)
{
throw
new
IllegalArgumentException
(
"Minimum number of optional scorers should not be negative"
)
;
}
coordinator
=
new
Coordinator
(
)
;
this
.
minNrShouldMatch
=
minNrShouldMatch
;
this
.
allowDocsOutOfOrder
=
allowDocsOutOfOrder
;
}
public
BooleanScorer2
(
Similarity
similarity
,
int
minNrShouldMatch
)
{
this
(
similarity
,
minNrShouldMatch
,
false
)
;
}
public
BooleanScorer2
(
Similarity
similarity
)
{
this
(
similarity
,
0
,
false
)
;
}
public
void
add
(
final
Scorer
scorer
,
boolean
required
,
boolean
prohibited
)
{
if
(
!
prohibited
)
{
coordinator
.
maxCoord
++
;
}
if
(
required
)
{
if
(
prohibited
)
{
throw
new
IllegalArgumentException
(
"scorer cannot be required and prohibited"
)
;
}
requiredScorers
.
add
(
scorer
)
;
}
else
if
(
prohibited
)
{
prohibitedScorers
.
add
(
scorer
)
;
}
else
{
optionalScorers
.
add
(
scorer
)
;
}
}
private
void
initCountingSumScorer
(
)
throws
IOException
{
coordinator
.
init
(
)
;
countingSumScorer
=
makeCountingSumScorer
(
)
;
}
private
class
SingleMatchScorer
extends
Scorer
{
private
Scorer
scorer
;
private
int
lastScoredDoc
=
-
1
;
SingleMatchScorer
(
Scorer
scorer
)
{
super
(
scorer
.
getSimilarity
(
)
)
;
this
.
scorer
=
scorer
;
}
public
float
score
(
)
throws
IOException
{
if
(
this
.
doc
(
)
>=
lastScoredDoc
)
{
lastScoredDoc
=
this
.
doc
(
)
;
coordinator
.
nrMatchers
++
;
}
return
scorer
.
score
(
)
;
}
public
int
doc
(
)
{
return
scorer
.
doc
(
)
;
}
public
boolean
next
(
)
throws
IOException
{
return
scorer
.
next
(
)
;
}
public
boolean
skipTo
(
int
docNr
)
throws
IOException
{
return
scorer
.
skipTo
(
docNr
)
;
}
public
Explanation
explain
(
int
docNr
)
throws
IOException
{
return
scorer
.
explain
(
docNr
)
;
}
}
private
Scorer
countingDisjunctionSumScorer
(
final
List
scorers
,
int
minNrShouldMatch
)
{
return
new
DisjunctionSumScorer
(
scorers
,
minNrShouldMatch
)
{
private
int
lastScoredDoc
=
-
1
;
public
float
score
(
)
throws
IOException
{
if
(
this
.
doc
(
)
>=
lastScoredDoc
)
{
lastScoredDoc
=
this
.
doc
(
)
;
coordinator
.
nrMatchers
+=
super
.
nrMatchers
;
}
return
super
.
score
(
)
;
}
}
;
}
private
static
Similarity
defaultSimilarity
=
new
DefaultSimilarity
(
)
;
private
Scorer
countingConjunctionSumScorer
(
List
requiredScorers
)
throws
IOException
{
final
int
requiredNrMatchers
=
requiredScorers
.
size
(
)
;
return
new
ConjunctionScorer
(
defaultSimilarity
,
requiredScorers
)
{
private
int
lastScoredDoc
=
-
1
;
public
float
score
(
)
throws
IOException
{
if
(
this
.
doc
(
)
>=
lastScoredDoc
)
{
lastScoredDoc
=
this
.
doc
(
)
;
coordinator
.
nrMatchers
+=
requiredNrMatchers
;
}
return
super
.
score
(
)
;
}
}
;
}
private
Scorer
dualConjunctionSumScorer
(
Scorer
req1
,
Scorer
req2
)
throws
IOException
{
return
new
ConjunctionScorer
(
defaultSimilarity
,
new
Scorer
[
]
{
req1
,
req2
}
)
;
}
private
Scorer
makeCountingSumScorer
(
)
throws
IOException
{
return
(
requiredScorers
.
size
(
)
==
0
)
?
makeCountingSumScorerNoReq
(
)
:
makeCountingSumScorerSomeReq
(
)
;
}
private
Scorer
makeCountingSumScorerNoReq
(
)
throws
IOException
{
if
(
optionalScorers
.
size
(
)
==
0
)
{
return
new
NonMatchingScorer
(
)
;
}
else
{
int
nrOptRequired
=
(
minNrShouldMatch
<
1
)
?
1
:
minNrShouldMatch
;
if
(
optionalScorers
.
size
(
)
<
nrOptRequired
)
{
return
new
NonMatchingScorer
(
)
;
}
else
{
Scorer
requiredCountingSumScorer
=
(
optionalScorers
.
size
(
)
>
nrOptRequired
)
?
countingDisjunctionSumScorer
(
optionalScorers
,
nrOptRequired
)
:
(
optionalScorers
.
size
(
)
==
1
)
?
new
SingleMatchScorer
(
(
Scorer
)
optionalScorers
.
get
(
0
)
)
:
countingConjunctionSumScorer
(
optionalScorers
)
;
return
addProhibitedScorers
(
requiredCountingSumScorer
)
;
}
}
}
private
Scorer
makeCountingSumScorerSomeReq
(
)
throws
IOException
{
if
(
optionalScorers
.
size
(
)
<
minNrShouldMatch
)
{
return
new
NonMatchingScorer
(
)
;
}
else
if
(
optionalScorers
.
size
(
)
==
minNrShouldMatch
)
{
ArrayList
allReq
=
new
ArrayList
(
requiredScorers
)
;
allReq
.
addAll
(
optionalScorers
)
;
return
addProhibitedScorers
(
countingConjunctionSumScorer
(
allReq
)
)
;
}
else
{
Scorer
requiredCountingSumScorer
=
(
requiredScorers
.
size
(
)
==
1
)
?
new
SingleMatchScorer
(
(
Scorer
)
requiredScorers
.
get
(
0
)
)
:
countingConjunctionSumScorer
(
requiredScorers
)
;
if
(
minNrShouldMatch
>
0
)
{
return
addProhibitedScorers
(
dualConjunctionSumScorer
(
requiredCountingSumScorer
,
countingDisjunctionSumScorer
(
optionalScorers
,
minNrShouldMatch
)
)
)
;
}
else
{
return
new
ReqOptSumScorer
(
addProhibitedScorers
(
requiredCountingSumScorer
)
,
(
(
optionalScorers
.
size
(
)
==
1
)
?
new
SingleMatchScorer
(
(
Scorer
)
optionalScorers
.
get
(
0
)
)
:
countingDisjunctionSumScorer
(
optionalScorers
,
1
)
)
)
;
}
}
}
private
Scorer
addProhibitedScorers
(
Scorer
requiredCountingSumScorer
)
{
return
(
prohibitedScorers
.
size
(
)
==
0
)
?
requiredCountingSumScorer
:
new
ReqExclScorer
(
requiredCountingSumScorer
,
(
(
prohibitedScorers
.
size
(
)
==
1
)
?
(
Scorer
)
prohibitedScorers
.
get
(
0
)
:
new
DisjunctionSumScorer
(
prohibitedScorers
)
)
)
;
}
public
void
score
(
HitCollector
hc
)
throws
IOException
{
if
(
allowDocsOutOfOrder
&&
requiredScorers
.
size
(
)
==
0
&&
prohibitedScorers
.
size
(
)
<
32
)
{
BooleanScorer
bs
=
new
BooleanScorer
(
getSimilarity
(
)
,
minNrShouldMatch
)
;
Iterator
si
=
optionalScorers
.
iterator
(
)
;
while
(
si
.
hasNext
(
)
)
{
bs
.
add
(
(
Scorer
)
si
.
next
(
)
,
false
,
false
)
;
}
si
=
prohibitedScorers
.
iterator
(
)
;
while
(
si
.
hasNext
(
)
)
{
bs
.
add
(
(
Scorer
)
si
.
next
(
)
,
false
,
true
)
;
}
bs
.
score
(
hc
)
;
}
else
{
if
(
countingSumScorer
==
null
)
{
initCountingSumScorer
(
)
;
}
while
(
countingSumScorer
.
next
(
)
)
{
hc
.
collect
(
countingSumScorer
.
doc
(
)
,
score
(
)
)
;
}
}
}
protected
boolean
score
(
HitCollector
hc
,
int
max
)
throws
IOException
{
int
docNr
=
countingSumScorer
.
doc
(
)
;
while
(
docNr
<
max
)
{
hc
.
collect
(
docNr
,
score
(
)
)
;
if
(
!
countingSumScorer
.
next
(
)
)
{
return
false
;
}
docNr
=
countingSumScorer
.
doc
(
)
;
}
return
true
;
}
public
int
doc
(
)
{
return
countingSumScorer
.
doc
(
)
;
}
public
boolean
next
(
)
throws
IOException
{
if
(
countingSumScorer
==
null
)
{
initCountingSumScorer
(
)
;
}
return
countingSumScorer
.
next
(
)
;
}
public
float
score
(
)
throws
IOException
{
coordinator
.
initDoc
(
)
;
float
sum
=
countingSumScorer
.
score
(
)
;
return
sum
*
coordinator
.
coordFactor
(
)
;
}
public
boolean
skipTo
(
int
target
)
throws
IOException
{
if
(
countingSumScorer
==
null
)
{
initCountingSumScorer
(
)
;
}
return
countingSumScorer
.
skipTo
(
target
)
;
}
public
Explanation
explain
(
int
doc
)
{
throw
new
UnsupportedOperationException
(
)
;
}
}
