package
org
.
apache
.
lucene
.
search
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
index
.
Term
;
import
java
.
io
.
IOException
;
public
final
class
FuzzyTermEnum
extends
FilteredTermEnum
{
private
static
final
int
TYPICAL_LONGEST_WORD_IN_INDEX
=
19
;
private
int
[
]
[
]
d
;
private
float
similarity
;
private
boolean
endEnum
=
false
;
private
Term
searchTerm
=
null
;
private
final
String
field
;
private
final
String
text
;
private
final
String
prefix
;
private
final
float
minimumSimilarity
;
private
final
float
scale_factor
;
private
final
int
[
]
maxDistances
=
new
int
[
TYPICAL_LONGEST_WORD_IN_INDEX
]
;
public
FuzzyTermEnum
(
IndexReader
reader
,
Term
term
)
throws
IOException
{
this
(
reader
,
term
,
FuzzyQuery
.
defaultMinSimilarity
,
FuzzyQuery
.
defaultPrefixLength
)
;
}
public
FuzzyTermEnum
(
IndexReader
reader
,
Term
term
,
float
minSimilarity
)
throws
IOException
{
this
(
reader
,
term
,
minSimilarity
,
FuzzyQuery
.
defaultPrefixLength
)
;
}
public
FuzzyTermEnum
(
IndexReader
reader
,
Term
term
,
final
float
minSimilarity
,
final
int
prefixLength
)
throws
IOException
{
super
(
)
;
if
(
minSimilarity
>=
1.0f
)
throw
new
IllegalArgumentException
(
"minimumSimilarity cannot be greater than or equal to 1"
)
;
else
if
(
minSimilarity
<
0.0f
)
throw
new
IllegalArgumentException
(
"minimumSimilarity cannot be less than 0"
)
;
if
(
prefixLength
<
0
)
throw
new
IllegalArgumentException
(
"prefixLength cannot be less than 0"
)
;
this
.
minimumSimilarity
=
minSimilarity
;
this
.
scale_factor
=
1.0f
/
(
1.0f
-
minimumSimilarity
)
;
this
.
searchTerm
=
term
;
this
.
field
=
searchTerm
.
field
(
)
;
final
int
fullSearchTermLength
=
searchTerm
.
text
(
)
.
length
(
)
;
final
int
realPrefixLength
=
prefixLength
>
fullSearchTermLength
?
fullSearchTermLength
:
prefixLength
;
this
.
text
=
searchTerm
.
text
(
)
.
substring
(
realPrefixLength
)
;
this
.
prefix
=
searchTerm
.
text
(
)
.
substring
(
0
,
realPrefixLength
)
;
initializeMaxDistances
(
)
;
this
.
d
=
initDistanceArray
(
)
;
setEnum
(
reader
.
terms
(
new
Term
(
searchTerm
.
field
(
)
,
prefix
)
)
)
;
}
protected
final
boolean
termCompare
(
Term
term
)
{
if
(
field
==
term
.
field
(
)
&&
term
.
text
(
)
.
startsWith
(
prefix
)
)
{
final
String
target
=
term
.
text
(
)
.
substring
(
prefix
.
length
(
)
)
;
this
.
similarity
=
similarity
(
target
)
;
return
(
similarity
>
minimumSimilarity
)
;
}
endEnum
=
true
;
return
false
;
}
public
final
float
difference
(
)
{
return
(
float
)
(
(
similarity
-
minimumSimilarity
)
*
scale_factor
)
;
}
public
final
boolean
endEnum
(
)
{
return
endEnum
;
}
private
static
final
int
min
(
int
a
,
int
b
,
int
c
)
{
final
int
t
=
(
a
<
b
)
?
a
:
b
;
return
(
t
<
c
)
?
t
:
c
;
}
private
final
int
[
]
[
]
initDistanceArray
(
)
{
return
new
int
[
this
.
text
.
length
(
)
+
1
]
[
TYPICAL_LONGEST_WORD_IN_INDEX
]
;
}
private
synchronized
final
float
similarity
(
final
String
target
)
{
final
int
m
=
target
.
length
(
)
;
final
int
n
=
text
.
length
(
)
;
if
(
n
==
0
)
{
return
prefix
.
length
(
)
==
0
?
0.0f
:
1.0f
-
(
(
float
)
m
/
prefix
.
length
(
)
)
;
}
if
(
m
==
0
)
{
return
prefix
.
length
(
)
==
0
?
0.0f
:
1.0f
-
(
(
float
)
n
/
prefix
.
length
(
)
)
;
}
final
int
maxDistance
=
getMaxDistance
(
m
)
;
if
(
maxDistance
<
Math
.
abs
(
m
-
n
)
)
{
return
0.0f
;
}
if
(
d
[
0
]
.
length
<=
m
)
{
growDistanceArray
(
m
)
;
}
for
(
int
i
=
0
;
i
<=
n
;
i
++
)
d
[
i
]
[
0
]
=
i
;
for
(
int
j
=
0
;
j
<=
m
;
j
++
)
d
[
0
]
[
j
]
=
j
;
for
(
int
i
=
1
;
i
<=
n
;
i
++
)
{
int
bestPossibleEditDistance
=
m
;
final
char
s_i
=
text
.
charAt
(
i
-
1
)
;
for
(
int
j
=
1
;
j
<=
m
;
j
++
)
{
if
(
s_i
!=
target
.
charAt
(
j
-
1
)
)
{
d
[
i
]
[
j
]
=
min
(
d
[
i
-
1
]
[
j
]
,
d
[
i
]
[
j
-
1
]
,
d
[
i
-
1
]
[
j
-
1
]
)
+
1
;
}
else
{
d
[
i
]
[
j
]
=
min
(
d
[
i
-
1
]
[
j
]
+
1
,
d
[
i
]
[
j
-
1
]
+
1
,
d
[
i
-
1
]
[
j
-
1
]
)
;
}
bestPossibleEditDistance
=
Math
.
min
(
bestPossibleEditDistance
,
d
[
i
]
[
j
]
)
;
}
if
(
i
>
maxDistance
&&
bestPossibleEditDistance
>
maxDistance
)
{
return
0.0f
;
}
}
return
1.0f
-
(
(
float
)
d
[
n
]
[
m
]
/
(
float
)
(
prefix
.
length
(
)
+
Math
.
min
(
n
,
m
)
)
)
;
}
private
void
growDistanceArray
(
int
m
)
{
for
(
int
i
=
0
;
i
<
d
.
length
;
i
++
)
{
d
[
i
]
=
new
int
[
m
+
1
]
;
}
}
private
final
int
getMaxDistance
(
int
m
)
{
return
(
m
<
maxDistances
.
length
)
?
maxDistances
[
m
]
:
calculateMaxDistance
(
m
)
;
}
private
void
initializeMaxDistances
(
)
{
for
(
int
i
=
0
;
i
<
maxDistances
.
length
;
i
++
)
{
maxDistances
[
i
]
=
calculateMaxDistance
(
i
)
;
}
}
private
int
calculateMaxDistance
(
int
m
)
{
return
(
int
)
(
(
1
-
minimumSimilarity
)
*
(
Math
.
min
(
text
.
length
(
)
,
m
)
+
prefix
.
length
(
)
)
)
;
}
public
void
close
(
)
throws
IOException
{
super
.
close
(
)
;
}
}
