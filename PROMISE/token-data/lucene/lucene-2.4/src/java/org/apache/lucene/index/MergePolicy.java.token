package
org
.
apache
.
lucene
.
index
;
import
org
.
apache
.
lucene
.
store
.
Directory
;
import
java
.
io
.
IOException
;
import
java
.
util
.
List
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Set
;
public
abstract
class
MergePolicy
{
public
static
class
OneMerge
{
SegmentInfo
info
;
boolean
mergeDocStores
;
boolean
optimize
;
SegmentInfos
segmentsClone
;
boolean
increfDone
;
boolean
registerDone
;
long
mergeGen
;
boolean
isExternal
;
int
maxNumSegmentsOptimize
;
final
SegmentInfos
segments
;
final
boolean
useCompoundFile
;
boolean
aborted
;
Throwable
error
;
public
OneMerge
(
SegmentInfos
segments
,
boolean
useCompoundFile
)
{
if
(
0
==
segments
.
size
(
)
)
throw
new
RuntimeException
(
"segments must include at least one segment"
)
;
this
.
segments
=
segments
;
this
.
useCompoundFile
=
useCompoundFile
;
}
synchronized
void
setException
(
Throwable
error
)
{
this
.
error
=
error
;
}
synchronized
Throwable
getException
(
)
{
return
error
;
}
synchronized
void
abort
(
)
{
aborted
=
true
;
}
synchronized
boolean
isAborted
(
)
{
return
aborted
;
}
synchronized
void
checkAborted
(
Directory
dir
)
throws
MergeAbortedException
{
if
(
aborted
)
throw
new
MergeAbortedException
(
"merge is aborted: "
+
segString
(
dir
)
)
;
}
String
segString
(
Directory
dir
)
{
StringBuffer
b
=
new
StringBuffer
(
)
;
final
int
numSegments
=
segments
.
size
(
)
;
for
(
int
i
=
0
;
i
<
numSegments
;
i
++
)
{
if
(
i
>
0
)
b
.
append
(
' '
)
;
b
.
append
(
segments
.
info
(
i
)
.
segString
(
dir
)
)
;
}
if
(
info
!=
null
)
b
.
append
(
" into "
)
.
append
(
info
.
name
)
;
if
(
optimize
)
b
.
append
(
" [optimize]"
)
;
return
b
.
toString
(
)
;
}
}
public
static
class
MergeSpecification
{
public
List
merges
=
new
ArrayList
(
)
;
public
void
add
(
OneMerge
merge
)
{
merges
.
add
(
merge
)
;
}
public
String
segString
(
Directory
dir
)
{
StringBuffer
b
=
new
StringBuffer
(
)
;
b
.
append
(
"MergeSpec:\n"
)
;
final
int
count
=
merges
.
size
(
)
;
for
(
int
i
=
0
;
i
<
count
;
i
++
)
b
.
append
(
"  "
)
.
append
(
1
+
i
)
.
append
(
": "
)
.
append
(
(
(
OneMerge
)
merges
.
get
(
i
)
)
.
segString
(
dir
)
)
;
return
b
.
toString
(
)
;
}
}
public
static
class
MergeException
extends
RuntimeException
{
private
Directory
dir
;
public
MergeException
(
String
message
)
{
super
(
message
)
;
}
public
MergeException
(
String
message
,
Directory
dir
)
{
super
(
message
)
;
this
.
dir
=
dir
;
}
public
MergeException
(
Throwable
exc
)
{
super
(
exc
)
;
}
public
MergeException
(
Throwable
exc
,
Directory
dir
)
{
super
(
exc
)
;
this
.
dir
=
dir
;
}
public
Directory
getDirectory
(
)
{
return
dir
;
}
}
public
static
class
MergeAbortedException
extends
IOException
{
public
MergeAbortedException
(
)
{
super
(
"merge is aborted"
)
;
}
public
MergeAbortedException
(
String
message
)
{
super
(
message
)
;
}
}
abstract
MergeSpecification
findMerges
(
SegmentInfos
segmentInfos
,
IndexWriter
writer
)
throws
CorruptIndexException
,
IOException
;
abstract
MergeSpecification
findMergesForOptimize
(
SegmentInfos
segmentInfos
,
IndexWriter
writer
,
int
maxSegmentCount
,
Set
segmentsToOptimize
)
throws
CorruptIndexException
,
IOException
;
MergeSpecification
findMergesToExpungeDeletes
(
SegmentInfos
segmentInfos
,
IndexWriter
writer
)
throws
CorruptIndexException
,
IOException
{
throw
new
RuntimeException
(
"not implemented"
)
;
}
abstract
void
close
(
)
;
abstract
boolean
useCompoundFile
(
SegmentInfos
segments
,
SegmentInfo
newSegment
)
;
abstract
boolean
useCompoundDocStore
(
SegmentInfos
segments
)
;
}
