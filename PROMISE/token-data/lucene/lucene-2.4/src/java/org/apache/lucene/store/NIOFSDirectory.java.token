package
org
.
apache
.
lucene
.
store
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
nio
.
ByteBuffer
;
import
java
.
nio
.
channels
.
FileChannel
;
public
class
NIOFSDirectory
extends
FSDirectory
{
public
IndexInput
openInput
(
String
name
,
int
bufferSize
)
throws
IOException
{
ensureOpen
(
)
;
return
new
NIOFSIndexInput
(
new
File
(
getFile
(
)
,
name
)
,
bufferSize
)
;
}
private
static
class
NIOFSIndexInput
extends
FSDirectory
.
FSIndexInput
{
private
ByteBuffer
byteBuf
;
private
byte
[
]
otherBuffer
;
private
ByteBuffer
otherByteBuf
;
final
FileChannel
channel
;
public
NIOFSIndexInput
(
File
path
,
int
bufferSize
)
throws
IOException
{
super
(
path
,
bufferSize
)
;
channel
=
file
.
getChannel
(
)
;
}
protected
void
newBuffer
(
byte
[
]
newBuffer
)
{
super
.
newBuffer
(
newBuffer
)
;
byteBuf
=
ByteBuffer
.
wrap
(
newBuffer
)
;
}
public
void
close
(
)
throws
IOException
{
if
(
!
isClone
&&
file
.
isOpen
)
{
try
{
channel
.
close
(
)
;
}
finally
{
file
.
close
(
)
;
}
}
}
protected
void
readInternal
(
byte
[
]
b
,
int
offset
,
int
len
)
throws
IOException
{
final
ByteBuffer
bb
;
if
(
b
==
buffer
&&
0
==
offset
)
{
assert
byteBuf
!=
null
;
byteBuf
.
clear
(
)
;
byteBuf
.
limit
(
len
)
;
bb
=
byteBuf
;
}
else
{
if
(
offset
==
0
)
{
if
(
otherBuffer
!=
b
)
{
otherBuffer
=
b
;
otherByteBuf
=
ByteBuffer
.
wrap
(
b
)
;
}
else
otherByteBuf
.
clear
(
)
;
otherByteBuf
.
limit
(
len
)
;
bb
=
otherByteBuf
;
}
else
bb
=
ByteBuffer
.
wrap
(
b
,
offset
,
len
)
;
}
long
pos
=
getFilePointer
(
)
;
while
(
bb
.
hasRemaining
(
)
)
{
int
i
=
channel
.
read
(
bb
,
pos
)
;
if
(
i
==
-
1
)
throw
new
IOException
(
"read past EOF"
)
;
pos
+=
i
;
}
}
}
}
