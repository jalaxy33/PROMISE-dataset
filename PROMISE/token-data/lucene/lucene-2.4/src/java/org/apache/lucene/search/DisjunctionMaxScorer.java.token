package
org
.
apache
.
lucene
.
search
;
import
java
.
io
.
IOException
;
import
java
.
util
.
ArrayList
;
class
DisjunctionMaxScorer
extends
Scorer
{
private
ArrayList
subScorers
=
new
ArrayList
(
)
;
private
float
tieBreakerMultiplier
;
private
boolean
more
=
false
;
private
boolean
firstTime
=
true
;
public
DisjunctionMaxScorer
(
float
tieBreakerMultiplier
,
Similarity
similarity
)
{
super
(
similarity
)
;
this
.
tieBreakerMultiplier
=
tieBreakerMultiplier
;
}
public
void
add
(
Scorer
scorer
)
throws
IOException
{
if
(
scorer
.
next
(
)
)
{
subScorers
.
add
(
scorer
)
;
more
=
true
;
}
}
public
boolean
next
(
)
throws
IOException
{
if
(
!
more
)
return
false
;
if
(
firstTime
)
{
heapify
(
)
;
firstTime
=
false
;
return
true
;
}
int
lastdoc
=
(
(
Scorer
)
subScorers
.
get
(
0
)
)
.
doc
(
)
;
do
{
if
(
(
(
Scorer
)
subScorers
.
get
(
0
)
)
.
next
(
)
)
heapAdjust
(
0
)
;
else
{
heapRemoveRoot
(
)
;
if
(
subScorers
.
isEmpty
(
)
)
return
(
more
=
false
)
;
}
}
while
(
(
(
Scorer
)
subScorers
.
get
(
0
)
)
.
doc
(
)
==
lastdoc
)
;
return
true
;
}
public
int
doc
(
)
{
return
(
(
Scorer
)
subScorers
.
get
(
0
)
)
.
doc
(
)
;
}
public
float
score
(
)
throws
IOException
{
int
doc
=
(
(
Scorer
)
subScorers
.
get
(
0
)
)
.
doc
(
)
;
float
[
]
sum
=
{
(
(
Scorer
)
subScorers
.
get
(
0
)
)
.
score
(
)
}
,
max
=
{
sum
[
0
]
}
;
int
size
=
subScorers
.
size
(
)
;
scoreAll
(
1
,
size
,
doc
,
sum
,
max
)
;
scoreAll
(
2
,
size
,
doc
,
sum
,
max
)
;
return
max
[
0
]
+
(
sum
[
0
]
-
max
[
0
]
)
*
tieBreakerMultiplier
;
}
private
void
scoreAll
(
int
root
,
int
size
,
int
doc
,
float
[
]
sum
,
float
[
]
max
)
throws
IOException
{
if
(
root
<
size
&&
(
(
Scorer
)
subScorers
.
get
(
root
)
)
.
doc
(
)
==
doc
)
{
float
sub
=
(
(
Scorer
)
subScorers
.
get
(
root
)
)
.
score
(
)
;
sum
[
0
]
+=
sub
;
max
[
0
]
=
Math
.
max
(
max
[
0
]
,
sub
)
;
scoreAll
(
(
root
<<
1
)
+
1
,
size
,
doc
,
sum
,
max
)
;
scoreAll
(
(
root
<<
1
)
+
2
,
size
,
doc
,
sum
,
max
)
;
}
}
public
boolean
skipTo
(
int
target
)
throws
IOException
{
if
(
firstTime
)
{
if
(
!
more
)
return
false
;
heapify
(
)
;
firstTime
=
false
;
}
while
(
subScorers
.
size
(
)
>
0
&&
(
(
Scorer
)
subScorers
.
get
(
0
)
)
.
doc
(
)
<
target
)
{
if
(
(
(
Scorer
)
subScorers
.
get
(
0
)
)
.
skipTo
(
target
)
)
heapAdjust
(
0
)
;
else
heapRemoveRoot
(
)
;
}
if
(
(
subScorers
.
size
(
)
==
0
)
)
return
(
more
=
false
)
;
return
true
;
}
public
Explanation
explain
(
int
doc
)
throws
IOException
{
throw
new
UnsupportedOperationException
(
)
;
}
private
void
heapify
(
)
{
int
size
=
subScorers
.
size
(
)
;
for
(
int
i
=
(
size
>
>
1
)
-
1
;
i
>=
0
;
i
--
)
heapAdjust
(
i
)
;
}
private
void
heapAdjust
(
int
root
)
{
Scorer
scorer
=
(
Scorer
)
subScorers
.
get
(
root
)
;
int
doc
=
scorer
.
doc
(
)
;
int
i
=
root
,
size
=
subScorers
.
size
(
)
;
while
(
i
<=
(
size
>
>
1
)
-
1
)
{
int
lchild
=
(
i
<<
1
)
+
1
;
Scorer
lscorer
=
(
Scorer
)
subScorers
.
get
(
lchild
)
;
int
ldoc
=
lscorer
.
doc
(
)
;
int
rdoc
=
Integer
.
MAX_VALUE
,
rchild
=
(
i
<<
1
)
+
2
;
Scorer
rscorer
=
null
;
if
(
rchild
<
size
)
{
rscorer
=
(
Scorer
)
subScorers
.
get
(
rchild
)
;
rdoc
=
rscorer
.
doc
(
)
;
}
if
(
ldoc
<
doc
)
{
if
(
rdoc
<
ldoc
)
{
subScorers
.
set
(
i
,
rscorer
)
;
subScorers
.
set
(
rchild
,
scorer
)
;
i
=
rchild
;
}
else
{
subScorers
.
set
(
i
,
lscorer
)
;
subScorers
.
set
(
lchild
,
scorer
)
;
i
=
lchild
;
}
}
else
if
(
rdoc
<
doc
)
{
subScorers
.
set
(
i
,
rscorer
)
;
subScorers
.
set
(
rchild
,
scorer
)
;
i
=
rchild
;
}
else
return
;
}
}
private
void
heapRemoveRoot
(
)
{
int
size
=
subScorers
.
size
(
)
;
if
(
size
==
1
)
subScorers
.
remove
(
0
)
;
else
{
subScorers
.
set
(
0
,
subScorers
.
get
(
size
-
1
)
)
;
subScorers
.
remove
(
size
-
1
)
;
heapAdjust
(
0
)
;
}
}
}
