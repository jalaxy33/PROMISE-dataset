package
org
.
apache
.
lucene
.
store
;
import
java
.
nio
.
channels
.
FileChannel
;
import
java
.
nio
.
channels
.
FileLock
;
import
java
.
io
.
File
;
import
java
.
io
.
RandomAccessFile
;
import
java
.
io
.
IOException
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Random
;
public
class
NativeFSLockFactory
extends
LockFactory
{
private
File
lockDir
;
private
void
acquireTestLock
(
)
throws
IOException
{
String
randomLockName
=
"lucene-"
+
Long
.
toString
(
new
Random
(
)
.
nextInt
(
)
,
Character
.
MAX_RADIX
)
+
"-test.lock"
;
Lock
l
=
makeLock
(
randomLockName
)
;
try
{
l
.
obtain
(
)
;
}
catch
(
IOException
e
)
{
IOException
e2
=
new
IOException
(
"Failed to acquire random test lock; please verify filesystem for lock directory '"
+
lockDir
+
"' supports locking"
)
;
e2
.
initCause
(
e
)
;
throw
e2
;
}
l
.
release
(
)
;
}
NativeFSLockFactory
(
)
throws
IOException
{
this
(
(
File
)
null
)
;
}
public
NativeFSLockFactory
(
String
lockDirName
)
throws
IOException
{
this
(
new
File
(
lockDirName
)
)
;
}
public
NativeFSLockFactory
(
File
lockDir
)
throws
IOException
{
setLockDir
(
lockDir
)
;
}
void
setLockDir
(
File
lockDir
)
throws
IOException
{
this
.
lockDir
=
lockDir
;
if
(
lockDir
!=
null
)
{
if
(
!
lockDir
.
exists
(
)
)
{
if
(
!
lockDir
.
mkdirs
(
)
)
throw
new
IOException
(
"Cannot create directory: "
+
lockDir
.
getAbsolutePath
(
)
)
;
}
else
if
(
!
lockDir
.
isDirectory
(
)
)
{
throw
new
IOException
(
"Found regular file where directory expected: "
+
lockDir
.
getAbsolutePath
(
)
)
;
}
acquireTestLock
(
)
;
}
}
public
synchronized
Lock
makeLock
(
String
lockName
)
{
if
(
lockPrefix
!=
null
)
lockName
=
lockPrefix
+
"-n-"
+
lockName
;
return
new
NativeFSLock
(
lockDir
,
lockName
)
;
}
public
void
clearLock
(
String
lockName
)
throws
IOException
{
if
(
lockDir
.
exists
(
)
)
{
if
(
lockPrefix
!=
null
)
{
lockName
=
lockPrefix
+
"-n-"
+
lockName
;
}
File
lockFile
=
new
File
(
lockDir
,
lockName
)
;
if
(
lockFile
.
exists
(
)
&&
!
lockFile
.
delete
(
)
)
{
throw
new
IOException
(
"Cannot delete "
+
lockFile
)
;
}
}
}
}
;
class
NativeFSLock
extends
Lock
{
private
RandomAccessFile
f
;
private
FileChannel
channel
;
private
FileLock
lock
;
private
File
path
;
private
File
lockDir
;
private
static
HashSet
LOCK_HELD
=
new
HashSet
(
)
;
public
NativeFSLock
(
File
lockDir
,
String
lockFileName
)
{
this
.
lockDir
=
lockDir
;
path
=
new
File
(
lockDir
,
lockFileName
)
;
}
public
synchronized
boolean
obtain
(
)
throws
IOException
{
if
(
isLocked
(
)
)
{
return
false
;
}
if
(
!
lockDir
.
exists
(
)
)
{
if
(
!
lockDir
.
mkdirs
(
)
)
throw
new
IOException
(
"Cannot create directory: "
+
lockDir
.
getAbsolutePath
(
)
)
;
}
else
if
(
!
lockDir
.
isDirectory
(
)
)
{
throw
new
IOException
(
"Found regular file where directory expected: "
+
lockDir
.
getAbsolutePath
(
)
)
;
}
String
canonicalPath
=
path
.
getCanonicalPath
(
)
;
boolean
markedHeld
=
false
;
try
{
synchronized
(
LOCK_HELD
)
{
if
(
LOCK_HELD
.
contains
(
canonicalPath
)
)
{
return
false
;
}
else
{
LOCK_HELD
.
add
(
canonicalPath
)
;
markedHeld
=
true
;
}
}
try
{
f
=
new
RandomAccessFile
(
path
,
"rw"
)
;
}
catch
(
IOException
e
)
{
failureReason
=
e
;
f
=
null
;
}
if
(
f
!=
null
)
{
try
{
channel
=
f
.
getChannel
(
)
;
try
{
lock
=
channel
.
tryLock
(
)
;
}
catch
(
IOException
e
)
{
failureReason
=
e
;
}
finally
{
if
(
lock
==
null
)
{
try
{
channel
.
close
(
)
;
}
finally
{
channel
=
null
;
}
}
}
}
finally
{
if
(
channel
==
null
)
{
try
{
f
.
close
(
)
;
}
finally
{
f
=
null
;
}
}
}
}
}
finally
{
if
(
markedHeld
&&
!
isLocked
(
)
)
{
synchronized
(
LOCK_HELD
)
{
if
(
LOCK_HELD
.
contains
(
canonicalPath
)
)
{
LOCK_HELD
.
remove
(
canonicalPath
)
;
}
}
}
}
return
isLocked
(
)
;
}
public
synchronized
void
release
(
)
throws
IOException
{
if
(
isLocked
(
)
)
{
try
{
lock
.
release
(
)
;
}
finally
{
lock
=
null
;
try
{
channel
.
close
(
)
;
}
finally
{
channel
=
null
;
try
{
f
.
close
(
)
;
}
finally
{
f
=
null
;
synchronized
(
LOCK_HELD
)
{
LOCK_HELD
.
remove
(
path
.
getCanonicalPath
(
)
)
;
}
}
}
}
if
(
!
path
.
delete
(
)
)
throw
new
LockReleaseFailedException
(
"failed to delete "
+
path
)
;
}
}
public
synchronized
boolean
isLocked
(
)
{
return
lock
!=
null
;
}
public
String
toString
(
)
{
return
"NativeFSLock@"
+
path
;
}
public
void
finalize
(
)
throws
Throwable
{
try
{
if
(
isLocked
(
)
)
{
release
(
)
;
}
}
finally
{
super
.
finalize
(
)
;
}
}
}
