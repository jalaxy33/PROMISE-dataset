package
org
.
apache
.
lucene
.
analysis
;
import
org
.
apache
.
lucene
.
index
.
Payload
;
import
org
.
apache
.
lucene
.
index
.
TermPositions
;
import
org
.
apache
.
lucene
.
util
.
ArrayUtil
;
public
class
Token
implements
Cloneable
{
public
static
final
String
DEFAULT_TYPE
=
"word"
;
private
static
int
MIN_BUFFER_SIZE
=
10
;
private
String
termText
;
char
[
]
termBuffer
;
int
termLength
;
int
startOffset
;
int
endOffset
;
String
type
=
DEFAULT_TYPE
;
private
int
flags
;
Payload
payload
;
int
positionIncrement
=
1
;
public
Token
(
)
{
}
public
Token
(
int
start
,
int
end
)
{
startOffset
=
start
;
endOffset
=
end
;
}
public
Token
(
int
start
,
int
end
,
String
typ
)
{
startOffset
=
start
;
endOffset
=
end
;
type
=
typ
;
}
public
Token
(
int
start
,
int
end
,
int
flags
)
{
startOffset
=
start
;
endOffset
=
end
;
this
.
flags
=
flags
;
}
public
Token
(
String
text
,
int
start
,
int
end
)
{
termText
=
text
;
startOffset
=
start
;
endOffset
=
end
;
}
public
Token
(
String
text
,
int
start
,
int
end
,
String
typ
)
{
termText
=
text
;
startOffset
=
start
;
endOffset
=
end
;
type
=
typ
;
}
public
Token
(
String
text
,
int
start
,
int
end
,
int
flags
)
{
termText
=
text
;
startOffset
=
start
;
endOffset
=
end
;
this
.
flags
=
flags
;
}
public
Token
(
char
[
]
startTermBuffer
,
int
termBufferOffset
,
int
termBufferLength
,
int
start
,
int
end
)
{
setTermBuffer
(
startTermBuffer
,
termBufferOffset
,
termBufferLength
)
;
startOffset
=
start
;
endOffset
=
end
;
}
public
void
setPositionIncrement
(
int
positionIncrement
)
{
if
(
positionIncrement
<
0
)
throw
new
IllegalArgumentException
(
"Increment must be zero or greater: "
+
positionIncrement
)
;
this
.
positionIncrement
=
positionIncrement
;
}
public
int
getPositionIncrement
(
)
{
return
positionIncrement
;
}
public
void
setTermText
(
String
text
)
{
termText
=
text
;
termBuffer
=
null
;
}
public
final
String
termText
(
)
{
if
(
termText
==
null
&&
termBuffer
!=
null
)
termText
=
new
String
(
termBuffer
,
0
,
termLength
)
;
return
termText
;
}
public
final
String
term
(
)
{
if
(
termText
!=
null
)
return
termText
;
initTermBuffer
(
)
;
return
new
String
(
termBuffer
,
0
,
termLength
)
;
}
public
final
void
setTermBuffer
(
char
[
]
buffer
,
int
offset
,
int
length
)
{
termText
=
null
;
char
[
]
newCharBuffer
=
growTermBuffer
(
length
)
;
if
(
newCharBuffer
!=
null
)
{
termBuffer
=
newCharBuffer
;
}
System
.
arraycopy
(
buffer
,
offset
,
termBuffer
,
0
,
length
)
;
termLength
=
length
;
}
public
final
void
setTermBuffer
(
String
buffer
)
{
termText
=
null
;
int
length
=
buffer
.
length
(
)
;
char
[
]
newCharBuffer
=
growTermBuffer
(
length
)
;
if
(
newCharBuffer
!=
null
)
{
termBuffer
=
newCharBuffer
;
}
buffer
.
getChars
(
0
,
length
,
termBuffer
,
0
)
;
termLength
=
length
;
}
public
final
void
setTermBuffer
(
String
buffer
,
int
offset
,
int
length
)
{
assert
offset
<=
buffer
.
length
(
)
;
assert
offset
+
length
<=
buffer
.
length
(
)
;
termText
=
null
;
char
[
]
newCharBuffer
=
growTermBuffer
(
length
)
;
if
(
newCharBuffer
!=
null
)
{
termBuffer
=
newCharBuffer
;
}
buffer
.
getChars
(
offset
,
offset
+
length
,
termBuffer
,
0
)
;
termLength
=
length
;
}
public
final
char
[
]
termBuffer
(
)
{
initTermBuffer
(
)
;
return
termBuffer
;
}
public
char
[
]
resizeTermBuffer
(
int
newSize
)
{
char
[
]
newCharBuffer
=
growTermBuffer
(
newSize
)
;
if
(
termBuffer
==
null
)
{
assert
newCharBuffer
!=
null
;
if
(
termText
!=
null
)
{
termText
.
getChars
(
0
,
termText
.
length
(
)
,
newCharBuffer
,
0
)
;
}
termBuffer
=
newCharBuffer
;
}
else
if
(
newCharBuffer
!=
null
)
{
System
.
arraycopy
(
termBuffer
,
0
,
newCharBuffer
,
0
,
termBuffer
.
length
)
;
termBuffer
=
newCharBuffer
;
}
termText
=
null
;
return
termBuffer
;
}
private
char
[
]
growTermBuffer
(
int
newSize
)
{
if
(
termBuffer
!=
null
)
{
if
(
termBuffer
.
length
>=
newSize
)
return
null
;
else
return
new
char
[
ArrayUtil
.
getNextSize
(
newSize
)
]
;
}
else
{
if
(
newSize
<
MIN_BUFFER_SIZE
)
{
newSize
=
MIN_BUFFER_SIZE
;
}
if
(
termText
!=
null
)
{
int
ttLength
=
termText
.
length
(
)
;
if
(
newSize
<
ttLength
)
{
newSize
=
ttLength
;
}
}
return
new
char
[
newSize
]
;
}
}
private
void
initTermBuffer
(
)
{
if
(
termBuffer
==
null
)
{
if
(
termText
==
null
)
{
termBuffer
=
new
char
[
MIN_BUFFER_SIZE
]
;
termLength
=
0
;
}
else
{
int
length
=
termText
.
length
(
)
;
if
(
length
<
MIN_BUFFER_SIZE
)
length
=
MIN_BUFFER_SIZE
;
termBuffer
=
new
char
[
length
]
;
termLength
=
termText
.
length
(
)
;
termText
.
getChars
(
0
,
termText
.
length
(
)
,
termBuffer
,
0
)
;
termText
=
null
;
}
}
else
if
(
termText
!=
null
)
termText
=
null
;
}
public
final
int
termLength
(
)
{
initTermBuffer
(
)
;
return
termLength
;
}
public
final
void
setTermLength
(
int
length
)
{
initTermBuffer
(
)
;
if
(
length
>
termBuffer
.
length
)
throw
new
IllegalArgumentException
(
"length "
+
length
+
" exceeds the size of the termBuffer ("
+
termBuffer
.
length
+
")"
)
;
termLength
=
length
;
}
public
final
int
startOffset
(
)
{
return
startOffset
;
}
public
void
setStartOffset
(
int
offset
)
{
this
.
startOffset
=
offset
;
}
public
final
int
endOffset
(
)
{
return
endOffset
;
}
public
void
setEndOffset
(
int
offset
)
{
this
.
endOffset
=
offset
;
}
public
final
String
type
(
)
{
return
type
;
}
public
final
void
setType
(
String
type
)
{
this
.
type
=
type
;
}
public
int
getFlags
(
)
{
return
flags
;
}
public
void
setFlags
(
int
flags
)
{
this
.
flags
=
flags
;
}
public
Payload
getPayload
(
)
{
return
this
.
payload
;
}
public
void
setPayload
(
Payload
payload
)
{
this
.
payload
=
payload
;
}
public
String
toString
(
)
{
StringBuffer
sb
=
new
StringBuffer
(
)
;
sb
.
append
(
'('
)
;
initTermBuffer
(
)
;
if
(
termBuffer
==
null
)
sb
.
append
(
"null"
)
;
else
sb
.
append
(
termBuffer
,
0
,
termLength
)
;
sb
.
append
(
','
)
.
append
(
startOffset
)
.
append
(
','
)
.
append
(
endOffset
)
;
if
(
!
type
.
equals
(
"word"
)
)
sb
.
append
(
",type="
)
.
append
(
type
)
;
if
(
positionIncrement
!=
1
)
sb
.
append
(
",posIncr="
)
.
append
(
positionIncrement
)
;
sb
.
append
(
')'
)
;
return
sb
.
toString
(
)
;
}
public
void
clear
(
)
{
payload
=
null
;
termLength
=
0
;
termText
=
null
;
positionIncrement
=
1
;
flags
=
0
;
}
public
Object
clone
(
)
{
try
{
Token
t
=
(
Token
)
super
.
clone
(
)
;
if
(
termBuffer
!=
null
)
{
t
.
termBuffer
=
(
char
[
]
)
termBuffer
.
clone
(
)
;
}
if
(
payload
!=
null
)
{
t
.
setPayload
(
(
Payload
)
payload
.
clone
(
)
)
;
}
return
t
;
}
catch
(
CloneNotSupportedException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
}
public
Token
clone
(
char
[
]
newTermBuffer
,
int
newTermOffset
,
int
newTermLength
,
int
newStartOffset
,
int
newEndOffset
)
{
final
Token
t
=
new
Token
(
newTermBuffer
,
newTermOffset
,
newTermLength
,
newStartOffset
,
newEndOffset
)
;
t
.
positionIncrement
=
positionIncrement
;
t
.
flags
=
flags
;
t
.
type
=
type
;
if
(
payload
!=
null
)
t
.
payload
=
(
Payload
)
payload
.
clone
(
)
;
return
t
;
}
public
boolean
equals
(
Object
obj
)
{
if
(
obj
==
this
)
return
true
;
if
(
obj
instanceof
Token
)
{
Token
other
=
(
Token
)
obj
;
initTermBuffer
(
)
;
other
.
initTermBuffer
(
)
;
if
(
termLength
==
other
.
termLength
&&
startOffset
==
other
.
startOffset
&&
endOffset
==
other
.
endOffset
&&
flags
==
other
.
flags
&&
positionIncrement
==
other
.
positionIncrement
&&
subEqual
(
type
,
other
.
type
)
&&
subEqual
(
payload
,
other
.
payload
)
)
{
for
(
int
i
=
0
;
i
<
termLength
;
i
++
)
if
(
termBuffer
[
i
]
!=
other
.
termBuffer
[
i
]
)
return
false
;
return
true
;
}
else
return
false
;
}
else
return
false
;
}
private
boolean
subEqual
(
Object
o1
,
Object
o2
)
{
if
(
o1
==
null
)
return
o2
==
null
;
else
return
o1
.
equals
(
o2
)
;
}
public
int
hashCode
(
)
{
initTermBuffer
(
)
;
int
code
=
termLength
;
code
=
code
*
31
+
startOffset
;
code
=
code
*
31
+
endOffset
;
code
=
code
*
31
+
flags
;
code
=
code
*
31
+
positionIncrement
;
code
=
code
*
31
+
type
.
hashCode
(
)
;
code
=
(
payload
==
null
?
code
:
code
*
31
+
payload
.
hashCode
(
)
)
;
code
=
code
*
31
+
ArrayUtil
.
hashCode
(
termBuffer
,
0
,
termLength
)
;
return
code
;
}
private
void
clearNoTermBuffer
(
)
{
payload
=
null
;
positionIncrement
=
1
;
flags
=
0
;
}
public
Token
reinit
(
char
[
]
newTermBuffer
,
int
newTermOffset
,
int
newTermLength
,
int
newStartOffset
,
int
newEndOffset
,
String
newType
)
{
clearNoTermBuffer
(
)
;
payload
=
null
;
positionIncrement
=
1
;
setTermBuffer
(
newTermBuffer
,
newTermOffset
,
newTermLength
)
;
startOffset
=
newStartOffset
;
endOffset
=
newEndOffset
;
type
=
newType
;
return
this
;
}
public
Token
reinit
(
char
[
]
newTermBuffer
,
int
newTermOffset
,
int
newTermLength
,
int
newStartOffset
,
int
newEndOffset
)
{
clearNoTermBuffer
(
)
;
setTermBuffer
(
newTermBuffer
,
newTermOffset
,
newTermLength
)
;
startOffset
=
newStartOffset
;
endOffset
=
newEndOffset
;
type
=
DEFAULT_TYPE
;
return
this
;
}
public
Token
reinit
(
String
newTerm
,
int
newStartOffset
,
int
newEndOffset
,
String
newType
)
{
clearNoTermBuffer
(
)
;
setTermBuffer
(
newTerm
)
;
startOffset
=
newStartOffset
;
endOffset
=
newEndOffset
;
type
=
newType
;
return
this
;
}
public
Token
reinit
(
String
newTerm
,
int
newTermOffset
,
int
newTermLength
,
int
newStartOffset
,
int
newEndOffset
,
String
newType
)
{
clearNoTermBuffer
(
)
;
setTermBuffer
(
newTerm
,
newTermOffset
,
newTermLength
)
;
startOffset
=
newStartOffset
;
endOffset
=
newEndOffset
;
type
=
newType
;
return
this
;
}
public
Token
reinit
(
String
newTerm
,
int
newStartOffset
,
int
newEndOffset
)
{
clearNoTermBuffer
(
)
;
setTermBuffer
(
newTerm
)
;
startOffset
=
newStartOffset
;
endOffset
=
newEndOffset
;
type
=
DEFAULT_TYPE
;
return
this
;
}
public
Token
reinit
(
String
newTerm
,
int
newTermOffset
,
int
newTermLength
,
int
newStartOffset
,
int
newEndOffset
)
{
clearNoTermBuffer
(
)
;
setTermBuffer
(
newTerm
,
newTermOffset
,
newTermLength
)
;
startOffset
=
newStartOffset
;
endOffset
=
newEndOffset
;
type
=
DEFAULT_TYPE
;
return
this
;
}
public
void
reinit
(
Token
prototype
)
{
prototype
.
initTermBuffer
(
)
;
setTermBuffer
(
prototype
.
termBuffer
,
0
,
prototype
.
termLength
)
;
positionIncrement
=
prototype
.
positionIncrement
;
flags
=
prototype
.
flags
;
startOffset
=
prototype
.
startOffset
;
endOffset
=
prototype
.
endOffset
;
type
=
prototype
.
type
;
payload
=
prototype
.
payload
;
}
public
void
reinit
(
Token
prototype
,
String
newTerm
)
{
setTermBuffer
(
newTerm
)
;
positionIncrement
=
prototype
.
positionIncrement
;
flags
=
prototype
.
flags
;
startOffset
=
prototype
.
startOffset
;
endOffset
=
prototype
.
endOffset
;
type
=
prototype
.
type
;
payload
=
prototype
.
payload
;
}
public
void
reinit
(
Token
prototype
,
char
[
]
newTermBuffer
,
int
offset
,
int
length
)
{
setTermBuffer
(
newTermBuffer
,
offset
,
length
)
;
positionIncrement
=
prototype
.
positionIncrement
;
flags
=
prototype
.
flags
;
startOffset
=
prototype
.
startOffset
;
endOffset
=
prototype
.
endOffset
;
type
=
prototype
.
type
;
payload
=
prototype
.
payload
;
}
}
