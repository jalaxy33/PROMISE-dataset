package
org
.
apache
.
lucene
.
search
;
import
org
.
apache
.
lucene
.
document
.
Document
;
import
org
.
apache
.
lucene
.
document
.
FieldSelector
;
import
org
.
apache
.
lucene
.
index
.
CorruptIndexException
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
index
.
Term
;
import
org
.
apache
.
lucene
.
store
.
Directory
;
import
java
.
io
.
IOException
;
public
class
IndexSearcher
extends
Searcher
{
IndexReader
reader
;
private
boolean
closeReader
;
public
IndexSearcher
(
String
path
)
throws
CorruptIndexException
,
IOException
{
this
(
IndexReader
.
open
(
path
)
,
true
)
;
}
public
IndexSearcher
(
Directory
directory
)
throws
CorruptIndexException
,
IOException
{
this
(
IndexReader
.
open
(
directory
)
,
true
)
;
}
public
IndexSearcher
(
IndexReader
r
)
{
this
(
r
,
false
)
;
}
private
IndexSearcher
(
IndexReader
r
,
boolean
closeReader
)
{
reader
=
r
;
this
.
closeReader
=
closeReader
;
}
public
IndexReader
getIndexReader
(
)
{
return
reader
;
}
public
void
close
(
)
throws
IOException
{
if
(
closeReader
)
reader
.
close
(
)
;
}
public
int
docFreq
(
Term
term
)
throws
IOException
{
return
reader
.
docFreq
(
term
)
;
}
public
Document
doc
(
int
i
)
throws
CorruptIndexException
,
IOException
{
return
reader
.
document
(
i
)
;
}
public
Document
doc
(
int
i
,
FieldSelector
fieldSelector
)
throws
CorruptIndexException
,
IOException
{
return
reader
.
document
(
i
,
fieldSelector
)
;
}
public
int
maxDoc
(
)
throws
IOException
{
return
reader
.
maxDoc
(
)
;
}
public
TopDocs
search
(
Weight
weight
,
Filter
filter
,
final
int
nDocs
)
throws
IOException
{
if
(
nDocs
<=
0
)
throw
new
IllegalArgumentException
(
"nDocs must be > 0"
)
;
TopDocCollector
collector
=
new
TopDocCollector
(
nDocs
)
;
search
(
weight
,
filter
,
collector
)
;
return
collector
.
topDocs
(
)
;
}
public
TopFieldDocs
search
(
Weight
weight
,
Filter
filter
,
final
int
nDocs
,
Sort
sort
)
throws
IOException
{
TopFieldDocCollector
collector
=
new
TopFieldDocCollector
(
reader
,
sort
,
nDocs
)
;
search
(
weight
,
filter
,
collector
)
;
return
(
TopFieldDocs
)
collector
.
topDocs
(
)
;
}
public
void
search
(
Weight
weight
,
Filter
filter
,
final
HitCollector
results
)
throws
IOException
{
Scorer
scorer
=
weight
.
scorer
(
reader
)
;
if
(
scorer
==
null
)
return
;
if
(
filter
==
null
)
{
scorer
.
score
(
results
)
;
return
;
}
DocIdSetIterator
filterDocIdIterator
=
filter
.
getDocIdSet
(
reader
)
.
iterator
(
)
;
boolean
more
=
filterDocIdIterator
.
next
(
)
&&
scorer
.
skipTo
(
filterDocIdIterator
.
doc
(
)
)
;
while
(
more
)
{
int
filterDocId
=
filterDocIdIterator
.
doc
(
)
;
if
(
filterDocId
>
scorer
.
doc
(
)
&&
!
scorer
.
skipTo
(
filterDocId
)
)
{
more
=
false
;
}
else
{
int
scorerDocId
=
scorer
.
doc
(
)
;
if
(
scorerDocId
==
filterDocId
)
{
results
.
collect
(
scorerDocId
,
scorer
.
score
(
)
)
;
more
=
filterDocIdIterator
.
next
(
)
;
}
else
{
more
=
filterDocIdIterator
.
skipTo
(
scorerDocId
)
;
}
}
}
}
public
Query
rewrite
(
Query
original
)
throws
IOException
{
Query
query
=
original
;
for
(
Query
rewrittenQuery
=
query
.
rewrite
(
reader
)
;
rewrittenQuery
!=
query
;
rewrittenQuery
=
query
.
rewrite
(
reader
)
)
{
query
=
rewrittenQuery
;
}
return
query
;
}
public
Explanation
explain
(
Weight
weight
,
int
doc
)
throws
IOException
{
return
weight
.
explain
(
reader
,
doc
)
;
}
}
