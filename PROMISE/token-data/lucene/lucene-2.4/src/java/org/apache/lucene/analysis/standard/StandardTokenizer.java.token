package
org
.
apache
.
lucene
.
analysis
.
standard
;
import
java
.
io
.
IOException
;
import
java
.
io
.
Reader
;
import
org
.
apache
.
lucene
.
analysis
.
Token
;
import
org
.
apache
.
lucene
.
analysis
.
Tokenizer
;
public
class
StandardTokenizer
extends
Tokenizer
{
private
final
StandardTokenizerImpl
scanner
;
public
static
final
int
ALPHANUM
=
0
;
public
static
final
int
APOSTROPHE
=
1
;
public
static
final
int
ACRONYM
=
2
;
public
static
final
int
COMPANY
=
3
;
public
static
final
int
EMAIL
=
4
;
public
static
final
int
HOST
=
5
;
public
static
final
int
NUM
=
6
;
public
static
final
int
CJ
=
7
;
public
static
final
int
ACRONYM_DEP
=
8
;
public
static
final
String
[
]
TOKEN_TYPES
=
new
String
[
]
{
"<ALPHANUM>"
,
"<APOSTROPHE>"
,
"<ACRONYM>"
,
"<COMPANY>"
,
"<EMAIL>"
,
"<HOST>"
,
"<NUM>"
,
"<CJ>"
,
"<ACRONYM_DEP>"
}
;
public
static
final
String
[
]
tokenImage
=
TOKEN_TYPES
;
private
boolean
replaceInvalidAcronym
=
false
;
void
setInput
(
Reader
reader
)
{
this
.
input
=
reader
;
}
private
int
maxTokenLength
=
StandardAnalyzer
.
DEFAULT_MAX_TOKEN_LENGTH
;
public
void
setMaxTokenLength
(
int
length
)
{
this
.
maxTokenLength
=
length
;
}
public
int
getMaxTokenLength
(
)
{
return
maxTokenLength
;
}
public
StandardTokenizer
(
Reader
input
)
{
this
.
input
=
input
;
this
.
scanner
=
new
StandardTokenizerImpl
(
input
)
;
}
public
StandardTokenizer
(
Reader
input
,
boolean
replaceInvalidAcronym
)
{
this
.
replaceInvalidAcronym
=
replaceInvalidAcronym
;
this
.
input
=
input
;
this
.
scanner
=
new
StandardTokenizerImpl
(
input
)
;
}
public
Token
next
(
final
Token
reusableToken
)
throws
IOException
{
assert
reusableToken
!=
null
;
int
posIncr
=
1
;
while
(
true
)
{
int
tokenType
=
scanner
.
getNextToken
(
)
;
if
(
tokenType
==
StandardTokenizerImpl
.
YYEOF
)
{
return
null
;
}
if
(
scanner
.
yylength
(
)
<=
maxTokenLength
)
{
reusableToken
.
clear
(
)
;
reusableToken
.
setPositionIncrement
(
posIncr
)
;
scanner
.
getText
(
reusableToken
)
;
final
int
start
=
scanner
.
yychar
(
)
;
reusableToken
.
setStartOffset
(
start
)
;
reusableToken
.
setEndOffset
(
start
+
reusableToken
.
termLength
(
)
)
;
if
(
tokenType
==
StandardTokenizerImpl
.
ACRONYM_DEP
)
{
if
(
replaceInvalidAcronym
)
{
reusableToken
.
setType
(
StandardTokenizerImpl
.
TOKEN_TYPES
[
StandardTokenizerImpl
.
HOST
]
)
;
reusableToken
.
setTermLength
(
reusableToken
.
termLength
(
)
-
1
)
;
}
else
{
reusableToken
.
setType
(
StandardTokenizerImpl
.
TOKEN_TYPES
[
StandardTokenizerImpl
.
ACRONYM
]
)
;
}
}
else
{
reusableToken
.
setType
(
StandardTokenizerImpl
.
TOKEN_TYPES
[
tokenType
]
)
;
}
return
reusableToken
;
}
else
posIncr
++
;
}
}
public
void
reset
(
)
throws
IOException
{
super
.
reset
(
)
;
scanner
.
yyreset
(
input
)
;
}
public
void
reset
(
Reader
reader
)
throws
IOException
{
input
=
reader
;
reset
(
)
;
}
public
boolean
isReplaceInvalidAcronym
(
)
{
return
replaceInvalidAcronym
;
}
public
void
setReplaceInvalidAcronym
(
boolean
replaceInvalidAcronym
)
{
this
.
replaceInvalidAcronym
=
replaceInvalidAcronym
;
}
}
