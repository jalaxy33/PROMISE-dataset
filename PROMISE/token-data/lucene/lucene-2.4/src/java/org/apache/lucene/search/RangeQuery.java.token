package
org
.
apache
.
lucene
.
search
;
import
java
.
io
.
IOException
;
import
java
.
text
.
Collator
;
import
org
.
apache
.
lucene
.
index
.
Term
;
import
org
.
apache
.
lucene
.
index
.
TermEnum
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
util
.
ToStringUtils
;
public
class
RangeQuery
extends
Query
{
private
Term
lowerTerm
;
private
Term
upperTerm
;
private
boolean
inclusive
;
private
Collator
collator
;
public
RangeQuery
(
Term
lowerTerm
,
Term
upperTerm
,
boolean
inclusive
)
{
if
(
lowerTerm
==
null
&&
upperTerm
==
null
)
{
throw
new
IllegalArgumentException
(
"At least one term must be non-null"
)
;
}
if
(
lowerTerm
!=
null
&&
upperTerm
!=
null
&&
lowerTerm
.
field
(
)
!=
upperTerm
.
field
(
)
)
{
throw
new
IllegalArgumentException
(
"Both terms must be for the same field"
)
;
}
if
(
lowerTerm
!=
null
)
{
this
.
lowerTerm
=
lowerTerm
;
}
else
{
this
.
lowerTerm
=
new
Term
(
upperTerm
.
field
(
)
)
;
}
this
.
upperTerm
=
upperTerm
;
this
.
inclusive
=
inclusive
;
}
public
RangeQuery
(
Term
lowerTerm
,
Term
upperTerm
,
boolean
inclusive
,
Collator
collator
)
{
this
(
lowerTerm
,
upperTerm
,
inclusive
)
;
this
.
collator
=
collator
;
}
public
Query
rewrite
(
IndexReader
reader
)
throws
IOException
{
BooleanQuery
query
=
new
BooleanQuery
(
true
)
;
String
testField
=
getField
(
)
;
if
(
collator
!=
null
)
{
TermEnum
enumerator
=
reader
.
terms
(
new
Term
(
testField
,
""
)
)
;
String
lowerTermText
=
lowerTerm
!=
null
?
lowerTerm
.
text
(
)
:
null
;
String
upperTermText
=
upperTerm
!=
null
?
upperTerm
.
text
(
)
:
null
;
try
{
do
{
Term
term
=
enumerator
.
term
(
)
;
if
(
term
!=
null
&&
term
.
field
(
)
==
testField
)
{
if
(
(
lowerTermText
==
null
||
(
inclusive
?
collator
.
compare
(
term
.
text
(
)
,
lowerTermText
)
>=
0
:
collator
.
compare
(
term
.
text
(
)
,
lowerTermText
)
>
0
)
)
&&
(
upperTermText
==
null
||
(
inclusive
?
collator
.
compare
(
term
.
text
(
)
,
upperTermText
)
<=
0
:
collator
.
compare
(
term
.
text
(
)
,
upperTermText
)
<
0
)
)
)
{
addTermToQuery
(
term
,
query
)
;
}
}
}
while
(
enumerator
.
next
(
)
)
;
}
finally
{
enumerator
.
close
(
)
;
}
}
else
{
TermEnum
enumerator
=
reader
.
terms
(
lowerTerm
)
;
try
{
boolean
checkLower
=
false
;
if
(
!
inclusive
)
checkLower
=
true
;
do
{
Term
term
=
enumerator
.
term
(
)
;
if
(
term
!=
null
&&
term
.
field
(
)
==
testField
)
{
if
(
!
checkLower
||
term
.
text
(
)
.
compareTo
(
lowerTerm
.
text
(
)
)
>
0
)
{
checkLower
=
false
;
if
(
upperTerm
!=
null
)
{
int
compare
=
upperTerm
.
text
(
)
.
compareTo
(
term
.
text
(
)
)
;
if
(
(
compare
<
0
)
||
(
!
inclusive
&&
compare
==
0
)
)
break
;
}
addTermToQuery
(
term
,
query
)
;
}
}
else
{
break
;
}
}
while
(
enumerator
.
next
(
)
)
;
}
finally
{
enumerator
.
close
(
)
;
}
}
return
query
;
}
private
void
addTermToQuery
(
Term
term
,
BooleanQuery
query
)
{
TermQuery
tq
=
new
TermQuery
(
term
)
;
tq
.
setBoost
(
getBoost
(
)
)
;
query
.
add
(
tq
,
BooleanClause
.
Occur
.
SHOULD
)
;
}
public
String
getField
(
)
{
return
(
lowerTerm
!=
null
?
lowerTerm
.
field
(
)
:
upperTerm
.
field
(
)
)
;
}
public
Term
getLowerTerm
(
)
{
return
lowerTerm
;
}
public
Term
getUpperTerm
(
)
{
return
upperTerm
;
}
public
boolean
isInclusive
(
)
{
return
inclusive
;
}
public
Collator
getCollator
(
)
{
return
collator
;
}
public
String
toString
(
String
field
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
if
(
!
getField
(
)
.
equals
(
field
)
)
{
buffer
.
append
(
getField
(
)
)
;
buffer
.
append
(
":"
)
;
}
buffer
.
append
(
inclusive
?
"["
:
"{"
)
;
buffer
.
append
(
lowerTerm
!=
null
?
lowerTerm
.
text
(
)
:
"null"
)
;
buffer
.
append
(
" TO "
)
;
buffer
.
append
(
upperTerm
!=
null
?
upperTerm
.
text
(
)
:
"null"
)
;
buffer
.
append
(
inclusive
?
"]"
:
"}"
)
;
buffer
.
append
(
ToStringUtils
.
boost
(
getBoost
(
)
)
)
;
return
buffer
.
toString
(
)
;
}
public
boolean
equals
(
Object
o
)
{
if
(
this
==
o
)
return
true
;
if
(
!
(
o
instanceof
RangeQuery
)
)
return
false
;
final
RangeQuery
other
=
(
RangeQuery
)
o
;
if
(
this
.
getBoost
(
)
!=
other
.
getBoost
(
)
)
return
false
;
if
(
this
.
inclusive
!=
other
.
inclusive
)
return
false
;
if
(
this
.
collator
!=
null
&&
!
this
.
collator
.
equals
(
other
.
collator
)
)
return
false
;
if
(
this
.
lowerTerm
!=
null
?
!
this
.
lowerTerm
.
equals
(
other
.
lowerTerm
)
:
other
.
lowerTerm
!=
null
)
return
false
;
if
(
this
.
upperTerm
!=
null
?
!
this
.
upperTerm
.
equals
(
other
.
upperTerm
)
:
other
.
upperTerm
!=
null
)
return
false
;
return
true
;
}
public
int
hashCode
(
)
{
int
h
=
Float
.
floatToIntBits
(
getBoost
(
)
)
;
h
^=
lowerTerm
!=
null
?
lowerTerm
.
hashCode
(
)
:
0
;
h
^=
(
h
<<
25
)
|
(
h
>
>
>
8
)
;
h
^=
upperTerm
!=
null
?
upperTerm
.
hashCode
(
)
:
0
;
h
^=
this
.
inclusive
?
0x2742E74A
:
0
;
h
^=
collator
!=
null
?
collator
.
hashCode
(
)
:
0
;
return
h
;
}
}
