package
org
.
apache
.
lucene
.
index
;
import
org
.
apache
.
lucene
.
document
.
Document
;
import
org
.
apache
.
lucene
.
document
.
Fieldable
;
import
org
.
apache
.
lucene
.
store
.
Directory
;
import
org
.
apache
.
lucene
.
store
.
IndexInput
;
import
org
.
apache
.
lucene
.
store
.
IndexOutput
;
import
java
.
io
.
IOException
;
import
java
.
util
.
*
;
final
class
FieldInfos
{
static
final
byte
IS_INDEXED
=
0x1
;
static
final
byte
STORE_TERMVECTOR
=
0x2
;
static
final
byte
STORE_POSITIONS_WITH_TERMVECTOR
=
0x4
;
static
final
byte
STORE_OFFSET_WITH_TERMVECTOR
=
0x8
;
static
final
byte
OMIT_NORMS
=
0x10
;
static
final
byte
STORE_PAYLOADS
=
0x20
;
static
final
byte
OMIT_TF
=
0x40
;
private
ArrayList
byNumber
=
new
ArrayList
(
)
;
private
HashMap
byName
=
new
HashMap
(
)
;
FieldInfos
(
)
{
}
FieldInfos
(
Directory
d
,
String
name
)
throws
IOException
{
IndexInput
input
=
d
.
openInput
(
name
)
;
try
{
read
(
input
)
;
}
finally
{
input
.
close
(
)
;
}
}
synchronized
public
Object
clone
(
)
{
FieldInfos
fis
=
new
FieldInfos
(
)
;
final
int
numField
=
byNumber
.
size
(
)
;
for
(
int
i
=
0
;
i
<
numField
;
i
++
)
{
FieldInfo
fi
=
(
FieldInfo
)
(
(
FieldInfo
)
byNumber
.
get
(
i
)
)
.
clone
(
)
;
fis
.
byNumber
.
add
(
fi
)
;
fis
.
byName
.
put
(
fi
.
name
,
fi
)
;
}
return
fis
;
}
synchronized
public
void
add
(
Document
doc
)
{
List
fields
=
doc
.
getFields
(
)
;
Iterator
fieldIterator
=
fields
.
iterator
(
)
;
while
(
fieldIterator
.
hasNext
(
)
)
{
Fieldable
field
=
(
Fieldable
)
fieldIterator
.
next
(
)
;
add
(
field
.
name
(
)
,
field
.
isIndexed
(
)
,
field
.
isTermVectorStored
(
)
,
field
.
isStorePositionWithTermVector
(
)
,
field
.
isStoreOffsetWithTermVector
(
)
,
field
.
getOmitNorms
(
)
)
;
}
}
boolean
hasProx
(
)
{
final
int
numFields
=
byNumber
.
size
(
)
;
for
(
int
i
=
0
;
i
<
numFields
;
i
++
)
if
(
!
fieldInfo
(
i
)
.
omitTf
)
return
true
;
return
false
;
}
synchronized
public
void
addIndexed
(
Collection
names
,
boolean
storeTermVectors
,
boolean
storePositionWithTermVector
,
boolean
storeOffsetWithTermVector
)
{
Iterator
i
=
names
.
iterator
(
)
;
while
(
i
.
hasNext
(
)
)
{
add
(
(
String
)
i
.
next
(
)
,
true
,
storeTermVectors
,
storePositionWithTermVector
,
storeOffsetWithTermVector
)
;
}
}
synchronized
public
void
add
(
Collection
names
,
boolean
isIndexed
)
{
Iterator
i
=
names
.
iterator
(
)
;
while
(
i
.
hasNext
(
)
)
{
add
(
(
String
)
i
.
next
(
)
,
isIndexed
)
;
}
}
synchronized
public
void
add
(
String
name
,
boolean
isIndexed
)
{
add
(
name
,
isIndexed
,
false
,
false
,
false
,
false
)
;
}
synchronized
public
void
add
(
String
name
,
boolean
isIndexed
,
boolean
storeTermVector
)
{
add
(
name
,
isIndexed
,
storeTermVector
,
false
,
false
,
false
)
;
}
synchronized
public
void
add
(
String
name
,
boolean
isIndexed
,
boolean
storeTermVector
,
boolean
storePositionWithTermVector
,
boolean
storeOffsetWithTermVector
)
{
add
(
name
,
isIndexed
,
storeTermVector
,
storePositionWithTermVector
,
storeOffsetWithTermVector
,
false
)
;
}
synchronized
public
void
add
(
String
name
,
boolean
isIndexed
,
boolean
storeTermVector
,
boolean
storePositionWithTermVector
,
boolean
storeOffsetWithTermVector
,
boolean
omitNorms
)
{
add
(
name
,
isIndexed
,
storeTermVector
,
storePositionWithTermVector
,
storeOffsetWithTermVector
,
omitNorms
,
false
,
false
)
;
}
synchronized
public
FieldInfo
add
(
String
name
,
boolean
isIndexed
,
boolean
storeTermVector
,
boolean
storePositionWithTermVector
,
boolean
storeOffsetWithTermVector
,
boolean
omitNorms
,
boolean
storePayloads
,
boolean
omitTf
)
{
FieldInfo
fi
=
fieldInfo
(
name
)
;
if
(
fi
==
null
)
{
return
addInternal
(
name
,
isIndexed
,
storeTermVector
,
storePositionWithTermVector
,
storeOffsetWithTermVector
,
omitNorms
,
storePayloads
,
omitTf
)
;
}
else
{
fi
.
update
(
isIndexed
,
storeTermVector
,
storePositionWithTermVector
,
storeOffsetWithTermVector
,
omitNorms
,
storePayloads
,
omitTf
)
;
}
return
fi
;
}
synchronized
public
FieldInfo
add
(
FieldInfo
fieldInfo
)
{
FieldInfo
fi
=
fieldInfo
(
fieldInfo
.
name
)
;
if
(
fi
==
null
)
{
return
addInternal
(
fieldInfo
.
name
,
fieldInfo
.
isIndexed
,
fieldInfo
.
storeTermVector
,
fieldInfo
.
storePositionWithTermVector
,
fieldInfo
.
storeOffsetWithTermVector
,
fieldInfo
.
omitNorms
,
fieldInfo
.
storePayloads
,
fieldInfo
.
omitTf
)
;
}
else
{
fi
.
update
(
fieldInfo
)
;
}
return
fi
;
}
private
FieldInfo
addInternal
(
String
name
,
boolean
isIndexed
,
boolean
storeTermVector
,
boolean
storePositionWithTermVector
,
boolean
storeOffsetWithTermVector
,
boolean
omitNorms
,
boolean
storePayloads
,
boolean
omitTf
)
{
FieldInfo
fi
=
new
FieldInfo
(
name
,
isIndexed
,
byNumber
.
size
(
)
,
storeTermVector
,
storePositionWithTermVector
,
storeOffsetWithTermVector
,
omitNorms
,
storePayloads
,
omitTf
)
;
byNumber
.
add
(
fi
)
;
byName
.
put
(
name
,
fi
)
;
return
fi
;
}
public
int
fieldNumber
(
String
fieldName
)
{
FieldInfo
fi
=
fieldInfo
(
fieldName
)
;
return
(
fi
!=
null
)
?
fi
.
number
:
-
1
;
}
public
FieldInfo
fieldInfo
(
String
fieldName
)
{
return
(
FieldInfo
)
byName
.
get
(
fieldName
)
;
}
public
String
fieldName
(
int
fieldNumber
)
{
FieldInfo
fi
=
fieldInfo
(
fieldNumber
)
;
return
(
fi
!=
null
)
?
fi
.
name
:
""
;
}
public
FieldInfo
fieldInfo
(
int
fieldNumber
)
{
return
(
fieldNumber
>=
0
)
?
(
FieldInfo
)
byNumber
.
get
(
fieldNumber
)
:
null
;
}
public
int
size
(
)
{
return
byNumber
.
size
(
)
;
}
public
boolean
hasVectors
(
)
{
boolean
hasVectors
=
false
;
for
(
int
i
=
0
;
i
<
size
(
)
;
i
++
)
{
if
(
fieldInfo
(
i
)
.
storeTermVector
)
{
hasVectors
=
true
;
break
;
}
}
return
hasVectors
;
}
public
void
write
(
Directory
d
,
String
name
)
throws
IOException
{
IndexOutput
output
=
d
.
createOutput
(
name
)
;
try
{
write
(
output
)
;
}
finally
{
output
.
close
(
)
;
}
}
public
void
write
(
IndexOutput
output
)
throws
IOException
{
output
.
writeVInt
(
size
(
)
)
;
for
(
int
i
=
0
;
i
<
size
(
)
;
i
++
)
{
FieldInfo
fi
=
fieldInfo
(
i
)
;
byte
bits
=
0x0
;
if
(
fi
.
isIndexed
)
bits
|=
IS_INDEXED
;
if
(
fi
.
storeTermVector
)
bits
|=
STORE_TERMVECTOR
;
if
(
fi
.
storePositionWithTermVector
)
bits
|=
STORE_POSITIONS_WITH_TERMVECTOR
;
if
(
fi
.
storeOffsetWithTermVector
)
bits
|=
STORE_OFFSET_WITH_TERMVECTOR
;
if
(
fi
.
omitNorms
)
bits
|=
OMIT_NORMS
;
if
(
fi
.
storePayloads
)
bits
|=
STORE_PAYLOADS
;
if
(
fi
.
omitTf
)
bits
|=
OMIT_TF
;
output
.
writeString
(
fi
.
name
)
;
output
.
writeByte
(
bits
)
;
}
}
private
void
read
(
IndexInput
input
)
throws
IOException
{
int
size
=
input
.
readVInt
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
String
name
=
input
.
readString
(
)
.
intern
(
)
;
byte
bits
=
input
.
readByte
(
)
;
boolean
isIndexed
=
(
bits
&
IS_INDEXED
)
!=
0
;
boolean
storeTermVector
=
(
bits
&
STORE_TERMVECTOR
)
!=
0
;
boolean
storePositionsWithTermVector
=
(
bits
&
STORE_POSITIONS_WITH_TERMVECTOR
)
!=
0
;
boolean
storeOffsetWithTermVector
=
(
bits
&
STORE_OFFSET_WITH_TERMVECTOR
)
!=
0
;
boolean
omitNorms
=
(
bits
&
OMIT_NORMS
)
!=
0
;
boolean
storePayloads
=
(
bits
&
STORE_PAYLOADS
)
!=
0
;
boolean
omitTf
=
(
bits
&
OMIT_TF
)
!=
0
;
addInternal
(
name
,
isIndexed
,
storeTermVector
,
storePositionsWithTermVector
,
storeOffsetWithTermVector
,
omitNorms
,
storePayloads
,
omitTf
)
;
}
}
}
