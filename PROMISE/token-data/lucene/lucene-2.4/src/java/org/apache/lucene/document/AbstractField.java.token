package
org
.
apache
.
lucene
.
document
;
public
abstract
class
AbstractField
implements
Fieldable
{
protected
String
name
=
"body"
;
protected
boolean
storeTermVector
=
false
;
protected
boolean
storeOffsetWithTermVector
=
false
;
protected
boolean
storePositionWithTermVector
=
false
;
protected
boolean
omitNorms
=
false
;
protected
boolean
isStored
=
false
;
protected
boolean
isIndexed
=
true
;
protected
boolean
isTokenized
=
true
;
protected
boolean
isBinary
=
false
;
protected
boolean
isCompressed
=
false
;
protected
boolean
lazy
=
false
;
protected
boolean
omitTf
=
false
;
protected
float
boost
=
1.0f
;
protected
Object
fieldsData
=
null
;
protected
int
binaryLength
;
protected
int
binaryOffset
;
protected
AbstractField
(
)
{
}
protected
AbstractField
(
String
name
,
Field
.
Store
store
,
Field
.
Index
index
,
Field
.
TermVector
termVector
)
{
if
(
name
==
null
)
throw
new
NullPointerException
(
"name cannot be null"
)
;
this
.
name
=
name
.
intern
(
)
;
if
(
store
==
Field
.
Store
.
YES
)
{
this
.
isStored
=
true
;
this
.
isCompressed
=
false
;
}
else
if
(
store
==
Field
.
Store
.
COMPRESS
)
{
this
.
isStored
=
true
;
this
.
isCompressed
=
true
;
}
else
if
(
store
==
Field
.
Store
.
NO
)
{
this
.
isStored
=
false
;
this
.
isCompressed
=
false
;
}
else
throw
new
IllegalArgumentException
(
"unknown store parameter "
+
store
)
;
if
(
index
==
Field
.
Index
.
NO
)
{
this
.
isIndexed
=
false
;
this
.
isTokenized
=
false
;
}
else
if
(
index
==
Field
.
Index
.
ANALYZED
)
{
this
.
isIndexed
=
true
;
this
.
isTokenized
=
true
;
}
else
if
(
index
==
Field
.
Index
.
NOT_ANALYZED
)
{
this
.
isIndexed
=
true
;
this
.
isTokenized
=
false
;
}
else
if
(
index
==
Field
.
Index
.
NOT_ANALYZED_NO_NORMS
)
{
this
.
isIndexed
=
true
;
this
.
isTokenized
=
false
;
this
.
omitNorms
=
true
;
}
else
if
(
index
==
Field
.
Index
.
ANALYZED_NO_NORMS
)
{
this
.
isIndexed
=
true
;
this
.
isTokenized
=
true
;
this
.
omitNorms
=
true
;
}
else
{
throw
new
IllegalArgumentException
(
"unknown index parameter "
+
index
)
;
}
this
.
isBinary
=
false
;
setStoreTermVector
(
termVector
)
;
}
public
void
setBoost
(
float
boost
)
{
this
.
boost
=
boost
;
}
public
float
getBoost
(
)
{
return
boost
;
}
public
String
name
(
)
{
return
name
;
}
protected
void
setStoreTermVector
(
Field
.
TermVector
termVector
)
{
if
(
termVector
==
Field
.
TermVector
.
NO
)
{
this
.
storeTermVector
=
false
;
this
.
storePositionWithTermVector
=
false
;
this
.
storeOffsetWithTermVector
=
false
;
}
else
if
(
termVector
==
Field
.
TermVector
.
YES
)
{
this
.
storeTermVector
=
true
;
this
.
storePositionWithTermVector
=
false
;
this
.
storeOffsetWithTermVector
=
false
;
}
else
if
(
termVector
==
Field
.
TermVector
.
WITH_POSITIONS
)
{
this
.
storeTermVector
=
true
;
this
.
storePositionWithTermVector
=
true
;
this
.
storeOffsetWithTermVector
=
false
;
}
else
if
(
termVector
==
Field
.
TermVector
.
WITH_OFFSETS
)
{
this
.
storeTermVector
=
true
;
this
.
storePositionWithTermVector
=
false
;
this
.
storeOffsetWithTermVector
=
true
;
}
else
if
(
termVector
==
Field
.
TermVector
.
WITH_POSITIONS_OFFSETS
)
{
this
.
storeTermVector
=
true
;
this
.
storePositionWithTermVector
=
true
;
this
.
storeOffsetWithTermVector
=
true
;
}
else
{
throw
new
IllegalArgumentException
(
"unknown termVector parameter "
+
termVector
)
;
}
}
public
final
boolean
isStored
(
)
{
return
isStored
;
}
public
final
boolean
isIndexed
(
)
{
return
isIndexed
;
}
public
final
boolean
isTokenized
(
)
{
return
isTokenized
;
}
public
final
boolean
isCompressed
(
)
{
return
isCompressed
;
}
public
final
boolean
isTermVectorStored
(
)
{
return
storeTermVector
;
}
public
boolean
isStoreOffsetWithTermVector
(
)
{
return
storeOffsetWithTermVector
;
}
public
boolean
isStorePositionWithTermVector
(
)
{
return
storePositionWithTermVector
;
}
public
final
boolean
isBinary
(
)
{
return
isBinary
;
}
public
byte
[
]
getBinaryValue
(
)
{
return
getBinaryValue
(
null
)
;
}
public
byte
[
]
getBinaryValue
(
byte
[
]
result
)
{
if
(
isBinary
||
fieldsData
instanceof
byte
[
]
)
return
(
byte
[
]
)
fieldsData
;
else
return
null
;
}
public
int
getBinaryLength
(
)
{
if
(
isBinary
)
{
if
(
!
isCompressed
)
return
binaryLength
;
else
return
(
(
byte
[
]
)
fieldsData
)
.
length
;
}
else
if
(
fieldsData
instanceof
byte
[
]
)
return
(
(
byte
[
]
)
fieldsData
)
.
length
;
else
return
0
;
}
public
int
getBinaryOffset
(
)
{
return
binaryOffset
;
}
public
boolean
getOmitNorms
(
)
{
return
omitNorms
;
}
public
boolean
getOmitTf
(
)
{
return
omitTf
;
}
public
void
setOmitNorms
(
boolean
omitNorms
)
{
this
.
omitNorms
=
omitNorms
;
}
public
void
setOmitTf
(
boolean
omitTf
)
{
this
.
omitTf
=
omitTf
;
}
public
boolean
isLazy
(
)
{
return
lazy
;
}
public
final
String
toString
(
)
{
StringBuffer
result
=
new
StringBuffer
(
)
;
if
(
isStored
)
{
result
.
append
(
"stored"
)
;
if
(
isCompressed
)
result
.
append
(
"/compressed"
)
;
else
result
.
append
(
"/uncompressed"
)
;
}
if
(
isIndexed
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"indexed"
)
;
}
if
(
isTokenized
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"tokenized"
)
;
}
if
(
storeTermVector
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"termVector"
)
;
}
if
(
storeOffsetWithTermVector
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"termVectorOffsets"
)
;
}
if
(
storePositionWithTermVector
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"termVectorPosition"
)
;
}
if
(
isBinary
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"binary"
)
;
}
if
(
omitNorms
)
{
result
.
append
(
",omitNorms"
)
;
}
if
(
omitTf
)
{
result
.
append
(
",omitTf"
)
;
}
if
(
lazy
)
{
result
.
append
(
",lazy"
)
;
}
result
.
append
(
'<'
)
;
result
.
append
(
name
)
;
result
.
append
(
':'
)
;
if
(
fieldsData
!=
null
&&
lazy
==
false
)
{
result
.
append
(
fieldsData
)
;
}
result
.
append
(
'>'
)
;
return
result
.
toString
(
)
;
}
}
