package
org
.
apache
.
lucene
.
search
;
import
java
.
util
.
List
;
import
java
.
util
.
Iterator
;
import
java
.
io
.
IOException
;
import
org
.
apache
.
lucene
.
util
.
ScorerDocQueue
;
class
DisjunctionSumScorer
extends
Scorer
{
private
final
int
nrScorers
;
protected
final
List
subScorers
;
private
final
int
minimumNrMatchers
;
private
ScorerDocQueue
scorerDocQueue
=
null
;
private
int
queueSize
=
-
1
;
private
int
currentDoc
=
-
1
;
protected
int
nrMatchers
=
-
1
;
private
float
currentScore
=
Float
.
NaN
;
public
DisjunctionSumScorer
(
List
subScorers
,
int
minimumNrMatchers
)
{
super
(
null
)
;
nrScorers
=
subScorers
.
size
(
)
;
if
(
minimumNrMatchers
<=
0
)
{
throw
new
IllegalArgumentException
(
"Minimum nr of matchers must be positive"
)
;
}
if
(
nrScorers
<=
1
)
{
throw
new
IllegalArgumentException
(
"There must be at least 2 subScorers"
)
;
}
this
.
minimumNrMatchers
=
minimumNrMatchers
;
this
.
subScorers
=
subScorers
;
}
public
DisjunctionSumScorer
(
List
subScorers
)
{
this
(
subScorers
,
1
)
;
}
private
void
initScorerDocQueue
(
)
throws
IOException
{
Iterator
si
=
subScorers
.
iterator
(
)
;
scorerDocQueue
=
new
ScorerDocQueue
(
nrScorers
)
;
queueSize
=
0
;
while
(
si
.
hasNext
(
)
)
{
Scorer
se
=
(
Scorer
)
si
.
next
(
)
;
if
(
se
.
next
(
)
)
{
if
(
scorerDocQueue
.
insert
(
se
)
)
{
queueSize
++
;
}
}
}
}
public
void
score
(
HitCollector
hc
)
throws
IOException
{
while
(
next
(
)
)
{
hc
.
collect
(
currentDoc
,
currentScore
)
;
}
}
protected
boolean
score
(
HitCollector
hc
,
int
max
)
throws
IOException
{
while
(
currentDoc
<
max
)
{
hc
.
collect
(
currentDoc
,
currentScore
)
;
if
(
!
next
(
)
)
{
return
false
;
}
}
return
true
;
}
public
boolean
next
(
)
throws
IOException
{
if
(
scorerDocQueue
==
null
)
{
initScorerDocQueue
(
)
;
}
return
(
scorerDocQueue
.
size
(
)
>=
minimumNrMatchers
)
&&
advanceAfterCurrent
(
)
;
}
protected
boolean
advanceAfterCurrent
(
)
throws
IOException
{
do
{
currentDoc
=
scorerDocQueue
.
topDoc
(
)
;
currentScore
=
scorerDocQueue
.
topScore
(
)
;
nrMatchers
=
1
;
do
{
if
(
!
scorerDocQueue
.
topNextAndAdjustElsePop
(
)
)
{
if
(
--
queueSize
==
0
)
{
break
;
}
}
if
(
scorerDocQueue
.
topDoc
(
)
!=
currentDoc
)
{
break
;
}
currentScore
+=
scorerDocQueue
.
topScore
(
)
;
nrMatchers
++
;
}
while
(
true
)
;
if
(
nrMatchers
>=
minimumNrMatchers
)
{
return
true
;
}
else
if
(
queueSize
<
minimumNrMatchers
)
{
return
false
;
}
}
while
(
true
)
;
}
public
float
score
(
)
throws
IOException
{
return
currentScore
;
}
public
int
doc
(
)
{
return
currentDoc
;
}
public
int
nrMatchers
(
)
{
return
nrMatchers
;
}
public
boolean
skipTo
(
int
target
)
throws
IOException
{
if
(
scorerDocQueue
==
null
)
{
initScorerDocQueue
(
)
;
}
if
(
queueSize
<
minimumNrMatchers
)
{
return
false
;
}
if
(
target
<=
currentDoc
)
{
return
true
;
}
do
{
if
(
scorerDocQueue
.
topDoc
(
)
>=
target
)
{
return
advanceAfterCurrent
(
)
;
}
else
if
(
!
scorerDocQueue
.
topSkipToAndAdjustElsePop
(
target
)
)
{
if
(
--
queueSize
<
minimumNrMatchers
)
{
return
false
;
}
}
}
while
(
true
)
;
}
public
Explanation
explain
(
int
doc
)
throws
IOException
{
Explanation
res
=
new
Explanation
(
)
;
Iterator
ssi
=
subScorers
.
iterator
(
)
;
float
sumScore
=
0.0f
;
int
nrMatches
=
0
;
while
(
ssi
.
hasNext
(
)
)
{
Explanation
es
=
(
(
Scorer
)
ssi
.
next
(
)
)
.
explain
(
doc
)
;
if
(
es
.
getValue
(
)
>
0.0f
)
{
sumScore
+=
es
.
getValue
(
)
;
nrMatches
++
;
}
res
.
addDetail
(
es
)
;
}
if
(
nrMatchers
>=
minimumNrMatchers
)
{
res
.
setValue
(
sumScore
)
;
res
.
setDescription
(
"sum over at least "
+
minimumNrMatchers
+
" of "
+
subScorers
.
size
(
)
+
":"
)
;
}
else
{
res
.
setValue
(
0.0f
)
;
res
.
setDescription
(
nrMatches
+
" match(es) but at least "
+
minimumNrMatchers
+
" of "
+
subScorers
.
size
(
)
+
" needed"
)
;
}
return
res
;
}
}
