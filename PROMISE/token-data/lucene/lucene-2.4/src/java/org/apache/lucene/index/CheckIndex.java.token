package
org
.
apache
.
lucene
.
index
;
import
org
.
apache
.
lucene
.
store
.
FSDirectory
;
import
org
.
apache
.
lucene
.
store
.
Directory
;
import
org
.
apache
.
lucene
.
store
.
IndexInput
;
import
org
.
apache
.
lucene
.
document
.
Document
;
import
java
.
text
.
NumberFormat
;
import
java
.
io
.
PrintStream
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
ArrayList
;
import
org
.
apache
.
lucene
.
document
.
Fieldable
;
public
class
CheckIndex
{
public
static
PrintStream
out
=
null
;
private
PrintStream
infoStream
;
private
Directory
dir
;
public
static
class
Status
{
public
boolean
clean
;
public
boolean
missingSegments
;
public
boolean
cantOpenSegments
;
public
boolean
missingSegmentVersion
;
public
String
segmentsFileName
;
public
int
numSegments
;
public
String
segmentFormat
;
public
List
segmentsChecked
=
new
ArrayList
(
)
;
public
boolean
toolOutOfDate
;
public
List
segmentInfos
=
new
ArrayList
(
)
;
public
Directory
dir
;
SegmentInfos
newSegments
;
public
int
totLoseDocCount
;
public
int
numBadSegments
;
public
boolean
partial
;
public
static
class
SegmentInfoStatus
{
public
String
name
;
public
int
docCount
;
public
boolean
compound
;
public
int
numFiles
;
public
double
sizeMB
;
public
int
docStoreOffset
=
-
1
;
public
String
docStoreSegment
;
public
boolean
docStoreCompoundFile
;
public
boolean
hasDeletions
;
public
String
deletionsFileName
;
public
int
numDeleted
;
public
boolean
openReaderPassed
;
int
numFields
;
public
boolean
hasProx
;
}
}
public
CheckIndex
(
Directory
dir
)
{
this
.
dir
=
dir
;
infoStream
=
out
;
}
public
void
setInfoStream
(
PrintStream
out
)
{
infoStream
=
out
;
}
private
void
msg
(
String
msg
)
{
if
(
infoStream
!=
null
)
infoStream
.
println
(
msg
)
;
}
private
static
class
MySegmentTermDocs
extends
SegmentTermDocs
{
int
delCount
;
MySegmentTermDocs
(
SegmentReader
p
)
{
super
(
p
)
;
}
public
void
seek
(
Term
term
)
throws
IOException
{
super
.
seek
(
term
)
;
delCount
=
0
;
}
protected
void
skippingDoc
(
)
throws
IOException
{
delCount
++
;
}
}
public
static
boolean
check
(
Directory
dir
,
boolean
doFix
)
throws
IOException
{
return
check
(
dir
,
doFix
,
null
)
;
}
public
static
boolean
check
(
Directory
dir
,
boolean
doFix
,
List
onlySegments
)
throws
IOException
{
CheckIndex
checker
=
new
CheckIndex
(
dir
)
;
Status
status
=
checker
.
checkIndex
(
onlySegments
)
;
if
(
doFix
&&
!
status
.
clean
)
checker
.
fixIndex
(
status
)
;
return
status
.
clean
;
}
public
Status
checkIndex
(
)
throws
IOException
{
return
checkIndex
(
null
)
;
}
public
Status
checkIndex
(
List
onlySegments
)
throws
IOException
{
NumberFormat
nf
=
NumberFormat
.
getInstance
(
)
;
SegmentInfos
sis
=
new
SegmentInfos
(
)
;
Status
result
=
new
Status
(
)
;
result
.
dir
=
dir
;
try
{
sis
.
read
(
dir
)
;
}
catch
(
Throwable
t
)
{
msg
(
"ERROR: could not read any segments file in directory"
)
;
result
.
missingSegments
=
true
;
if
(
infoStream
!=
null
)
t
.
printStackTrace
(
infoStream
)
;
return
result
;
}
final
int
numSegments
=
sis
.
size
(
)
;
final
String
segmentsFileName
=
sis
.
getCurrentSegmentFileName
(
)
;
IndexInput
input
=
null
;
try
{
input
=
dir
.
openInput
(
segmentsFileName
)
;
}
catch
(
Throwable
t
)
{
msg
(
"ERROR: could not open segments file in directory"
)
;
if
(
infoStream
!=
null
)
t
.
printStackTrace
(
infoStream
)
;
result
.
cantOpenSegments
=
true
;
return
result
;
}
int
format
=
0
;
try
{
format
=
input
.
readInt
(
)
;
}
catch
(
Throwable
t
)
{
msg
(
"ERROR: could not read segment file version in directory"
)
;
if
(
infoStream
!=
null
)
t
.
printStackTrace
(
infoStream
)
;
result
.
missingSegmentVersion
=
true
;
return
result
;
}
finally
{
if
(
input
!=
null
)
input
.
close
(
)
;
}
String
sFormat
=
""
;
boolean
skip
=
false
;
if
(
format
==
SegmentInfos
.
FORMAT
)
sFormat
=
"FORMAT [Lucene Pre-2.1]"
;
if
(
format
==
SegmentInfos
.
FORMAT_LOCKLESS
)
sFormat
=
"FORMAT_LOCKLESS [Lucene 2.1]"
;
else
if
(
format
==
SegmentInfos
.
FORMAT_SINGLE_NORM_FILE
)
sFormat
=
"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]"
;
else
if
(
format
==
SegmentInfos
.
FORMAT_SHARED_DOC_STORE
)
sFormat
=
"FORMAT_SHARED_DOC_STORE [Lucene 2.3]"
;
else
{
if
(
format
==
SegmentInfos
.
FORMAT_CHECKSUM
)
sFormat
=
"FORMAT_CHECKSUM [Lucene 2.4]"
;
else
if
(
format
==
SegmentInfos
.
FORMAT_DEL_COUNT
)
sFormat
=
"FORMAT_DEL_COUNT [Lucene 2.4]"
;
else
if
(
format
==
SegmentInfos
.
FORMAT_HAS_PROX
)
sFormat
=
"FORMAT_HAS_PROX [Lucene 2.4]"
;
else
if
(
format
<
SegmentInfos
.
CURRENT_FORMAT
)
{
sFormat
=
"int="
+
format
+
" [newer version of Lucene than this tool]"
;
skip
=
true
;
}
else
{
sFormat
=
format
+
" [Lucene 1.3 or prior]"
;
}
}
msg
(
"Segments file="
+
segmentsFileName
+
" numSegments="
+
numSegments
+
" version="
+
sFormat
)
;
result
.
segmentsFileName
=
segmentsFileName
;
result
.
numSegments
=
numSegments
;
result
.
segmentFormat
=
sFormat
;
if
(
onlySegments
!=
null
)
{
result
.
partial
=
true
;
if
(
infoStream
!=
null
)
infoStream
.
print
(
"\nChecking only these segments:"
)
;
Iterator
it
=
onlySegments
.
iterator
(
)
;
while
(
it
.
hasNext
(
)
)
{
if
(
infoStream
!=
null
)
infoStream
.
print
(
" "
+
it
.
next
(
)
)
;
}
result
.
segmentsChecked
.
addAll
(
onlySegments
)
;
msg
(
":"
)
;
}
if
(
skip
)
{
msg
(
"\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting"
)
;
result
.
toolOutOfDate
=
true
;
return
result
;
}
result
.
newSegments
=
(
SegmentInfos
)
sis
.
clone
(
)
;
result
.
newSegments
.
clear
(
)
;
for
(
int
i
=
0
;
i
<
numSegments
;
i
++
)
{
final
SegmentInfo
info
=
sis
.
info
(
i
)
;
if
(
onlySegments
!=
null
&&
!
onlySegments
.
contains
(
info
.
name
)
)
continue
;
Status
.
SegmentInfoStatus
segInfoStat
=
new
Status
.
SegmentInfoStatus
(
)
;
result
.
segmentInfos
.
add
(
segInfoStat
)
;
msg
(
"  "
+
(
1
+
i
)
+
" of "
+
numSegments
+
": name="
+
info
.
name
+
" docCount="
+
info
.
docCount
)
;
segInfoStat
.
name
=
info
.
name
;
segInfoStat
.
docCount
=
info
.
docCount
;
int
toLoseDocCount
=
info
.
docCount
;
SegmentReader
reader
=
null
;
try
{
msg
(
"    compound="
+
info
.
getUseCompoundFile
(
)
)
;
segInfoStat
.
compound
=
info
.
getUseCompoundFile
(
)
;
msg
(
"    hasProx="
+
info
.
getHasProx
(
)
)
;
segInfoStat
.
hasProx
=
info
.
getHasProx
(
)
;
msg
(
"    numFiles="
+
info
.
files
(
)
.
size
(
)
)
;
segInfoStat
.
numFiles
=
info
.
files
(
)
.
size
(
)
;
msg
(
"    size (MB)="
+
nf
.
format
(
info
.
sizeInBytes
(
)
/
(
1024.
*
1024.
)
)
)
;
segInfoStat
.
sizeMB
=
info
.
sizeInBytes
(
)
/
(
1024.
*
1024.
)
;
final
int
docStoreOffset
=
info
.
getDocStoreOffset
(
)
;
if
(
docStoreOffset
!=
-
1
)
{
msg
(
"    docStoreOffset="
+
docStoreOffset
)
;
segInfoStat
.
docStoreOffset
=
docStoreOffset
;
msg
(
"    docStoreSegment="
+
info
.
getDocStoreSegment
(
)
)
;
segInfoStat
.
docStoreSegment
=
info
.
getDocStoreSegment
(
)
;
msg
(
"    docStoreIsCompoundFile="
+
info
.
getDocStoreIsCompoundFile
(
)
)
;
segInfoStat
.
docStoreCompoundFile
=
info
.
getDocStoreIsCompoundFile
(
)
;
}
final
String
delFileName
=
info
.
getDelFileName
(
)
;
if
(
delFileName
==
null
)
{
msg
(
"    no deletions"
)
;
segInfoStat
.
hasDeletions
=
false
;
}
else
{
msg
(
"    has deletions [delFileName="
+
delFileName
+
"]"
)
;
segInfoStat
.
hasDeletions
=
true
;
segInfoStat
.
deletionsFileName
=
delFileName
;
}
if
(
infoStream
!=
null
)
infoStream
.
print
(
"    test: open reader........."
)
;
reader
=
SegmentReader
.
get
(
info
)
;
final
int
numDocs
=
reader
.
numDocs
(
)
;
toLoseDocCount
=
numDocs
;
if
(
reader
.
hasDeletions
(
)
)
{
if
(
info
.
docCount
-
numDocs
!=
info
.
getDelCount
(
)
)
{
throw
new
RuntimeException
(
"delete count mismatch: info="
+
info
.
getDelCount
(
)
+
" vs reader="
+
(
info
.
docCount
-
numDocs
)
)
;
}
segInfoStat
.
numDeleted
=
info
.
docCount
-
numDocs
;
msg
(
"OK ["
+
(
segInfoStat
.
numDeleted
)
+
" deleted docs]"
)
;
}
else
{
if
(
info
.
getDelCount
(
)
!=
0
)
{
throw
new
RuntimeException
(
"delete count mismatch: info="
+
info
.
getDelCount
(
)
+
" vs reader="
+
(
info
.
docCount
-
numDocs
)
)
;
}
msg
(
"OK"
)
;
}
if
(
infoStream
!=
null
)
infoStream
.
print
(
"    test: fields, norms......."
)
;
Collection
fieldNames
=
reader
.
getFieldNames
(
IndexReader
.
FieldOption
.
ALL
)
;
Iterator
it
=
fieldNames
.
iterator
(
)
;
while
(
it
.
hasNext
(
)
)
{
final
String
fieldName
=
(
String
)
it
.
next
(
)
;
byte
[
]
b
=
reader
.
norms
(
fieldName
)
;
if
(
b
.
length
!=
info
.
docCount
)
throw
new
RuntimeException
(
"norms for field \""
+
fieldName
+
"\" is length "
+
b
.
length
+
" != maxDoc "
+
info
.
docCount
)
;
}
msg
(
"OK ["
+
fieldNames
.
size
(
)
+
" fields]"
)
;
segInfoStat
.
numFields
=
fieldNames
.
size
(
)
;
if
(
infoStream
!=
null
)
infoStream
.
print
(
"    test: terms, freq, prox..."
)
;
final
TermEnum
termEnum
=
reader
.
terms
(
)
;
final
TermPositions
termPositions
=
reader
.
termPositions
(
)
;
final
MySegmentTermDocs
myTermDocs
=
new
MySegmentTermDocs
(
reader
)
;
long
termCount
=
0
;
long
totFreq
=
0
;
long
totPos
=
0
;
while
(
termEnum
.
next
(
)
)
{
termCount
++
;
final
Term
term
=
termEnum
.
term
(
)
;
final
int
docFreq
=
termEnum
.
docFreq
(
)
;
termPositions
.
seek
(
term
)
;
int
lastDoc
=
-
1
;
int
freq0
=
0
;
totFreq
+=
docFreq
;
while
(
termPositions
.
next
(
)
)
{
freq0
++
;
final
int
doc
=
termPositions
.
doc
(
)
;
final
int
freq
=
termPositions
.
freq
(
)
;
if
(
doc
<=
lastDoc
)
throw
new
RuntimeException
(
"term "
+
term
+
": doc "
+
doc
+
" <= lastDoc "
+
lastDoc
)
;
lastDoc
=
doc
;
if
(
freq
<=
0
)
throw
new
RuntimeException
(
"term "
+
term
+
": doc "
+
doc
+
": freq "
+
freq
+
" is out of bounds"
)
;
int
lastPos
=
-
1
;
totPos
+=
freq
;
for
(
int
j
=
0
;
j
<
freq
;
j
++
)
{
final
int
pos
=
termPositions
.
nextPosition
(
)
;
if
(
pos
<
-
1
)
throw
new
RuntimeException
(
"term "
+
term
+
": doc "
+
doc
+
": pos "
+
pos
+
" is out of bounds"
)
;
if
(
pos
<
lastPos
)
throw
new
RuntimeException
(
"term "
+
term
+
": doc "
+
doc
+
": pos "
+
pos
+
" < lastPos "
+
lastPos
)
;
}
}
final
int
delCount
;
if
(
reader
.
hasDeletions
(
)
)
{
myTermDocs
.
seek
(
term
)
;
while
(
myTermDocs
.
next
(
)
)
{
}
delCount
=
myTermDocs
.
delCount
;
}
else
delCount
=
0
;
if
(
freq0
+
delCount
!=
docFreq
)
throw
new
RuntimeException
(
"term "
+
term
+
" docFreq="
+
docFreq
+
" != num docs seen "
+
freq0
+
" + num docs deleted "
+
delCount
)
;
}
msg
(
"OK ["
+
termCount
+
" terms; "
+
totFreq
+
" terms/docs pairs; "
+
totPos
+
" tokens]"
)
;
if
(
infoStream
!=
null
)
infoStream
.
print
(
"    test: stored fields......."
)
;
int
docCount
=
0
;
long
totFields
=
0
;
for
(
int
j
=
0
;
j
<
info
.
docCount
;
j
++
)
if
(
!
reader
.
isDeleted
(
j
)
)
{
docCount
++
;
Document
doc
=
reader
.
document
(
j
)
;
totFields
+=
doc
.
getFields
(
)
.
size
(
)
;
}
if
(
docCount
!=
reader
.
numDocs
(
)
)
throw
new
RuntimeException
(
"docCount="
+
docCount
+
" but saw "
+
docCount
+
" undeleted docs"
)
;
msg
(
"OK ["
+
totFields
+
" total field count; avg "
+
nf
.
format
(
(
(
(
float
)
totFields
)
/
docCount
)
)
+
" fields per doc]"
)
;
if
(
infoStream
!=
null
)
infoStream
.
print
(
"    test: term vectors........"
)
;
int
totVectors
=
0
;
for
(
int
j
=
0
;
j
<
info
.
docCount
;
j
++
)
if
(
!
reader
.
isDeleted
(
j
)
)
{
TermFreqVector
[
]
tfv
=
reader
.
getTermFreqVectors
(
j
)
;
if
(
tfv
!=
null
)
totVectors
+=
tfv
.
length
;
}
msg
(
"OK ["
+
totVectors
+
" total vector count; avg "
+
nf
.
format
(
(
(
(
float
)
totVectors
)
/
docCount
)
)
+
" term/freq vector fields per doc]"
)
;
msg
(
""
)
;
}
catch
(
Throwable
t
)
{
msg
(
"FAILED"
)
;
String
comment
;
comment
=
"fixIndex() would remove reference to this segment"
;
msg
(
"    WARNING: "
+
comment
+
"; full exception:"
)
;
if
(
infoStream
!=
null
)
t
.
printStackTrace
(
infoStream
)
;
msg
(
""
)
;
result
.
totLoseDocCount
+=
toLoseDocCount
;
result
.
numBadSegments
++
;
continue
;
}
finally
{
if
(
reader
!=
null
)
reader
.
close
(
)
;
}
result
.
newSegments
.
add
(
info
.
clone
(
)
)
;
}
if
(
0
==
result
.
numBadSegments
)
{
result
.
clean
=
true
;
msg
(
"No problems were detected with this index.\n"
)
;
}
else
msg
(
"WARNING: "
+
result
.
numBadSegments
+
" broken segments (containing "
+
result
.
totLoseDocCount
+
" documents) detected"
)
;
return
result
;
}
public
void
fixIndex
(
Status
result
)
throws
IOException
{
if
(
result
.
partial
)
throw
new
IllegalArgumentException
(
"can only fix an index that was fully checked (this status checked a subset of segments)"
)
;
result
.
newSegments
.
commit
(
result
.
dir
)
;
}
private
static
boolean
assertsOn
;
private
static
boolean
testAsserts
(
)
{
assertsOn
=
true
;
return
true
;
}
private
static
boolean
assertsOn
(
)
{
assert
testAsserts
(
)
;
return
assertsOn
;
}
public
static
void
main
(
String
[
]
args
)
throws
IOException
{
boolean
doFix
=
false
;
List
onlySegments
=
new
ArrayList
(
)
;
String
indexPath
=
null
;
int
i
=
0
;
while
(
i
<
args
.
length
)
{
if
(
args
[
i
]
.
equals
(
"-fix"
)
)
{
doFix
=
true
;
i
++
;
}
else
if
(
args
[
i
]
.
equals
(
"-segment"
)
)
{
if
(
i
==
args
.
length
-
1
)
{
System
.
out
.
println
(
"ERROR: missing name for -segment option"
)
;
System
.
exit
(
1
)
;
}
onlySegments
.
add
(
args
[
i
+
1
]
)
;
i
+=
2
;
}
else
{
if
(
indexPath
!=
null
)
{
System
.
out
.
println
(
"ERROR: unexpected extra argument '"
+
args
[
i
]
+
"'"
)
;
System
.
exit
(
1
)
;
}
indexPath
=
args
[
i
]
;
i
++
;
}
}
if
(
indexPath
==
null
)
{
System
.
out
.
println
(
"\nERROR: index path not specified"
)
;
System
.
out
.
println
(
"\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n"
+
"\n"
+
"  -fix: actually write a new segments_N file, removing any problematic segments\n"
+
"  -segment X: only check the specified segments.  This can be specified multiple\n"
+
"              times, to check more than one segment, eg '-segment _2 -segment _a'.\n"
+
"              You can't use this with the -fix option\n"
+
"\n"
+
"**WARNING**: -fix should only be used on an emergency basis as it will cause\n"
+
"documents (perhaps many) to be permanently removed from the index.  Always make\n"
+
"a backup copy of your index before running this!  Do not run this tool on an index\n"
+
"that is actively being written to.  You have been warned!\n"
+
"\n"
+
"Run without -fix, this tool will open the index, report version information\n"
+
"and report any exceptions it hits and what action it would take if -fix were\n"
+
"specified.  With -fix, this tool will remove any segments that have issues and\n"
+
"write a new segments_N file.  This means all documents contained in the affected\n"
+
"segments will be removed.\n"
+
"\n"
+
"This tool exits with exit code 1 if the index cannot be opened or has any\n"
+
"corruption, else 0.\n"
)
;
System
.
exit
(
1
)
;
}
if
(
!
assertsOn
(
)
)
System
.
out
.
println
(
"\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled"
)
;
if
(
onlySegments
.
size
(
)
==
0
)
onlySegments
=
null
;
else
if
(
doFix
)
{
System
.
out
.
println
(
"ERROR: cannot specify both -fix and -segment"
)
;
System
.
exit
(
1
)
;
}
System
.
out
.
println
(
"\nOpening index @ "
+
indexPath
+
"\n"
)
;
Directory
dir
=
null
;
try
{
dir
=
FSDirectory
.
getDirectory
(
indexPath
)
;
}
catch
(
Throwable
t
)
{
System
.
out
.
println
(
"ERROR: could not open directory \""
+
indexPath
+
"\"; exiting"
)
;
t
.
printStackTrace
(
System
.
out
)
;
System
.
exit
(
1
)
;
}
CheckIndex
checker
=
new
CheckIndex
(
dir
)
;
checker
.
setInfoStream
(
System
.
out
)
;
Status
result
=
checker
.
checkIndex
(
onlySegments
)
;
if
(
!
result
.
clean
)
{
if
(
!
doFix
)
{
System
.
out
.
println
(
"WARNING: would write new segments file, and "
+
result
.
totLoseDocCount
+
" documents would be lost, if -fix were specified\n"
)
;
}
else
{
System
.
out
.
println
(
"WARNING: "
+
result
.
totLoseDocCount
+
" documents will be lost\n"
)
;
System
.
out
.
println
(
"NOTE: will write new segments file in 5 seconds; this will remove "
+
result
.
totLoseDocCount
+
" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!"
)
;
for
(
int
s
=
0
;
s
<
5
;
s
++
)
{
try
{
Thread
.
sleep
(
1000
)
;
}
catch
(
InterruptedException
ie
)
{
Thread
.
currentThread
(
)
.
interrupt
(
)
;
s
--
;
continue
;
}
System
.
out
.
println
(
"  "
+
(
5
-
s
)
+
"..."
)
;
}
System
.
out
.
println
(
"Writing..."
)
;
checker
.
fixIndex
(
result
)
;
System
.
out
.
println
(
"OK"
)
;
System
.
out
.
println
(
"Wrote new segments file \""
+
result
.
newSegments
.
getCurrentSegmentFileName
(
)
+
"\""
)
;
}
}
System
.
out
.
println
(
""
)
;
final
int
exitCode
;
if
(
result
!=
null
&&
result
.
clean
==
true
)
exitCode
=
0
;
else
exitCode
=
1
;
System
.
exit
(
exitCode
)
;
}
}
