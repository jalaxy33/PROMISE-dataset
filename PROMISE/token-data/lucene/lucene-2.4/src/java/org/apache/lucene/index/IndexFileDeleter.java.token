package
org
.
apache
.
lucene
.
index
;
import
org
.
apache
.
lucene
.
store
.
Directory
;
import
java
.
io
.
IOException
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
PrintStream
;
import
java
.
util
.
Map
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Collection
;
final
class
IndexFileDeleter
{
private
List
deletable
;
private
Map
refCounts
=
new
HashMap
(
)
;
private
List
commits
=
new
ArrayList
(
)
;
private
List
lastFiles
=
new
ArrayList
(
)
;
private
List
commitsToDelete
=
new
ArrayList
(
)
;
private
PrintStream
infoStream
;
private
Directory
directory
;
private
IndexDeletionPolicy
policy
;
private
DocumentsWriter
docWriter
;
public
static
boolean
VERBOSE_REF_COUNTS
=
false
;
void
setInfoStream
(
PrintStream
infoStream
)
{
this
.
infoStream
=
infoStream
;
if
(
infoStream
!=
null
)
message
(
"setInfoStream deletionPolicy="
+
policy
)
;
}
private
void
message
(
String
message
)
{
infoStream
.
println
(
"IFD ["
+
Thread
.
currentThread
(
)
.
getName
(
)
+
"]: "
+
message
)
;
}
public
IndexFileDeleter
(
Directory
directory
,
IndexDeletionPolicy
policy
,
SegmentInfos
segmentInfos
,
PrintStream
infoStream
,
DocumentsWriter
docWriter
)
throws
CorruptIndexException
,
IOException
{
this
.
docWriter
=
docWriter
;
this
.
infoStream
=
infoStream
;
if
(
infoStream
!=
null
)
message
(
"init: current segments file is \""
+
segmentInfos
.
getCurrentSegmentFileName
(
)
+
"\"; deletionPolicy="
+
policy
)
;
this
.
policy
=
policy
;
this
.
directory
=
directory
;
long
currentGen
=
segmentInfos
.
getGeneration
(
)
;
IndexFileNameFilter
filter
=
IndexFileNameFilter
.
getFilter
(
)
;
String
[
]
files
=
directory
.
list
(
)
;
if
(
files
==
null
)
throw
new
IOException
(
"cannot read directory "
+
directory
+
": list() returned null"
)
;
CommitPoint
currentCommitPoint
=
null
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
String
fileName
=
files
[
i
]
;
if
(
filter
.
accept
(
null
,
fileName
)
&&
!
fileName
.
equals
(
IndexFileNames
.
SEGMENTS_GEN
)
)
{
getRefCount
(
fileName
)
;
if
(
fileName
.
startsWith
(
IndexFileNames
.
SEGMENTS
)
)
{
if
(
SegmentInfos
.
generationFromSegmentsFileName
(
fileName
)
<=
currentGen
)
{
if
(
infoStream
!=
null
)
{
message
(
"init: load commit \""
+
fileName
+
"\""
)
;
}
SegmentInfos
sis
=
new
SegmentInfos
(
)
;
try
{
sis
.
read
(
directory
,
fileName
)
;
}
catch
(
FileNotFoundException
e
)
{
if
(
infoStream
!=
null
)
{
message
(
"init: hit FileNotFoundException when loading commit \""
+
fileName
+
"\"; skipping this commit point"
)
;
}
sis
=
null
;
}
if
(
sis
!=
null
)
{
CommitPoint
commitPoint
=
new
CommitPoint
(
commitsToDelete
,
directory
,
sis
)
;
if
(
sis
.
getGeneration
(
)
==
segmentInfos
.
getGeneration
(
)
)
{
currentCommitPoint
=
commitPoint
;
}
commits
.
add
(
commitPoint
)
;
incRef
(
sis
,
true
)
;
}
}
}
}
}
if
(
currentCommitPoint
==
null
)
{
SegmentInfos
sis
=
new
SegmentInfos
(
)
;
try
{
sis
.
read
(
directory
,
segmentInfos
.
getCurrentSegmentFileName
(
)
)
;
}
catch
(
IOException
e
)
{
throw
new
CorruptIndexException
(
"failed to locate current segments_N file"
)
;
}
if
(
infoStream
!=
null
)
message
(
"forced open of current segments file "
+
segmentInfos
.
getCurrentSegmentFileName
(
)
)
;
currentCommitPoint
=
new
CommitPoint
(
commitsToDelete
,
directory
,
sis
)
;
commits
.
add
(
currentCommitPoint
)
;
incRef
(
sis
,
true
)
;
}
Collections
.
sort
(
commits
)
;
Iterator
it
=
refCounts
.
keySet
(
)
.
iterator
(
)
;
while
(
it
.
hasNext
(
)
)
{
String
fileName
=
(
String
)
it
.
next
(
)
;
RefCount
rc
=
(
RefCount
)
refCounts
.
get
(
fileName
)
;
if
(
0
==
rc
.
count
)
{
if
(
infoStream
!=
null
)
{
message
(
"init: removing unreferenced file \""
+
fileName
+
"\""
)
;
}
deleteFile
(
fileName
)
;
}
}
policy
.
onInit
(
commits
)
;
if
(
currentCommitPoint
.
deleted
)
{
checkpoint
(
segmentInfos
,
false
)
;
}
deleteCommits
(
)
;
}
private
void
deleteCommits
(
)
throws
IOException
{
int
size
=
commitsToDelete
.
size
(
)
;
if
(
size
>
0
)
{
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
CommitPoint
commit
=
(
CommitPoint
)
commitsToDelete
.
get
(
i
)
;
if
(
infoStream
!=
null
)
{
message
(
"deleteCommits: now decRef commit \""
+
commit
.
getSegmentsFileName
(
)
+
"\""
)
;
}
int
size2
=
commit
.
files
.
size
(
)
;
for
(
int
j
=
0
;
j
<
size2
;
j
++
)
{
decRef
(
(
String
)
commit
.
files
.
get
(
j
)
)
;
}
}
commitsToDelete
.
clear
(
)
;
size
=
commits
.
size
(
)
;
int
readFrom
=
0
;
int
writeTo
=
0
;
while
(
readFrom
<
size
)
{
CommitPoint
commit
=
(
CommitPoint
)
commits
.
get
(
readFrom
)
;
if
(
!
commit
.
deleted
)
{
if
(
writeTo
!=
readFrom
)
{
commits
.
set
(
writeTo
,
commits
.
get
(
readFrom
)
)
;
}
writeTo
++
;
}
readFrom
++
;
}
while
(
size
>
writeTo
)
{
commits
.
remove
(
size
-
1
)
;
size
--
;
}
}
}
public
void
refresh
(
String
segmentName
)
throws
IOException
{
String
[
]
files
=
directory
.
list
(
)
;
if
(
files
==
null
)
throw
new
IOException
(
"cannot read directory "
+
directory
+
": list() returned null"
)
;
IndexFileNameFilter
filter
=
IndexFileNameFilter
.
getFilter
(
)
;
String
segmentPrefix1
;
String
segmentPrefix2
;
if
(
segmentName
!=
null
)
{
segmentPrefix1
=
segmentName
+
"."
;
segmentPrefix2
=
segmentName
+
"_"
;
}
else
{
segmentPrefix1
=
null
;
segmentPrefix2
=
null
;
}
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
String
fileName
=
files
[
i
]
;
if
(
filter
.
accept
(
null
,
fileName
)
&&
(
segmentName
==
null
||
fileName
.
startsWith
(
segmentPrefix1
)
||
fileName
.
startsWith
(
segmentPrefix2
)
)
&&
!
refCounts
.
containsKey
(
fileName
)
&&
!
fileName
.
equals
(
IndexFileNames
.
SEGMENTS_GEN
)
)
{
if
(
infoStream
!=
null
)
{
message
(
"refresh [prefix="
+
segmentName
+
"]: removing newly created unreferenced file \""
+
fileName
+
"\""
)
;
}
deleteFile
(
fileName
)
;
}
}
}
public
void
refresh
(
)
throws
IOException
{
refresh
(
null
)
;
}
public
void
close
(
)
throws
IOException
{
deletePendingFiles
(
)
;
}
private
void
deletePendingFiles
(
)
throws
IOException
{
if
(
deletable
!=
null
)
{
List
oldDeletable
=
deletable
;
deletable
=
null
;
int
size
=
oldDeletable
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
if
(
infoStream
!=
null
)
message
(
"delete pending file "
+
oldDeletable
.
get
(
i
)
)
;
deleteFile
(
(
String
)
oldDeletable
.
get
(
i
)
)
;
}
}
}
public
void
checkpoint
(
SegmentInfos
segmentInfos
,
boolean
isCommit
)
throws
IOException
{
if
(
infoStream
!=
null
)
{
message
(
"now checkpoint \""
+
segmentInfos
.
getCurrentSegmentFileName
(
)
+
"\" ["
+
segmentInfos
.
size
(
)
+
" segments "
+
"; isCommit = "
+
isCommit
+
"]"
)
;
}
deletePendingFiles
(
)
;
incRef
(
segmentInfos
,
isCommit
)
;
if
(
isCommit
)
{
commits
.
add
(
new
CommitPoint
(
commitsToDelete
,
directory
,
segmentInfos
)
)
;
policy
.
onCommit
(
commits
)
;
deleteCommits
(
)
;
}
else
{
final
List
docWriterFiles
;
if
(
docWriter
!=
null
)
{
docWriterFiles
=
docWriter
.
openFiles
(
)
;
if
(
docWriterFiles
!=
null
)
incRef
(
docWriterFiles
)
;
}
else
docWriterFiles
=
null
;
int
size
=
lastFiles
.
size
(
)
;
if
(
size
>
0
)
{
for
(
int
i
=
0
;
i
<
size
;
i
++
)
decRef
(
(
List
)
lastFiles
.
get
(
i
)
)
;
lastFiles
.
clear
(
)
;
}
size
=
segmentInfos
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
SegmentInfo
segmentInfo
=
segmentInfos
.
info
(
i
)
;
if
(
segmentInfo
.
dir
==
directory
)
{
lastFiles
.
add
(
segmentInfo
.
files
(
)
)
;
}
}
if
(
docWriterFiles
!=
null
)
lastFiles
.
add
(
docWriterFiles
)
;
}
}
void
incRef
(
SegmentInfos
segmentInfos
,
boolean
isCommit
)
throws
IOException
{
int
size
=
segmentInfos
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
SegmentInfo
segmentInfo
=
segmentInfos
.
info
(
i
)
;
if
(
segmentInfo
.
dir
==
directory
)
{
incRef
(
segmentInfo
.
files
(
)
)
;
}
}
if
(
isCommit
)
{
getRefCount
(
segmentInfos
.
getCurrentSegmentFileName
(
)
)
.
IncRef
(
)
;
}
}
void
incRef
(
List
files
)
throws
IOException
{
int
size
=
files
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
String
fileName
=
(
String
)
files
.
get
(
i
)
;
RefCount
rc
=
getRefCount
(
fileName
)
;
if
(
infoStream
!=
null
&&
VERBOSE_REF_COUNTS
)
{
message
(
"  IncRef \""
+
fileName
+
"\": pre-incr count is "
+
rc
.
count
)
;
}
rc
.
IncRef
(
)
;
}
}
void
decRef
(
List
files
)
throws
IOException
{
int
size
=
files
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
decRef
(
(
String
)
files
.
get
(
i
)
)
;
}
}
void
decRef
(
String
fileName
)
throws
IOException
{
RefCount
rc
=
getRefCount
(
fileName
)
;
if
(
infoStream
!=
null
&&
VERBOSE_REF_COUNTS
)
{
message
(
"  DecRef \""
+
fileName
+
"\": pre-decr count is "
+
rc
.
count
)
;
}
if
(
0
==
rc
.
DecRef
(
)
)
{
deleteFile
(
fileName
)
;
refCounts
.
remove
(
fileName
)
;
}
}
void
decRef
(
SegmentInfos
segmentInfos
)
throws
IOException
{
final
int
size
=
segmentInfos
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
SegmentInfo
segmentInfo
=
segmentInfos
.
info
(
i
)
;
if
(
segmentInfo
.
dir
==
directory
)
{
decRef
(
segmentInfo
.
files
(
)
)
;
}
}
}
private
RefCount
getRefCount
(
String
fileName
)
{
RefCount
rc
;
if
(
!
refCounts
.
containsKey
(
fileName
)
)
{
rc
=
new
RefCount
(
)
;
refCounts
.
put
(
fileName
,
rc
)
;
}
else
{
rc
=
(
RefCount
)
refCounts
.
get
(
fileName
)
;
}
return
rc
;
}
void
deleteFiles
(
List
files
)
throws
IOException
{
final
int
size
=
files
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
deleteFile
(
(
String
)
files
.
get
(
i
)
)
;
}
void
deleteNewFiles
(
Collection
files
)
throws
IOException
{
final
Iterator
it
=
files
.
iterator
(
)
;
while
(
it
.
hasNext
(
)
)
{
final
String
fileName
=
(
String
)
it
.
next
(
)
;
if
(
!
refCounts
.
containsKey
(
fileName
)
)
deleteFile
(
fileName
)
;
}
}
void
deleteFile
(
String
fileName
)
throws
IOException
{
try
{
if
(
infoStream
!=
null
)
{
message
(
"delete \""
+
fileName
+
"\""
)
;
}
directory
.
deleteFile
(
fileName
)
;
}
catch
(
IOException
e
)
{
if
(
directory
.
fileExists
(
fileName
)
)
{
if
(
infoStream
!=
null
)
{
message
(
"IndexFileDeleter: unable to remove file \""
+
fileName
+
"\": "
+
e
.
toString
(
)
+
"; Will re-try later."
)
;
}
if
(
deletable
==
null
)
{
deletable
=
new
ArrayList
(
)
;
}
deletable
.
add
(
fileName
)
;
}
}
}
final
private
static
class
RefCount
{
int
count
;
public
int
IncRef
(
)
{
return
++
count
;
}
public
int
DecRef
(
)
{
assert
count
>
0
;
return
--
count
;
}
}
final
private
static
class
CommitPoint
extends
IndexCommit
implements
Comparable
{
long
gen
;
List
files
;
String
segmentsFileName
;
boolean
deleted
;
Directory
directory
;
Collection
commitsToDelete
;
long
version
;
long
generation
;
final
boolean
isOptimized
;
public
CommitPoint
(
Collection
commitsToDelete
,
Directory
directory
,
SegmentInfos
segmentInfos
)
throws
IOException
{
this
.
directory
=
directory
;
this
.
commitsToDelete
=
commitsToDelete
;
segmentsFileName
=
segmentInfos
.
getCurrentSegmentFileName
(
)
;
version
=
segmentInfos
.
getVersion
(
)
;
generation
=
segmentInfos
.
getGeneration
(
)
;
int
size
=
segmentInfos
.
size
(
)
;
files
=
new
ArrayList
(
size
)
;
files
.
add
(
segmentsFileName
)
;
gen
=
segmentInfos
.
getGeneration
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
SegmentInfo
segmentInfo
=
segmentInfos
.
info
(
i
)
;
if
(
segmentInfo
.
dir
==
directory
)
{
files
.
addAll
(
segmentInfo
.
files
(
)
)
;
}
}
isOptimized
=
segmentInfos
.
size
(
)
==
1
&&
!
segmentInfos
.
info
(
0
)
.
hasDeletions
(
)
;
}
public
boolean
isOptimized
(
)
{
return
isOptimized
;
}
public
String
getSegmentsFileName
(
)
{
return
segmentsFileName
;
}
public
Collection
getFileNames
(
)
throws
IOException
{
return
Collections
.
unmodifiableCollection
(
files
)
;
}
public
Directory
getDirectory
(
)
{
return
directory
;
}
public
long
getVersion
(
)
{
return
version
;
}
public
long
getGeneration
(
)
{
return
generation
;
}
public
void
delete
(
)
{
if
(
!
deleted
)
{
deleted
=
true
;
commitsToDelete
.
add
(
this
)
;
}
}
public
boolean
isDeleted
(
)
{
return
deleted
;
}
public
int
compareTo
(
Object
obj
)
{
CommitPoint
commit
=
(
CommitPoint
)
obj
;
if
(
gen
<
commit
.
gen
)
{
return
-
1
;
}
else
if
(
gen
>
commit
.
gen
)
{
return
1
;
}
else
{
return
0
;
}
}
}
}
