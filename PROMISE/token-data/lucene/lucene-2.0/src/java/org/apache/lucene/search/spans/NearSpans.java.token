package
org
.
apache
.
lucene
.
search
.
spans
;
import
java
.
io
.
IOException
;
import
java
.
util
.
List
;
import
java
.
util
.
ArrayList
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
util
.
PriorityQueue
;
class
NearSpans
implements
Spans
{
private
SpanNearQuery
query
;
private
List
ordered
=
new
ArrayList
(
)
;
private
int
slop
;
private
boolean
inOrder
;
private
SpansCell
first
;
private
SpansCell
last
;
private
int
totalLength
;
private
CellQueue
queue
;
private
SpansCell
max
;
private
boolean
more
=
true
;
private
boolean
firstTime
=
true
;
private
class
CellQueue
extends
PriorityQueue
{
public
CellQueue
(
int
size
)
{
initialize
(
size
)
;
}
protected
final
boolean
lessThan
(
Object
o1
,
Object
o2
)
{
SpansCell
spans1
=
(
SpansCell
)
o1
;
SpansCell
spans2
=
(
SpansCell
)
o2
;
if
(
spans1
.
doc
(
)
==
spans2
.
doc
(
)
)
{
if
(
spans1
.
start
(
)
==
spans2
.
start
(
)
)
{
if
(
spans1
.
end
(
)
==
spans2
.
end
(
)
)
{
return
spans1
.
index
>
spans2
.
index
;
}
else
{
return
spans1
.
end
(
)
<
spans2
.
end
(
)
;
}
}
else
{
return
spans1
.
start
(
)
<
spans2
.
start
(
)
;
}
}
else
{
return
spans1
.
doc
(
)
<
spans2
.
doc
(
)
;
}
}
}
private
class
SpansCell
implements
Spans
{
private
Spans
spans
;
private
SpansCell
next
;
private
int
length
=
-
1
;
private
int
index
;
public
SpansCell
(
Spans
spans
,
int
index
)
{
this
.
spans
=
spans
;
this
.
index
=
index
;
}
public
boolean
next
(
)
throws
IOException
{
if
(
length
!=
-
1
)
totalLength
-=
length
;
boolean
more
=
spans
.
next
(
)
;
if
(
more
)
{
length
=
end
(
)
-
start
(
)
;
totalLength
+=
length
;
if
(
max
==
null
||
doc
(
)
>
max
.
doc
(
)
||
(
doc
(
)
==
max
.
doc
(
)
&&
end
(
)
>
max
.
end
(
)
)
)
max
=
this
;
}
return
more
;
}
public
boolean
skipTo
(
int
target
)
throws
IOException
{
if
(
length
!=
-
1
)
totalLength
-=
length
;
boolean
more
=
spans
.
skipTo
(
target
)
;
if
(
more
)
{
length
=
end
(
)
-
start
(
)
;
totalLength
+=
length
;
if
(
max
==
null
||
doc
(
)
>
max
.
doc
(
)
||
(
doc
(
)
==
max
.
doc
(
)
&&
end
(
)
>
max
.
end
(
)
)
)
max
=
this
;
}
return
more
;
}
public
int
doc
(
)
{
return
spans
.
doc
(
)
;
}
public
int
start
(
)
{
return
spans
.
start
(
)
;
}
public
int
end
(
)
{
return
spans
.
end
(
)
;
}
public
String
toString
(
)
{
return
spans
.
toString
(
)
+
"#"
+
index
;
}
}
public
NearSpans
(
SpanNearQuery
query
,
IndexReader
reader
)
throws
IOException
{
this
.
query
=
query
;
this
.
slop
=
query
.
getSlop
(
)
;
this
.
inOrder
=
query
.
isInOrder
(
)
;
SpanQuery
[
]
clauses
=
query
.
getClauses
(
)
;
queue
=
new
CellQueue
(
clauses
.
length
)
;
for
(
int
i
=
0
;
i
<
clauses
.
length
;
i
++
)
{
SpansCell
cell
=
new
SpansCell
(
clauses
[
i
]
.
getSpans
(
reader
)
,
i
)
;
ordered
.
add
(
cell
)
;
}
}
public
boolean
next
(
)
throws
IOException
{
if
(
firstTime
)
{
initList
(
true
)
;
listToQueue
(
)
;
firstTime
=
false
;
}
else
if
(
more
)
{
more
=
min
(
)
.
next
(
)
;
if
(
more
)
queue
.
adjustTop
(
)
;
}
while
(
more
)
{
boolean
queueStale
=
false
;
if
(
min
(
)
.
doc
(
)
!=
max
.
doc
(
)
)
{
queueToList
(
)
;
queueStale
=
true
;
}
while
(
more
&&
first
.
doc
(
)
<
last
.
doc
(
)
)
{
more
=
first
.
skipTo
(
last
.
doc
(
)
)
;
firstToLast
(
)
;
queueStale
=
true
;
}
if
(
!
more
)
return
false
;
if
(
queueStale
)
{
listToQueue
(
)
;
queueStale
=
false
;
}
if
(
atMatch
(
)
)
return
true
;
if
(
inOrder
&&
checkSlop
(
)
)
{
more
=
firstNonOrderedNextToPartialList
(
)
;
if
(
more
)
{
partialListToQueue
(
)
;
}
}
else
{
more
=
min
(
)
.
next
(
)
;
if
(
more
)
{
queue
.
adjustTop
(
)
;
}
}
}
return
false
;
}
public
boolean
skipTo
(
int
target
)
throws
IOException
{
if
(
firstTime
)
{
initList
(
false
)
;
for
(
SpansCell
cell
=
first
;
more
&&
cell
!=
null
;
cell
=
cell
.
next
)
{
more
=
cell
.
skipTo
(
target
)
;
}
if
(
more
)
{
listToQueue
(
)
;
}
firstTime
=
false
;
}
else
{
while
(
more
&&
min
(
)
.
doc
(
)
<
target
)
{
more
=
min
(
)
.
skipTo
(
target
)
;
if
(
more
)
queue
.
adjustTop
(
)
;
}
}
if
(
more
)
{
if
(
atMatch
(
)
)
return
true
;
return
next
(
)
;
}
return
false
;
}
private
SpansCell
min
(
)
{
return
(
SpansCell
)
queue
.
top
(
)
;
}
public
int
doc
(
)
{
return
min
(
)
.
doc
(
)
;
}
public
int
start
(
)
{
return
min
(
)
.
start
(
)
;
}
public
int
end
(
)
{
return
max
.
end
(
)
;
}
public
String
toString
(
)
{
return
"spans("
+
query
.
toString
(
)
+
")@"
+
(
firstTime
?
"START"
:
(
more
?
(
doc
(
)
+
":"
+
start
(
)
+
"-"
+
end
(
)
)
:
"END"
)
)
;
}
private
void
initList
(
boolean
next
)
throws
IOException
{
for
(
int
i
=
0
;
more
&&
i
<
ordered
.
size
(
)
;
i
++
)
{
SpansCell
cell
=
(
SpansCell
)
ordered
.
get
(
i
)
;
if
(
next
)
more
=
cell
.
next
(
)
;
if
(
more
)
{
addToList
(
cell
)
;
}
}
}
private
void
addToList
(
SpansCell
cell
)
{
if
(
last
!=
null
)
{
last
.
next
=
cell
;
}
else
first
=
cell
;
last
=
cell
;
cell
.
next
=
null
;
}
private
void
firstToLast
(
)
{
last
.
next
=
first
;
last
=
first
;
first
=
first
.
next
;
last
.
next
=
null
;
}
private
void
queueToList
(
)
{
last
=
first
=
null
;
while
(
queue
.
top
(
)
!=
null
)
{
addToList
(
(
SpansCell
)
queue
.
pop
(
)
)
;
}
}
private
boolean
firstNonOrderedNextToPartialList
(
)
throws
IOException
{
last
=
first
=
null
;
int
orderedIndex
=
0
;
while
(
queue
.
top
(
)
!=
null
)
{
SpansCell
cell
=
(
SpansCell
)
queue
.
pop
(
)
;
addToList
(
cell
)
;
if
(
cell
.
index
==
orderedIndex
)
{
orderedIndex
++
;
}
else
{
return
cell
.
next
(
)
;
}
}
throw
new
RuntimeException
(
"Unexpected: ordered"
)
;
}
private
void
listToQueue
(
)
{
queue
.
clear
(
)
;
partialListToQueue
(
)
;
}
private
void
partialListToQueue
(
)
{
for
(
SpansCell
cell
=
first
;
cell
!=
null
;
cell
=
cell
.
next
)
{
queue
.
put
(
cell
)
;
}
}
private
boolean
atMatch
(
)
{
return
(
min
(
)
.
doc
(
)
==
max
.
doc
(
)
)
&&
checkSlop
(
)
&&
(
!
inOrder
||
matchIsOrdered
(
)
)
;
}
private
boolean
checkSlop
(
)
{
int
matchLength
=
max
.
end
(
)
-
min
(
)
.
start
(
)
;
return
(
matchLength
-
totalLength
)
<=
slop
;
}
private
boolean
matchIsOrdered
(
)
{
int
lastStart
=
-
1
;
for
(
int
i
=
0
;
i
<
ordered
.
size
(
)
;
i
++
)
{
int
start
=
(
(
SpansCell
)
ordered
.
get
(
i
)
)
.
start
(
)
;
if
(
!
(
start
>
lastStart
)
)
return
false
;
lastStart
=
start
;
}
return
true
;
}
}
