package
org
.
apache
.
lucene
.
search
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Iterator
;
import
org
.
apache
.
lucene
.
document
.
Document
;
public
final
class
Hits
{
private
Weight
weight
;
private
Searcher
searcher
;
private
Filter
filter
=
null
;
private
Sort
sort
=
null
;
private
int
length
;
private
Vector
hitDocs
=
new
Vector
(
)
;
private
HitDoc
first
;
private
HitDoc
last
;
private
int
numDocs
=
0
;
private
int
maxDocs
=
200
;
Hits
(
Searcher
s
,
Query
q
,
Filter
f
)
throws
IOException
{
weight
=
q
.
weight
(
s
)
;
searcher
=
s
;
filter
=
f
;
getMoreDocs
(
50
)
;
}
Hits
(
Searcher
s
,
Query
q
,
Filter
f
,
Sort
o
)
throws
IOException
{
weight
=
q
.
weight
(
s
)
;
searcher
=
s
;
filter
=
f
;
sort
=
o
;
getMoreDocs
(
50
)
;
}
private
final
void
getMoreDocs
(
int
min
)
throws
IOException
{
if
(
hitDocs
.
size
(
)
>
min
)
{
min
=
hitDocs
.
size
(
)
;
}
int
n
=
min
*
2
;
TopDocs
topDocs
=
(
sort
==
null
)
?
searcher
.
search
(
weight
,
filter
,
n
)
:
searcher
.
search
(
weight
,
filter
,
n
,
sort
)
;
length
=
topDocs
.
totalHits
;
ScoreDoc
[
]
scoreDocs
=
topDocs
.
scoreDocs
;
float
scoreNorm
=
1.0f
;
if
(
length
>
0
&&
topDocs
.
getMaxScore
(
)
>
1.0f
)
{
scoreNorm
=
1.0f
/
topDocs
.
getMaxScore
(
)
;
}
int
end
=
scoreDocs
.
length
<
length
?
scoreDocs
.
length
:
length
;
for
(
int
i
=
hitDocs
.
size
(
)
;
i
<
end
;
i
++
)
{
hitDocs
.
addElement
(
new
HitDoc
(
scoreDocs
[
i
]
.
score
*
scoreNorm
,
scoreDocs
[
i
]
.
doc
)
)
;
}
}
public
final
int
length
(
)
{
return
length
;
}
public
final
Document
doc
(
int
n
)
throws
IOException
{
HitDoc
hitDoc
=
hitDoc
(
n
)
;
remove
(
hitDoc
)
;
addToFront
(
hitDoc
)
;
if
(
numDocs
>
maxDocs
)
{
HitDoc
oldLast
=
last
;
remove
(
last
)
;
oldLast
.
doc
=
null
;
}
if
(
hitDoc
.
doc
==
null
)
{
hitDoc
.
doc
=
searcher
.
doc
(
hitDoc
.
id
)
;
}
return
hitDoc
.
doc
;
}
public
final
float
score
(
int
n
)
throws
IOException
{
return
hitDoc
(
n
)
.
score
;
}
public
final
int
id
(
int
n
)
throws
IOException
{
return
hitDoc
(
n
)
.
id
;
}
public
Iterator
iterator
(
)
{
return
new
HitIterator
(
this
)
;
}
private
final
HitDoc
hitDoc
(
int
n
)
throws
IOException
{
if
(
n
>=
length
)
{
throw
new
IndexOutOfBoundsException
(
"Not a valid hit number: "
+
n
)
;
}
if
(
n
>=
hitDocs
.
size
(
)
)
{
getMoreDocs
(
n
)
;
}
return
(
HitDoc
)
hitDocs
.
elementAt
(
n
)
;
}
private
final
void
addToFront
(
HitDoc
hitDoc
)
{
if
(
first
==
null
)
{
last
=
hitDoc
;
}
else
{
first
.
prev
=
hitDoc
;
}
hitDoc
.
next
=
first
;
first
=
hitDoc
;
hitDoc
.
prev
=
null
;
numDocs
++
;
}
private
final
void
remove
(
HitDoc
hitDoc
)
{
if
(
hitDoc
.
doc
==
null
)
{
return
;
}
if
(
hitDoc
.
next
==
null
)
{
last
=
hitDoc
.
prev
;
}
else
{
hitDoc
.
next
.
prev
=
hitDoc
.
prev
;
}
if
(
hitDoc
.
prev
==
null
)
{
first
=
hitDoc
.
next
;
}
else
{
hitDoc
.
prev
.
next
=
hitDoc
.
next
;
}
numDocs
--
;
}
}
final
class
HitDoc
{
float
score
;
int
id
;
Document
doc
=
null
;
HitDoc
next
;
HitDoc
prev
;
HitDoc
(
float
s
,
int
i
)
{
score
=
s
;
id
=
i
;
}
}
