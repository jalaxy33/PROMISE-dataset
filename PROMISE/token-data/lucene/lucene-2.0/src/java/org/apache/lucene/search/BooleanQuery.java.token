package
org
.
apache
.
lucene
.
search
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
util
.
ToStringUtils
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Set
;
import
java
.
util
.
Vector
;
public
class
BooleanQuery
extends
Query
{
private
static
int
maxClauseCount
=
1024
;
public
static
class
TooManyClauses
extends
RuntimeException
{
}
public
static
int
getMaxClauseCount
(
)
{
return
maxClauseCount
;
}
public
static
void
setMaxClauseCount
(
int
maxClauseCount
)
{
if
(
maxClauseCount
<
1
)
throw
new
IllegalArgumentException
(
"maxClauseCount must be >= 1"
)
;
BooleanQuery
.
maxClauseCount
=
maxClauseCount
;
}
private
Vector
clauses
=
new
Vector
(
)
;
private
boolean
disableCoord
;
public
BooleanQuery
(
)
{
}
public
BooleanQuery
(
boolean
disableCoord
)
{
this
.
disableCoord
=
disableCoord
;
}
public
boolean
isCoordDisabled
(
)
{
return
disableCoord
;
}
public
Similarity
getSimilarity
(
Searcher
searcher
)
{
Similarity
result
=
super
.
getSimilarity
(
searcher
)
;
if
(
disableCoord
)
{
result
=
new
SimilarityDelegator
(
result
)
{
public
float
coord
(
int
overlap
,
int
maxOverlap
)
{
return
1.0f
;
}
}
;
}
return
result
;
}
public
void
setMinimumNumberShouldMatch
(
int
min
)
{
this
.
minNrShouldMatch
=
min
;
}
protected
int
minNrShouldMatch
=
0
;
public
int
getMinimumNumberShouldMatch
(
)
{
return
minNrShouldMatch
;
}
public
void
add
(
Query
query
,
BooleanClause
.
Occur
occur
)
{
add
(
new
BooleanClause
(
query
,
occur
)
)
;
}
public
void
add
(
BooleanClause
clause
)
{
if
(
clauses
.
size
(
)
>=
maxClauseCount
)
throw
new
TooManyClauses
(
)
;
clauses
.
addElement
(
clause
)
;
}
public
BooleanClause
[
]
getClauses
(
)
{
return
(
BooleanClause
[
]
)
clauses
.
toArray
(
new
BooleanClause
[
0
]
)
;
}
private
class
BooleanWeight
implements
Weight
{
protected
Similarity
similarity
;
protected
Vector
weights
=
new
Vector
(
)
;
public
BooleanWeight
(
Searcher
searcher
)
throws
IOException
{
this
.
similarity
=
getSimilarity
(
searcher
)
;
for
(
int
i
=
0
;
i
<
clauses
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
elementAt
(
i
)
;
weights
.
add
(
c
.
getQuery
(
)
.
createWeight
(
searcher
)
)
;
}
}
public
Query
getQuery
(
)
{
return
BooleanQuery
.
this
;
}
public
float
getValue
(
)
{
return
getBoost
(
)
;
}
public
float
sumOfSquaredWeights
(
)
throws
IOException
{
float
sum
=
0.0f
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
elementAt
(
i
)
;
Weight
w
=
(
Weight
)
weights
.
elementAt
(
i
)
;
if
(
!
c
.
isProhibited
(
)
)
sum
+=
w
.
sumOfSquaredWeights
(
)
;
}
sum
*=
getBoost
(
)
*
getBoost
(
)
;
return
sum
;
}
public
void
normalize
(
float
norm
)
{
norm
*=
getBoost
(
)
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
elementAt
(
i
)
;
Weight
w
=
(
Weight
)
weights
.
elementAt
(
i
)
;
if
(
!
c
.
isProhibited
(
)
)
w
.
normalize
(
norm
)
;
}
}
public
Scorer
scorer
(
IndexReader
reader
)
throws
IOException
{
boolean
allRequired
=
true
;
boolean
noneBoolean
=
true
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
elementAt
(
i
)
;
if
(
!
c
.
isRequired
(
)
)
allRequired
=
false
;
if
(
c
.
getQuery
(
)
instanceof
BooleanQuery
)
noneBoolean
=
false
;
}
if
(
allRequired
&&
noneBoolean
)
{
ConjunctionScorer
result
=
new
ConjunctionScorer
(
similarity
)
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
Weight
w
=
(
Weight
)
weights
.
elementAt
(
i
)
;
Scorer
subScorer
=
w
.
scorer
(
reader
)
;
if
(
subScorer
==
null
)
return
null
;
result
.
add
(
subScorer
)
;
}
return
result
;
}
BooleanScorer
result
=
new
BooleanScorer
(
similarity
)
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
elementAt
(
i
)
;
Weight
w
=
(
Weight
)
weights
.
elementAt
(
i
)
;
Scorer
subScorer
=
w
.
scorer
(
reader
)
;
if
(
subScorer
!=
null
)
result
.
add
(
subScorer
,
c
.
isRequired
(
)
,
c
.
isProhibited
(
)
)
;
else
if
(
c
.
isRequired
(
)
)
return
null
;
}
return
result
;
}
public
Explanation
explain
(
IndexReader
reader
,
int
doc
)
throws
IOException
{
Explanation
sumExpl
=
new
Explanation
(
)
;
sumExpl
.
setDescription
(
"sum of:"
)
;
int
coord
=
0
;
int
maxCoord
=
0
;
float
sum
=
0.0f
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
elementAt
(
i
)
;
Weight
w
=
(
Weight
)
weights
.
elementAt
(
i
)
;
Explanation
e
=
w
.
explain
(
reader
,
doc
)
;
if
(
!
c
.
isProhibited
(
)
)
maxCoord
++
;
if
(
e
.
getValue
(
)
>
0
)
{
if
(
!
c
.
isProhibited
(
)
)
{
sumExpl
.
addDetail
(
e
)
;
sum
+=
e
.
getValue
(
)
;
coord
++
;
}
else
{
return
new
Explanation
(
0.0f
,
"match prohibited"
)
;
}
}
else
if
(
c
.
isRequired
(
)
)
{
return
new
Explanation
(
0.0f
,
"match required"
)
;
}
}
sumExpl
.
setValue
(
sum
)
;
if
(
coord
==
1
)
sumExpl
=
sumExpl
.
getDetails
(
)
[
0
]
;
float
coordFactor
=
similarity
.
coord
(
coord
,
maxCoord
)
;
if
(
coordFactor
==
1.0f
)
return
sumExpl
;
else
{
Explanation
result
=
new
Explanation
(
)
;
result
.
setDescription
(
"product of:"
)
;
result
.
addDetail
(
sumExpl
)
;
result
.
addDetail
(
new
Explanation
(
coordFactor
,
"coord("
+
coord
+
"/"
+
maxCoord
+
")"
)
)
;
result
.
setValue
(
sum
*
coordFactor
)
;
return
result
;
}
}
}
private
class
BooleanWeight2
extends
BooleanWeight
{
public
BooleanWeight2
(
Searcher
searcher
)
throws
IOException
{
super
(
searcher
)
;
}
public
Scorer
scorer
(
IndexReader
reader
)
throws
IOException
{
BooleanScorer2
result
=
new
BooleanScorer2
(
similarity
,
minNrShouldMatch
)
;
for
(
int
i
=
0
;
i
<
weights
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
elementAt
(
i
)
;
Weight
w
=
(
Weight
)
weights
.
elementAt
(
i
)
;
Scorer
subScorer
=
w
.
scorer
(
reader
)
;
if
(
subScorer
!=
null
)
result
.
add
(
subScorer
,
c
.
isRequired
(
)
,
c
.
isProhibited
(
)
)
;
else
if
(
c
.
isRequired
(
)
)
return
null
;
}
return
result
;
}
}
private
static
boolean
useScorer14
=
false
;
public
static
void
setUseScorer14
(
boolean
use14
)
{
useScorer14
=
use14
;
}
public
static
boolean
getUseScorer14
(
)
{
return
useScorer14
;
}
protected
Weight
createWeight
(
Searcher
searcher
)
throws
IOException
{
if
(
0
<
minNrShouldMatch
)
{
return
new
BooleanWeight2
(
searcher
)
;
}
return
getUseScorer14
(
)
?
(
Weight
)
new
BooleanWeight
(
searcher
)
:
(
Weight
)
new
BooleanWeight2
(
searcher
)
;
}
public
Query
rewrite
(
IndexReader
reader
)
throws
IOException
{
if
(
clauses
.
size
(
)
==
1
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
elementAt
(
0
)
;
if
(
!
c
.
isProhibited
(
)
)
{
Query
query
=
c
.
getQuery
(
)
.
rewrite
(
reader
)
;
if
(
getBoost
(
)
!=
1.0f
)
{
if
(
query
==
c
.
getQuery
(
)
)
query
=
(
Query
)
query
.
clone
(
)
;
query
.
setBoost
(
getBoost
(
)
*
query
.
getBoost
(
)
)
;
}
return
query
;
}
}
BooleanQuery
clone
=
null
;
for
(
int
i
=
0
;
i
<
clauses
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
elementAt
(
i
)
;
Query
query
=
c
.
getQuery
(
)
.
rewrite
(
reader
)
;
if
(
query
!=
c
.
getQuery
(
)
)
{
if
(
clone
==
null
)
clone
=
(
BooleanQuery
)
this
.
clone
(
)
;
clone
.
clauses
.
setElementAt
(
new
BooleanClause
(
query
,
c
.
getOccur
(
)
)
,
i
)
;
}
}
if
(
clone
!=
null
)
{
return
clone
;
}
else
return
this
;
}
public
void
extractTerms
(
Set
terms
)
{
for
(
Iterator
i
=
clauses
.
iterator
(
)
;
i
.
hasNext
(
)
;
)
{
BooleanClause
clause
=
(
BooleanClause
)
i
.
next
(
)
;
clause
.
getQuery
(
)
.
extractTerms
(
terms
)
;
}
}
public
Object
clone
(
)
{
BooleanQuery
clone
=
(
BooleanQuery
)
super
.
clone
(
)
;
clone
.
clauses
=
(
Vector
)
this
.
clauses
.
clone
(
)
;
return
clone
;
}
public
String
toString
(
String
field
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
boolean
needParens
=
(
getBoost
(
)
!=
1.0
)
||
(
getMinimumNumberShouldMatch
(
)
>
0
)
;
if
(
needParens
)
{
buffer
.
append
(
"("
)
;
}
for
(
int
i
=
0
;
i
<
clauses
.
size
(
)
;
i
++
)
{
BooleanClause
c
=
(
BooleanClause
)
clauses
.
elementAt
(
i
)
;
if
(
c
.
isProhibited
(
)
)
buffer
.
append
(
"-"
)
;
else
if
(
c
.
isRequired
(
)
)
buffer
.
append
(
"+"
)
;
Query
subQuery
=
c
.
getQuery
(
)
;
if
(
subQuery
instanceof
BooleanQuery
)
{
buffer
.
append
(
"("
)
;
buffer
.
append
(
c
.
getQuery
(
)
.
toString
(
field
)
)
;
buffer
.
append
(
")"
)
;
}
else
buffer
.
append
(
c
.
getQuery
(
)
.
toString
(
field
)
)
;
if
(
i
!=
clauses
.
size
(
)
-
1
)
buffer
.
append
(
" "
)
;
}
if
(
needParens
)
{
buffer
.
append
(
")"
)
;
}
if
(
getMinimumNumberShouldMatch
(
)
>
0
)
{
buffer
.
append
(
'~'
)
;
buffer
.
append
(
getMinimumNumberShouldMatch
(
)
)
;
}
if
(
getBoost
(
)
!=
1.0f
)
{
buffer
.
append
(
ToStringUtils
.
boost
(
getBoost
(
)
)
)
;
}
return
buffer
.
toString
(
)
;
}
public
boolean
equals
(
Object
o
)
{
if
(
!
(
o
instanceof
BooleanQuery
)
)
return
false
;
BooleanQuery
other
=
(
BooleanQuery
)
o
;
return
(
this
.
getBoost
(
)
==
other
.
getBoost
(
)
)
&&
this
.
clauses
.
equals
(
other
.
clauses
)
&&
this
.
getMinimumNumberShouldMatch
(
)
==
other
.
getMinimumNumberShouldMatch
(
)
;
}
public
int
hashCode
(
)
{
return
Float
.
floatToIntBits
(
getBoost
(
)
)
^
clauses
.
hashCode
(
)
+
getMinimumNumberShouldMatch
(
)
;
}
}
