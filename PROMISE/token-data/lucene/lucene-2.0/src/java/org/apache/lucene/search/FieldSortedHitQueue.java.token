package
org
.
apache
.
lucene
.
search
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
util
.
PriorityQueue
;
import
java
.
io
.
IOException
;
import
java
.
util
.
WeakHashMap
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Map
;
import
java
.
util
.
Locale
;
import
java
.
text
.
Collator
;
public
class
FieldSortedHitQueue
extends
PriorityQueue
{
public
FieldSortedHitQueue
(
IndexReader
reader
,
SortField
[
]
fields
,
int
size
)
throws
IOException
{
final
int
n
=
fields
.
length
;
comparators
=
new
ScoreDocComparator
[
n
]
;
this
.
fields
=
new
SortField
[
n
]
;
for
(
int
i
=
0
;
i
<
n
;
++
i
)
{
String
fieldname
=
fields
[
i
]
.
getField
(
)
;
comparators
[
i
]
=
getCachedComparator
(
reader
,
fieldname
,
fields
[
i
]
.
getType
(
)
,
fields
[
i
]
.
getLocale
(
)
,
fields
[
i
]
.
getFactory
(
)
)
;
if
(
comparators
[
i
]
.
sortType
(
)
==
SortField
.
STRING
)
{
this
.
fields
[
i
]
=
new
SortField
(
fieldname
,
fields
[
i
]
.
getLocale
(
)
,
fields
[
i
]
.
getReverse
(
)
)
;
}
else
{
this
.
fields
[
i
]
=
new
SortField
(
fieldname
,
comparators
[
i
]
.
sortType
(
)
,
fields
[
i
]
.
getReverse
(
)
)
;
}
}
initialize
(
size
)
;
}
protected
ScoreDocComparator
[
]
comparators
;
protected
SortField
[
]
fields
;
protected
float
maxscore
=
Float
.
NEGATIVE_INFINITY
;
public
float
getMaxScore
(
)
{
return
maxscore
;
}
public
boolean
insert
(
FieldDoc
fdoc
)
{
maxscore
=
Math
.
max
(
maxscore
,
fdoc
.
score
)
;
return
super
.
insert
(
fdoc
)
;
}
public
boolean
insert
(
Object
fdoc
)
{
return
insert
(
(
FieldDoc
)
fdoc
)
;
}
protected
boolean
lessThan
(
final
Object
a
,
final
Object
b
)
{
final
ScoreDoc
docA
=
(
ScoreDoc
)
a
;
final
ScoreDoc
docB
=
(
ScoreDoc
)
b
;
final
int
n
=
comparators
.
length
;
int
c
=
0
;
for
(
int
i
=
0
;
i
<
n
&&
c
==
0
;
++
i
)
{
c
=
(
fields
[
i
]
.
reverse
)
?
comparators
[
i
]
.
compare
(
docB
,
docA
)
:
comparators
[
i
]
.
compare
(
docA
,
docB
)
;
}
if
(
c
==
0
)
return
docA
.
doc
>
docB
.
doc
;
return
c
>
0
;
}
FieldDoc
fillFields
(
final
FieldDoc
doc
)
{
final
int
n
=
comparators
.
length
;
final
Comparable
[
]
fields
=
new
Comparable
[
n
]
;
for
(
int
i
=
0
;
i
<
n
;
++
i
)
fields
[
i
]
=
comparators
[
i
]
.
sortValue
(
doc
)
;
doc
.
fields
=
fields
;
return
doc
;
}
SortField
[
]
getFields
(
)
{
return
fields
;
}
static
final
Map
Comparators
=
new
WeakHashMap
(
)
;
static
ScoreDocComparator
lookup
(
IndexReader
reader
,
String
field
,
int
type
,
Locale
locale
,
Object
factory
)
{
FieldCacheImpl
.
Entry
entry
=
(
factory
!=
null
)
?
new
FieldCacheImpl
.
Entry
(
field
,
factory
)
:
new
FieldCacheImpl
.
Entry
(
field
,
type
,
locale
)
;
synchronized
(
Comparators
)
{
HashMap
readerCache
=
(
HashMap
)
Comparators
.
get
(
reader
)
;
if
(
readerCache
==
null
)
return
null
;
return
(
ScoreDocComparator
)
readerCache
.
get
(
entry
)
;
}
}
static
Object
store
(
IndexReader
reader
,
String
field
,
int
type
,
Locale
locale
,
Object
factory
,
Object
value
)
{
FieldCacheImpl
.
Entry
entry
=
(
factory
!=
null
)
?
new
FieldCacheImpl
.
Entry
(
field
,
factory
)
:
new
FieldCacheImpl
.
Entry
(
field
,
type
,
locale
)
;
synchronized
(
Comparators
)
{
HashMap
readerCache
=
(
HashMap
)
Comparators
.
get
(
reader
)
;
if
(
readerCache
==
null
)
{
readerCache
=
new
HashMap
(
)
;
Comparators
.
put
(
reader
,
readerCache
)
;
}
return
readerCache
.
put
(
entry
,
value
)
;
}
}
static
ScoreDocComparator
getCachedComparator
(
IndexReader
reader
,
String
fieldname
,
int
type
,
Locale
locale
,
SortComparatorSource
factory
)
throws
IOException
{
if
(
type
==
SortField
.
DOC
)
return
ScoreDocComparator
.
INDEXORDER
;
if
(
type
==
SortField
.
SCORE
)
return
ScoreDocComparator
.
RELEVANCE
;
ScoreDocComparator
comparator
=
lookup
(
reader
,
fieldname
,
type
,
locale
,
factory
)
;
if
(
comparator
==
null
)
{
switch
(
type
)
{
case
SortField
.
AUTO
:
comparator
=
comparatorAuto
(
reader
,
fieldname
)
;
break
;
case
SortField
.
INT
:
comparator
=
comparatorInt
(
reader
,
fieldname
)
;
break
;
case
SortField
.
FLOAT
:
comparator
=
comparatorFloat
(
reader
,
fieldname
)
;
break
;
case
SortField
.
STRING
:
if
(
locale
!=
null
)
comparator
=
comparatorStringLocale
(
reader
,
fieldname
,
locale
)
;
else
comparator
=
comparatorString
(
reader
,
fieldname
)
;
break
;
case
SortField
.
CUSTOM
:
comparator
=
factory
.
newComparator
(
reader
,
fieldname
)
;
break
;
default
:
throw
new
RuntimeException
(
"unknown field type: "
+
type
)
;
}
store
(
reader
,
fieldname
,
type
,
locale
,
factory
,
comparator
)
;
}
return
comparator
;
}
static
ScoreDocComparator
comparatorInt
(
final
IndexReader
reader
,
final
String
fieldname
)
throws
IOException
{
final
String
field
=
fieldname
.
intern
(
)
;
final
int
[
]
fieldOrder
=
FieldCache
.
DEFAULT
.
getInts
(
reader
,
field
)
;
return
new
ScoreDocComparator
(
)
{
public
final
int
compare
(
final
ScoreDoc
i
,
final
ScoreDoc
j
)
{
final
int
fi
=
fieldOrder
[
i
.
doc
]
;
final
int
fj
=
fieldOrder
[
j
.
doc
]
;
if
(
fi
<
fj
)
return
-
1
;
if
(
fi
>
fj
)
return
1
;
return
0
;
}
public
Comparable
sortValue
(
final
ScoreDoc
i
)
{
return
new
Integer
(
fieldOrder
[
i
.
doc
]
)
;
}
public
int
sortType
(
)
{
return
SortField
.
INT
;
}
}
;
}
static
ScoreDocComparator
comparatorFloat
(
final
IndexReader
reader
,
final
String
fieldname
)
throws
IOException
{
final
String
field
=
fieldname
.
intern
(
)
;
final
float
[
]
fieldOrder
=
FieldCache
.
DEFAULT
.
getFloats
(
reader
,
field
)
;
return
new
ScoreDocComparator
(
)
{
public
final
int
compare
(
final
ScoreDoc
i
,
final
ScoreDoc
j
)
{
final
float
fi
=
fieldOrder
[
i
.
doc
]
;
final
float
fj
=
fieldOrder
[
j
.
doc
]
;
if
(
fi
<
fj
)
return
-
1
;
if
(
fi
>
fj
)
return
1
;
return
0
;
}
public
Comparable
sortValue
(
final
ScoreDoc
i
)
{
return
new
Float
(
fieldOrder
[
i
.
doc
]
)
;
}
public
int
sortType
(
)
{
return
SortField
.
FLOAT
;
}
}
;
}
static
ScoreDocComparator
comparatorString
(
final
IndexReader
reader
,
final
String
fieldname
)
throws
IOException
{
final
String
field
=
fieldname
.
intern
(
)
;
final
FieldCache
.
StringIndex
index
=
FieldCache
.
DEFAULT
.
getStringIndex
(
reader
,
field
)
;
return
new
ScoreDocComparator
(
)
{
public
final
int
compare
(
final
ScoreDoc
i
,
final
ScoreDoc
j
)
{
final
int
fi
=
index
.
order
[
i
.
doc
]
;
final
int
fj
=
index
.
order
[
j
.
doc
]
;
if
(
fi
<
fj
)
return
-
1
;
if
(
fi
>
fj
)
return
1
;
return
0
;
}
public
Comparable
sortValue
(
final
ScoreDoc
i
)
{
return
index
.
lookup
[
index
.
order
[
i
.
doc
]
]
;
}
public
int
sortType
(
)
{
return
SortField
.
STRING
;
}
}
;
}
static
ScoreDocComparator
comparatorStringLocale
(
final
IndexReader
reader
,
final
String
fieldname
,
final
Locale
locale
)
throws
IOException
{
final
Collator
collator
=
Collator
.
getInstance
(
locale
)
;
final
String
field
=
fieldname
.
intern
(
)
;
final
String
[
]
index
=
FieldCache
.
DEFAULT
.
getStrings
(
reader
,
field
)
;
return
new
ScoreDocComparator
(
)
{
public
final
int
compare
(
final
ScoreDoc
i
,
final
ScoreDoc
j
)
{
return
collator
.
compare
(
index
[
i
.
doc
]
,
index
[
j
.
doc
]
)
;
}
public
Comparable
sortValue
(
final
ScoreDoc
i
)
{
return
index
[
i
.
doc
]
;
}
public
int
sortType
(
)
{
return
SortField
.
STRING
;
}
}
;
}
static
ScoreDocComparator
comparatorAuto
(
final
IndexReader
reader
,
final
String
fieldname
)
throws
IOException
{
final
String
field
=
fieldname
.
intern
(
)
;
Object
lookupArray
=
FieldCache
.
DEFAULT
.
getAuto
(
reader
,
field
)
;
if
(
lookupArray
instanceof
FieldCache
.
StringIndex
)
{
return
comparatorString
(
reader
,
field
)
;
}
else
if
(
lookupArray
instanceof
int
[
]
)
{
return
comparatorInt
(
reader
,
field
)
;
}
else
if
(
lookupArray
instanceof
float
[
]
)
{
return
comparatorFloat
(
reader
,
field
)
;
}
else
if
(
lookupArray
instanceof
String
[
]
)
{
return
comparatorString
(
reader
,
field
)
;
}
else
{
throw
new
RuntimeException
(
"unknown data type in field '"
+
field
+
"'"
)
;
}
}
}
