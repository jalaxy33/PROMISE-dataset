package
org
.
apache
.
lucene
.
store
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
RandomAccessFile
;
import
java
.
security
.
MessageDigest
;
import
java
.
security
.
NoSuchAlgorithmException
;
import
java
.
util
.
Hashtable
;
import
org
.
apache
.
lucene
.
index
.
IndexFileNameFilter
;
public
class
FSDirectory
extends
Directory
{
private
static
final
Hashtable
DIRECTORIES
=
new
Hashtable
(
)
;
private
static
boolean
disableLocks
=
false
;
public
static
void
setDisableLocks
(
boolean
doDisableLocks
)
{
FSDirectory
.
disableLocks
=
doDisableLocks
;
}
public
static
boolean
getDisableLocks
(
)
{
return
FSDirectory
.
disableLocks
;
}
public
static
final
String
LOCK_DIR
=
System
.
getProperty
(
"org.apache.lucene.lockDir"
,
System
.
getProperty
(
"java.io.tmpdir"
)
)
;
private
static
Class
IMPL
;
static
{
try
{
String
name
=
System
.
getProperty
(
"org.apache.lucene.FSDirectory.class"
,
FSDirectory
.
class
.
getName
(
)
)
;
IMPL
=
Class
.
forName
(
name
)
;
}
catch
(
ClassNotFoundException
e
)
{
throw
new
RuntimeException
(
"cannot load FSDirectory class: "
+
e
.
toString
(
)
,
e
)
;
}
catch
(
SecurityException
se
)
{
try
{
IMPL
=
Class
.
forName
(
FSDirectory
.
class
.
getName
(
)
)
;
}
catch
(
ClassNotFoundException
e
)
{
throw
new
RuntimeException
(
"cannot load default FSDirectory class: "
+
e
.
toString
(
)
,
e
)
;
}
}
}
private
static
MessageDigest
DIGESTER
;
static
{
try
{
DIGESTER
=
MessageDigest
.
getInstance
(
"MD5"
)
;
}
catch
(
NoSuchAlgorithmException
e
)
{
throw
new
RuntimeException
(
e
.
toString
(
)
,
e
)
;
}
}
private
byte
[
]
buffer
=
null
;
public
static
FSDirectory
getDirectory
(
String
path
,
boolean
create
)
throws
IOException
{
return
getDirectory
(
new
File
(
path
)
,
create
)
;
}
public
static
FSDirectory
getDirectory
(
File
file
,
boolean
create
)
throws
IOException
{
file
=
new
File
(
file
.
getCanonicalPath
(
)
)
;
FSDirectory
dir
;
synchronized
(
DIRECTORIES
)
{
dir
=
(
FSDirectory
)
DIRECTORIES
.
get
(
file
)
;
if
(
dir
==
null
)
{
try
{
dir
=
(
FSDirectory
)
IMPL
.
newInstance
(
)
;
}
catch
(
Exception
e
)
{
throw
new
RuntimeException
(
"cannot load FSDirectory class: "
+
e
.
toString
(
)
,
e
)
;
}
dir
.
init
(
file
,
create
)
;
DIRECTORIES
.
put
(
file
,
dir
)
;
}
else
if
(
create
)
{
dir
.
create
(
)
;
}
}
synchronized
(
dir
)
{
dir
.
refCount
++
;
}
return
dir
;
}
private
File
directory
=
null
;
private
int
refCount
;
private
File
lockDir
;
protected
FSDirectory
(
)
{
}
;
private
void
init
(
File
path
,
boolean
create
)
throws
IOException
{
directory
=
path
;
if
(
LOCK_DIR
==
null
)
{
lockDir
=
directory
;
}
else
{
lockDir
=
new
File
(
LOCK_DIR
)
;
}
if
(
!
lockDir
.
exists
(
)
)
{
if
(
!
lockDir
.
mkdirs
(
)
)
throw
new
IOException
(
"Cannot create directory: "
+
lockDir
.
getAbsolutePath
(
)
)
;
}
else
if
(
!
lockDir
.
isDirectory
(
)
)
{
throw
new
IOException
(
"Found regular file where directory expected: "
+
lockDir
.
getAbsolutePath
(
)
)
;
}
if
(
create
)
{
create
(
)
;
}
if
(
!
directory
.
isDirectory
(
)
)
throw
new
IOException
(
path
+
" not a directory"
)
;
}
private
synchronized
void
create
(
)
throws
IOException
{
if
(
!
directory
.
exists
(
)
)
if
(
!
directory
.
mkdirs
(
)
)
throw
new
IOException
(
"Cannot create directory: "
+
directory
)
;
if
(
!
directory
.
isDirectory
(
)
)
throw
new
IOException
(
directory
+
" not a directory"
)
;
String
[
]
files
=
directory
.
list
(
new
IndexFileNameFilter
(
)
)
;
if
(
files
==
null
)
throw
new
IOException
(
"Cannot read directory "
+
directory
.
getAbsolutePath
(
)
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
File
file
=
new
File
(
directory
,
files
[
i
]
)
;
if
(
!
file
.
delete
(
)
)
throw
new
IOException
(
"Cannot delete "
+
file
)
;
}
String
lockPrefix
=
getLockPrefix
(
)
.
toString
(
)
;
files
=
lockDir
.
list
(
)
;
if
(
files
==
null
)
throw
new
IOException
(
"Cannot read lock directory "
+
lockDir
.
getAbsolutePath
(
)
)
;
for
(
int
i
=
0
;
i
<
files
.
length
;
i
++
)
{
if
(
!
files
[
i
]
.
startsWith
(
lockPrefix
)
)
continue
;
File
lockFile
=
new
File
(
lockDir
,
files
[
i
]
)
;
if
(
!
lockFile
.
delete
(
)
)
throw
new
IOException
(
"Cannot delete "
+
lockFile
)
;
}
}
public
String
[
]
list
(
)
{
return
directory
.
list
(
)
;
}
public
boolean
fileExists
(
String
name
)
{
File
file
=
new
File
(
directory
,
name
)
;
return
file
.
exists
(
)
;
}
public
long
fileModified
(
String
name
)
{
File
file
=
new
File
(
directory
,
name
)
;
return
file
.
lastModified
(
)
;
}
public
static
long
fileModified
(
File
directory
,
String
name
)
{
File
file
=
new
File
(
directory
,
name
)
;
return
file
.
lastModified
(
)
;
}
public
void
touchFile
(
String
name
)
{
File
file
=
new
File
(
directory
,
name
)
;
file
.
setLastModified
(
System
.
currentTimeMillis
(
)
)
;
}
public
long
fileLength
(
String
name
)
{
File
file
=
new
File
(
directory
,
name
)
;
return
file
.
length
(
)
;
}
public
void
deleteFile
(
String
name
)
throws
IOException
{
File
file
=
new
File
(
directory
,
name
)
;
if
(
!
file
.
delete
(
)
)
throw
new
IOException
(
"Cannot delete "
+
file
)
;
}
public
synchronized
void
renameFile
(
String
from
,
String
to
)
throws
IOException
{
File
old
=
new
File
(
directory
,
from
)
;
File
nu
=
new
File
(
directory
,
to
)
;
if
(
nu
.
exists
(
)
)
if
(
!
nu
.
delete
(
)
)
throw
new
IOException
(
"Cannot delete "
+
nu
)
;
if
(
!
old
.
renameTo
(
nu
)
)
{
java
.
io
.
InputStream
in
=
null
;
java
.
io
.
OutputStream
out
=
null
;
try
{
in
=
new
FileInputStream
(
old
)
;
out
=
new
FileOutputStream
(
nu
)
;
if
(
buffer
==
null
)
{
buffer
=
new
byte
[
1024
]
;
}
int
len
;
while
(
(
len
=
in
.
read
(
buffer
)
)
>=
0
)
{
out
.
write
(
buffer
,
0
,
len
)
;
}
old
.
delete
(
)
;
}
catch
(
IOException
ioe
)
{
IOException
newExc
=
new
IOException
(
"Cannot rename "
+
old
+
" to "
+
nu
)
;
newExc
.
initCause
(
ioe
)
;
throw
newExc
;
}
finally
{
if
(
in
!=
null
)
{
try
{
in
.
close
(
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
"Cannot close input stream: "
+
e
.
toString
(
)
,
e
)
;
}
}
if
(
out
!=
null
)
{
try
{
out
.
close
(
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
"Cannot close output stream: "
+
e
.
toString
(
)
,
e
)
;
}
}
}
}
}
public
IndexOutput
createOutput
(
String
name
)
throws
IOException
{
File
file
=
new
File
(
directory
,
name
)
;
if
(
file
.
exists
(
)
&&
!
file
.
delete
(
)
)
throw
new
IOException
(
"Cannot overwrite: "
+
file
)
;
return
new
FSIndexOutput
(
file
)
;
}
public
IndexInput
openInput
(
String
name
)
throws
IOException
{
return
new
FSIndexInput
(
new
File
(
directory
,
name
)
)
;
}
private
static
final
char
[
]
HEX_DIGITS
=
{
'0'
,
'1'
,
'2'
,
'3'
,
'4'
,
'5'
,
'6'
,
'7'
,
'8'
,
'9'
,
'a'
,
'b'
,
'c'
,
'd'
,
'e'
,
'f'
}
;
public
Lock
makeLock
(
String
name
)
{
StringBuffer
buf
=
getLockPrefix
(
)
;
buf
.
append
(
"-"
)
;
buf
.
append
(
name
)
;
final
File
lockFile
=
new
File
(
lockDir
,
buf
.
toString
(
)
)
;
return
new
Lock
(
)
{
public
boolean
obtain
(
)
throws
IOException
{
if
(
disableLocks
)
return
true
;
if
(
!
lockDir
.
exists
(
)
)
{
if
(
!
lockDir
.
mkdirs
(
)
)
{
throw
new
IOException
(
"Cannot create lock directory: "
+
lockDir
)
;
}
}
return
lockFile
.
createNewFile
(
)
;
}
public
void
release
(
)
{
if
(
disableLocks
)
return
;
lockFile
.
delete
(
)
;
}
public
boolean
isLocked
(
)
{
if
(
disableLocks
)
return
false
;
return
lockFile
.
exists
(
)
;
}
public
String
toString
(
)
{
return
"Lock@"
+
lockFile
;
}
}
;
}
private
StringBuffer
getLockPrefix
(
)
{
String
dirName
;
try
{
dirName
=
directory
.
getCanonicalPath
(
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
e
.
toString
(
)
,
e
)
;
}
byte
digest
[
]
;
synchronized
(
DIGESTER
)
{
digest
=
DIGESTER
.
digest
(
dirName
.
getBytes
(
)
)
;
}
StringBuffer
buf
=
new
StringBuffer
(
)
;
buf
.
append
(
"lucene-"
)
;
for
(
int
i
=
0
;
i
<
digest
.
length
;
i
++
)
{
int
b
=
digest
[
i
]
;
buf
.
append
(
HEX_DIGITS
[
(
b
>
>
4
)
&
0xf
]
)
;
buf
.
append
(
HEX_DIGITS
[
b
&
0xf
]
)
;
}
return
buf
;
}
public
synchronized
void
close
(
)
{
if
(
--
refCount
<=
0
)
{
synchronized
(
DIRECTORIES
)
{
DIRECTORIES
.
remove
(
directory
)
;
}
}
}
public
File
getFile
(
)
{
return
directory
;
}
public
String
toString
(
)
{
return
this
.
getClass
(
)
.
getName
(
)
+
"@"
+
directory
;
}
}
class
FSIndexInput
extends
BufferedIndexInput
{
private
class
Descriptor
extends
RandomAccessFile
{
public
long
position
;
public
Descriptor
(
File
file
,
String
mode
)
throws
IOException
{
super
(
file
,
mode
)
;
}
}
private
Descriptor
file
=
null
;
boolean
isClone
;
private
long
length
;
public
FSIndexInput
(
File
path
)
throws
IOException
{
file
=
new
Descriptor
(
path
,
"r"
)
;
length
=
file
.
length
(
)
;
}
protected
void
readInternal
(
byte
[
]
b
,
int
offset
,
int
len
)
throws
IOException
{
synchronized
(
file
)
{
long
position
=
getFilePointer
(
)
;
if
(
position
!=
file
.
position
)
{
file
.
seek
(
position
)
;
file
.
position
=
position
;
}
int
total
=
0
;
do
{
int
i
=
file
.
read
(
b
,
offset
+
total
,
len
-
total
)
;
if
(
i
==
-
1
)
throw
new
IOException
(
"read past EOF"
)
;
file
.
position
+=
i
;
total
+=
i
;
}
while
(
total
<
len
)
;
}
}
public
void
close
(
)
throws
IOException
{
if
(
!
isClone
)
file
.
close
(
)
;
}
protected
void
seekInternal
(
long
position
)
{
}
public
long
length
(
)
{
return
length
;
}
protected
void
finalize
(
)
throws
IOException
{
close
(
)
;
}
public
Object
clone
(
)
{
FSIndexInput
clone
=
(
FSIndexInput
)
super
.
clone
(
)
;
clone
.
isClone
=
true
;
return
clone
;
}
boolean
isFDValid
(
)
throws
IOException
{
return
file
.
getFD
(
)
.
valid
(
)
;
}
}
class
FSIndexOutput
extends
BufferedIndexOutput
{
RandomAccessFile
file
=
null
;
public
FSIndexOutput
(
File
path
)
throws
IOException
{
file
=
new
RandomAccessFile
(
path
,
"rw"
)
;
}
public
void
flushBuffer
(
byte
[
]
b
,
int
size
)
throws
IOException
{
file
.
write
(
b
,
0
,
size
)
;
}
public
void
close
(
)
throws
IOException
{
super
.
close
(
)
;
file
.
close
(
)
;
}
public
void
seek
(
long
pos
)
throws
IOException
{
super
.
seek
(
pos
)
;
file
.
seek
(
pos
)
;
}
public
long
length
(
)
throws
IOException
{
return
file
.
length
(
)
;
}
protected
void
finalize
(
)
throws
IOException
{
file
.
close
(
)
;
}
}
