package
org
.
apache
.
lucene
.
search
;
import
java
.
util
.
List
;
import
java
.
util
.
Iterator
;
import
java
.
io
.
IOException
;
import
org
.
apache
.
lucene
.
util
.
PriorityQueue
;
class
DisjunctionSumScorer
extends
Scorer
{
private
final
int
nrScorers
;
protected
final
List
subScorers
;
private
final
int
minimumNrMatchers
;
private
ScorerQueue
scorerQueue
=
null
;
private
int
currentDoc
=
-
1
;
protected
int
nrMatchers
=
-
1
;
private
float
currentScore
=
Float
.
NaN
;
public
DisjunctionSumScorer
(
List
subScorers
,
int
minimumNrMatchers
)
{
super
(
null
)
;
nrScorers
=
subScorers
.
size
(
)
;
if
(
minimumNrMatchers
<=
0
)
{
throw
new
IllegalArgumentException
(
"Minimum nr of matchers must be positive"
)
;
}
if
(
nrScorers
<=
1
)
{
throw
new
IllegalArgumentException
(
"There must be at least 2 subScorers"
)
;
}
this
.
minimumNrMatchers
=
minimumNrMatchers
;
this
.
subScorers
=
subScorers
;
}
public
DisjunctionSumScorer
(
List
subScorers
)
{
this
(
subScorers
,
1
)
;
}
private
void
initScorerQueue
(
)
throws
IOException
{
Iterator
si
=
subScorers
.
iterator
(
)
;
scorerQueue
=
new
ScorerQueue
(
nrScorers
)
;
while
(
si
.
hasNext
(
)
)
{
Scorer
se
=
(
Scorer
)
si
.
next
(
)
;
if
(
se
.
next
(
)
)
{
scorerQueue
.
insert
(
se
)
;
}
}
}
private
class
ScorerQueue
extends
PriorityQueue
{
ScorerQueue
(
int
size
)
{
initialize
(
size
)
;
}
protected
boolean
lessThan
(
Object
o1
,
Object
o2
)
{
return
(
(
Scorer
)
o1
)
.
doc
(
)
<
(
(
Scorer
)
o2
)
.
doc
(
)
;
}
}
public
boolean
next
(
)
throws
IOException
{
if
(
scorerQueue
==
null
)
{
initScorerQueue
(
)
;
}
if
(
scorerQueue
.
size
(
)
<
minimumNrMatchers
)
{
return
false
;
}
else
{
return
advanceAfterCurrent
(
)
;
}
}
protected
boolean
advanceAfterCurrent
(
)
throws
IOException
{
do
{
Scorer
top
=
(
Scorer
)
scorerQueue
.
top
(
)
;
currentDoc
=
top
.
doc
(
)
;
currentScore
=
top
.
score
(
)
;
nrMatchers
=
1
;
do
{
if
(
top
.
next
(
)
)
{
scorerQueue
.
adjustTop
(
)
;
}
else
{
scorerQueue
.
pop
(
)
;
if
(
scorerQueue
.
size
(
)
<
(
minimumNrMatchers
-
nrMatchers
)
)
{
return
false
;
}
if
(
scorerQueue
.
size
(
)
==
0
)
{
break
;
}
}
top
=
(
Scorer
)
scorerQueue
.
top
(
)
;
if
(
top
.
doc
(
)
!=
currentDoc
)
{
break
;
}
else
{
currentScore
+=
top
.
score
(
)
;
nrMatchers
++
;
}
}
while
(
true
)
;
if
(
nrMatchers
>=
minimumNrMatchers
)
{
return
true
;
}
else
if
(
scorerQueue
.
size
(
)
<
minimumNrMatchers
)
{
return
false
;
}
}
while
(
true
)
;
}
public
float
score
(
)
throws
IOException
{
return
currentScore
;
}
public
int
doc
(
)
{
return
currentDoc
;
}
public
int
nrMatchers
(
)
{
return
nrMatchers
;
}
public
boolean
skipTo
(
int
target
)
throws
IOException
{
if
(
scorerQueue
==
null
)
{
initScorerQueue
(
)
;
}
if
(
scorerQueue
.
size
(
)
<
minimumNrMatchers
)
{
return
false
;
}
if
(
target
<=
currentDoc
)
{
return
true
;
}
do
{
Scorer
top
=
(
Scorer
)
scorerQueue
.
top
(
)
;
if
(
top
.
doc
(
)
>=
target
)
{
return
advanceAfterCurrent
(
)
;
}
else
if
(
top
.
skipTo
(
target
)
)
{
scorerQueue
.
adjustTop
(
)
;
}
else
{
scorerQueue
.
pop
(
)
;
if
(
scorerQueue
.
size
(
)
<
minimumNrMatchers
)
{
return
false
;
}
}
}
while
(
true
)
;
}
public
Explanation
explain
(
int
doc
)
throws
IOException
{
Explanation
res
=
new
Explanation
(
)
;
res
.
setDescription
(
"At least "
+
minimumNrMatchers
+
" of"
)
;
Iterator
ssi
=
subScorers
.
iterator
(
)
;
while
(
ssi
.
hasNext
(
)
)
{
res
.
addDetail
(
(
(
Scorer
)
ssi
.
next
(
)
)
.
explain
(
doc
)
)
;
}
return
res
;
}
}
