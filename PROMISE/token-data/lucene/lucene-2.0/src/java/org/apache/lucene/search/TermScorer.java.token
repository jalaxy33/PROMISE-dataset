package
org
.
apache
.
lucene
.
search
;
import
java
.
io
.
IOException
;
import
org
.
apache
.
lucene
.
index
.
TermDocs
;
final
class
TermScorer
extends
Scorer
{
private
Weight
weight
;
private
TermDocs
termDocs
;
private
byte
[
]
norms
;
private
float
weightValue
;
private
int
doc
;
private
final
int
[
]
docs
=
new
int
[
32
]
;
private
final
int
[
]
freqs
=
new
int
[
32
]
;
private
int
pointer
;
private
int
pointerMax
;
private
static
final
int
SCORE_CACHE_SIZE
=
32
;
private
float
[
]
scoreCache
=
new
float
[
SCORE_CACHE_SIZE
]
;
TermScorer
(
Weight
weight
,
TermDocs
td
,
Similarity
similarity
,
byte
[
]
norms
)
{
super
(
similarity
)
;
this
.
weight
=
weight
;
this
.
termDocs
=
td
;
this
.
norms
=
norms
;
this
.
weightValue
=
weight
.
getValue
(
)
;
for
(
int
i
=
0
;
i
<
SCORE_CACHE_SIZE
;
i
++
)
scoreCache
[
i
]
=
getSimilarity
(
)
.
tf
(
i
)
*
weightValue
;
}
public
void
score
(
HitCollector
hc
)
throws
IOException
{
next
(
)
;
score
(
hc
,
Integer
.
MAX_VALUE
)
;
}
protected
boolean
score
(
HitCollector
c
,
int
end
)
throws
IOException
{
Similarity
similarity
=
getSimilarity
(
)
;
float
[
]
normDecoder
=
Similarity
.
getNormDecoder
(
)
;
while
(
doc
<
end
)
{
int
f
=
freqs
[
pointer
]
;
float
score
=
f
<
SCORE_CACHE_SIZE
?
scoreCache
[
f
]
:
similarity
.
tf
(
f
)
*
weightValue
;
score
*=
normDecoder
[
norms
[
doc
]
&
0xFF
]
;
c
.
collect
(
doc
,
score
)
;
if
(
++
pointer
>=
pointerMax
)
{
pointerMax
=
termDocs
.
read
(
docs
,
freqs
)
;
if
(
pointerMax
!=
0
)
{
pointer
=
0
;
}
else
{
termDocs
.
close
(
)
;
doc
=
Integer
.
MAX_VALUE
;
return
false
;
}
}
doc
=
docs
[
pointer
]
;
}
return
true
;
}
public
int
doc
(
)
{
return
doc
;
}
public
boolean
next
(
)
throws
IOException
{
pointer
++
;
if
(
pointer
>=
pointerMax
)
{
pointerMax
=
termDocs
.
read
(
docs
,
freqs
)
;
if
(
pointerMax
!=
0
)
{
pointer
=
0
;
}
else
{
termDocs
.
close
(
)
;
doc
=
Integer
.
MAX_VALUE
;
return
false
;
}
}
doc
=
docs
[
pointer
]
;
return
true
;
}
public
float
score
(
)
{
int
f
=
freqs
[
pointer
]
;
float
raw
=
f
<
SCORE_CACHE_SIZE
?
scoreCache
[
f
]
:
getSimilarity
(
)
.
tf
(
f
)
*
weightValue
;
return
raw
*
Similarity
.
decodeNorm
(
norms
[
doc
]
)
;
}
public
boolean
skipTo
(
int
target
)
throws
IOException
{
for
(
pointer
++
;
pointer
<
pointerMax
;
pointer
++
)
{
if
(
docs
[
pointer
]
>=
target
)
{
doc
=
docs
[
pointer
]
;
return
true
;
}
}
boolean
result
=
termDocs
.
skipTo
(
target
)
;
if
(
result
)
{
pointerMax
=
1
;
pointer
=
0
;
docs
[
pointer
]
=
doc
=
termDocs
.
doc
(
)
;
freqs
[
pointer
]
=
termDocs
.
freq
(
)
;
}
else
{
doc
=
Integer
.
MAX_VALUE
;
}
return
result
;
}
public
Explanation
explain
(
int
doc
)
throws
IOException
{
TermQuery
query
=
(
TermQuery
)
weight
.
getQuery
(
)
;
Explanation
tfExplanation
=
new
Explanation
(
)
;
int
tf
=
0
;
while
(
pointer
<
pointerMax
)
{
if
(
docs
[
pointer
]
==
doc
)
tf
=
freqs
[
pointer
]
;
pointer
++
;
}
if
(
tf
==
0
)
{
while
(
termDocs
.
next
(
)
)
{
if
(
termDocs
.
doc
(
)
==
doc
)
{
tf
=
termDocs
.
freq
(
)
;
}
}
}
termDocs
.
close
(
)
;
tfExplanation
.
setValue
(
getSimilarity
(
)
.
tf
(
tf
)
)
;
tfExplanation
.
setDescription
(
"tf(termFreq("
+
query
.
getTerm
(
)
+
")="
+
tf
+
")"
)
;
return
tfExplanation
;
}
public
String
toString
(
)
{
return
"scorer("
+
weight
+
")"
;
}
}
