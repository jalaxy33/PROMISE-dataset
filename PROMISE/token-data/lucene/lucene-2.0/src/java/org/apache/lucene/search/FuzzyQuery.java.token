package
org
.
apache
.
lucene
.
search
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
index
.
Term
;
import
org
.
apache
.
lucene
.
util
.
PriorityQueue
;
import
org
.
apache
.
lucene
.
util
.
ToStringUtils
;
import
java
.
io
.
IOException
;
public
final
class
FuzzyQuery
extends
MultiTermQuery
{
public
final
static
float
defaultMinSimilarity
=
0.5f
;
public
final
static
int
defaultPrefixLength
=
0
;
private
float
minimumSimilarity
;
private
int
prefixLength
;
public
FuzzyQuery
(
Term
term
,
float
minimumSimilarity
,
int
prefixLength
)
throws
IllegalArgumentException
{
super
(
term
)
;
if
(
minimumSimilarity
>=
1.0f
)
throw
new
IllegalArgumentException
(
"minimumSimilarity >= 1"
)
;
else
if
(
minimumSimilarity
<
0.0f
)
throw
new
IllegalArgumentException
(
"minimumSimilarity < 0"
)
;
if
(
prefixLength
<
0
)
throw
new
IllegalArgumentException
(
"prefixLength < 0"
)
;
this
.
minimumSimilarity
=
minimumSimilarity
;
this
.
prefixLength
=
prefixLength
;
}
public
FuzzyQuery
(
Term
term
,
float
minimumSimilarity
)
throws
IllegalArgumentException
{
this
(
term
,
minimumSimilarity
,
defaultPrefixLength
)
;
}
public
FuzzyQuery
(
Term
term
)
{
this
(
term
,
defaultMinSimilarity
,
defaultPrefixLength
)
;
}
public
float
getMinSimilarity
(
)
{
return
minimumSimilarity
;
}
public
int
getPrefixLength
(
)
{
return
prefixLength
;
}
protected
FilteredTermEnum
getEnum
(
IndexReader
reader
)
throws
IOException
{
return
new
FuzzyTermEnum
(
reader
,
getTerm
(
)
,
minimumSimilarity
,
prefixLength
)
;
}
public
Query
rewrite
(
IndexReader
reader
)
throws
IOException
{
FilteredTermEnum
enumerator
=
getEnum
(
reader
)
;
int
maxClauseCount
=
BooleanQuery
.
getMaxClauseCount
(
)
;
ScoreTermQueue
stQueue
=
new
ScoreTermQueue
(
maxClauseCount
)
;
try
{
do
{
float
minScore
=
0.0f
;
float
score
=
0.0f
;
Term
t
=
enumerator
.
term
(
)
;
if
(
t
!=
null
)
{
score
=
enumerator
.
difference
(
)
;
if
(
stQueue
.
size
(
)
<
maxClauseCount
||
score
>
minScore
)
{
stQueue
.
insert
(
new
ScoreTerm
(
t
,
score
)
)
;
minScore
=
(
(
ScoreTerm
)
stQueue
.
top
(
)
)
.
score
;
}
}
}
while
(
enumerator
.
next
(
)
)
;
}
finally
{
enumerator
.
close
(
)
;
}
BooleanQuery
query
=
new
BooleanQuery
(
true
)
;
int
size
=
stQueue
.
size
(
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
ScoreTerm
st
=
(
ScoreTerm
)
stQueue
.
pop
(
)
;
TermQuery
tq
=
new
TermQuery
(
st
.
term
)
;
tq
.
setBoost
(
getBoost
(
)
*
st
.
score
)
;
query
.
add
(
tq
,
BooleanClause
.
Occur
.
SHOULD
)
;
}
return
query
;
}
public
String
toString
(
String
field
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
Term
term
=
getTerm
(
)
;
if
(
!
term
.
field
(
)
.
equals
(
field
)
)
{
buffer
.
append
(
term
.
field
(
)
)
;
buffer
.
append
(
":"
)
;
}
buffer
.
append
(
term
.
text
(
)
)
;
buffer
.
append
(
'~'
)
;
buffer
.
append
(
Float
.
toString
(
minimumSimilarity
)
)
;
buffer
.
append
(
ToStringUtils
.
boost
(
getBoost
(
)
)
)
;
return
buffer
.
toString
(
)
;
}
private
static
class
ScoreTerm
{
public
Term
term
;
public
float
score
;
public
ScoreTerm
(
Term
term
,
float
score
)
{
this
.
term
=
term
;
this
.
score
=
score
;
}
}
private
static
class
ScoreTermQueue
extends
PriorityQueue
{
public
ScoreTermQueue
(
int
size
)
{
initialize
(
size
)
;
}
protected
boolean
lessThan
(
Object
a
,
Object
b
)
{
ScoreTerm
termA
=
(
ScoreTerm
)
a
;
ScoreTerm
termB
=
(
ScoreTerm
)
b
;
if
(
termA
.
score
==
termB
.
score
)
return
termA
.
term
.
compareTo
(
termB
.
term
)
>
0
;
else
return
termA
.
score
<
termB
.
score
;
}
}
public
boolean
equals
(
Object
o
)
{
if
(
this
==
o
)
return
true
;
if
(
!
(
o
instanceof
FuzzyQuery
)
)
return
false
;
if
(
!
super
.
equals
(
o
)
)
return
false
;
final
FuzzyQuery
fuzzyQuery
=
(
FuzzyQuery
)
o
;
if
(
minimumSimilarity
!=
fuzzyQuery
.
minimumSimilarity
)
return
false
;
if
(
prefixLength
!=
fuzzyQuery
.
prefixLength
)
return
false
;
return
true
;
}
public
int
hashCode
(
)
{
int
result
=
super
.
hashCode
(
)
;
result
=
29
*
result
+
minimumSimilarity
!=
+
0.0f
?
Float
.
floatToIntBits
(
minimumSimilarity
)
:
0
;
result
=
29
*
result
+
prefixLength
;
return
result
;
}
}
