package
org
.
apache
.
lucene
.
search
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Set
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
lucene
.
index
.
Term
;
import
org
.
apache
.
lucene
.
index
.
TermPositions
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
util
.
ToStringUtils
;
public
class
PhraseQuery
extends
Query
{
private
String
field
;
private
Vector
terms
=
new
Vector
(
)
;
private
Vector
positions
=
new
Vector
(
)
;
private
int
slop
=
0
;
public
PhraseQuery
(
)
{
}
public
void
setSlop
(
int
s
)
{
slop
=
s
;
}
public
int
getSlop
(
)
{
return
slop
;
}
public
void
add
(
Term
term
)
{
int
position
=
0
;
if
(
positions
.
size
(
)
>
0
)
position
=
(
(
Integer
)
positions
.
lastElement
(
)
)
.
intValue
(
)
+
1
;
add
(
term
,
position
)
;
}
public
void
add
(
Term
term
,
int
position
)
{
if
(
terms
.
size
(
)
==
0
)
field
=
term
.
field
(
)
;
else
if
(
term
.
field
(
)
!=
field
)
throw
new
IllegalArgumentException
(
"All phrase terms must be in the same field: "
+
term
)
;
terms
.
addElement
(
term
)
;
positions
.
addElement
(
new
Integer
(
position
)
)
;
}
public
Term
[
]
getTerms
(
)
{
return
(
Term
[
]
)
terms
.
toArray
(
new
Term
[
0
]
)
;
}
public
int
[
]
getPositions
(
)
{
int
[
]
result
=
new
int
[
positions
.
size
(
)
]
;
for
(
int
i
=
0
;
i
<
positions
.
size
(
)
;
i
++
)
result
[
i
]
=
(
(
Integer
)
positions
.
elementAt
(
i
)
)
.
intValue
(
)
;
return
result
;
}
private
class
PhraseWeight
implements
Weight
{
private
Similarity
similarity
;
private
float
value
;
private
float
idf
;
private
float
queryNorm
;
private
float
queryWeight
;
public
PhraseWeight
(
Searcher
searcher
)
throws
IOException
{
this
.
similarity
=
getSimilarity
(
searcher
)
;
idf
=
similarity
.
idf
(
terms
,
searcher
)
;
}
public
String
toString
(
)
{
return
"weight("
+
PhraseQuery
.
this
+
")"
;
}
public
Query
getQuery
(
)
{
return
PhraseQuery
.
this
;
}
public
float
getValue
(
)
{
return
value
;
}
public
float
sumOfSquaredWeights
(
)
{
queryWeight
=
idf
*
getBoost
(
)
;
return
queryWeight
*
queryWeight
;
}
public
void
normalize
(
float
queryNorm
)
{
this
.
queryNorm
=
queryNorm
;
queryWeight
*=
queryNorm
;
value
=
queryWeight
*
idf
;
}
public
Scorer
scorer
(
IndexReader
reader
)
throws
IOException
{
if
(
terms
.
size
(
)
==
0
)
return
null
;
TermPositions
[
]
tps
=
new
TermPositions
[
terms
.
size
(
)
]
;
for
(
int
i
=
0
;
i
<
terms
.
size
(
)
;
i
++
)
{
TermPositions
p
=
reader
.
termPositions
(
(
Term
)
terms
.
elementAt
(
i
)
)
;
if
(
p
==
null
)
return
null
;
tps
[
i
]
=
p
;
}
if
(
slop
==
0
)
return
new
ExactPhraseScorer
(
this
,
tps
,
getPositions
(
)
,
similarity
,
reader
.
norms
(
field
)
)
;
else
return
new
SloppyPhraseScorer
(
this
,
tps
,
getPositions
(
)
,
similarity
,
slop
,
reader
.
norms
(
field
)
)
;
}
public
Explanation
explain
(
IndexReader
reader
,
int
doc
)
throws
IOException
{
Explanation
result
=
new
Explanation
(
)
;
result
.
setDescription
(
"weight("
+
getQuery
(
)
+
" in "
+
doc
+
"), product of:"
)
;
StringBuffer
docFreqs
=
new
StringBuffer
(
)
;
StringBuffer
query
=
new
StringBuffer
(
)
;
query
.
append
(
'\"'
)
;
for
(
int
i
=
0
;
i
<
terms
.
size
(
)
;
i
++
)
{
if
(
i
!=
0
)
{
docFreqs
.
append
(
" "
)
;
query
.
append
(
" "
)
;
}
Term
term
=
(
Term
)
terms
.
elementAt
(
i
)
;
docFreqs
.
append
(
term
.
text
(
)
)
;
docFreqs
.
append
(
"="
)
;
docFreqs
.
append
(
reader
.
docFreq
(
term
)
)
;
query
.
append
(
term
.
text
(
)
)
;
}
query
.
append
(
'\"'
)
;
Explanation
idfExpl
=
new
Explanation
(
idf
,
"idf("
+
field
+
": "
+
docFreqs
+
")"
)
;
Explanation
queryExpl
=
new
Explanation
(
)
;
queryExpl
.
setDescription
(
"queryWeight("
+
getQuery
(
)
+
"), product of:"
)
;
Explanation
boostExpl
=
new
Explanation
(
getBoost
(
)
,
"boost"
)
;
if
(
getBoost
(
)
!=
1.0f
)
queryExpl
.
addDetail
(
boostExpl
)
;
queryExpl
.
addDetail
(
idfExpl
)
;
Explanation
queryNormExpl
=
new
Explanation
(
queryNorm
,
"queryNorm"
)
;
queryExpl
.
addDetail
(
queryNormExpl
)
;
queryExpl
.
setValue
(
boostExpl
.
getValue
(
)
*
idfExpl
.
getValue
(
)
*
queryNormExpl
.
getValue
(
)
)
;
result
.
addDetail
(
queryExpl
)
;
Explanation
fieldExpl
=
new
Explanation
(
)
;
fieldExpl
.
setDescription
(
"fieldWeight("
+
field
+
":"
+
query
+
" in "
+
doc
+
"), product of:"
)
;
Explanation
tfExpl
=
scorer
(
reader
)
.
explain
(
doc
)
;
fieldExpl
.
addDetail
(
tfExpl
)
;
fieldExpl
.
addDetail
(
idfExpl
)
;
Explanation
fieldNormExpl
=
new
Explanation
(
)
;
byte
[
]
fieldNorms
=
reader
.
norms
(
field
)
;
float
fieldNorm
=
fieldNorms
!=
null
?
Similarity
.
decodeNorm
(
fieldNorms
[
doc
]
)
:
0.0f
;
fieldNormExpl
.
setValue
(
fieldNorm
)
;
fieldNormExpl
.
setDescription
(
"fieldNorm(field="
+
field
+
", doc="
+
doc
+
")"
)
;
fieldExpl
.
addDetail
(
fieldNormExpl
)
;
fieldExpl
.
setValue
(
tfExpl
.
getValue
(
)
*
idfExpl
.
getValue
(
)
*
fieldNormExpl
.
getValue
(
)
)
;
result
.
addDetail
(
fieldExpl
)
;
result
.
setValue
(
queryExpl
.
getValue
(
)
*
fieldExpl
.
getValue
(
)
)
;
if
(
queryExpl
.
getValue
(
)
==
1.0f
)
return
fieldExpl
;
return
result
;
}
}
protected
Weight
createWeight
(
Searcher
searcher
)
throws
IOException
{
if
(
terms
.
size
(
)
==
1
)
{
Term
term
=
(
Term
)
terms
.
elementAt
(
0
)
;
Query
termQuery
=
new
TermQuery
(
term
)
;
termQuery
.
setBoost
(
getBoost
(
)
)
;
return
termQuery
.
createWeight
(
searcher
)
;
}
return
new
PhraseWeight
(
searcher
)
;
}
public
void
extractTerms
(
Set
queryTerms
)
{
queryTerms
.
addAll
(
terms
)
;
}
public
String
toString
(
String
f
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
if
(
!
field
.
equals
(
f
)
)
{
buffer
.
append
(
field
)
;
buffer
.
append
(
":"
)
;
}
buffer
.
append
(
"\""
)
;
for
(
int
i
=
0
;
i
<
terms
.
size
(
)
;
i
++
)
{
buffer
.
append
(
(
(
Term
)
terms
.
elementAt
(
i
)
)
.
text
(
)
)
;
if
(
i
!=
terms
.
size
(
)
-
1
)
buffer
.
append
(
" "
)
;
}
buffer
.
append
(
"\""
)
;
if
(
slop
!=
0
)
{
buffer
.
append
(
"~"
)
;
buffer
.
append
(
slop
)
;
}
buffer
.
append
(
ToStringUtils
.
boost
(
getBoost
(
)
)
)
;
return
buffer
.
toString
(
)
;
}
public
boolean
equals
(
Object
o
)
{
if
(
!
(
o
instanceof
PhraseQuery
)
)
return
false
;
PhraseQuery
other
=
(
PhraseQuery
)
o
;
return
(
this
.
getBoost
(
)
==
other
.
getBoost
(
)
)
&&
(
this
.
slop
==
other
.
slop
)
&&
this
.
terms
.
equals
(
other
.
terms
)
&&
this
.
positions
.
equals
(
other
.
positions
)
;
}
public
int
hashCode
(
)
{
return
Float
.
floatToIntBits
(
getBoost
(
)
)
^
slop
^
terms
.
hashCode
(
)
^
positions
.
hashCode
(
)
;
}
}
