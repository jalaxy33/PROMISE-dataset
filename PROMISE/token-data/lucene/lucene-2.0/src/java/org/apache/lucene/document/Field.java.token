package
org
.
apache
.
lucene
.
document
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
search
.
Hits
;
import
org
.
apache
.
lucene
.
search
.
Similarity
;
import
org
.
apache
.
lucene
.
util
.
Parameter
;
import
java
.
io
.
Reader
;
import
java
.
io
.
Serializable
;
public
final
class
Field
implements
Serializable
{
private
String
name
=
"body"
;
private
Object
fieldsData
=
null
;
private
boolean
storeTermVector
=
false
;
private
boolean
storeOffsetWithTermVector
=
false
;
private
boolean
storePositionWithTermVector
=
false
;
private
boolean
omitNorms
=
false
;
private
boolean
isStored
=
false
;
private
boolean
isIndexed
=
true
;
private
boolean
isTokenized
=
true
;
private
boolean
isBinary
=
false
;
private
boolean
isCompressed
=
false
;
private
float
boost
=
1.0f
;
public
static
final
class
Store
extends
Parameter
implements
Serializable
{
private
Store
(
String
name
)
{
super
(
name
)
;
}
public
static
final
Store
COMPRESS
=
new
Store
(
"COMPRESS"
)
;
public
static
final
Store
YES
=
new
Store
(
"YES"
)
;
public
static
final
Store
NO
=
new
Store
(
"NO"
)
;
}
public
static
final
class
Index
extends
Parameter
implements
Serializable
{
private
Index
(
String
name
)
{
super
(
name
)
;
}
public
static
final
Index
NO
=
new
Index
(
"NO"
)
;
public
static
final
Index
TOKENIZED
=
new
Index
(
"TOKENIZED"
)
;
public
static
final
Index
UN_TOKENIZED
=
new
Index
(
"UN_TOKENIZED"
)
;
public
static
final
Index
NO_NORMS
=
new
Index
(
"NO_NORMS"
)
;
}
public
static
final
class
TermVector
extends
Parameter
implements
Serializable
{
private
TermVector
(
String
name
)
{
super
(
name
)
;
}
public
static
final
TermVector
NO
=
new
TermVector
(
"NO"
)
;
public
static
final
TermVector
YES
=
new
TermVector
(
"YES"
)
;
public
static
final
TermVector
WITH_POSITIONS
=
new
TermVector
(
"WITH_POSITIONS"
)
;
public
static
final
TermVector
WITH_OFFSETS
=
new
TermVector
(
"WITH_OFFSETS"
)
;
public
static
final
TermVector
WITH_POSITIONS_OFFSETS
=
new
TermVector
(
"WITH_POSITIONS_OFFSETS"
)
;
}
public
void
setBoost
(
float
boost
)
{
this
.
boost
=
boost
;
}
public
float
getBoost
(
)
{
return
boost
;
}
public
String
name
(
)
{
return
name
;
}
public
String
stringValue
(
)
{
return
fieldsData
instanceof
String
?
(
String
)
fieldsData
:
null
;
}
public
Reader
readerValue
(
)
{
return
fieldsData
instanceof
Reader
?
(
Reader
)
fieldsData
:
null
;
}
public
byte
[
]
binaryValue
(
)
{
return
fieldsData
instanceof
byte
[
]
?
(
byte
[
]
)
fieldsData
:
null
;
}
public
Field
(
String
name
,
String
value
,
Store
store
,
Index
index
)
{
this
(
name
,
value
,
store
,
index
,
TermVector
.
NO
)
;
}
public
Field
(
String
name
,
String
value
,
Store
store
,
Index
index
,
TermVector
termVector
)
{
if
(
name
==
null
)
throw
new
NullPointerException
(
"name cannot be null"
)
;
if
(
value
==
null
)
throw
new
NullPointerException
(
"value cannot be null"
)
;
if
(
name
.
length
(
)
==
0
&&
value
.
length
(
)
==
0
)
throw
new
IllegalArgumentException
(
"name and value cannot both be empty"
)
;
if
(
index
==
Index
.
NO
&&
store
==
Store
.
NO
)
throw
new
IllegalArgumentException
(
"it doesn't make sense to have a field that "
+
"is neither indexed nor stored"
)
;
if
(
index
==
Index
.
NO
&&
termVector
!=
TermVector
.
NO
)
throw
new
IllegalArgumentException
(
"cannot store term vector information "
+
"for a field that is not indexed"
)
;
this
.
name
=
name
.
intern
(
)
;
this
.
fieldsData
=
value
;
if
(
store
==
Store
.
YES
)
{
this
.
isStored
=
true
;
this
.
isCompressed
=
false
;
}
else
if
(
store
==
Store
.
COMPRESS
)
{
this
.
isStored
=
true
;
this
.
isCompressed
=
true
;
}
else
if
(
store
==
Store
.
NO
)
{
this
.
isStored
=
false
;
this
.
isCompressed
=
false
;
}
else
throw
new
IllegalArgumentException
(
"unknown store parameter "
+
store
)
;
if
(
index
==
Index
.
NO
)
{
this
.
isIndexed
=
false
;
this
.
isTokenized
=
false
;
}
else
if
(
index
==
Index
.
TOKENIZED
)
{
this
.
isIndexed
=
true
;
this
.
isTokenized
=
true
;
}
else
if
(
index
==
Index
.
UN_TOKENIZED
)
{
this
.
isIndexed
=
true
;
this
.
isTokenized
=
false
;
}
else
if
(
index
==
Index
.
NO_NORMS
)
{
this
.
isIndexed
=
true
;
this
.
isTokenized
=
false
;
this
.
omitNorms
=
true
;
}
else
{
throw
new
IllegalArgumentException
(
"unknown index parameter "
+
index
)
;
}
this
.
isBinary
=
false
;
setStoreTermVector
(
termVector
)
;
}
public
Field
(
String
name
,
Reader
reader
)
{
this
(
name
,
reader
,
TermVector
.
NO
)
;
}
public
Field
(
String
name
,
Reader
reader
,
TermVector
termVector
)
{
if
(
name
==
null
)
throw
new
NullPointerException
(
"name cannot be null"
)
;
if
(
reader
==
null
)
throw
new
NullPointerException
(
"reader cannot be null"
)
;
this
.
name
=
name
.
intern
(
)
;
this
.
fieldsData
=
reader
;
this
.
isStored
=
false
;
this
.
isCompressed
=
false
;
this
.
isIndexed
=
true
;
this
.
isTokenized
=
true
;
this
.
isBinary
=
false
;
setStoreTermVector
(
termVector
)
;
}
public
Field
(
String
name
,
byte
[
]
value
,
Store
store
)
{
if
(
name
==
null
)
throw
new
IllegalArgumentException
(
"name cannot be null"
)
;
if
(
value
==
null
)
throw
new
IllegalArgumentException
(
"value cannot be null"
)
;
this
.
name
=
name
.
intern
(
)
;
this
.
fieldsData
=
value
;
if
(
store
==
Store
.
YES
)
{
this
.
isStored
=
true
;
this
.
isCompressed
=
false
;
}
else
if
(
store
==
Store
.
COMPRESS
)
{
this
.
isStored
=
true
;
this
.
isCompressed
=
true
;
}
else
if
(
store
==
Store
.
NO
)
throw
new
IllegalArgumentException
(
"binary values can't be unstored"
)
;
else
throw
new
IllegalArgumentException
(
"unknown store parameter "
+
store
)
;
this
.
isIndexed
=
false
;
this
.
isTokenized
=
false
;
this
.
isBinary
=
true
;
setStoreTermVector
(
TermVector
.
NO
)
;
}
private
void
setStoreTermVector
(
TermVector
termVector
)
{
if
(
termVector
==
TermVector
.
NO
)
{
this
.
storeTermVector
=
false
;
this
.
storePositionWithTermVector
=
false
;
this
.
storeOffsetWithTermVector
=
false
;
}
else
if
(
termVector
==
TermVector
.
YES
)
{
this
.
storeTermVector
=
true
;
this
.
storePositionWithTermVector
=
false
;
this
.
storeOffsetWithTermVector
=
false
;
}
else
if
(
termVector
==
TermVector
.
WITH_POSITIONS
)
{
this
.
storeTermVector
=
true
;
this
.
storePositionWithTermVector
=
true
;
this
.
storeOffsetWithTermVector
=
false
;
}
else
if
(
termVector
==
TermVector
.
WITH_OFFSETS
)
{
this
.
storeTermVector
=
true
;
this
.
storePositionWithTermVector
=
false
;
this
.
storeOffsetWithTermVector
=
true
;
}
else
if
(
termVector
==
TermVector
.
WITH_POSITIONS_OFFSETS
)
{
this
.
storeTermVector
=
true
;
this
.
storePositionWithTermVector
=
true
;
this
.
storeOffsetWithTermVector
=
true
;
}
else
{
throw
new
IllegalArgumentException
(
"unknown termVector parameter "
+
termVector
)
;
}
}
public
final
boolean
isStored
(
)
{
return
isStored
;
}
public
final
boolean
isIndexed
(
)
{
return
isIndexed
;
}
public
final
boolean
isTokenized
(
)
{
return
isTokenized
;
}
public
final
boolean
isCompressed
(
)
{
return
isCompressed
;
}
public
final
boolean
isTermVectorStored
(
)
{
return
storeTermVector
;
}
public
boolean
isStoreOffsetWithTermVector
(
)
{
return
storeOffsetWithTermVector
;
}
public
boolean
isStorePositionWithTermVector
(
)
{
return
storePositionWithTermVector
;
}
public
final
boolean
isBinary
(
)
{
return
isBinary
;
}
public
boolean
getOmitNorms
(
)
{
return
omitNorms
;
}
public
void
setOmitNorms
(
boolean
omitNorms
)
{
this
.
omitNorms
=
omitNorms
;
}
public
final
String
toString
(
)
{
StringBuffer
result
=
new
StringBuffer
(
)
;
if
(
isStored
)
{
result
.
append
(
"stored"
)
;
if
(
isCompressed
)
result
.
append
(
"/compressed"
)
;
else
result
.
append
(
"/uncompressed"
)
;
}
if
(
isIndexed
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"indexed"
)
;
}
if
(
isTokenized
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"tokenized"
)
;
}
if
(
storeTermVector
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"termVector"
)
;
}
if
(
storeOffsetWithTermVector
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"termVectorOffsets"
)
;
}
if
(
storePositionWithTermVector
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"termVectorPosition"
)
;
}
if
(
isBinary
)
{
if
(
result
.
length
(
)
>
0
)
result
.
append
(
","
)
;
result
.
append
(
"binary"
)
;
}
if
(
omitNorms
)
{
result
.
append
(
",omitNorms"
)
;
}
result
.
append
(
'<'
)
;
result
.
append
(
name
)
;
result
.
append
(
':'
)
;
if
(
fieldsData
!=
null
)
{
result
.
append
(
fieldsData
)
;
}
result
.
append
(
'>'
)
;
return
result
.
toString
(
)
;
}
}
