package
org
.
apache
.
lucene
.
search
.
spans
;
import
java
.
io
.
IOException
;
import
java
.
util
.
Collection
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Set
;
import
org
.
apache
.
lucene
.
index
.
IndexReader
;
import
org
.
apache
.
lucene
.
index
.
Term
;
import
org
.
apache
.
lucene
.
index
.
TermPositions
;
import
org
.
apache
.
lucene
.
util
.
ToStringUtils
;
public
class
SpanTermQuery
extends
SpanQuery
{
private
Term
term
;
public
SpanTermQuery
(
Term
term
)
{
this
.
term
=
term
;
}
public
Term
getTerm
(
)
{
return
term
;
}
public
String
getField
(
)
{
return
term
.
field
(
)
;
}
public
Collection
getTerms
(
)
{
Collection
terms
=
new
ArrayList
(
)
;
terms
.
add
(
term
)
;
return
terms
;
}
public
void
extractTerms
(
Set
terms
)
{
terms
.
add
(
term
)
;
}
public
String
toString
(
String
field
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
if
(
term
.
field
(
)
.
equals
(
field
)
)
buffer
.
append
(
term
.
text
(
)
)
;
else
buffer
.
append
(
term
.
toString
(
)
)
;
buffer
.
append
(
ToStringUtils
.
boost
(
getBoost
(
)
)
)
;
return
buffer
.
toString
(
)
;
}
public
boolean
equals
(
Object
o
)
{
if
(
!
(
o
instanceof
SpanTermQuery
)
)
return
false
;
SpanTermQuery
other
=
(
SpanTermQuery
)
o
;
return
(
this
.
getBoost
(
)
==
other
.
getBoost
(
)
)
&&
this
.
term
.
equals
(
other
.
term
)
;
}
public
int
hashCode
(
)
{
return
Float
.
floatToIntBits
(
getBoost
(
)
)
^
term
.
hashCode
(
)
^
0xD23FE494
;
}
public
Spans
getSpans
(
final
IndexReader
reader
)
throws
IOException
{
return
new
Spans
(
)
{
private
TermPositions
positions
=
reader
.
termPositions
(
term
)
;
private
int
doc
=
-
1
;
private
int
freq
;
private
int
count
;
private
int
position
;
public
boolean
next
(
)
throws
IOException
{
if
(
count
==
freq
)
{
if
(
!
positions
.
next
(
)
)
{
doc
=
Integer
.
MAX_VALUE
;
return
false
;
}
doc
=
positions
.
doc
(
)
;
freq
=
positions
.
freq
(
)
;
count
=
0
;
}
position
=
positions
.
nextPosition
(
)
;
count
++
;
return
true
;
}
public
boolean
skipTo
(
int
target
)
throws
IOException
{
if
(
doc
>=
target
)
{
return
true
;
}
if
(
!
positions
.
skipTo
(
target
)
)
{
doc
=
Integer
.
MAX_VALUE
;
return
false
;
}
doc
=
positions
.
doc
(
)
;
freq
=
positions
.
freq
(
)
;
count
=
0
;
position
=
positions
.
nextPosition
(
)
;
count
++
;
return
true
;
}
public
int
doc
(
)
{
return
doc
;
}
public
int
start
(
)
{
return
position
;
}
public
int
end
(
)
{
return
position
+
1
;
}
public
String
toString
(
)
{
return
"spans("
+
SpanTermQuery
.
this
.
toString
(
)
+
")@"
+
(
doc
==
-
1
?
"START"
:
(
doc
==
Integer
.
MAX_VALUE
)
?
"END"
:
doc
+
"-"
+
position
)
;
}
}
;
}
}
