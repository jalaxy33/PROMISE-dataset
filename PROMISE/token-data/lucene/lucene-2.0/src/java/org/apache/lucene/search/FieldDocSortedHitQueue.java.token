package
org
.
apache
.
lucene
.
search
;
import
org
.
apache
.
lucene
.
util
.
PriorityQueue
;
import
java
.
text
.
Collator
;
import
java
.
util
.
Locale
;
class
FieldDocSortedHitQueue
extends
PriorityQueue
{
volatile
SortField
[
]
fields
;
volatile
Collator
[
]
collators
;
FieldDocSortedHitQueue
(
SortField
[
]
fields
,
int
size
)
{
this
.
fields
=
fields
;
this
.
collators
=
hasCollators
(
fields
)
;
initialize
(
size
)
;
}
synchronized
void
setFields
(
SortField
[
]
fields
)
{
if
(
this
.
fields
==
null
)
{
this
.
fields
=
fields
;
this
.
collators
=
hasCollators
(
fields
)
;
}
}
SortField
[
]
getFields
(
)
{
return
fields
;
}
private
Collator
[
]
hasCollators
(
final
SortField
[
]
fields
)
{
if
(
fields
==
null
)
return
null
;
Collator
[
]
ret
=
new
Collator
[
fields
.
length
]
;
for
(
int
i
=
0
;
i
<
fields
.
length
;
++
i
)
{
Locale
locale
=
fields
[
i
]
.
getLocale
(
)
;
if
(
locale
!=
null
)
ret
[
i
]
=
Collator
.
getInstance
(
locale
)
;
}
return
ret
;
}
protected
final
boolean
lessThan
(
final
Object
a
,
final
Object
b
)
{
final
FieldDoc
docA
=
(
FieldDoc
)
a
;
final
FieldDoc
docB
=
(
FieldDoc
)
b
;
final
int
n
=
fields
.
length
;
int
c
=
0
;
for
(
int
i
=
0
;
i
<
n
&&
c
==
0
;
++
i
)
{
final
int
type
=
fields
[
i
]
.
getType
(
)
;
switch
(
type
)
{
case
SortField
.
SCORE
:
float
r1
=
(
(
Float
)
docA
.
fields
[
i
]
)
.
floatValue
(
)
;
float
r2
=
(
(
Float
)
docB
.
fields
[
i
]
)
.
floatValue
(
)
;
if
(
r1
>
r2
)
c
=
-
1
;
if
(
r1
<
r2
)
c
=
1
;
break
;
case
SortField
.
DOC
:
case
SortField
.
INT
:
int
i1
=
(
(
Integer
)
docA
.
fields
[
i
]
)
.
intValue
(
)
;
int
i2
=
(
(
Integer
)
docB
.
fields
[
i
]
)
.
intValue
(
)
;
if
(
i1
<
i2
)
c
=
-
1
;
if
(
i1
>
i2
)
c
=
1
;
break
;
case
SortField
.
STRING
:
String
s1
=
(
String
)
docA
.
fields
[
i
]
;
String
s2
=
(
String
)
docB
.
fields
[
i
]
;
if
(
s1
==
null
)
c
=
(
s2
==
null
)
?
0
:
-
1
;
else
if
(
s2
==
null
)
c
=
1
;
else
if
(
fields
[
i
]
.
getLocale
(
)
==
null
)
{
c
=
s1
.
compareTo
(
s2
)
;
}
else
{
c
=
collators
[
i
]
.
compare
(
s1
,
s2
)
;
}
break
;
case
SortField
.
FLOAT
:
float
f1
=
(
(
Float
)
docA
.
fields
[
i
]
)
.
floatValue
(
)
;
float
f2
=
(
(
Float
)
docB
.
fields
[
i
]
)
.
floatValue
(
)
;
if
(
f1
<
f2
)
c
=
-
1
;
if
(
f1
>
f2
)
c
=
1
;
break
;
case
SortField
.
CUSTOM
:
c
=
docA
.
fields
[
i
]
.
compareTo
(
docB
.
fields
[
i
]
)
;
break
;
case
SortField
.
AUTO
:
throw
new
RuntimeException
(
"FieldDocSortedHitQueue cannot use an AUTO SortField"
)
;
default
:
throw
new
RuntimeException
(
"invalid SortField type: "
+
type
)
;
}
if
(
fields
[
i
]
.
getReverse
(
)
)
{
c
=
-
c
;
}
}
if
(
c
==
0
)
return
docA
.
doc
>
docB
.
doc
;
return
c
>
0
;
}
}
