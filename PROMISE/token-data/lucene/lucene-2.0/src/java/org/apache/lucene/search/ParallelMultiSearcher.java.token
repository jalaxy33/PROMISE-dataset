package
org
.
apache
.
lucene
.
search
;
import
java
.
io
.
IOException
;
import
org
.
apache
.
lucene
.
index
.
Term
;
import
org
.
apache
.
lucene
.
util
.
PriorityQueue
;
public
class
ParallelMultiSearcher
extends
MultiSearcher
{
private
Searchable
[
]
searchables
;
private
int
[
]
starts
;
public
ParallelMultiSearcher
(
Searchable
[
]
searchables
)
throws
IOException
{
super
(
searchables
)
;
this
.
searchables
=
searchables
;
this
.
starts
=
getStarts
(
)
;
}
public
int
docFreq
(
Term
term
)
throws
IOException
{
return
super
.
docFreq
(
term
)
;
}
public
TopDocs
search
(
Weight
weight
,
Filter
filter
,
int
nDocs
)
throws
IOException
{
HitQueue
hq
=
new
HitQueue
(
nDocs
)
;
int
totalHits
=
0
;
MultiSearcherThread
[
]
msta
=
new
MultiSearcherThread
[
searchables
.
length
]
;
for
(
int
i
=
0
;
i
<
searchables
.
length
;
i
++
)
{
msta
[
i
]
=
new
MultiSearcherThread
(
searchables
[
i
]
,
weight
,
filter
,
nDocs
,
hq
,
i
,
starts
,
"MultiSearcher thread #"
+
(
i
+
1
)
)
;
msta
[
i
]
.
start
(
)
;
}
for
(
int
i
=
0
;
i
<
searchables
.
length
;
i
++
)
{
try
{
msta
[
i
]
.
join
(
)
;
}
catch
(
InterruptedException
ie
)
{
;
}
IOException
ioe
=
msta
[
i
]
.
getIOException
(
)
;
if
(
ioe
==
null
)
{
totalHits
+=
msta
[
i
]
.
hits
(
)
;
}
else
{
throw
ioe
;
}
}
ScoreDoc
[
]
scoreDocs
=
new
ScoreDoc
[
hq
.
size
(
)
]
;
for
(
int
i
=
hq
.
size
(
)
-
1
;
i
>=
0
;
i
--
)
scoreDocs
[
i
]
=
(
ScoreDoc
)
hq
.
pop
(
)
;
float
maxScore
=
(
totalHits
==
0
)
?
Float
.
NEGATIVE_INFINITY
:
scoreDocs
[
0
]
.
score
;
return
new
TopDocs
(
totalHits
,
scoreDocs
,
maxScore
)
;
}
public
TopFieldDocs
search
(
Weight
weight
,
Filter
filter
,
int
nDocs
,
Sort
sort
)
throws
IOException
{
FieldDocSortedHitQueue
hq
=
new
FieldDocSortedHitQueue
(
null
,
nDocs
)
;
int
totalHits
=
0
;
MultiSearcherThread
[
]
msta
=
new
MultiSearcherThread
[
searchables
.
length
]
;
for
(
int
i
=
0
;
i
<
searchables
.
length
;
i
++
)
{
msta
[
i
]
=
new
MultiSearcherThread
(
searchables
[
i
]
,
weight
,
filter
,
nDocs
,
hq
,
sort
,
i
,
starts
,
"MultiSearcher thread #"
+
(
i
+
1
)
)
;
msta
[
i
]
.
start
(
)
;
}
float
maxScore
=
Float
.
NEGATIVE_INFINITY
;
for
(
int
i
=
0
;
i
<
searchables
.
length
;
i
++
)
{
try
{
msta
[
i
]
.
join
(
)
;
}
catch
(
InterruptedException
ie
)
{
;
}
IOException
ioe
=
msta
[
i
]
.
getIOException
(
)
;
if
(
ioe
==
null
)
{
totalHits
+=
msta
[
i
]
.
hits
(
)
;
maxScore
=
Math
.
max
(
maxScore
,
msta
[
i
]
.
getMaxScore
(
)
)
;
}
else
{
throw
ioe
;
}
}
ScoreDoc
[
]
scoreDocs
=
new
ScoreDoc
[
hq
.
size
(
)
]
;
for
(
int
i
=
hq
.
size
(
)
-
1
;
i
>=
0
;
i
--
)
scoreDocs
[
i
]
=
(
ScoreDoc
)
hq
.
pop
(
)
;
return
new
TopFieldDocs
(
totalHits
,
scoreDocs
,
hq
.
getFields
(
)
,
maxScore
)
;
}
public
void
search
(
Weight
weight
,
Filter
filter
,
final
HitCollector
results
)
throws
IOException
{
for
(
int
i
=
0
;
i
<
searchables
.
length
;
i
++
)
{
final
int
start
=
starts
[
i
]
;
searchables
[
i
]
.
search
(
weight
,
filter
,
new
HitCollector
(
)
{
public
void
collect
(
int
doc
,
float
score
)
{
results
.
collect
(
doc
+
start
,
score
)
;
}
}
)
;
}
}
public
Query
rewrite
(
Query
original
)
throws
IOException
{
return
super
.
rewrite
(
original
)
;
}
}
class
MultiSearcherThread
extends
Thread
{
private
Searchable
searchable
;
private
Weight
weight
;
private
Filter
filter
;
private
int
nDocs
;
private
TopDocs
docs
;
private
int
i
;
private
PriorityQueue
hq
;
private
int
[
]
starts
;
private
IOException
ioe
;
private
Sort
sort
;
public
MultiSearcherThread
(
Searchable
searchable
,
Weight
weight
,
Filter
filter
,
int
nDocs
,
HitQueue
hq
,
int
i
,
int
[
]
starts
,
String
name
)
{
super
(
name
)
;
this
.
searchable
=
searchable
;
this
.
weight
=
weight
;
this
.
filter
=
filter
;
this
.
nDocs
=
nDocs
;
this
.
hq
=
hq
;
this
.
i
=
i
;
this
.
starts
=
starts
;
}
public
MultiSearcherThread
(
Searchable
searchable
,
Weight
weight
,
Filter
filter
,
int
nDocs
,
FieldDocSortedHitQueue
hq
,
Sort
sort
,
int
i
,
int
[
]
starts
,
String
name
)
{
super
(
name
)
;
this
.
searchable
=
searchable
;
this
.
weight
=
weight
;
this
.
filter
=
filter
;
this
.
nDocs
=
nDocs
;
this
.
hq
=
hq
;
this
.
i
=
i
;
this
.
starts
=
starts
;
this
.
sort
=
sort
;
}
public
void
run
(
)
{
try
{
docs
=
(
sort
==
null
)
?
searchable
.
search
(
weight
,
filter
,
nDocs
)
:
searchable
.
search
(
weight
,
filter
,
nDocs
,
sort
)
;
}
catch
(
IOException
ioe
)
{
this
.
ioe
=
ioe
;
}
if
(
ioe
==
null
)
{
if
(
sort
!=
null
)
{
(
(
FieldDocSortedHitQueue
)
hq
)
.
setFields
(
(
(
TopFieldDocs
)
docs
)
.
fields
)
;
}
ScoreDoc
[
]
scoreDocs
=
docs
.
scoreDocs
;
for
(
int
j
=
0
;
j
<
scoreDocs
.
length
;
j
++
)
{
ScoreDoc
scoreDoc
=
scoreDocs
[
j
]
;
scoreDoc
.
doc
+=
starts
[
i
]
;
synchronized
(
hq
)
{
if
(
!
hq
.
insert
(
scoreDoc
)
)
break
;
}
}
}
}
public
int
hits
(
)
{
return
docs
.
totalHits
;
}
public
float
getMaxScore
(
)
{
return
docs
.
getMaxScore
(
)
;
}
public
IOException
getIOException
(
)
{
return
ioe
;
}
}
