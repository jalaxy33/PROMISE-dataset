package
org
.
gjt
.
sp
.
util
;
import
javax
.
swing
.
text
.
*
;
import
java
.
io
.
*
;
import
java
.
util
.
StringTokenizer
;
public
class
Log
{
public
static
final
int
MAXLINES
=
500
;
public
static
final
int
DEBUG
=
1
;
public
static
final
int
MESSAGE
=
3
;
public
static
final
int
NOTICE
=
5
;
public
static
final
int
WARNING
=
7
;
public
static
final
int
ERROR
=
9
;
public
static
void
init
(
boolean
stdio
,
int
level
)
{
if
(
stdio
)
{
if
(
System
.
out
==
realOut
&&
System
.
err
==
realErr
)
{
System
.
setOut
(
createPrintStream
(
NOTICE
,
null
)
)
;
System
.
setErr
(
createPrintStream
(
ERROR
,
null
)
)
;
}
}
Log
.
level
=
level
;
Log
.
stream
=
stream
;
log
(
MESSAGE
,
Log
.
class
,
"When reporting bugs, please"
+
" include the following information:"
)
;
String
[
]
props
=
{
"java.version"
,
"java.vendor"
,
"java.compiler"
,
"os.name"
,
"os.version"
,
"os.arch"
,
"user.home"
,
"java.class.path"
,
}
;
for
(
int
i
=
0
;
i
<
props
.
length
;
i
++
)
{
log
(
MESSAGE
,
Log
.
class
,
props
[
i
]
+
"="
+
System
.
getProperty
(
props
[
i
]
)
)
;
}
}
public
static
void
setLogWriter
(
Writer
stream
)
{
if
(
Log
.
stream
==
null
&&
stream
!=
null
)
{
try
{
stream
.
write
(
logDocument
.
getText
(
0
,
logDocument
.
getLength
(
)
)
)
;
stream
.
flush
(
)
;
}
catch
(
Exception
e
)
{
}
}
Log
.
stream
=
stream
;
}
public
static
Document
getLogDocument
(
)
{
return
logDocument
;
}
public
static
void
flushStream
(
)
{
if
(
stream
!=
null
)
{
try
{
stream
.
flush
(
)
;
}
catch
(
IOException
io
)
{
io
.
printStackTrace
(
realErr
)
;
}
}
}
public
static
void
closeStream
(
)
{
if
(
stream
!=
null
)
{
try
{
stream
.
close
(
)
;
stream
=
null
;
}
catch
(
IOException
io
)
{
io
.
printStackTrace
(
realErr
)
;
}
}
}
public
static
void
log
(
int
urgency
,
Object
source
,
Object
message
)
{
String
_source
;
if
(
source
==
null
)
{
_source
=
Thread
.
currentThread
(
)
.
getName
(
)
;
if
(
_source
==
null
)
{
_source
=
Thread
.
currentThread
(
)
.
getClass
(
)
.
getName
(
)
;
}
}
else
if
(
source
instanceof
Class
)
_source
=
(
(
Class
)
source
)
.
getName
(
)
;
else
_source
=
source
.
getClass
(
)
.
getName
(
)
;
int
index
=
_source
.
lastIndexOf
(
'.'
)
;
if
(
index
!=
-
1
)
_source
=
_source
.
substring
(
index
+
1
)
;
if
(
message
instanceof
Throwable
)
{
_logException
(
urgency
,
source
,
(
Throwable
)
message
)
;
}
else
{
String
_message
=
String
.
valueOf
(
message
)
;
synchronized
(
LOCK
)
{
StringTokenizer
st
=
new
StringTokenizer
(
_message
,
"\r\n"
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
_log
(
urgency
,
_source
,
st
.
nextToken
(
)
)
;
}
}
}
}
private
static
Object
LOCK
=
new
Object
(
)
;
private
static
Document
logDocument
;
private
static
int
level
;
private
static
Writer
stream
;
private
static
String
lineSep
;
private
static
PrintStream
realOut
;
private
static
PrintStream
realErr
;
static
{
level
=
WARNING
;
realOut
=
System
.
out
;
realErr
=
System
.
err
;
logDocument
=
new
PlainDocument
(
)
;
lineSep
=
System
.
getProperty
(
"line.separator"
)
;
}
private
static
PrintStream
createPrintStream
(
final
int
urgency
,
final
Object
source
)
{
return
new
PrintStream
(
new
OutputStream
(
)
{
public
void
write
(
int
b
)
{
byte
[
]
barray
=
{
(
byte
)
b
}
;
write
(
barray
,
0
,
1
)
;
}
public
void
write
(
byte
[
]
b
,
int
off
,
int
len
)
{
String
str
=
new
String
(
b
,
off
,
len
)
;
log
(
urgency
,
source
,
str
)
;
}
}
)
;
}
private
static
void
_logException
(
final
int
urgency
,
final
Object
source
,
final
Throwable
message
)
{
PrintStream
out
=
createPrintStream
(
urgency
,
source
)
;
synchronized
(
LOCK
)
{
message
.
printStackTrace
(
out
)
;
}
}
private
static
void
_log
(
int
urgency
,
String
source
,
String
message
)
{
String
urgencyString
=
"["
+
urgencyToString
(
urgency
)
+
"] "
;
String
fullMessage
=
urgencyString
+
source
+
": "
+
message
;
try
{
logDocument
.
insertString
(
logDocument
.
getLength
(
)
,
fullMessage
,
null
)
;
logDocument
.
insertString
(
logDocument
.
getLength
(
)
,
"\n"
,
null
)
;
Element
map
=
logDocument
.
getDefaultRootElement
(
)
;
int
lines
=
map
.
getElementCount
(
)
;
if
(
lines
>
MAXLINES
)
{
Element
first
=
map
.
getElement
(
0
)
;
Element
last
=
map
.
getElement
(
lines
-
MAXLINES
)
;
logDocument
.
remove
(
first
.
getStartOffset
(
)
,
last
.
getEndOffset
(
)
)
;
}
if
(
stream
!=
null
)
{
stream
.
write
(
fullMessage
)
;
stream
.
write
(
lineSep
)
;
}
}
catch
(
Exception
e
)
{
e
.
printStackTrace
(
realErr
)
;
}
message
=
urgencyString
+
message
+
'\n'
;
if
(
urgency
>=
level
)
{
if
(
urgency
==
ERROR
)
realErr
.
print
(
message
)
;
else
realOut
.
print
(
message
)
;
}
}
private
static
String
urgencyToString
(
int
urgency
)
{
switch
(
urgency
)
{
case
DEBUG
:
return
"debug"
;
case
MESSAGE
:
return
"message"
;
case
NOTICE
:
return
"notice"
;
case
WARNING
:
return
"warning"
;
case
ERROR
:
return
"error"
;
}
throw
new
IllegalArgumentException
(
"Invalid urgency: "
+
urgency
)
;
}
}
