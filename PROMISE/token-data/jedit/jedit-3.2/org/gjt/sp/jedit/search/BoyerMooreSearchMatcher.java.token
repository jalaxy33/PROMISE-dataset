package
org
.
gjt
.
sp
.
jedit
.
search
;
import
bsh
.
NameSpace
;
import
javax
.
swing
.
text
.
Segment
;
import
org
.
gjt
.
sp
.
jedit
.
BeanShell
;
import
org
.
gjt
.
sp
.
util
.
Log
;
public
class
BoyerMooreSearchMatcher
implements
SearchMatcher
{
public
BoyerMooreSearchMatcher
(
String
pattern
,
String
replace
,
boolean
ignoreCase
,
boolean
reverseSearch
,
boolean
beanshell
,
String
replaceMethod
)
{
if
(
ignoreCase
)
{
this
.
pattern
=
pattern
.
toUpperCase
(
)
.
toCharArray
(
)
;
}
else
{
this
.
pattern
=
pattern
.
toCharArray
(
)
;
}
if
(
reverseSearch
)
{
char
[
]
tmp
=
new
char
[
this
.
pattern
.
length
]
;
for
(
int
i
=
0
;
i
<
tmp
.
length
;
i
++
)
{
tmp
[
i
]
=
this
.
pattern
[
this
.
pattern
.
length
-
(
i
+
1
)
]
;
}
this
.
pattern
=
tmp
;
}
this
.
replace
=
replace
;
this
.
ignoreCase
=
ignoreCase
;
this
.
reverseSearch
=
reverseSearch
;
this
.
beanshell
=
beanshell
;
if
(
beanshell
)
{
this
.
replaceMethod
=
replaceMethod
;
replaceNS
=
new
NameSpace
(
BeanShell
.
getNameSpace
(
)
,
"search and replace"
)
;
}
generateSkipArray
(
)
;
generateSuffixArray
(
)
;
}
public
int
[
]
nextMatch
(
Segment
text
)
{
int
pos
=
match
(
text
.
array
,
text
.
offset
,
text
.
offset
+
text
.
count
)
;
if
(
pos
==
-
1
)
{
return
null
;
}
else
{
return
new
int
[
]
{
pos
-
text
.
offset
,
pos
+
pattern
.
length
-
text
.
offset
}
;
}
}
public
String
substitute
(
String
text
)
throws
Exception
{
if
(
beanshell
)
{
replaceNS
.
setVariable
(
"_0"
,
text
)
;
Object
obj
=
BeanShell
.
runCachedBlock
(
replaceMethod
,
null
,
replaceNS
)
;
if
(
obj
==
null
)
return
null
;
else
return
obj
.
toString
(
)
;
}
else
return
replace
;
}
public
int
match
(
char
[
]
text
,
int
offset
,
int
length
)
{
int
anchor
=
reverseSearch
?
length
-
1
:
offset
;
int
pos
;
int
last_anchor
=
reverseSearch
?
offset
+
pattern
.
length
-
1
:
length
-
pattern
.
length
;
int
pattern_end
=
pattern
.
length
-
1
;
char
ch
=
0
;
int
bad_char
;
int
good_suffix
;
SEARCH
:
while
(
reverseSearch
?
anchor
>=
last_anchor
:
anchor
<=
last_anchor
)
{
for
(
pos
=
pattern_end
;
pos
>=
0
;
--
pos
)
{
int
idx
=
reverseSearch
?
anchor
-
pos
:
anchor
+
pos
;
ch
=
ignoreCase
?
Character
.
toUpperCase
(
text
[
idx
]
)
:
text
[
idx
]
;
if
(
ch
!=
pattern
[
pos
]
)
{
bad_char
=
pos
-
skip
[
getSkipIndex
(
ch
)
]
;
good_suffix
=
suffix
[
pos
]
;
int
skip
=
(
bad_char
>
good_suffix
)
?
bad_char
:
good_suffix
;
anchor
+=
reverseSearch
?
-
skip
:
skip
;
continue
SEARCH
;
}
}
return
(
reverseSearch
?
anchor
-
pattern_end
:
anchor
)
;
}
return
-
1
;
}
private
char
[
]
pattern
;
private
String
replace
;
private
boolean
ignoreCase
;
private
boolean
reverseSearch
;
private
boolean
beanshell
;
private
String
replaceMethod
;
private
NameSpace
replaceNS
;
private
int
[
]
skip
;
private
int
[
]
suffix
;
private
void
generateSkipArray
(
)
{
skip
=
new
int
[
256
]
;
if
(
pattern
.
length
==
0
)
return
;
int
pos
=
0
;
do
{
skip
[
getSkipIndex
(
pattern
[
pos
]
)
]
=
pos
;
}
while
(
++
pos
<
pattern
.
length
)
;
}
private
static
final
int
getSkipIndex
(
char
ch
)
{
return
(
(
int
)
ch
)
&
0x000000FF
;
}
private
void
generateSuffixArray
(
)
{
int
m
=
pattern
.
length
;
int
j
=
m
+
1
;
suffix
=
new
int
[
j
]
;
int
[
]
tmp
=
new
int
[
j
]
;
tmp
[
m
]
=
j
;
for
(
int
i
=
m
;
i
>
0
;
--
i
)
{
while
(
j
<=
m
&&
pattern
[
i
-
1
]
!=
pattern
[
j
-
1
]
)
{
if
(
suffix
[
j
]
==
0
)
{
suffix
[
j
]
=
j
-
i
;
}
j
=
tmp
[
j
]
;
}
tmp
[
i
-
1
]
=
--
j
;
}
int
k
=
tmp
[
0
]
;
for
(
j
=
0
;
j
<=
m
;
j
++
)
{
if
(
j
>
0
)
{
suffix
[
j
-
1
]
=
(
suffix
[
j
]
==
0
)
?
k
:
suffix
[
j
]
;
}
if
(
j
==
k
)
{
k
=
tmp
[
k
]
;
}
}
}
}
