package
org
.
gjt
.
sp
.
jedit
;
import
javax
.
swing
.
JMenuItem
;
import
java
.
io
.
*
;
import
java
.
util
.
Vector
;
import
java
.
util
.
StringTokenizer
;
public
class
MiscUtilities
{
public
static
String
fileToClass
(
String
name
)
{
char
[
]
clsName
=
name
.
toCharArray
(
)
;
for
(
int
i
=
clsName
.
length
-
6
;
i
>=
0
;
i
--
)
if
(
clsName
[
i
]
==
'/'
)
clsName
[
i
]
=
'.'
;
return
new
String
(
clsName
,
0
,
clsName
.
length
-
6
)
;
}
public
static
String
classToFile
(
String
name
)
{
return
name
.
replace
(
'.'
,
'/'
)
.
concat
(
".class"
)
;
}
public
static
String
constructPath
(
String
parent
,
String
path
)
{
if
(
new
File
(
path
)
.
isAbsolute
(
)
)
return
canonPath
(
path
)
;
if
(
parent
==
null
)
parent
=
System
.
getProperty
(
"user.dir"
)
;
if
(
File
.
separatorChar
==
'\\'
)
{
if
(
path
.
length
(
)
==
2
&&
path
.
charAt
(
1
)
==
':'
)
return
path
;
if
(
path
.
startsWith
(
"/"
)
||
path
.
startsWith
(
"\\"
)
)
parent
=
parent
.
substring
(
0
,
2
)
;
}
if
(
parent
.
endsWith
(
File
.
separator
)
||
path
.
endsWith
(
"/"
)
)
return
canonPath
(
parent
+
path
)
;
else
return
canonPath
(
parent
+
File
.
separator
+
path
)
;
}
public
static
String
constructPath
(
String
parent
,
String
path1
,
String
path2
)
{
return
constructPath
(
constructPath
(
parent
,
path1
)
,
path2
)
;
}
public
static
String
concatPath
(
String
parent
,
String
path
)
{
if
(
path
.
startsWith
(
File
.
separator
)
)
path
=
path
.
substring
(
1
)
;
else
if
(
(
path
.
length
(
)
>=
3
)
&&
(
path
.
charAt
(
1
)
==
':'
)
)
path
=
path
.
replace
(
':'
,
File
.
separatorChar
)
;
if
(
parent
==
null
)
parent
=
System
.
getProperty
(
"user.dir"
)
;
if
(
parent
.
endsWith
(
File
.
separator
)
)
return
parent
+
path
;
else
return
parent
+
File
.
separator
+
path
;
}
public
static
String
getFileExtension
(
String
name
)
{
int
index
=
name
.
indexOf
(
'.'
)
;
if
(
index
==
-
1
)
return
""
;
else
return
name
.
substring
(
index
)
;
}
public
static
String
getFileName
(
String
path
)
{
int
count
=
Math
.
max
(
0
,
path
.
length
(
)
-
2
)
;
int
index1
=
path
.
lastIndexOf
(
File
.
separatorChar
,
count
)
;
int
index2
=
path
.
lastIndexOf
(
'/'
,
count
)
;
return
path
.
substring
(
Math
.
max
(
index1
,
index2
)
+
1
)
;
}
public
static
String
getFileParent
(
String
path
)
{
return
getParentOfPath
(
path
)
;
}
public
static
String
getParentOfPath
(
String
path
)
{
int
count
=
Math
.
max
(
0
,
path
.
length
(
)
-
2
)
;
int
index
=
path
.
lastIndexOf
(
File
.
separatorChar
,
count
)
;
if
(
index
==
-
1
)
index
=
path
.
lastIndexOf
(
'/'
,
count
)
;
if
(
index
==
-
1
)
{
index
=
path
.
lastIndexOf
(
':'
)
;
}
return
path
.
substring
(
0
,
index
+
1
)
;
}
public
static
String
getFileProtocol
(
String
url
)
{
return
getProtocolOfURL
(
url
)
;
}
public
static
String
getProtocolOfURL
(
String
url
)
{
return
url
.
substring
(
0
,
url
.
indexOf
(
':'
)
)
;
}
public
static
boolean
isURL
(
String
str
)
{
int
fsIndex
=
Math
.
max
(
str
.
indexOf
(
File
.
separatorChar
)
,
str
.
indexOf
(
'/'
)
)
;
if
(
fsIndex
==
0
)
return
false
;
else
if
(
fsIndex
==
2
)
return
false
;
int
cIndex
=
str
.
indexOf
(
':'
)
;
if
(
cIndex
<=
1
)
return
false
;
else
if
(
fsIndex
!=
-
1
&&
cIndex
>
fsIndex
)
return
false
;
return
true
;
}
public
static
int
getLeadingWhiteSpace
(
String
str
)
{
int
whitespace
=
0
;
loop
:
for
(
;
whitespace
<
str
.
length
(
)
;
)
{
switch
(
str
.
charAt
(
whitespace
)
)
{
case
' '
:
case
'\t'
:
whitespace
++
;
break
;
default
:
break
loop
;
}
}
return
whitespace
;
}
public
static
int
getTrailingWhiteSpace
(
String
str
)
{
int
whitespace
=
0
;
loop
:
for
(
int
i
=
str
.
length
(
)
-
1
;
i
>=
0
;
i
--
)
{
switch
(
str
.
charAt
(
i
)
)
{
case
' '
:
case
'\t'
:
whitespace
++
;
break
;
default
:
break
loop
;
}
}
return
whitespace
;
}
public
static
int
getLeadingWhiteSpaceWidth
(
String
str
,
int
tabSize
)
{
int
whitespace
=
0
;
loop
:
for
(
int
i
=
0
;
i
<
str
.
length
(
)
;
i
++
)
{
switch
(
str
.
charAt
(
i
)
)
{
case
' '
:
whitespace
++
;
break
;
case
'\t'
:
whitespace
+=
(
tabSize
-
whitespace
%
tabSize
)
;
break
;
default
:
break
loop
;
}
}
return
whitespace
;
}
public
static
String
createWhiteSpace
(
int
len
,
int
tabSize
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
if
(
tabSize
==
0
)
{
while
(
len
--
>
0
)
buf
.
append
(
' '
)
;
}
else
{
int
count
=
len
/
tabSize
;
while
(
count
--
>
0
)
buf
.
append
(
'\t'
)
;
count
=
len
%
tabSize
;
while
(
count
--
>
0
)
buf
.
append
(
' '
)
;
}
return
buf
.
toString
(
)
;
}
public
static
String
globToRE
(
String
glob
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
boolean
backslash
=
false
;
boolean
insideGroup
=
false
;
for
(
int
i
=
0
;
i
<
glob
.
length
(
)
;
i
++
)
{
char
c
=
glob
.
charAt
(
i
)
;
if
(
backslash
)
{
buf
.
append
(
'\\'
)
;
buf
.
append
(
c
)
;
backslash
=
false
;
continue
;
}
switch
(
c
)
{
case
'\\'
:
backslash
=
true
;
break
;
case
'?'
:
buf
.
append
(
'.'
)
;
break
;
case
'.'
:
buf
.
append
(
"\\."
)
;
break
;
case
'*'
:
buf
.
append
(
".*"
)
;
break
;
case
'{'
:
buf
.
append
(
'('
)
;
insideGroup
=
true
;
break
;
case
','
:
if
(
insideGroup
)
buf
.
append
(
'|'
)
;
else
buf
.
append
(
','
)
;
break
;
case
'}'
:
buf
.
append
(
')'
)
;
insideGroup
=
false
;
break
;
default
:
buf
.
append
(
c
)
;
}
}
return
buf
.
toString
(
)
;
}
public
static
String
escapesToChars
(
String
str
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
str
.
length
(
)
;
i
++
)
{
char
c
=
str
.
charAt
(
i
)
;
switch
(
c
)
{
case
'\\'
:
if
(
i
==
str
.
length
(
)
-
1
)
{
buf
.
append
(
'\\'
)
;
break
;
}
c
=
str
.
charAt
(
++
i
)
;
switch
(
c
)
{
case
'n'
:
buf
.
append
(
'\n'
)
;
break
;
case
't'
:
buf
.
append
(
'\t'
)
;
break
;
default
:
buf
.
append
(
c
)
;
break
;
}
break
;
default
:
buf
.
append
(
c
)
;
}
}
return
buf
.
toString
(
)
;
}
public
static
String
charsToEscapes
(
String
str
)
{
return
charsToEscapes
(
str
,
false
)
;
}
public
static
String
charsToEscapes
(
String
str
,
boolean
history
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
str
.
length
(
)
;
i
++
)
{
char
c
=
str
.
charAt
(
i
)
;
switch
(
c
)
{
case
'\n'
:
buf
.
append
(
"\\n"
)
;
break
;
case
'\t'
:
buf
.
append
(
"\\t"
)
;
break
;
case
'['
:
if
(
history
)
buf
.
append
(
"\\["
)
;
else
buf
.
append
(
c
)
;
break
;
case
']'
:
if
(
history
)
buf
.
append
(
"\\]"
)
;
else
buf
.
append
(
c
)
;
break
;
case
'"'
:
if
(
history
)
buf
.
append
(
c
)
;
else
buf
.
append
(
"\\\""
)
;
break
;
case
'\''
:
if
(
history
)
buf
.
append
(
c
)
;
else
buf
.
append
(
"\\\'"
)
;
break
;
case
'\\'
:
buf
.
append
(
"\\\\"
)
;
break
;
default
:
buf
.
append
(
c
)
;
break
;
}
}
return
buf
.
toString
(
)
;
}
public
static
void
quicksort
(
Object
[
]
obj
,
Compare
compare
)
{
if
(
obj
.
length
==
0
)
return
;
quicksort
(
obj
,
0
,
obj
.
length
-
1
,
compare
)
;
}
public
static
void
quicksort
(
Vector
vector
,
Compare
compare
)
{
if
(
vector
.
size
(
)
==
0
)
return
;
quicksort
(
vector
,
0
,
vector
.
size
(
)
-
1
,
compare
)
;
}
public
interface
Compare
{
int
compare
(
Object
obj1
,
Object
obj2
)
;
}
public
static
class
StringCompare
implements
Compare
{
public
int
compare
(
Object
obj1
,
Object
obj2
)
{
return
obj1
.
toString
(
)
.
compareTo
(
obj2
.
toString
(
)
)
;
}
}
public
static
class
StringICaseCompare
implements
Compare
{
public
int
compare
(
Object
obj1
,
Object
obj2
)
{
return
obj1
.
toString
(
)
.
toLowerCase
(
)
.
compareTo
(
obj2
.
toString
(
)
.
toLowerCase
(
)
)
;
}
}
public
static
class
MenuItemCompare
implements
Compare
{
public
int
compare
(
Object
obj1
,
Object
obj2
)
{
return
(
(
JMenuItem
)
obj1
)
.
getText
(
)
.
compareTo
(
(
(
JMenuItem
)
obj2
)
.
getText
(
)
)
;
}
}
public
static
class
VersionCompare
implements
Compare
{
public
int
compare
(
Object
obj1
,
Object
obj2
)
{
String
v1
=
obj1
.
toString
(
)
;
String
v2
=
obj2
.
toString
(
)
;
StringTokenizer
vt1
=
new
StringTokenizer
(
v1
,
"."
)
;
StringTokenizer
vt2
=
new
StringTokenizer
(
v2
,
"."
)
;
int
comp
=
0
;
while
(
vt1
.
hasMoreTokens
(
)
&&
vt2
.
hasMoreTokens
(
)
)
{
String
vt1tok
=
vt1
.
nextToken
(
)
;
String
vt2tok
=
vt2
.
nextToken
(
)
;
try
{
int
i1
=
Integer
.
parseInt
(
vt1tok
)
;
int
i2
=
Integer
.
parseInt
(
vt2tok
)
;
comp
=
i1
<
i2
?
-
1
:
i1
>
i2
?
1
:
0
;
}
catch
(
NumberFormatException
e
)
{
comp
=
vt1tok
.
compareTo
(
vt2tok
)
;
}
if
(
comp
!=
0
)
return
comp
;
}
return
vt1
.
hasMoreTokens
(
)
?
1
:
vt2
.
hasMoreTokens
(
)
?
-
1
:
0
;
}
}
public
static
int
compareVersions
(
String
version1
,
String
version2
)
{
VersionCompare
comparator
=
new
VersionCompare
(
)
;
return
comparator
.
compare
(
version1
,
version2
)
;
}
public
static
String
buildToVersion
(
String
build
)
{
if
(
build
.
length
(
)
!=
11
)
return
"<unknown version: "
+
build
+
">"
;
int
major
=
Integer
.
parseInt
(
build
.
substring
(
0
,
2
)
)
;
int
minor
=
Integer
.
parseInt
(
build
.
substring
(
3
,
5
)
)
;
int
beta
=
Integer
.
parseInt
(
build
.
substring
(
6
,
8
)
)
;
int
bugfix
=
Integer
.
parseInt
(
build
.
substring
(
9
,
11
)
)
;
return
""
+
major
+
"."
+
minor
+
(
beta
!=
99
?
"pre"
+
beta
:
(
bugfix
!=
0
?
"."
+
bugfix
:
"final"
)
)
;
}
private
MiscUtilities
(
)
{
}
private
static
String
canonPath
(
String
path
)
{
if
(
File
.
separatorChar
==
'\\'
)
{
path
=
path
.
replace
(
'/'
,
'\\'
)
;
}
try
{
return
new
File
(
path
)
.
getCanonicalPath
(
)
;
}
catch
(
Exception
e
)
{
return
path
;
}
}
private
static
void
quicksort
(
Object
[
]
obj
,
int
_start
,
int
_end
,
Compare
compare
)
{
int
start
=
_start
;
int
end
=
_end
;
Object
mid
=
obj
[
(
_start
+
_end
)
/
2
]
;
if
(
_start
>
_end
)
return
;
while
(
start
<=
end
)
{
while
(
(
start
<
_end
)
&&
(
compare
.
compare
(
obj
[
start
]
,
mid
)
<
0
)
)
start
++
;
while
(
(
end
>
_start
)
&&
(
compare
.
compare
(
obj
[
end
]
,
mid
)
>
0
)
)
end
--
;
if
(
start
<=
end
)
{
Object
o
=
obj
[
start
]
;
obj
[
start
]
=
obj
[
end
]
;
obj
[
end
]
=
o
;
start
++
;
end
--
;
}
}
if
(
_start
<
end
)
quicksort
(
obj
,
_start
,
end
,
compare
)
;
if
(
start
<
_end
)
quicksort
(
obj
,
start
,
_end
,
compare
)
;
}
private
static
void
quicksort
(
Vector
obj
,
int
_start
,
int
_end
,
Compare
compare
)
{
int
start
=
_start
;
int
end
=
_end
;
Object
mid
=
obj
.
elementAt
(
(
_start
+
_end
)
/
2
)
;
if
(
_start
>
_end
)
return
;
while
(
start
<=
end
)
{
while
(
(
start
<
_end
)
&&
(
compare
.
compare
(
obj
.
elementAt
(
start
)
,
mid
)
<
0
)
)
start
++
;
while
(
(
end
>
_start
)
&&
(
compare
.
compare
(
obj
.
elementAt
(
end
)
,
mid
)
>
0
)
)
end
--
;
if
(
start
<=
end
)
{
Object
o
=
obj
.
elementAt
(
start
)
;
obj
.
setElementAt
(
obj
.
elementAt
(
end
)
,
start
)
;
obj
.
setElementAt
(
o
,
end
)
;
start
++
;
end
--
;
}
}
if
(
_start
<
end
)
quicksort
(
obj
,
_start
,
end
,
compare
)
;
if
(
start
<
_end
)
quicksort
(
obj
,
start
,
_end
,
compare
)
;
}
}
