package
org
.
gjt
.
sp
.
jedit
;
import
javax
.
swing
.
text
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
syntax
.
*
;
public
class
TextUtilities
{
public
static
int
findMatchingBracket
(
Buffer
buffer
,
int
line
,
int
offset
)
throws
BadLocationException
{
return
findMatchingBracket
(
buffer
,
line
,
offset
,
0
,
buffer
.
getDefaultRootElement
(
)
.
getElementCount
(
)
)
;
}
public
static
int
findMatchingBracket
(
Buffer
buffer
,
int
line
,
int
offset
,
int
startLine
,
int
endLine
)
throws
BadLocationException
{
if
(
buffer
.
getLength
(
)
==
0
)
return
-
1
;
Element
map
=
buffer
.
getDefaultRootElement
(
)
;
Element
lineElement
=
map
.
getElement
(
line
)
;
Segment
lineText
=
new
Segment
(
)
;
int
lineStart
=
lineElement
.
getStartOffset
(
)
;
buffer
.
getText
(
lineStart
,
lineElement
.
getEndOffset
(
)
-
lineStart
-
1
,
lineText
)
;
char
c
=
lineText
.
array
[
lineText
.
offset
+
offset
]
;
char
cprime
;
boolean
direction
;
switch
(
c
)
{
case
'('
:
cprime
=
')'
;
direction
=
false
;
break
;
case
')'
:
cprime
=
'('
;
direction
=
true
;
break
;
case
'['
:
cprime
=
']'
;
direction
=
false
;
break
;
case
']'
:
cprime
=
'['
;
direction
=
true
;
break
;
case
'{'
:
cprime
=
'}'
;
direction
=
false
;
break
;
case
'}'
:
cprime
=
'{'
;
direction
=
true
;
break
;
default
:
return
-
1
;
}
int
count
;
byte
idOfBracket
=
Token
.
NULL
;
Buffer
.
LineInfo
lineInfo
=
buffer
.
markTokens
(
line
)
;
Token
lineTokens
=
lineInfo
.
getFirstToken
(
)
;
int
tokenListOffset
=
0
;
for
(
;
;
)
{
if
(
lineTokens
.
id
==
Token
.
END
)
throw
new
InternalError
(
"offset > line length"
)
;
if
(
tokenListOffset
+
lineTokens
.
length
>
offset
)
{
idOfBracket
=
lineTokens
.
id
;
break
;
}
else
{
tokenListOffset
+=
lineTokens
.
length
;
lineTokens
=
lineTokens
.
next
;
}
}
if
(
direction
)
{
count
=
0
;
for
(
int
i
=
line
;
i
>=
startLine
;
i
--
)
{
lineElement
=
map
.
getElement
(
i
)
;
lineStart
=
lineElement
.
getStartOffset
(
)
;
int
lineLength
=
lineElement
.
getEndOffset
(
)
-
lineStart
-
1
;
buffer
.
getText
(
lineStart
,
lineLength
,
lineText
)
;
int
scanStartOffset
;
if
(
i
!=
line
)
{
lineTokens
=
buffer
.
markTokens
(
i
)
.
getLastToken
(
)
;
tokenListOffset
=
scanStartOffset
=
lineLength
-
1
;
}
else
{
if
(
tokenListOffset
!=
lineLength
)
tokenListOffset
+=
lineTokens
.
length
;
scanStartOffset
=
offset
;
}
while
(
lineTokens
!=
null
)
{
byte
id
=
lineTokens
.
id
;
if
(
id
==
Token
.
END
)
{
lineTokens
=
lineTokens
.
prev
;
continue
;
}
int
len
=
lineTokens
.
length
;
if
(
id
==
idOfBracket
)
{
for
(
int
j
=
scanStartOffset
;
j
>=
Math
.
max
(
0
,
tokenListOffset
-
len
)
;
j
--
)
{
if
(
j
>=
lineText
.
count
)
System
.
err
.
println
(
"WARNING: "
+
j
+
" >= "
+
lineText
.
count
)
;
else
if
(
j
<
0
)
{
System
.
err
.
println
(
"sso="
+
scanStartOffset
+
", tlo="
+
tokenListOffset
+
",len="
+
len
)
;
System
.
err
.
println
(
"WARNING: "
+
j
+
" < 0"
)
;
}
char
ch
=
lineText
.
array
[
lineText
.
offset
+
j
]
;
if
(
ch
==
c
)
count
++
;
else
if
(
ch
==
cprime
)
{
if
(
--
count
==
0
)
return
lineStart
+
j
;
}
}
}
scanStartOffset
=
tokenListOffset
=
tokenListOffset
-
len
;
lineTokens
=
lineTokens
.
prev
;
}
}
}
else
{
count
=
0
;
for
(
int
i
=
line
;
i
<
endLine
;
i
++
)
{
lineElement
=
map
.
getElement
(
i
)
;
lineStart
=
lineElement
.
getStartOffset
(
)
;
buffer
.
getText
(
lineStart
,
lineElement
.
getEndOffset
(
)
-
lineStart
-
1
,
lineText
)
;
int
scanStartOffset
;
if
(
i
!=
line
)
{
lineTokens
=
buffer
.
markTokens
(
i
)
.
getFirstToken
(
)
;
tokenListOffset
=
0
;
scanStartOffset
=
0
;
}
else
scanStartOffset
=
offset
+
1
;
for
(
;
;
)
{
byte
id
=
lineTokens
.
id
;
if
(
id
==
Token
.
END
)
break
;
int
len
=
lineTokens
.
length
;
if
(
id
==
idOfBracket
)
{
for
(
int
j
=
scanStartOffset
;
j
<
tokenListOffset
+
len
;
j
++
)
{
char
ch
=
lineText
.
array
[
lineText
.
offset
+
j
]
;
if
(
ch
==
c
)
count
++
;
else
if
(
ch
==
cprime
)
{
if
(
count
--
==
0
)
return
lineStart
+
j
;
}
}
}
scanStartOffset
=
tokenListOffset
=
tokenListOffset
+
len
;
lineTokens
=
lineTokens
.
next
;
}
}
}
return
-
1
;
}
public
static
int
findWordStart
(
String
line
,
int
pos
,
String
noWordSep
)
{
char
ch
=
line
.
charAt
(
pos
)
;
if
(
noWordSep
==
null
)
noWordSep
=
""
;
boolean
selectNoLetter
=
(
!
Character
.
isLetterOrDigit
(
ch
)
&&
noWordSep
.
indexOf
(
ch
)
==
-
1
)
;
int
wordStart
=
0
;
for
(
int
i
=
pos
;
i
>=
0
;
i
--
)
{
ch
=
line
.
charAt
(
i
)
;
if
(
selectNoLetter
^
(
!
Character
.
isLetterOrDigit
(
ch
)
&&
noWordSep
.
indexOf
(
ch
)
==
-
1
)
)
{
wordStart
=
i
+
1
;
break
;
}
}
return
wordStart
;
}
public
static
int
findWordEnd
(
String
line
,
int
pos
,
String
noWordSep
)
{
if
(
pos
!=
0
)
pos
--
;
char
ch
=
line
.
charAt
(
pos
)
;
if
(
noWordSep
==
null
)
noWordSep
=
""
;
boolean
selectNoLetter
=
(
!
Character
.
isLetterOrDigit
(
ch
)
&&
noWordSep
.
indexOf
(
ch
)
==
-
1
)
;
int
wordEnd
=
line
.
length
(
)
;
for
(
int
i
=
pos
;
i
<
line
.
length
(
)
;
i
++
)
{
ch
=
line
.
charAt
(
i
)
;
if
(
selectNoLetter
^
(
!
Character
.
isLetterOrDigit
(
ch
)
&&
noWordSep
.
indexOf
(
ch
)
==
-
1
)
)
{
wordEnd
=
i
;
break
;
}
}
return
wordEnd
;
}
public
static
boolean
regionMatches
(
boolean
ignoreCase
,
Segment
text
,
int
offset
,
char
[
]
match
)
{
int
length
=
offset
+
match
.
length
;
char
[
]
textArray
=
text
.
array
;
if
(
length
>
text
.
offset
+
text
.
count
)
return
false
;
for
(
int
i
=
offset
,
j
=
0
;
i
<
length
;
i
++
,
j
++
)
{
char
c1
=
textArray
[
i
]
;
char
c2
=
match
[
j
]
;
if
(
ignoreCase
)
{
c1
=
Character
.
toUpperCase
(
c1
)
;
c2
=
Character
.
toUpperCase
(
c2
)
;
}
if
(
c1
!=
c2
)
return
false
;
}
return
true
;
}
public
static
String
spacesToTabs
(
String
in
,
int
tabSize
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
int
width
=
0
;
int
whitespace
=
0
;
for
(
int
i
=
0
;
i
<
in
.
length
(
)
;
i
++
)
{
switch
(
in
.
charAt
(
i
)
)
{
case
' '
:
whitespace
++
;
width
++
;
break
;
case
'\t'
:
int
tab
=
tabSize
-
(
width
%
tabSize
)
;
width
+=
tab
;
whitespace
+=
tab
;
break
;
case
'\n'
:
if
(
whitespace
!=
0
)
{
buf
.
append
(
MiscUtilities
.
createWhiteSpace
(
whitespace
,
tabSize
)
)
;
}
whitespace
=
0
;
width
=
0
;
buf
.
append
(
'\n'
)
;
break
;
default
:
if
(
whitespace
!=
0
)
{
buf
.
append
(
MiscUtilities
.
createWhiteSpace
(
whitespace
,
tabSize
)
)
;
whitespace
=
0
;
}
buf
.
append
(
in
.
charAt
(
i
)
)
;
width
++
;
break
;
}
}
if
(
whitespace
!=
0
)
{
buf
.
append
(
MiscUtilities
.
createWhiteSpace
(
whitespace
,
tabSize
)
)
;
}
return
buf
.
toString
(
)
;
}
public
static
String
tabsToSpaces
(
String
in
,
int
tabSize
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
int
width
=
0
;
for
(
int
i
=
0
;
i
<
in
.
length
(
)
;
i
++
)
{
switch
(
in
.
charAt
(
i
)
)
{
case
'\t'
:
int
count
=
tabSize
-
(
width
%
tabSize
)
;
width
+=
count
;
while
(
--
count
>=
0
)
buf
.
append
(
' '
)
;
break
;
case
'\n'
:
width
=
0
;
buf
.
append
(
in
.
charAt
(
i
)
)
;
break
;
default
:
width
++
;
buf
.
append
(
in
.
charAt
(
i
)
)
;
break
;
}
}
return
buf
.
toString
(
)
;
}
public
static
String
format
(
String
text
,
int
maxLineLength
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
StringBuffer
word
=
new
StringBuffer
(
)
;
int
lineLength
=
0
;
boolean
newline
=
true
;
boolean
space
=
false
;
char
[
]
chars
=
text
.
toCharArray
(
)
;
for
(
int
i
=
0
;
i
<
chars
.
length
;
i
++
)
{
char
c
=
chars
[
i
]
;
switch
(
c
)
{
case
'\n'
:
if
(
i
==
0
||
chars
.
length
-
i
<=
2
)
{
if
(
lineLength
+
word
.
length
(
)
>=
maxLineLength
)
buf
.
append
(
'\n'
)
;
else
if
(
space
&&
word
.
length
(
)
!=
0
)
buf
.
append
(
' '
)
;
buf
.
append
(
word
)
;
word
.
setLength
(
0
)
;
buf
.
append
(
'\n'
)
;
newline
=
true
;
space
=
false
;
break
;
}
else
if
(
newline
)
{
if
(
lineLength
+
word
.
length
(
)
>=
maxLineLength
)
buf
.
append
(
'\n'
)
;
else
if
(
space
&&
word
.
length
(
)
!=
0
)
buf
.
append
(
' '
)
;
buf
.
append
(
word
)
;
word
.
setLength
(
0
)
;
buf
.
append
(
"\n\n"
)
;
newline
=
space
=
false
;
lineLength
=
0
;
break
;
}
else
newline
=
true
;
case
' '
:
if
(
lineLength
+
word
.
length
(
)
>=
maxLineLength
)
{
buf
.
append
(
'\n'
)
;
lineLength
=
0
;
newline
=
true
;
}
else
if
(
space
&&
lineLength
!=
0
&&
word
.
length
(
)
!=
0
)
{
buf
.
append
(
' '
)
;
lineLength
++
;
space
=
false
;
}
else
space
=
true
;
buf
.
append
(
word
)
;
lineLength
+=
word
.
length
(
)
;
word
.
setLength
(
0
)
;
break
;
default
:
newline
=
false
;
if
(
lineLength
!=
0
)
space
=
true
;
word
.
append
(
c
)
;
break
;
}
}
if
(
lineLength
+
word
.
length
(
)
>=
maxLineLength
)
buf
.
append
(
'\n'
)
;
else
if
(
space
&&
word
.
length
(
)
!=
0
)
buf
.
append
(
' '
)
;
buf
.
append
(
word
)
;
return
buf
.
toString
(
)
;
}
}
