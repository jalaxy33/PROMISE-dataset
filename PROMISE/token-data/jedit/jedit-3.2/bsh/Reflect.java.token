package
bsh
;
import
java
.
lang
.
reflect
.
*
;
import
java
.
io
.
*
;
import
java
.
util
.
Vector
;
class
Reflect
{
public
static
Object
invokeObjectMethod
(
Interpreter
interpreter
,
Object
object
,
String
methodName
,
Object
[
]
args
,
SimpleNode
callerInfo
)
throws
ReflectError
,
InvocationTargetException
,
EvalError
{
if
(
object
instanceof
This
)
return
(
(
This
)
object
)
.
invokeMethod
(
methodName
,
args
,
interpreter
,
null
,
callerInfo
)
;
else
return
invokeMethod
(
object
.
getClass
(
)
,
object
,
methodName
,
args
,
false
)
;
}
public
static
Object
invokeStaticMethod
(
Class
clas
,
String
methodName
,
Object
[
]
args
)
throws
ReflectError
,
InvocationTargetException
,
EvalError
{
Interpreter
.
debug
(
"invoke static Method"
)
;
return
invokeMethod
(
clas
,
null
,
methodName
,
args
,
true
)
;
}
public
static
Object
getIndex
(
Object
array
,
int
index
)
throws
ReflectError
,
TargetError
{
try
{
Object
val
=
Array
.
get
(
array
,
index
)
;
return
wrapPrimitive
(
val
,
array
.
getClass
(
)
.
getComponentType
(
)
)
;
}
catch
(
ArrayIndexOutOfBoundsException
e1
)
{
throw
new
TargetError
(
"Array Index"
,
e1
)
;
}
catch
(
Exception
e
)
{
throw
new
ReflectError
(
"Array access:"
+
e
)
;
}
}
public
static
void
setIndex
(
Object
array
,
int
index
,
Object
val
)
throws
ReflectError
,
TargetError
{
try
{
val
=
unwrapPrimitive
(
val
)
;
Array
.
set
(
array
,
index
,
val
)
;
}
catch
(
ArrayStoreException
e2
)
{
throw
new
TargetError
(
"Array store exception"
,
e2
)
;
}
catch
(
IllegalArgumentException
e1
)
{
throw
new
TargetError
(
"Illegal Argument"
,
new
ArrayStoreException
(
e1
.
toString
(
)
)
)
;
}
catch
(
Exception
e
)
{
throw
new
ReflectError
(
"Array access:"
+
e
)
;
}
}
public
static
Object
getStaticField
(
Class
clas
,
String
fieldName
)
throws
ReflectError
{
return
getFieldValue
(
clas
,
null
,
fieldName
)
;
}
public
static
Object
getObjectField
(
Object
object
,
String
fieldName
)
throws
ReflectError
{
if
(
object
instanceof
This
)
return
(
(
This
)
object
)
.
namespace
.
getVariable
(
fieldName
)
;
else
{
try
{
return
getFieldValue
(
object
.
getClass
(
)
,
object
,
fieldName
)
;
}
catch
(
ReflectError
e
)
{
if
(
hasObjectPropertyGetter
(
object
.
getClass
(
)
,
fieldName
)
)
return
getObjectProperty
(
object
,
fieldName
)
;
else
throw
e
;
}
}
}
static
LHS
getLHSStaticField
(
Class
clas
,
String
fieldName
)
throws
ReflectError
{
Field
f
=
getField
(
clas
,
fieldName
)
;
return
new
LHS
(
f
)
;
}
static
LHS
getLHSObjectField
(
Object
object
,
String
fieldName
)
throws
ReflectError
{
if
(
object
instanceof
This
)
return
new
LHS
(
(
(
This
)
object
)
.
namespace
,
fieldName
)
;
try
{
Field
f
=
getField
(
object
.
getClass
(
)
,
fieldName
)
;
return
new
LHS
(
object
,
f
)
;
}
catch
(
ReflectError
e
)
{
if
(
hasObjectPropertySetter
(
object
.
getClass
(
)
,
fieldName
)
)
return
new
LHS
(
object
,
fieldName
)
;
else
throw
e
;
}
}
private
static
Object
getFieldValue
(
Class
clas
,
Object
object
,
String
fieldName
)
throws
ReflectError
{
try
{
Field
f
=
getField
(
clas
,
fieldName
)
;
if
(
f
==
null
)
throw
new
ReflectError
(
"internal: field not found:"
+
fieldName
)
;
Object
value
=
f
.
get
(
object
)
;
Class
returnType
=
f
.
getType
(
)
;
return
wrapPrimitive
(
value
,
returnType
)
;
}
catch
(
NullPointerException
e
)
{
throw
new
ReflectError
(
"???"
+
fieldName
+
" is not a static field."
)
;
}
catch
(
IllegalAccessException
e
)
{
throw
new
ReflectError
(
"Can't access field: "
+
fieldName
)
;
}
}
private
static
Field
getField
(
Class
clas
,
String
fieldName
)
throws
ReflectError
{
try
{
if
(
Capabilities
.
haveAccessibility
(
)
)
return
findAccessibleField
(
clas
,
fieldName
)
;
else
return
clas
.
getField
(
fieldName
)
;
}
catch
(
NoSuchFieldException
e
)
{
throw
new
ReflectError
(
"No such field: "
+
fieldName
)
;
}
}
private
static
Field
findAccessibleField
(
Class
clas
,
String
fieldName
)
throws
NoSuchFieldException
{
while
(
clas
!=
null
)
{
try
{
Field
field
=
clas
.
getDeclaredField
(
fieldName
)
;
if
(
ReflectManager
.
RMSetAccessible
(
field
)
)
return
field
;
}
catch
(
NoSuchFieldException
e
)
{
}
clas
=
clas
.
getSuperclass
(
)
;
}
throw
new
NoSuchFieldException
(
fieldName
)
;
}
private
static
Object
invokeMethod
(
Class
clas
,
Object
object
,
String
name
,
Object
[
]
args
,
boolean
onlyStatic
)
throws
ReflectError
,
InvocationTargetException
,
EvalError
{
if
(
object
==
Primitive
.
NULL
)
throw
new
TargetError
(
"Attempt to invoke method "
+
name
+
" on null value"
,
new
NullPointerException
(
)
)
;
if
(
object
==
Primitive
.
VOID
)
throw
new
EvalError
(
"Attempt to invoke method "
+
name
+
" on undefined variable or class name"
)
;
if
(
args
==
null
)
args
=
new
Object
[
]
{
}
;
for
(
int
i
=
0
;
i
<
args
.
length
;
i
++
)
if
(
args
[
i
]
==
Primitive
.
VOID
)
throw
new
ReflectError
(
"Attempt to pass void argument "
+
"(position "
+
i
+
") to method: "
+
name
)
;
Class
returnType
=
null
;
Object
returnValue
=
null
;
Class
[
]
types
=
getTypes
(
args
)
;
unwrapPrimitives
(
args
)
;
try
{
Method
m
=
null
;
try
{
m
=
findAccessibleMethod
(
clas
,
name
,
types
,
onlyStatic
)
;
}
catch
(
SecurityException
e
)
{
}
if
(
m
==
null
)
Interpreter
.
debug
(
"Exact method "
+
StringUtil
.
methodString
(
name
,
types
)
+
" not found in '"
+
clas
.
getName
(
)
+
"'"
)
;
if
(
m
==
null
)
{
if
(
types
.
length
==
0
)
throw
new
ReflectError
(
"No args "
+
(
onlyStatic
?
"static "
:
""
)
+
"method "
+
StringUtil
.
methodString
(
name
,
types
)
+
" not found in class'"
+
clas
.
getName
(
)
+
"'"
)
;
Method
[
]
methods
=
clas
.
getMethods
(
)
;
if
(
onlyStatic
)
methods
=
retainStaticMethods
(
methods
)
;
m
=
findMostSpecificMethod
(
name
,
types
,
methods
)
;
methods
=
clas
.
getMethods
(
)
;
if
(
m
==
null
)
m
=
findExtendedMethod
(
name
,
args
,
methods
)
;
if
(
m
!=
null
)
{
try
{
m
=
findAccessibleMethod
(
clas
,
m
.
getName
(
)
,
m
.
getParameterTypes
(
)
,
onlyStatic
)
;
}
catch
(
SecurityException
e
)
{
}
}
}
if
(
m
==
null
)
throw
new
ReflectError
(
(
onlyStatic
?
"Static method "
:
"Method "
)
+
StringUtil
.
methodString
(
name
,
types
)
+
" not found in class'"
+
clas
.
getName
(
)
+
"'"
)
;
returnValue
=
m
.
invoke
(
object
,
args
)
;
if
(
returnValue
==
null
)
returnValue
=
Primitive
.
NULL
;
returnType
=
m
.
getReturnType
(
)
;
}
catch
(
IllegalAccessException
e
)
{
throw
new
ReflectError
(
"Cannot access method "
+
StringUtil
.
methodString
(
name
,
types
)
+
" in '"
+
clas
.
getName
(
)
+
"' :"
+
e
)
;
}
return
wrapPrimitive
(
returnValue
,
returnType
)
;
}
private
static
Method
[
]
retainStaticMethods
(
Method
[
]
methods
)
{
Vector
v
=
new
Vector
(
)
;
for
(
int
i
=
0
;
i
<
methods
.
length
;
i
++
)
if
(
Modifier
.
isStatic
(
methods
[
i
]
.
getModifiers
(
)
)
)
v
.
addElement
(
methods
[
i
]
)
;
Method
[
]
ma
=
new
Method
[
v
.
size
(
)
]
;
v
.
copyInto
(
ma
)
;
return
ma
;
}
static
Method
findAccessibleMethod
(
Class
clas
,
String
name
,
Class
[
]
types
,
boolean
onlyStatic
)
{
Method
meth
=
null
;
Vector
classQ
=
new
Vector
(
)
;
classQ
.
addElement
(
clas
)
;
Method
found
=
null
;
while
(
classQ
.
size
(
)
>
0
)
{
Class
c
=
(
Class
)
classQ
.
firstElement
(
)
;
classQ
.
removeElementAt
(
0
)
;
if
(
Modifier
.
isPublic
(
c
.
getModifiers
(
)
)
||
(
Capabilities
.
haveAccessibility
(
)
&&
ReflectManager
.
RMSetAccessible
(
c
)
)
)
{
try
{
meth
=
c
.
getDeclaredMethod
(
name
,
types
)
;
if
(
Modifier
.
isPublic
(
meth
.
getModifiers
(
)
)
||
(
Capabilities
.
haveAccessibility
(
)
&&
ReflectManager
.
RMSetAccessible
(
meth
)
)
)
{
found
=
meth
;
break
;
}
}
catch
(
NoSuchMethodException
e
)
{
}
}
if
(
!
c
.
isInterface
(
)
)
{
Class
superclass
=
c
.
getSuperclass
(
)
;
if
(
superclass
!=
null
)
classQ
.
addElement
(
(
Object
)
superclass
)
;
}
Class
[
]
intfs
=
c
.
getInterfaces
(
)
;
for
(
int
i
=
0
;
i
<
intfs
.
length
;
i
++
)
classQ
.
addElement
(
(
Object
)
intfs
[
i
]
)
;
}
if
(
found
!=
null
&&
(
!
onlyStatic
||
Modifier
.
isStatic
(
found
.
getModifiers
(
)
)
)
)
return
found
;
return
null
;
}
private
static
Object
wrapPrimitive
(
Object
value
,
Class
returnType
)
throws
ReflectError
{
if
(
value
==
null
)
return
Primitive
.
NULL
;
if
(
returnType
==
Void
.
TYPE
)
return
Primitive
.
VOID
;
else
if
(
returnType
.
isPrimitive
(
)
)
{
if
(
value
instanceof
Number
)
return
new
Primitive
(
(
Number
)
value
)
;
if
(
value
instanceof
Boolean
)
return
new
Primitive
(
(
Boolean
)
value
)
;
if
(
value
instanceof
Character
)
return
new
Primitive
(
(
Character
)
value
)
;
throw
new
ReflectError
(
"Something bad happened"
)
;
}
else
return
value
;
}
public
static
Class
[
]
getTypes
(
Object
[
]
args
)
{
if
(
args
==
null
)
return
new
Class
[
0
]
;
Class
[
]
types
=
new
Class
[
args
.
length
]
;
for
(
int
i
=
0
;
i
<
args
.
length
;
i
++
)
{
if
(
args
[
i
]
instanceof
Primitive
)
types
[
i
]
=
(
(
Primitive
)
args
[
i
]
)
.
getType
(
)
;
else
types
[
i
]
=
args
[
i
]
.
getClass
(
)
;
}
return
types
;
}
private
static
void
unwrapPrimitives
(
Object
[
]
args
)
{
for
(
int
i
=
0
;
i
<
args
.
length
;
i
++
)
args
[
i
]
=
unwrapPrimitive
(
args
[
i
]
)
;
}
private
static
Object
unwrapPrimitive
(
Object
arg
)
{
if
(
arg
instanceof
Primitive
)
return
(
(
Primitive
)
arg
)
.
getValue
(
)
;
else
return
arg
;
}
static
Object
constructObject
(
String
clas
,
Object
[
]
args
)
throws
ReflectError
,
InvocationTargetException
{
Class
c
=
BshClassManager
.
classForName
(
clas
)
;
if
(
c
==
null
)
throw
new
ReflectError
(
"Class not found: "
+
clas
)
;
return
constructObject
(
c
,
args
)
;
}
static
Object
constructObject
(
Class
clas
,
Object
[
]
args
)
throws
ReflectError
,
InvocationTargetException
{
for
(
int
i
=
0
;
i
<
args
.
length
;
i
++
)
if
(
args
[
i
]
==
Primitive
.
VOID
)
throw
new
ReflectError
(
"Attempt to pass void argument "
+
"(position "
+
i
+
") to constructor for: "
+
clas
)
;
if
(
clas
.
isInterface
(
)
)
throw
new
ReflectError
(
"Can't create instance of an interface: "
+
clas
)
;
Object
obj
=
null
;
Class
[
]
types
=
getTypes
(
args
)
;
unwrapPrimitives
(
args
)
;
Constructor
con
=
null
;
Constructor
[
]
constructors
=
clas
.
getDeclaredConstructors
(
)
;
Interpreter
.
debug
(
"Looking for most specific constructor: "
+
clas
)
;
con
=
findMostSpecificConstructor
(
types
,
constructors
)
;
if
(
con
==
null
)
if
(
types
.
length
==
0
)
throw
new
ReflectError
(
"Can't find default constructor for: "
+
clas
)
;
else
con
=
findExtendedConstructor
(
args
,
constructors
)
;
if
(
con
==
null
)
throw
new
ReflectError
(
"Can't find constructor: "
+
clas
)
;
try
{
obj
=
con
.
newInstance
(
args
)
;
}
catch
(
InstantiationException
e
)
{
throw
new
ReflectError
(
"the class is abstract "
)
;
}
catch
(
IllegalAccessException
e
)
{
throw
new
ReflectError
(
"we don't have permission to create an instance"
)
;
}
catch
(
IllegalArgumentException
e
)
{
throw
new
ReflectError
(
"the number of arguments was wrong"
)
;
}
if
(
obj
==
null
)
throw
new
ReflectError
(
"couldn't construct the object"
)
;
return
obj
;
}
static
Method
findMostSpecificMethod
(
String
name
,
Class
[
]
idealMatch
,
Method
[
]
methods
)
{
Vector
sigs
=
new
Vector
(
)
;
Vector
meths
=
new
Vector
(
)
;
for
(
int
i
=
0
;
i
<
methods
.
length
;
i
++
)
if
(
methods
[
i
]
.
getName
(
)
.
equals
(
name
)
)
{
meths
.
addElement
(
methods
[
i
]
)
;
sigs
.
addElement
(
methods
[
i
]
.
getParameterTypes
(
)
)
;
}
Class
[
]
[
]
candidates
=
new
Class
[
sigs
.
size
(
)
]
[
]
;
sigs
.
copyInto
(
candidates
)
;
Interpreter
.
debug
(
"Looking for most specific method: "
+
name
)
;
int
match
=
findMostSpecificSignature
(
idealMatch
,
candidates
)
;
if
(
match
==
-
1
)
return
null
;
else
return
(
Method
)
meths
.
elementAt
(
match
)
;
}
static
Method
findExtendedMethod
(
String
name
,
Object
[
]
args
,
Method
[
]
methods
)
{
Method
bestMatch
=
null
;
Object
[
]
tempArgs
=
new
Object
[
args
.
length
]
;
for
(
int
i
=
0
;
i
<
methods
.
length
;
i
++
)
{
Method
currentMethod
=
methods
[
i
]
;
if
(
name
.
equals
(
currentMethod
.
getName
(
)
)
)
{
Class
[
]
parameters
=
currentMethod
.
getParameterTypes
(
)
;
if
(
parameters
.
length
!=
args
.
length
)
continue
;
try
{
for
(
int
j
=
0
;
j
<
parameters
.
length
;
j
++
)
tempArgs
[
j
]
=
NameSpace
.
getAssignableForm
(
args
[
j
]
,
parameters
[
j
]
)
;
System
.
arraycopy
(
tempArgs
,
0
,
args
,
0
,
args
.
length
)
;
return
currentMethod
;
}
catch
(
EvalError
e
)
{
}
}
}
return
null
;
}
static
Constructor
findMostSpecificConstructor
(
Class
[
]
idealMatch
,
Constructor
[
]
constructors
)
{
Class
[
]
[
]
candidates
=
new
Class
[
constructors
.
length
]
[
]
;
for
(
int
i
=
0
;
i
<
candidates
.
length
;
i
++
)
candidates
[
i
]
=
constructors
[
i
]
.
getParameterTypes
(
)
;
int
match
=
findMostSpecificSignature
(
idealMatch
,
candidates
)
;
if
(
match
==
-
1
)
return
null
;
else
return
constructors
[
match
]
;
}
static
Constructor
findExtendedConstructor
(
Object
[
]
args
,
Constructor
[
]
constructors
)
{
Constructor
bestMatch
=
null
;
Object
[
]
tempArgs
=
new
Object
[
args
.
length
]
;
for
(
int
i
=
0
;
i
<
constructors
.
length
;
i
++
)
{
Constructor
currentConstructor
=
constructors
[
i
]
;
Class
[
]
parameters
=
currentConstructor
.
getParameterTypes
(
)
;
if
(
parameters
.
length
!=
args
.
length
)
continue
;
try
{
for
(
int
j
=
0
;
j
<
parameters
.
length
;
j
++
)
tempArgs
[
j
]
=
NameSpace
.
getAssignableForm
(
args
[
j
]
,
parameters
[
j
]
)
;
System
.
arraycopy
(
tempArgs
,
0
,
args
,
0
,
args
.
length
)
;
return
currentConstructor
;
}
catch
(
EvalError
e
)
{
}
}
return
null
;
}
static
int
findMostSpecificSignature
(
Class
[
]
idealMatch
,
Class
[
]
[
]
candidates
)
{
Class
[
]
bestMatch
=
null
;
int
bestMatchIndex
=
-
1
;
for
(
int
i
=
0
;
i
<
candidates
.
length
;
i
++
)
{
Class
[
]
targetMatch
=
candidates
[
i
]
;
if
(
isAssignable
(
idealMatch
,
targetMatch
)
&&
(
(
bestMatch
==
null
)
||
isAssignable
(
targetMatch
,
bestMatch
)
)
)
{
bestMatch
=
targetMatch
;
bestMatchIndex
=
i
;
}
}
if
(
bestMatch
!=
null
)
{
return
bestMatchIndex
;
}
else
{
Interpreter
.
debug
(
"no match found"
)
;
return
-
1
;
}
}
static
boolean
isAssignable
(
Class
[
]
from
,
Class
[
]
to
)
{
if
(
from
==
null
)
from
=
new
Class
[
0
]
;
if
(
to
==
null
)
to
=
new
Class
[
0
]
;
if
(
from
.
length
!=
to
.
length
)
return
false
;
for
(
int
i
=
0
;
i
<
from
.
length
;
i
++
)
{
if
(
to
[
i
]
==
null
)
continue
;
if
(
from
[
i
]
==
null
)
{
if
(
!
(
to
[
i
]
.
isPrimitive
(
)
)
)
continue
;
else
return
false
;
}
if
(
!
isAssignableFrom
(
to
[
i
]
,
from
[
i
]
)
)
return
false
;
}
return
true
;
}
static
boolean
isAssignableFrom
(
Class
lhs
,
Class
rhs
)
{
if
(
lhs
.
isPrimitive
(
)
&&
rhs
.
isPrimitive
(
)
)
{
if
(
lhs
==
rhs
)
return
true
;
if
(
(
rhs
==
Byte
.
TYPE
)
&&
(
lhs
==
Short
.
TYPE
||
lhs
==
Integer
.
TYPE
||
lhs
==
Long
.
TYPE
||
lhs
==
Float
.
TYPE
||
lhs
==
Double
.
TYPE
)
)
return
true
;
if
(
(
rhs
==
Short
.
TYPE
)
&&
(
lhs
==
Integer
.
TYPE
||
lhs
==
Long
.
TYPE
||
lhs
==
Float
.
TYPE
||
lhs
==
Double
.
TYPE
)
)
return
true
;
if
(
(
rhs
==
Character
.
TYPE
)
&&
(
lhs
==
Integer
.
TYPE
||
lhs
==
Long
.
TYPE
||
lhs
==
Float
.
TYPE
||
lhs
==
Double
.
TYPE
)
)
return
true
;
if
(
(
rhs
==
Integer
.
TYPE
)
&&
(
lhs
==
Long
.
TYPE
||
lhs
==
Float
.
TYPE
||
lhs
==
Double
.
TYPE
)
)
return
true
;
if
(
(
rhs
==
Long
.
TYPE
)
&&
(
lhs
==
Float
.
TYPE
||
lhs
==
Double
.
TYPE
)
)
return
true
;
if
(
(
rhs
==
Float
.
TYPE
)
&&
(
lhs
==
Double
.
TYPE
)
)
return
true
;
}
else
if
(
lhs
.
isAssignableFrom
(
rhs
)
)
return
true
;
return
false
;
}
private
static
String
accessorName
(
String
getorset
,
String
propName
)
{
return
getorset
+
String
.
valueOf
(
Character
.
toUpperCase
(
propName
.
charAt
(
0
)
)
)
+
propName
.
substring
(
1
)
;
}
public
static
boolean
hasObjectPropertyGetter
(
Class
clas
,
String
propName
)
{
String
getterName
=
accessorName
(
"get"
,
propName
)
;
try
{
clas
.
getMethod
(
getterName
,
new
Class
[
0
]
)
;
return
true
;
}
catch
(
NoSuchMethodException
e
)
{
return
false
;
}
}
public
static
boolean
hasObjectPropertySetter
(
Class
clas
,
String
propName
)
{
String
setterName
=
accessorName
(
"set"
,
propName
)
;
Class
[
]
sig
=
new
Class
[
]
{
clas
}
;
Method
[
]
methods
=
clas
.
getMethods
(
)
;
for
(
int
i
=
0
;
i
<
methods
.
length
;
i
++
)
if
(
methods
[
i
]
.
getName
(
)
.
equals
(
setterName
)
)
return
true
;
return
false
;
}
public
static
Object
getObjectProperty
(
Object
obj
,
String
propName
)
throws
ReflectError
{
String
accessorName
=
accessorName
(
"get"
,
propName
)
;
Object
[
]
args
=
new
Object
[
]
{
}
;
Interpreter
.
debug
(
"property access: "
)
;
try
{
try
{
return
invokeObjectMethod
(
null
,
obj
,
accessorName
,
args
,
null
)
;
}
catch
(
EvalError
e
)
{
throw
new
ReflectError
(
"getter: "
+
e
)
;
}
}
catch
(
InvocationTargetException
e
)
{
throw
new
ReflectError
(
"Property accessor threw exception:"
+
e
)
;
}
}
public
static
void
setObjectProperty
(
Object
obj
,
String
propName
,
Object
value
)
throws
ReflectError
,
EvalError
{
String
accessorName
=
accessorName
(
"set"
,
propName
)
;
Object
[
]
args
=
new
Object
[
]
{
value
}
;
Interpreter
.
debug
(
"property access: "
)
;
try
{
invokeObjectMethod
(
null
,
obj
,
accessorName
,
args
,
null
)
;
}
catch
(
InvocationTargetException
e
)
{
throw
new
EvalError
(
"Property accessor threw exception!"
)
;
}
}
public
static
String
normalizeClassName
(
Class
type
)
{
if
(
!
type
.
isArray
(
)
)
return
type
.
getName
(
)
;
StringBuffer
className
=
new
StringBuffer
(
)
;
try
{
className
.
append
(
getArrayBaseType
(
type
)
.
getName
(
)
)
;
for
(
int
i
=
0
;
i
<
getArrayDimensions
(
type
)
;
i
++
)
className
.
append
(
"[]"
)
;
}
catch
(
Exception
e
)
{
}
return
className
.
toString
(
)
;
}
public
static
int
getArrayDimensions
(
Class
arrayClass
)
{
if
(
!
arrayClass
.
isArray
(
)
)
return
0
;
return
arrayClass
.
getName
(
)
.
lastIndexOf
(
'['
)
+
1
;
}
public
static
Class
getArrayBaseType
(
Class
arrayClass
)
throws
ReflectError
{
if
(
!
arrayClass
.
isArray
(
)
)
throw
new
ReflectError
(
"The class is not an array."
)
;
return
arrayClass
.
getComponentType
(
)
;
}
}
