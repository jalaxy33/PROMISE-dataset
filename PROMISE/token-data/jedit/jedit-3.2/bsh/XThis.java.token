package
bsh
;
import
java
.
lang
.
reflect
.
*
;
import
java
.
lang
.
reflect
.
InvocationHandler
;
import
java
.
io
.
*
;
class
XThis
extends
This
{
InvocationHandler
invocationHandler
=
new
Handler
(
)
;
XThis
(
NameSpace
namespace
,
Interpreter
declaringInterp
)
{
super
(
namespace
,
declaringInterp
)
;
}
public
String
toString
(
)
{
return
"'this' reference (XThis) to Bsh object: "
+
namespace
.
name
;
}
String
toStringShowInts
(
Class
[
]
ints
)
{
StringBuffer
sb
=
new
StringBuffer
(
toString
(
)
+
"\nimplements:"
)
;
for
(
int
i
=
0
;
i
<
ints
.
length
;
i
++
)
sb
.
append
(
" "
+
ints
[
i
]
.
getName
(
)
+
(
(
ints
.
length
>
1
)
?
","
:
""
)
)
;
return
sb
.
toString
(
)
;
}
public
Object
getInterface
(
Class
clas
)
{
return
Proxy
.
newProxyInstance
(
clas
.
getClassLoader
(
)
,
new
Class
[
]
{
clas
}
,
invocationHandler
)
;
}
class
Handler
implements
InvocationHandler
,
java
.
io
.
Serializable
{
public
Object
invoke
(
Object
proxy
,
Method
method
,
Object
[
]
args
)
throws
EvalError
{
Class
[
]
sig
=
Reflect
.
getTypes
(
args
)
;
BshMethod
bmethod
=
namespace
.
getMethod
(
method
.
getName
(
)
,
sig
)
;
if
(
bmethod
!=
null
)
return
Primitive
.
unwrap
(
bmethod
.
invokeDeclaredMethod
(
args
,
declaringInterpreter
,
callstack
,
null
)
)
;
bmethod
=
namespace
.
getMethod
(
"invoke"
,
new
Class
[
]
{
null
,
null
}
)
;
if
(
bmethod
!=
null
)
return
Primitive
.
unwrap
(
bmethod
.
invokeDeclaredMethod
(
new
Object
[
]
{
method
.
getName
(
)
,
args
}
,
declaringInterpreter
,
callstack
,
null
)
)
;
if
(
method
.
getName
(
)
.
equals
(
"toString"
)
)
return
toStringShowInts
(
proxy
.
getClass
(
)
.
getInterfaces
(
)
)
;
if
(
method
.
getName
(
)
.
equals
(
"hashCode"
)
)
return
new
Integer
(
this
.
hashCode
(
)
)
;
if
(
method
.
getName
(
)
.
equals
(
"equals"
)
)
{
Object
obj
=
args
[
0
]
;
return
new
Boolean
(
proxy
==
obj
)
;
}
throw
new
EvalError
(
"Bsh script method: "
+
method
.
getName
(
)
+
" not found in namespace: "
+
namespace
.
name
)
;
}
}
;
private
synchronized
void
writeObject
(
ObjectOutputStream
s
)
throws
IOException
{
NameSpace
parent
=
namespace
.
getParent
(
)
;
Interpreter
interpreter
=
declaringInterpreter
;
namespace
.
prune
(
)
;
s
.
defaultWriteObject
(
)
;
namespace
.
setParent
(
parent
)
;
declaringInterpreter
=
interpreter
;
}
}
