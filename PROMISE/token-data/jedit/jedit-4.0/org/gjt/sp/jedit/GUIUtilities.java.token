package
org
.
gjt
.
sp
.
jedit
;
import
gnu
.
regexp
.
REException
;
import
javax
.
swing
.
*
;
import
java
.
awt
.
*
;
import
java
.
awt
.
event
.
*
;
import
java
.
io
.
File
;
import
java
.
net
.
*
;
import
java
.
util
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
browser
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
gui
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
io
.
VFS
;
import
org
.
gjt
.
sp
.
jedit
.
msg
.
PropertiesChanged
;
import
org
.
gjt
.
sp
.
jedit
.
syntax
.
SyntaxStyle
;
import
org
.
gjt
.
sp
.
jedit
.
syntax
.
Token
;
import
org
.
gjt
.
sp
.
util
.
Log
;
public
class
GUIUtilities
{
public
static
final
Icon
NEW_BUFFER_ICON
=
loadIcon
(
"new.gif"
)
;
public
static
final
Icon
DIRTY_BUFFER_ICON
=
loadIcon
(
"dirty.gif"
)
;
public
static
final
Icon
READ_ONLY_BUFFER_ICON
=
loadIcon
(
"readonly.gif"
)
;
public
static
final
Icon
NORMAL_BUFFER_ICON
=
loadIcon
(
"normal.gif"
)
;
public
static
final
Icon
WINDOW_ICON
=
loadIcon
(
"jedit-icon.gif"
)
;
public
static
Icon
loadIcon
(
String
iconName
)
{
if
(
icons
==
null
)
icons
=
new
Hashtable
(
)
;
Icon
icon
=
(
Icon
)
icons
.
get
(
iconName
)
;
if
(
icon
!=
null
)
return
icon
;
if
(
iconName
.
startsWith
(
"file:"
)
)
{
icon
=
new
ImageIcon
(
iconName
.
substring
(
5
)
)
;
}
else
{
URL
url
=
GUIUtilities
.
class
.
getResource
(
"/org/gjt/sp/jedit/icons/"
+
iconName
)
;
if
(
url
==
null
)
{
Log
.
log
(
Log
.
ERROR
,
GUIUtilities
.
class
,
"Icon not found: "
+
iconName
)
;
return
null
;
}
icon
=
new
ImageIcon
(
url
)
;
}
icons
.
put
(
iconName
,
icon
)
;
return
icon
;
}
public
static
Image
getEditorIcon
(
)
{
return
(
(
ImageIcon
)
WINDOW_ICON
)
.
getImage
(
)
;
}
public
static
Image
getPluginIcon
(
)
{
return
(
(
ImageIcon
)
WINDOW_ICON
)
.
getImage
(
)
;
}
public
static
JMenuBar
loadMenuBar
(
String
name
)
{
String
menus
=
jEdit
.
getProperty
(
name
)
;
StringTokenizer
st
=
new
StringTokenizer
(
menus
)
;
JMenuBar
mbar
=
new
JMenuBar
(
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
String
menu
=
st
.
nextToken
(
)
;
if
(
menu
.
equals
(
"plugins"
)
)
loadPluginsMenu
(
mbar
)
;
else
mbar
.
add
(
loadMenu
(
menu
)
)
;
}
return
mbar
;
}
public
static
JMenu
loadMenu
(
View
view
,
String
name
)
{
return
loadMenu
(
name
)
;
}
public
static
JMenu
loadMenu
(
String
name
)
{
if
(
name
.
equals
(
"open-encoding"
)
)
return
new
OpenWithEncodingMenu
(
)
;
else
if
(
name
.
equals
(
"recent-files"
)
)
return
new
RecentFilesMenu
(
)
;
else
if
(
name
.
equals
(
"recent-directories"
)
)
return
new
RecentDirectoriesMenu
(
)
;
else
if
(
name
.
equals
(
"current-directory"
)
)
return
new
CurrentDirectoryMenu
(
)
;
else
if
(
name
.
equals
(
"markers"
)
)
return
new
MarkersMenu
(
)
;
else
if
(
name
.
equals
(
"macros"
)
)
return
new
MacrosMenu
(
)
;
else
return
new
EnhancedMenu
(
name
)
;
}
public
static
JPopupMenu
loadPopupMenu
(
String
name
)
{
JPopupMenu
menu
=
new
JPopupMenu
(
)
;
String
menuItems
=
jEdit
.
getProperty
(
name
)
;
if
(
menuItems
!=
null
)
{
StringTokenizer
st
=
new
StringTokenizer
(
menuItems
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
String
menuItemName
=
st
.
nextToken
(
)
;
if
(
menuItemName
.
equals
(
"-"
)
)
menu
.
addSeparator
(
)
;
else
{
if
(
menuItemName
.
startsWith
(
"%"
)
)
menu
.
add
(
loadMenu
(
menuItemName
.
substring
(
1
)
)
)
;
else
menu
.
add
(
loadMenuItem
(
menuItemName
,
false
)
)
;
}
}
}
return
menu
;
}
public
static
JMenuItem
loadMenuItem
(
String
name
)
{
return
loadMenuItem
(
name
,
true
)
;
}
public
static
JMenuItem
loadMenuItem
(
String
name
,
boolean
setMnemonic
)
{
EditAction
action
=
jEdit
.
getAction
(
name
)
;
String
label
=
(
action
==
null
?
jEdit
.
getProperty
(
name
+
".label"
)
:
action
.
getLabel
(
)
)
;
if
(
label
==
null
)
label
=
name
;
char
mnemonic
;
int
index
=
label
.
indexOf
(
'$'
)
;
if
(
index
!=
-
1
&&
label
.
length
(
)
-
index
>
1
)
{
mnemonic
=
Character
.
toLowerCase
(
label
.
charAt
(
index
+
1
)
)
;
label
=
label
.
substring
(
0
,
index
)
.
concat
(
label
.
substring
(
++
index
)
)
;
}
else
mnemonic
=
'\0'
;
JMenuItem
mi
;
if
(
action
!=
null
&&
action
.
isToggle
(
)
)
mi
=
new
EnhancedCheckBoxMenuItem
(
label
,
action
)
;
else
mi
=
new
EnhancedMenuItem
(
label
,
action
)
;
if
(
!
OperatingSystem
.
isMacOS
(
)
&&
setMnemonic
&&
mnemonic
!=
'\0'
)
mi
.
setMnemonic
(
mnemonic
)
;
return
mi
;
}
public
static
JToolBar
loadToolBar
(
String
name
)
{
JToolBar
toolBar
=
new
JToolBar
(
)
;
toolBar
.
setFloatable
(
false
)
;
toolBar
.
putClientProperty
(
"JToolBar.isRollover"
,
Boolean
.
TRUE
)
;
String
buttons
=
jEdit
.
getProperty
(
name
)
;
if
(
buttons
!=
null
)
{
StringTokenizer
st
=
new
StringTokenizer
(
buttons
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
String
button
=
st
.
nextToken
(
)
;
if
(
button
.
equals
(
"-"
)
)
toolBar
.
addSeparator
(
)
;
else
{
JButton
b
=
loadToolButton
(
button
)
;
if
(
b
!=
null
)
toolBar
.
add
(
b
)
;
}
}
}
return
toolBar
;
}
public
static
EnhancedButton
loadToolButton
(
String
name
)
{
EditAction
action
=
jEdit
.
getAction
(
name
)
;
String
label
=
(
action
==
null
?
jEdit
.
getProperty
(
name
+
".label"
)
:
action
.
getLabel
(
)
)
;
if
(
label
==
null
)
label
=
name
;
Icon
icon
;
String
iconName
=
jEdit
.
getProperty
(
name
+
".icon"
)
;
if
(
iconName
==
null
)
return
null
;
else
{
icon
=
loadIcon
(
iconName
)
;
if
(
icon
==
null
)
return
null
;
}
String
toolTip
=
prettifyMenuLabel
(
label
)
;
String
shortcut1
=
jEdit
.
getProperty
(
name
+
".shortcut"
)
;
String
shortcut2
=
jEdit
.
getProperty
(
name
+
".shortcut2"
)
;
if
(
shortcut1
!=
null
||
shortcut2
!=
null
)
{
toolTip
=
toolTip
+
" ("
+
(
shortcut1
!=
null
?
shortcut1
:
""
)
+
(
(
shortcut1
!=
null
&&
shortcut2
!=
null
)
?
" or "
:
""
)
+
(
shortcut2
!=
null
?
shortcut2
:
""
)
+
")"
;
}
return
new
EnhancedButton
(
icon
,
toolTip
,
action
)
;
}
public
static
String
prettifyMenuLabel
(
String
label
)
{
int
index
=
label
.
indexOf
(
'$'
)
;
if
(
index
!=
-
1
)
{
label
=
label
.
substring
(
0
,
index
)
.
concat
(
label
.
substring
(
index
+
1
)
)
;
}
return
label
;
}
public
static
void
message
(
Component
comp
,
String
name
,
Object
[
]
args
)
{
hideSplashScreen
(
)
;
JOptionPane
.
showMessageDialog
(
comp
,
jEdit
.
getProperty
(
name
.
concat
(
".message"
)
,
args
)
,
jEdit
.
getProperty
(
name
.
concat
(
".title"
)
,
args
)
,
JOptionPane
.
INFORMATION_MESSAGE
)
;
}
public
static
void
error
(
Component
comp
,
String
name
,
Object
[
]
args
)
{
hideSplashScreen
(
)
;
JOptionPane
.
showMessageDialog
(
comp
,
jEdit
.
getProperty
(
name
.
concat
(
".message"
)
,
args
)
,
jEdit
.
getProperty
(
name
.
concat
(
".title"
)
,
args
)
,
JOptionPane
.
ERROR_MESSAGE
)
;
}
public
static
String
input
(
Component
comp
,
String
name
,
Object
def
)
{
return
input
(
comp
,
name
,
null
,
def
)
;
}
public
static
String
inputProperty
(
Component
comp
,
String
name
,
String
def
)
{
return
inputProperty
(
comp
,
name
,
null
,
def
)
;
}
public
static
String
input
(
Component
comp
,
String
name
,
Object
[
]
args
,
Object
def
)
{
hideSplashScreen
(
)
;
String
retVal
=
(
String
)
JOptionPane
.
showInputDialog
(
comp
,
jEdit
.
getProperty
(
name
.
concat
(
".message"
)
,
args
)
,
jEdit
.
getProperty
(
name
.
concat
(
".title"
)
)
,
JOptionPane
.
QUESTION_MESSAGE
,
null
,
null
,
def
)
;
return
retVal
;
}
public
static
String
inputProperty
(
Component
comp
,
String
name
,
Object
[
]
args
,
String
def
)
{
hideSplashScreen
(
)
;
String
retVal
=
(
String
)
JOptionPane
.
showInputDialog
(
comp
,
jEdit
.
getProperty
(
name
.
concat
(
".message"
)
,
args
)
,
jEdit
.
getProperty
(
name
.
concat
(
".title"
)
)
,
JOptionPane
.
QUESTION_MESSAGE
,
null
,
null
,
jEdit
.
getProperty
(
def
)
)
;
if
(
retVal
!=
null
)
jEdit
.
setProperty
(
def
,
retVal
)
;
return
retVal
;
}
public
static
int
confirm
(
Component
comp
,
String
name
,
Object
[
]
args
,
int
buttons
,
int
type
)
{
hideSplashScreen
(
)
;
return
JOptionPane
.
showConfirmDialog
(
comp
,
jEdit
.
getProperty
(
name
+
".message"
,
args
)
,
jEdit
.
getProperty
(
name
+
".title"
)
,
buttons
,
type
)
;
}
public
static
String
[
]
showVFSFileDialog
(
View
view
,
String
path
,
int
type
,
boolean
multipleSelection
)
{
hideSplashScreen
(
)
;
VFSFileChooserDialog
fileChooser
=
new
VFSFileChooserDialog
(
view
,
path
,
type
,
multipleSelection
)
;
String
[
]
selectedFiles
=
fileChooser
.
getSelectedFiles
(
)
;
if
(
selectedFiles
==
null
)
return
null
;
return
selectedFiles
;
}
public
static
Color
parseColor
(
String
name
)
{
return
parseColor
(
name
,
Color
.
black
)
;
}
public
static
Color
parseColor
(
String
name
,
Color
defaultColor
)
{
if
(
name
==
null
)
return
defaultColor
;
else
if
(
name
.
startsWith
(
"#"
)
)
{
try
{
return
Color
.
decode
(
name
)
;
}
catch
(
NumberFormatException
nf
)
{
return
defaultColor
;
}
}
else
if
(
"red"
.
equals
(
name
)
)
return
Color
.
red
;
else
if
(
"green"
.
equals
(
name
)
)
return
Color
.
green
;
else
if
(
"blue"
.
equals
(
name
)
)
return
Color
.
blue
;
else
if
(
"yellow"
.
equals
(
name
)
)
return
Color
.
yellow
;
else
if
(
"orange"
.
equals
(
name
)
)
return
Color
.
orange
;
else
if
(
"white"
.
equals
(
name
)
)
return
Color
.
white
;
else
if
(
"lightGray"
.
equals
(
name
)
)
return
Color
.
lightGray
;
else
if
(
"gray"
.
equals
(
name
)
)
return
Color
.
gray
;
else
if
(
"darkGray"
.
equals
(
name
)
)
return
Color
.
darkGray
;
else
if
(
"black"
.
equals
(
name
)
)
return
Color
.
black
;
else
if
(
"cyan"
.
equals
(
name
)
)
return
Color
.
cyan
;
else
if
(
"magenta"
.
equals
(
name
)
)
return
Color
.
magenta
;
else
if
(
"pink"
.
equals
(
name
)
)
return
Color
.
pink
;
else
return
defaultColor
;
}
public
static
String
getColorHexString
(
Color
c
)
{
String
colString
=
Integer
.
toHexString
(
c
.
getRGB
(
)
&
0xffffff
)
;
return
"#000000"
.
substring
(
0
,
7
-
colString
.
length
(
)
)
.
concat
(
colString
)
;
}
public
static
SyntaxStyle
parseStyle
(
String
str
,
String
family
,
int
size
)
throws
IllegalArgumentException
{
return
parseStyle
(
str
,
family
,
size
,
true
)
;
}
public
static
SyntaxStyle
parseStyle
(
String
str
,
String
family
,
int
size
,
boolean
color
)
throws
IllegalArgumentException
{
Color
fgColor
=
Color
.
black
;
Color
bgColor
=
null
;
boolean
italic
=
false
;
boolean
bold
=
false
;
StringTokenizer
st
=
new
StringTokenizer
(
str
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
String
s
=
st
.
nextToken
(
)
;
if
(
s
.
startsWith
(
"color:"
)
)
{
if
(
color
)
fgColor
=
GUIUtilities
.
parseColor
(
s
.
substring
(
6
)
,
Color
.
black
)
;
}
else
if
(
s
.
startsWith
(
"bgColor:"
)
)
{
if
(
color
)
bgColor
=
GUIUtilities
.
parseColor
(
s
.
substring
(
8
)
,
null
)
;
}
else
if
(
s
.
startsWith
(
"style:"
)
)
{
for
(
int
i
=
6
;
i
<
s
.
length
(
)
;
i
++
)
{
if
(
s
.
charAt
(
i
)
==
'i'
)
italic
=
true
;
else
if
(
s
.
charAt
(
i
)
==
'b'
)
bold
=
true
;
else
throw
new
IllegalArgumentException
(
"Invalid style: "
+
s
)
;
}
}
else
throw
new
IllegalArgumentException
(
"Invalid directive: "
+
s
)
;
}
return
new
SyntaxStyle
(
fgColor
,
bgColor
,
new
Font
(
family
,
(
italic
?
Font
.
ITALIC
:
0
)
|
(
bold
?
Font
.
BOLD
:
0
)
,
size
)
)
;
}
public
static
String
getStyleString
(
SyntaxStyle
style
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
if
(
style
.
getForegroundColor
(
)
!=
null
)
{
buf
.
append
(
"color:"
+
getColorHexString
(
style
.
getForegroundColor
(
)
)
)
;
}
if
(
style
.
getBackgroundColor
(
)
!=
null
)
{
buf
.
append
(
" bgColor:"
+
getColorHexString
(
style
.
getBackgroundColor
(
)
)
)
;
}
if
(
!
style
.
getFont
(
)
.
isPlain
(
)
)
{
buf
.
append
(
" style:"
+
(
style
.
getFont
(
)
.
isItalic
(
)
?
"i"
:
""
)
+
(
style
.
getFont
(
)
.
isBold
(
)
?
"b"
:
""
)
)
;
}
return
buf
.
toString
(
)
;
}
public
static
SyntaxStyle
[
]
loadStyles
(
String
family
,
int
size
)
{
return
loadStyles
(
family
,
size
,
true
)
;
}
public
static
SyntaxStyle
[
]
loadStyles
(
String
family
,
int
size
,
boolean
color
)
{
SyntaxStyle
[
]
styles
=
new
SyntaxStyle
[
Token
.
ID_COUNT
]
;
try
{
styles
[
Token
.
COMMENT1
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.comment1"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
COMMENT2
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.comment2"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
LITERAL1
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.literal1"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
LITERAL2
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.literal2"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
LABEL
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.label"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
KEYWORD1
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.keyword1"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
KEYWORD2
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.keyword2"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
KEYWORD3
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.keyword3"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
FUNCTION
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.function"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
MARKUP
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.markup"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
OPERATOR
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.operator"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
DIGIT
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.digit"
)
,
family
,
size
,
color
)
;
styles
[
Token
.
INVALID
]
=
GUIUtilities
.
parseStyle
(
jEdit
.
getProperty
(
"view.style.invalid"
)
,
family
,
size
,
color
)
;
}
catch
(
Exception
e
)
{
Log
.
log
(
Log
.
ERROR
,
GUIUtilities
.
class
,
e
)
;
}
return
styles
;
}
public
static
void
loadGeometry
(
Window
win
,
String
name
)
{
int
x
,
y
,
width
,
height
,
adjust_x
,
adjust_y
,
adjust_width
,
adjust_height
;
Dimension
size
=
win
.
getSize
(
)
;
width
=
jEdit
.
getIntegerProperty
(
name
+
".width"
,
size
.
width
)
;
height
=
jEdit
.
getIntegerProperty
(
name
+
".height"
,
size
.
height
)
;
Component
parent
=
win
.
getParent
(
)
;
if
(
parent
==
null
)
{
Dimension
screen
=
win
.
getToolkit
(
)
.
getScreenSize
(
)
;
x
=
(
screen
.
width
-
width
)
/
2
;
y
=
(
screen
.
height
-
height
)
/
2
;
}
else
{
Rectangle
bounds
=
parent
.
getBounds
(
)
;
x
=
bounds
.
x
+
(
bounds
.
width
-
width
)
/
2
;
y
=
bounds
.
y
+
(
bounds
.
height
-
height
)
/
2
;
}
x
=
jEdit
.
getIntegerProperty
(
name
+
".x"
,
x
)
;
y
=
jEdit
.
getIntegerProperty
(
name
+
".y"
,
y
)
;
adjust_x
=
jEdit
.
getIntegerProperty
(
name
+
".dx"
,
0
)
;
adjust_y
=
jEdit
.
getIntegerProperty
(
name
+
".dy"
,
0
)
;
adjust_width
=
jEdit
.
getIntegerProperty
(
name
+
".d-width"
,
0
)
;
adjust_height
=
jEdit
.
getIntegerProperty
(
name
+
".d-height"
,
0
)
;
Rectangle
desired
=
new
Rectangle
(
x
,
y
,
width
,
height
)
;
Rectangle
required
=
new
Rectangle
(
x
-
adjust_x
,
y
-
adjust_y
,
width
-
adjust_width
,
height
-
adjust_height
)
;
win
.
setBounds
(
required
)
;
win
.
setBounds
(
desired
)
;
}
public
static
void
saveGeometry
(
Window
win
,
String
name
)
{
Rectangle
bounds
=
win
.
getBounds
(
)
;
jEdit
.
setIntegerProperty
(
name
+
".x"
,
bounds
.
x
)
;
jEdit
.
setIntegerProperty
(
name
+
".y"
,
bounds
.
y
)
;
jEdit
.
setIntegerProperty
(
name
+
".width"
,
bounds
.
width
)
;
jEdit
.
setIntegerProperty
(
name
+
".height"
,
bounds
.
height
)
;
}
public
static
void
hideSplashScreen
(
)
{
if
(
splash
!=
null
)
{
splash
.
dispose
(
)
;
splash
=
null
;
}
}
public
static
void
requestFocus
(
final
Window
win
,
final
Component
comp
)
{
win
.
addWindowListener
(
new
WindowAdapter
(
)
{
public
void
windowActivated
(
WindowEvent
evt
)
{
comp
.
requestFocus
(
)
;
win
.
removeWindowListener
(
this
)
;
}
}
)
;
}
public
static
boolean
isPopupTrigger
(
MouseEvent
evt
)
{
if
(
OperatingSystem
.
isMacOS
(
)
)
return
evt
.
isControlDown
(
)
;
else
return
(
(
evt
.
getModifiers
(
)
&
InputEvent
.
BUTTON3_MASK
)
!=
0
)
;
}
public
static
void
showPopupMenu
(
JPopupMenu
popup
,
Component
comp
,
int
x
,
int
y
)
{
Point
p
=
new
Point
(
x
,
y
)
;
SwingUtilities
.
convertPointToScreen
(
p
,
comp
)
;
Dimension
size
=
popup
.
getPreferredSize
(
)
;
Dimension
screen
=
Toolkit
.
getDefaultToolkit
(
)
.
getScreenSize
(
)
;
boolean
horiz
=
false
;
boolean
vert
=
false
;
int
origX
=
x
;
if
(
p
.
x
+
size
.
width
>
screen
.
width
&&
size
.
width
<
screen
.
width
)
{
x
+=
(
screen
.
width
-
p
.
x
-
size
.
width
)
;
horiz
=
true
;
}
if
(
p
.
y
+
size
.
height
>
screen
.
height
&&
size
.
height
<
screen
.
height
)
{
y
+=
(
screen
.
height
-
p
.
y
-
size
.
height
)
;
vert
=
true
;
}
if
(
horiz
&&
vert
)
{
x
=
origX
-
size
.
width
-
2
;
}
popup
.
show
(
comp
,
x
,
y
)
;
}
public
static
View
getView
(
Component
comp
)
{
for
(
;
;
)
{
if
(
comp
instanceof
JComponent
)
{
Component
real
=
(
Component
)
(
(
JComponent
)
comp
)
.
getClientProperty
(
"KORTE_REAL_FRAME"
)
;
if
(
real
!=
null
)
comp
=
real
;
}
if
(
comp
instanceof
View
)
return
(
View
)
comp
;
else
if
(
comp
instanceof
JPopupMenu
)
comp
=
(
(
JPopupMenu
)
comp
)
.
getInvoker
(
)
;
else
if
(
comp
!=
null
)
comp
=
comp
.
getParent
(
)
;
else
break
;
}
return
null
;
}
static
void
showSplashScreen
(
)
{
splash
=
new
SplashScreen
(
)
;
}
static
void
advanceSplashProgress
(
)
{
if
(
splash
!=
null
)
splash
.
advance
(
)
;
}
private
static
SplashScreen
splash
;
private
static
Hashtable
icons
;
private
GUIUtilities
(
)
{
}
private
static
void
loadPluginsMenu
(
JMenuBar
mbar
)
{
Vector
pluginMenuItems
=
new
Vector
(
)
;
EditPlugin
[
]
pluginArray
=
jEdit
.
getPlugins
(
)
;
for
(
int
i
=
0
;
i
<
pluginArray
.
length
;
i
++
)
{
try
{
EditPlugin
plugin
=
pluginArray
[
i
]
;
plugin
.
createMenuItems
(
pluginMenuItems
)
;
}
catch
(
Throwable
t
)
{
Log
.
log
(
Log
.
ERROR
,
GUIUtilities
.
class
,
"Error creating menu items"
+
" for plugin"
)
;
Log
.
log
(
Log
.
ERROR
,
GUIUtilities
.
class
,
t
)
;
}
}
JMenu
menu
=
new
EnhancedMenu
(
"plugins"
)
;
if
(
pluginMenuItems
.
isEmpty
(
)
)
{
menu
.
add
(
GUIUtilities
.
loadMenuItem
(
"no-plugins"
)
)
;
mbar
.
add
(
menu
)
;
return
;
}
MiscUtilities
.
quicksort
(
pluginMenuItems
,
new
MiscUtilities
.
MenuItemCompare
(
)
)
;
if
(
pluginMenuItems
.
size
(
)
<
20
)
{
for
(
int
i
=
0
;
i
<
pluginMenuItems
.
size
(
)
;
i
++
)
{
menu
.
add
(
(
JMenuItem
)
pluginMenuItems
.
get
(
i
)
)
;
}
mbar
.
add
(
menu
)
;
}
else
{
int
menuCount
=
1
;
menu
.
setText
(
menu
.
getText
(
)
+
" "
+
menuCount
)
;
for
(
int
i
=
0
;
i
<
pluginMenuItems
.
size
(
)
;
i
++
)
{
menu
.
add
(
(
JMenuItem
)
pluginMenuItems
.
get
(
i
)
)
;
if
(
menu
.
getMenuComponentCount
(
)
==
20
)
{
mbar
.
add
(
menu
)
;
menu
=
new
JMenu
(
String
.
valueOf
(
++
menuCount
)
)
;
}
}
if
(
menu
.
getMenuComponentCount
(
)
!=
0
)
mbar
.
add
(
menu
)
;
}
}
}
