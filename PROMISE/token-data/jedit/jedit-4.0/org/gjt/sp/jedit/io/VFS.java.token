package
org
.
gjt
.
sp
.
jedit
.
io
;
import
gnu
.
regexp
.
*
;
import
java
.
awt
.
Color
;
import
java
.
awt
.
Component
;
import
java
.
io
.
*
;
import
java
.
util
.
Vector
;
import
org
.
gjt
.
sp
.
jedit
.
msg
.
PropertiesChanged
;
import
org
.
gjt
.
sp
.
jedit
.
*
;
import
org
.
gjt
.
sp
.
util
.
Log
;
public
abstract
class
VFS
{
public
static
final
int
READ_CAP
=
1
<<
0
;
public
static
final
int
WRITE_CAP
=
1
<<
1
;
public
static
final
int
BROWSE_CAP
=
1
<<
2
;
public
static
final
int
DELETE_CAP
=
1
<<
3
;
public
static
final
int
RENAME_CAP
=
1
<<
4
;
public
static
final
int
MKDIR_CAP
=
1
<<
5
;
public
VFS
(
String
name
)
{
this
.
name
=
name
;
}
public
VFS
(
String
name
,
int
caps
)
{
this
.
name
=
name
;
this
.
caps
=
caps
;
}
public
String
getName
(
)
{
return
name
;
}
public
int
getCapabilities
(
)
{
return
caps
;
}
public
String
showBrowseDialog
(
Object
[
]
session
,
Component
comp
)
{
return
null
;
}
public
String
getFileName
(
String
path
)
{
if
(
path
.
equals
(
"/"
)
)
return
path
;
int
count
=
Math
.
max
(
0
,
path
.
length
(
)
-
2
)
;
int
index
=
Math
.
max
(
path
.
lastIndexOf
(
'/'
,
count
)
,
path
.
lastIndexOf
(
File
.
separatorChar
,
count
)
)
;
if
(
index
==
-
1
)
index
=
path
.
indexOf
(
':'
)
;
if
(
index
==
-
1
||
index
==
path
.
length
(
)
-
1
)
return
path
;
return
path
.
substring
(
index
+
1
)
;
}
public
String
getParentOfPath
(
String
path
)
{
int
count
=
Math
.
max
(
0
,
path
.
length
(
)
-
2
)
;
int
index
=
path
.
lastIndexOf
(
File
.
separatorChar
,
count
)
;
if
(
index
==
-
1
)
index
=
path
.
lastIndexOf
(
'/'
,
count
)
;
if
(
index
==
-
1
)
{
index
=
path
.
lastIndexOf
(
':'
)
;
}
return
path
.
substring
(
0
,
index
+
1
)
;
}
public
String
constructPath
(
String
parent
,
String
path
)
{
return
parent
+
path
;
}
public
char
getFileSeparator
(
)
{
return
'/'
;
}
public
void
reloadDirectory
(
String
path
)
{
}
public
Object
createVFSSession
(
String
path
,
Component
comp
)
{
return
new
Object
(
)
;
}
public
boolean
load
(
View
view
,
Buffer
buffer
,
String
path
)
{
if
(
(
getCapabilities
(
)
&
READ_CAP
)
==
0
)
{
VFSManager
.
error
(
view
,
path
,
"vfs.not-supported.load"
,
new
String
[
]
{
name
}
)
;
return
false
;
}
Object
session
=
createVFSSession
(
path
,
view
)
;
if
(
session
==
null
)
return
false
;
if
(
(
getCapabilities
(
)
&
WRITE_CAP
)
==
0
)
buffer
.
setReadOnly
(
true
)
;
BufferIORequest
request
=
new
BufferIORequest
(
BufferIORequest
.
LOAD
,
view
,
buffer
,
session
,
this
,
path
)
;
if
(
buffer
.
isTemporary
(
)
)
request
.
run
(
)
;
else
VFSManager
.
runInWorkThread
(
request
)
;
return
true
;
}
public
boolean
save
(
View
view
,
Buffer
buffer
,
String
path
)
{
if
(
(
getCapabilities
(
)
&
WRITE_CAP
)
==
0
)
{
VFSManager
.
error
(
view
,
path
,
"vfs.not-supported.save"
,
new
String
[
]
{
name
}
)
;
return
false
;
}
Object
session
=
createVFSSession
(
path
,
view
)
;
if
(
session
==
null
)
return
false
;
if
(
!
path
.
equals
(
buffer
.
getPath
(
)
)
)
buffer
.
unsetProperty
(
Buffer
.
BACKED_UP
)
;
VFSManager
.
runInWorkThread
(
new
BufferIORequest
(
BufferIORequest
.
SAVE
,
view
,
buffer
,
session
,
this
,
path
)
)
;
return
true
;
}
public
boolean
insert
(
View
view
,
Buffer
buffer
,
String
path
)
{
if
(
(
getCapabilities
(
)
&
READ_CAP
)
==
0
)
{
VFSManager
.
error
(
view
,
path
,
"vfs.not-supported.load"
,
new
String
[
]
{
name
}
)
;
return
false
;
}
Object
session
=
createVFSSession
(
path
,
view
)
;
if
(
session
==
null
)
return
false
;
VFSManager
.
runInWorkThread
(
new
BufferIORequest
(
BufferIORequest
.
INSERT
,
view
,
buffer
,
session
,
this
,
path
)
)
;
return
true
;
}
public
String
_canonPath
(
Object
session
,
String
path
,
Component
comp
)
throws
IOException
{
return
path
;
}
public
DirectoryEntry
[
]
_listDirectory
(
Object
session
,
String
directory
,
Component
comp
)
throws
IOException
{
VFSManager
.
error
(
comp
,
directory
,
"vfs.not-supported.list"
,
new
String
[
]
{
name
}
)
;
return
null
;
}
public
DirectoryEntry
_getDirectoryEntry
(
Object
session
,
String
path
,
Component
comp
)
throws
IOException
{
return
null
;
}
public
static
class
DirectoryEntry
implements
Serializable
{
public
static
final
int
FILE
=
0
;
public
static
final
int
DIRECTORY
=
1
;
public
static
final
int
FILESYSTEM
=
2
;
public
String
name
;
public
String
path
;
public
String
deletePath
;
public
int
type
;
public
long
length
;
public
boolean
hidden
;
public
DirectoryEntry
(
String
name
,
String
path
,
String
deletePath
,
int
type
,
long
length
,
boolean
hidden
)
{
this
.
name
=
name
;
this
.
path
=
path
;
this
.
deletePath
=
deletePath
;
this
.
type
=
type
;
this
.
length
=
length
;
this
.
hidden
=
hidden
;
}
protected
boolean
colorCalculated
;
protected
Color
color
;
public
Color
getColor
(
)
{
if
(
!
colorCalculated
)
{
colorCalculated
=
true
;
color
=
getDefaultColorFor
(
name
)
;
}
return
color
;
}
public
String
toString
(
)
{
return
name
;
}
}
public
boolean
_delete
(
Object
session
,
String
path
,
Component
comp
)
throws
IOException
{
return
false
;
}
public
boolean
_rename
(
Object
session
,
String
from
,
String
to
,
Component
comp
)
throws
IOException
{
return
false
;
}
public
boolean
_mkdir
(
Object
session
,
String
directory
,
Component
comp
)
throws
IOException
{
return
false
;
}
public
void
_backup
(
Object
session
,
String
path
,
Component
comp
)
throws
IOException
{
}
public
InputStream
_createInputStream
(
Object
session
,
String
path
,
boolean
ignoreErrors
,
Component
comp
)
throws
IOException
{
VFSManager
.
error
(
comp
,
path
,
"vfs.not-supported.load"
,
new
String
[
]
{
name
}
)
;
return
null
;
}
public
OutputStream
_createOutputStream
(
Object
session
,
String
path
,
Component
comp
)
throws
IOException
{
VFSManager
.
error
(
comp
,
path
,
"vfs.not-supported.save"
,
new
String
[
]
{
name
}
)
;
return
null
;
}
public
void
_saveComplete
(
Object
session
,
Buffer
buffer
,
Component
comp
)
throws
IOException
{
}
public
void
_endVFSSession
(
Object
session
,
Component
comp
)
throws
IOException
{
}
public
static
Color
getDefaultColorFor
(
String
name
)
{
synchronized
(
lock
)
{
if
(
colors
==
null
)
loadColors
(
)
;
for
(
int
i
=
0
;
i
<
colors
.
size
(
)
;
i
++
)
{
ColorEntry
entry
=
(
ColorEntry
)
colors
.
elementAt
(
i
)
;
if
(
entry
.
re
.
isMatch
(
name
)
)
return
entry
.
color
;
}
return
null
;
}
}
private
String
name
;
private
int
caps
;
private
static
Vector
colors
;
private
static
Object
lock
=
new
Object
(
)
;
static
{
EditBus
.
addToBus
(
new
EBComponent
(
)
{
public
void
handleMessage
(
EBMessage
msg
)
{
if
(
msg
instanceof
PropertiesChanged
)
{
synchronized
(
lock
)
{
colors
=
null
;
}
}
}
}
)
;
}
private
static
void
loadColors
(
)
{
synchronized
(
lock
)
{
colors
=
new
Vector
(
)
;
if
(
!
jEdit
.
getBooleanProperty
(
"vfs.browser.colorize"
)
)
return
;
try
{
String
glob
;
int
i
=
0
;
while
(
(
glob
=
jEdit
.
getProperty
(
"vfs.browser.colors."
+
i
+
".glob"
)
)
!=
null
)
{
colors
.
addElement
(
new
ColorEntry
(
new
RE
(
MiscUtilities
.
globToRE
(
glob
)
)
,
jEdit
.
getColorProperty
(
"vfs.browser.colors."
+
i
+
".color"
,
Color
.
black
)
)
)
;
i
++
;
}
}
catch
(
REException
e
)
{
Log
.
log
(
Log
.
ERROR
,
VFS
.
class
,
"Error loading file list colors:"
)
;
Log
.
log
(
Log
.
ERROR
,
VFS
.
class
,
e
)
;
}
}
}
static
class
ColorEntry
{
RE
re
;
Color
color
;
ColorEntry
(
RE
re
,
Color
color
)
{
this
.
re
=
re
;
this
.
color
=
color
;
}
}
}
