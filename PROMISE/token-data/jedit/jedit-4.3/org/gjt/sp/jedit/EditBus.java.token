package
org
.
gjt
.
sp
.
jedit
;
import
java
.
lang
.
annotation
.
*
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
*
;
import
org
.
gjt
.
sp
.
util
.
Log
;
public
class
EditBus
{
@
Retention
(
RetentionPolicy
.
RUNTIME
)
@
Target
(
ElementType
.
METHOD
)
public
static
@
interface
EBHandler
{
boolean
exact
(
)
default
false
;
}
public
static
void
addToBus
(
EBComponent
comp
)
{
addToBus
(
(
Object
)
comp
)
;
}
public
static
void
addToBus
(
Object
comp
)
{
components
.
addComponent
(
comp
)
;
}
public
static
void
removeFromBus
(
EBComponent
comp
)
{
removeFromBus
(
(
Object
)
comp
)
;
}
public
static
void
removeFromBus
(
Object
comp
)
{
components
.
removeComponent
(
comp
)
;
}
@
Deprecated
public
static
EBComponent
[
]
getComponents
(
)
{
return
new
EBComponent
[
0
]
;
}
public
static
void
send
(
EBMessage
message
)
{
Log
.
log
(
Log
.
DEBUG
,
EditBus
.
class
,
message
.
toString
(
)
)
;
components
.
lock
(
)
;
try
{
sendImpl
(
message
)
;
}
finally
{
components
.
unlock
(
)
;
}
}
private
static
final
HandlerList
components
=
new
HandlerList
(
)
;
private
EditBus
(
)
{
}
private
static
void
dispatch
(
EBMessageHandler
emh
,
EBMessage
msg
)
throws
Exception
{
if
(
emh
.
handler
!=
null
)
emh
.
handler
.
invoke
(
emh
.
comp
,
msg
)
;
else
{
assert
(
emh
.
comp
instanceof
EBComponent
)
;
(
(
EBComponent
)
emh
.
comp
)
.
handleMessage
(
msg
)
;
}
}
private
static
void
sendImpl
(
EBMessage
message
)
{
boolean
isExact
=
true
;
Class
<
?
>
type
=
message
.
getClass
(
)
;
while
(
!
type
.
equals
(
Object
.
class
)
)
{
List
<
EBMessageHandler
>
handlers
=
components
.
get
(
type
)
;
if
(
handlers
!=
null
)
{
try
{
for
(
EBMessageHandler
emh
:
handlers
)
{
if
(
!
isExact
&&
emh
.
source
!=
null
&&
emh
.
source
.
exact
(
)
)
{
continue
;
}
if
(
Debug
.
EB_TIMER
)
{
long
start
=
System
.
nanoTime
(
)
;
dispatch
(
emh
,
message
)
;
long
time
=
System
.
nanoTime
(
)
-
start
;
if
(
time
>=
1000000
)
{
Log
.
log
(
Log
.
DEBUG
,
EditBus
.
class
,
emh
.
comp
+
": "
+
time
+
" ns"
)
;
}
}
else
dispatch
(
emh
,
message
)
;
}
}
catch
(
Throwable
t
)
{
Log
.
log
(
Log
.
ERROR
,
EditBus
.
class
,
"Exception"
+
" while sending message on EditBus:"
)
;
Log
.
log
(
Log
.
ERROR
,
EditBus
.
class
,
t
)
;
}
}
type
=
type
.
getSuperclass
(
)
;
isExact
=
false
;
}
}
private
static
class
EBMessageHandler
{
EBMessageHandler
(
Object
comp
,
Method
handler
,
EBHandler
source
)
{
this
.
comp
=
comp
;
this
.
handler
=
handler
;
this
.
source
=
source
;
}
Object
comp
;
Method
handler
;
EBHandler
source
;
}
private
static
class
HandlerList
extends
HashMap
<
Class
<
?
>
,
List
<
EBMessageHandler
>
>
{
public
List
<
EBMessageHandler
>
safeGet
(
Class
<
?
>
type
)
{
List
<
EBMessageHandler
>
lst
=
super
.
get
(
type
)
;
if
(
lst
==
null
)
{
lst
=
new
LinkedList
<
EBMessageHandler
>
(
)
;
super
.
put
(
type
,
lst
)
;
}
return
lst
;
}
public
synchronized
void
lock
(
)
{
lock
++
;
}
public
synchronized
void
unlock
(
)
{
lock
--
;
if
(
lock
==
0
)
{
for
(
Object
comp
:
add
)
addComponent
(
comp
)
;
for
(
Object
comp
:
remove
)
removeComponent
(
comp
)
;
add
.
clear
(
)
;
remove
.
clear
(
)
;
}
}
public
synchronized
void
removeComponent
(
Object
comp
)
{
if
(
lock
!=
0
)
{
remove
.
add
(
comp
)
;
return
;
}
for
(
Class
<
?
>
msg
:
keySet
(
)
)
{
List
<
EBMessageHandler
>
handlers
=
get
(
msg
)
;
if
(
handlers
==
null
)
continue
;
for
(
Iterator
<
EBMessageHandler
>
it
=
handlers
.
iterator
(
)
;
it
.
hasNext
(
)
;
)
{
EBMessageHandler
emh
=
it
.
next
(
)
;
if
(
emh
.
comp
==
comp
)
it
.
remove
(
)
;
}
}
}
public
synchronized
void
addComponent
(
Object
comp
)
{
if
(
lock
!=
0
)
{
add
.
add
(
comp
)
;
return
;
}
for
(
Method
m
:
comp
.
getClass
(
)
.
getMethods
(
)
)
{
EBHandler
source
=
m
.
getAnnotation
(
EBHandler
.
class
)
;
if
(
source
==
null
)
continue
;
Class
[
]
params
=
m
.
getParameterTypes
(
)
;
if
(
params
.
length
!=
1
)
{
Log
.
log
(
Log
.
ERROR
,
EditBus
.
class
,
"Invalid EBHandler method "
+
m
.
getName
(
)
+
" in class "
+
comp
.
getClass
(
)
.
getName
(
)
+
": too many parameters."
)
;
continue
;
}
if
(
!
EBMessage
.
class
.
isAssignableFrom
(
params
[
0
]
)
)
{
Log
.
log
(
Log
.
ERROR
,
EditBus
.
class
,
"Invalid parameter "
+
params
[
0
]
.
getName
(
)
+
" in method "
+
m
.
getName
(
)
+
" of class "
+
comp
.
getClass
(
)
.
getName
(
)
)
;
continue
;
}
synchronized
(
components
)
{
safeGet
(
params
[
0
]
)
.
add
(
new
EBMessageHandler
(
comp
,
m
,
source
)
)
;
}
}
if
(
comp
instanceof
EBComponent
)
safeGet
(
EBMessage
.
class
)
.
add
(
new
EBMessageHandler
(
comp
,
null
,
null
)
)
;
}
private
int
lock
;
private
List
<
Object
>
add
=
new
LinkedList
<
Object
>
(
)
;
private
List
<
Object
>
remove
=
new
LinkedList
<
Object
>
(
)
;
}
}
