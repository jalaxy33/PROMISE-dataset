package
com
.
microstar
.
xml
;
import
java
.
io
.
BufferedInputStream
;
import
java
.
io
.
EOFException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
Reader
;
import
java
.
net
.
URL
;
import
java
.
net
.
URLConnection
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Stack
;
public
class
XmlParser
{
private
final
static
boolean
USE_CHEATS
=
true
;
public
XmlParser
(
)
{
}
public
void
setHandler
(
XmlHandler
handler
)
{
this
.
handler
=
handler
;
}
public
void
parse
(
String
systemId
,
String
publicId
,
String
encoding
)
throws
java
.
lang
.
Exception
{
doParse
(
systemId
,
publicId
,
null
,
null
,
encoding
)
;
}
public
void
parse
(
String
systemId
,
String
publicId
,
InputStream
stream
,
String
encoding
)
throws
java
.
lang
.
Exception
{
doParse
(
systemId
,
publicId
,
null
,
stream
,
encoding
)
;
}
public
void
parse
(
String
systemId
,
String
publicId
,
Reader
reader
)
throws
java
.
lang
.
Exception
{
doParse
(
systemId
,
publicId
,
reader
,
null
,
null
)
;
}
private
synchronized
void
doParse
(
String
systemId
,
String
publicId
,
Reader
reader
,
InputStream
stream
,
String
encoding
)
throws
java
.
lang
.
Exception
{
basePublicId
=
publicId
;
baseURI
=
systemId
;
baseReader
=
reader
;
baseInputStream
=
stream
;
initializeVariables
(
)
;
setInternalEntity
(
intern
(
"amp"
)
,
"&#38;"
)
;
setInternalEntity
(
intern
(
"lt"
)
,
"&#60;"
)
;
setInternalEntity
(
intern
(
"gt"
)
,
"&#62;"
)
;
setInternalEntity
(
intern
(
"apos"
)
,
"&#39;"
)
;
setInternalEntity
(
intern
(
"quot"
)
,
"&#34;"
)
;
if
(
handler
!=
null
)
{
handler
.
startDocument
(
)
;
}
pushURL
(
"[document]"
,
basePublicId
,
baseURI
,
baseReader
,
baseInputStream
,
encoding
)
;
parseDocument
(
)
;
if
(
handler
!=
null
)
{
handler
.
endDocument
(
)
;
}
cleanupVariables
(
)
;
}
public
final
static
int
CONTENT_UNDECLARED
=
0
;
public
final
static
int
CONTENT_ANY
=
1
;
public
final
static
int
CONTENT_EMPTY
=
2
;
public
final
static
int
CONTENT_MIXED
=
3
;
public
final
static
int
CONTENT_ELEMENTS
=
4
;
public
final
static
int
ENTITY_UNDECLARED
=
0
;
public
final
static
int
ENTITY_INTERNAL
=
1
;
public
final
static
int
ENTITY_NDATA
=
2
;
public
final
static
int
ENTITY_TEXT
=
3
;
public
final
static
int
ATTRIBUTE_UNDECLARED
=
0
;
public
final
static
int
ATTRIBUTE_CDATA
=
1
;
public
final
static
int
ATTRIBUTE_ID
=
2
;
public
final
static
int
ATTRIBUTE_IDREF
=
3
;
public
final
static
int
ATTRIBUTE_IDREFS
=
4
;
public
final
static
int
ATTRIBUTE_ENTITY
=
5
;
public
final
static
int
ATTRIBUTE_ENTITIES
=
6
;
public
final
static
int
ATTRIBUTE_NMTOKEN
=
7
;
public
final
static
int
ATTRIBUTE_NMTOKENS
=
8
;
public
final
static
int
ATTRIBUTE_ENUMERATED
=
9
;
public
final
static
int
ATTRIBUTE_NOTATION
=
10
;
private
static
Hashtable
attributeTypeHash
;
static
{
attributeTypeHash
=
new
Hashtable
(
)
;
attributeTypeHash
.
put
(
"CDATA"
,
new
Integer
(
ATTRIBUTE_CDATA
)
)
;
attributeTypeHash
.
put
(
"ID"
,
new
Integer
(
ATTRIBUTE_ID
)
)
;
attributeTypeHash
.
put
(
"IDREF"
,
new
Integer
(
ATTRIBUTE_IDREF
)
)
;
attributeTypeHash
.
put
(
"IDREFS"
,
new
Integer
(
ATTRIBUTE_IDREFS
)
)
;
attributeTypeHash
.
put
(
"ENTITY"
,
new
Integer
(
ATTRIBUTE_ENTITY
)
)
;
attributeTypeHash
.
put
(
"ENTITIES"
,
new
Integer
(
ATTRIBUTE_ENTITIES
)
)
;
attributeTypeHash
.
put
(
"NMTOKEN"
,
new
Integer
(
ATTRIBUTE_NMTOKEN
)
)
;
attributeTypeHash
.
put
(
"NMTOKENS"
,
new
Integer
(
ATTRIBUTE_NMTOKENS
)
)
;
attributeTypeHash
.
put
(
"NOTATION"
,
new
Integer
(
ATTRIBUTE_NOTATION
)
)
;
}
private
final
static
int
ENCODING_UTF_8
=
1
;
private
final
static
int
ENCODING_ISO_8859_1
=
2
;
private
final
static
int
ENCODING_UCS_2_12
=
3
;
private
final
static
int
ENCODING_UCS_2_21
=
4
;
private
final
static
int
ENCODING_UCS_4_1234
=
5
;
private
final
static
int
ENCODING_UCS_4_4321
=
6
;
private
final
static
int
ENCODING_UCS_4_2143
=
7
;
private
final
static
int
ENCODING_UCS_4_3412
=
8
;
public
final
static
int
ATTRIBUTE_DEFAULT_UNDECLARED
=
0
;
public
final
static
int
ATTRIBUTE_DEFAULT_SPECIFIED
=
1
;
public
final
static
int
ATTRIBUTE_DEFAULT_IMPLIED
=
2
;
public
final
static
int
ATTRIBUTE_DEFAULT_REQUIRED
=
3
;
public
final
static
int
ATTRIBUTE_DEFAULT_FIXED
=
4
;
private
final
static
int
INPUT_NONE
=
0
;
private
final
static
int
INPUT_INTERNAL
=
1
;
private
final
static
int
INPUT_EXTERNAL
=
2
;
private
final
static
int
INPUT_STREAM
=
3
;
private
final
static
int
INPUT_BUFFER
=
4
;
private
final
static
int
INPUT_READER
=
5
;
private
final
static
int
LIT_CHAR_REF
=
1
;
private
final
static
int
LIT_ENTITY_REF
=
2
;
private
final
static
int
LIT_PE_REF
=
4
;
private
final
static
int
LIT_NORMALIZE
=
8
;
private
final
static
int
CONTEXT_NONE
=
0
;
private
final
static
int
CONTEXT_DTD
=
1
;
private
final
static
int
CONTEXT_ENTITYVALUE
=
2
;
private
final
static
int
CONTEXT_ATTRIBUTEVALUE
=
3
;
void
error
(
String
message
,
String
textFound
,
String
textExpected
)
throws
java
.
lang
.
Exception
{
errorCount
++
;
if
(
textFound
!=
null
)
{
message
=
message
+
" (found \""
+
textFound
+
"\")"
;
}
if
(
textExpected
!=
null
)
{
message
=
message
+
" (expected \""
+
textExpected
+
"\")"
;
}
if
(
handler
!=
null
)
{
String
uri
=
null
;
if
(
externalEntity
!=
null
)
{
uri
=
externalEntity
.
getURL
(
)
.
toString
(
)
;
}
handler
.
error
(
message
,
uri
,
line
,
column
)
;
}
}
void
error
(
String
message
,
char
textFound
,
String
textExpected
)
throws
java
.
lang
.
Exception
{
error
(
message
,
new
Character
(
textFound
)
.
toString
(
)
,
textExpected
)
;
}
void
parseDocument
(
)
throws
java
.
lang
.
Exception
{
char
c
;
parseProlog
(
)
;
require
(
'<'
)
;
parseElement
(
)
;
try
{
parseMisc
(
)
;
c
=
readCh
(
)
;
error
(
"unexpected characters after document end"
,
c
,
null
)
;
}
catch
(
EOFException
e
)
{
return
;
}
}
void
parseComment
(
)
throws
java
.
lang
.
Exception
{
skipUntil
(
"-->"
)
;
}
void
parsePI
(
)
throws
java
.
lang
.
Exception
{
String
name
;
name
=
readNmtoken
(
true
)
;
if
(
!
tryRead
(
"?>"
)
)
{
requireWhitespace
(
)
;
parseUntil
(
"?>"
)
;
}
if
(
handler
!=
null
)
{
handler
.
processingInstruction
(
name
,
dataBufferToString
(
)
)
;
}
}
void
parseCDSect
(
)
throws
java
.
lang
.
Exception
{
parseUntil
(
"]]>"
)
;
}
void
parseProlog
(
)
throws
java
.
lang
.
Exception
{
parseMisc
(
)
;
if
(
tryRead
(
"<!DOCTYPE"
)
)
{
parseDoctypedecl
(
)
;
parseMisc
(
)
;
}
}
void
parseXMLDecl
(
boolean
ignoreEncoding
)
throws
java
.
lang
.
Exception
{
String
version
;
String
encodingName
=
null
;
String
standalone
=
null
;
require
(
"version"
)
;
parseEq
(
)
;
version
=
readLiteral
(
0
)
;
if
(
!
version
.
equals
(
"1.0"
)
)
{
error
(
"unsupported XML version"
,
version
,
"1.0"
)
;
}
skipWhitespace
(
)
;
if
(
tryRead
(
"encoding"
)
)
{
parseEq
(
)
;
encodingName
=
readLiteral
(
0
)
;
checkEncoding
(
encodingName
,
ignoreEncoding
)
;
}
skipWhitespace
(
)
;
if
(
tryRead
(
"standalone"
)
)
{
parseEq
(
)
;
standalone
=
readLiteral
(
0
)
;
}
skipWhitespace
(
)
;
require
(
"?>"
)
;
}
void
parseTextDecl
(
boolean
ignoreEncoding
)
throws
java
.
lang
.
Exception
{
String
encodingName
=
null
;
if
(
tryRead
(
"version"
)
)
{
String
version
;
parseEq
(
)
;
version
=
readLiteral
(
0
)
;
if
(
!
version
.
equals
(
"1.0"
)
)
{
error
(
"unsupported XML version"
,
version
,
"1.0"
)
;
}
requireWhitespace
(
)
;
}
require
(
"encoding"
)
;
parseEq
(
)
;
encodingName
=
readLiteral
(
0
)
;
checkEncoding
(
encodingName
,
ignoreEncoding
)
;
skipWhitespace
(
)
;
require
(
"?>"
)
;
}
void
checkEncoding
(
String
encodingName
,
boolean
ignoreEncoding
)
throws
java
.
lang
.
Exception
{
encodingName
=
encodingName
.
toUpperCase
(
)
;
if
(
ignoreEncoding
)
{
return
;
}
switch
(
encoding
)
{
case
ENCODING_UTF_8
:
if
(
encodingName
.
equals
(
"ISO-8859-1"
)
)
{
encoding
=
ENCODING_ISO_8859_1
;
}
else
if
(
!
encodingName
.
equals
(
"UTF-8"
)
)
{
error
(
"unsupported 8-bit encoding"
,
encodingName
,
"UTF-8 or ISO-8859-1"
)
;
}
break
;
case
ENCODING_UCS_2_12
:
case
ENCODING_UCS_2_21
:
if
(
!
encodingName
.
equals
(
"ISO-10646-UCS-2"
)
&&
!
encodingName
.
equals
(
"UTF-16"
)
)
{
error
(
"unsupported 16-bit encoding"
,
encodingName
,
"ISO-10646-UCS-2"
)
;
}
break
;
case
ENCODING_UCS_4_1234
:
case
ENCODING_UCS_4_4321
:
case
ENCODING_UCS_4_2143
:
case
ENCODING_UCS_4_3412
:
if
(
!
encodingName
.
equals
(
"ISO-10646-UCS-4"
)
)
{
error
(
"unsupported 32-bit encoding"
,
encodingName
,
"ISO-10646-UCS-4"
)
;
}
}
}
void
parseMisc
(
)
throws
java
.
lang
.
Exception
{
while
(
true
)
{
skipWhitespace
(
)
;
if
(
tryRead
(
"<?"
)
)
{
parsePI
(
)
;
}
else
if
(
tryRead
(
"<!--"
)
)
{
parseComment
(
)
;
}
else
{
return
;
}
}
}
void
parseDoctypedecl
(
)
throws
java
.
lang
.
Exception
{
char
c
;
String
doctypeName
,
ids
[
]
;
requireWhitespace
(
)
;
doctypeName
=
readNmtoken
(
true
)
;
skipWhitespace
(
)
;
ids
=
readExternalIds
(
false
)
;
skipWhitespace
(
)
;
if
(
tryRead
(
'['
)
)
{
while
(
true
)
{
context
=
CONTEXT_DTD
;
skipWhitespace
(
)
;
context
=
CONTEXT_NONE
;
if
(
tryRead
(
']'
)
)
{
break
;
}
else
{
context
=
CONTEXT_DTD
;
parseMarkupdecl
(
)
;
context
=
CONTEXT_NONE
;
}
}
}
if
(
ids
[
1
]
!=
null
)
{
pushURL
(
"[external subset]"
,
ids
[
0
]
,
ids
[
1
]
,
null
,
null
,
null
)
;
while
(
true
)
{
context
=
CONTEXT_DTD
;
skipWhitespace
(
)
;
context
=
CONTEXT_NONE
;
if
(
tryRead
(
'>'
)
)
{
break
;
}
else
{
context
=
CONTEXT_DTD
;
parseMarkupdecl
(
)
;
context
=
CONTEXT_NONE
;
}
}
}
else
{
skipWhitespace
(
)
;
require
(
'>'
)
;
}
if
(
handler
!=
null
)
{
handler
.
doctypeDecl
(
doctypeName
,
ids
[
0
]
,
ids
[
1
]
)
;
}
}
void
parseMarkupdecl
(
)
throws
java
.
lang
.
Exception
{
if
(
tryRead
(
"<!ELEMENT"
)
)
{
parseElementdecl
(
)
;
}
else
if
(
tryRead
(
"<!ATTLIST"
)
)
{
parseAttlistDecl
(
)
;
}
else
if
(
tryRead
(
"<!ENTITY"
)
)
{
parseEntityDecl
(
)
;
}
else
if
(
tryRead
(
"<!NOTATION"
)
)
{
parseNotationDecl
(
)
;
}
else
if
(
tryRead
(
"<?"
)
)
{
parsePI
(
)
;
}
else
if
(
tryRead
(
"<!--"
)
)
{
parseComment
(
)
;
}
else
if
(
tryRead
(
"<!["
)
)
{
parseConditionalSect
(
)
;
}
else
{
error
(
"expected markup declaration"
,
null
,
null
)
;
}
}
void
parseElement
(
)
throws
java
.
lang
.
Exception
{
String
gi
;
char
c
;
int
oldElementContent
=
currentElementContent
;
String
oldElement
=
currentElement
;
tagAttributePos
=
0
;
gi
=
readNmtoken
(
true
)
;
currentElement
=
gi
;
currentElementContent
=
getElementContentType
(
gi
)
;
if
(
currentElementContent
==
CONTENT_UNDECLARED
)
{
currentElementContent
=
CONTENT_ANY
;
}
skipWhitespace
(
)
;
c
=
readCh
(
)
;
while
(
c
!=
'/'
&&
c
!=
'>'
)
{
unread
(
c
)
;
parseAttribute
(
gi
)
;
skipWhitespace
(
)
;
c
=
readCh
(
)
;
}
unread
(
c
)
;
Enumeration
atts
=
declaredAttributes
(
gi
)
;
if
(
atts
!=
null
)
{
String
aname
;
loop
:
while
(
atts
.
hasMoreElements
(
)
)
{
aname
=
(
String
)
atts
.
nextElement
(
)
;
for
(
int
i
=
0
;
i
<
tagAttributePos
;
i
++
)
{
if
(
tagAttributes
[
i
]
==
aname
)
{
continue
loop
;
}
}
if
(
handler
!=
null
)
{
handler
.
attribute
(
aname
,
getAttributeExpandedValue
(
gi
,
aname
)
,
false
)
;
}
}
}
c
=
readCh
(
)
;
switch
(
c
)
{
case
'>'
:
if
(
handler
!=
null
)
{
handler
.
startElement
(
gi
)
;
}
parseContent
(
)
;
break
;
case
'/'
:
require
(
'>'
)
;
if
(
handler
!=
null
)
{
handler
.
startElement
(
gi
)
;
handler
.
endElement
(
gi
)
;
}
break
;
}
currentElement
=
oldElement
;
currentElementContent
=
oldElementContent
;
}
void
parseAttribute
(
String
name
)
throws
java
.
lang
.
Exception
{
String
aname
;
int
type
;
String
value
;
aname
=
readNmtoken
(
true
)
.
intern
(
)
;
type
=
getAttributeDefaultValueType
(
name
,
aname
)
;
parseEq
(
)
;
if
(
type
==
ATTRIBUTE_CDATA
||
type
==
ATTRIBUTE_UNDECLARED
)
{
value
=
readLiteral
(
LIT_CHAR_REF
|
LIT_ENTITY_REF
)
;
}
else
{
value
=
readLiteral
(
LIT_CHAR_REF
|
LIT_ENTITY_REF
|
LIT_NORMALIZE
)
;
}
if
(
handler
!=
null
)
{
handler
.
attribute
(
aname
,
value
,
true
)
;
}
dataBufferPos
=
0
;
if
(
tagAttributePos
==
tagAttributes
.
length
)
{
String
newAttrib
[
]
=
new
String
[
tagAttributes
.
length
*
2
]
;
System
.
arraycopy
(
tagAttributes
,
0
,
newAttrib
,
0
,
tagAttributePos
)
;
tagAttributes
=
newAttrib
;
}
tagAttributes
[
tagAttributePos
++
]
=
aname
;
}
void
parseEq
(
)
throws
java
.
lang
.
Exception
{
skipWhitespace
(
)
;
require
(
'='
)
;
skipWhitespace
(
)
;
}
void
parseETag
(
)
throws
java
.
lang
.
Exception
{
String
name
;
name
=
readNmtoken
(
true
)
;
if
(
name
!=
currentElement
)
{
error
(
"mismatched end tag"
,
name
,
currentElement
)
;
}
skipWhitespace
(
)
;
require
(
'>'
)
;
if
(
handler
!=
null
)
{
handler
.
endElement
(
name
)
;
}
}
void
parseContent
(
)
throws
java
.
lang
.
Exception
{
String
data
;
char
c
;
while
(
true
)
{
switch
(
currentElementContent
)
{
case
CONTENT_ANY
:
case
CONTENT_MIXED
:
parsePCData
(
)
;
break
;
case
CONTENT_ELEMENTS
:
parseWhitespace
(
)
;
break
;
}
c
=
readCh
(
)
;
switch
(
c
)
{
case
'&'
:
c
=
readCh
(
)
;
if
(
c
==
'#'
)
{
parseCharRef
(
)
;
}
else
{
unread
(
c
)
;
parseEntityRef
(
true
)
;
}
break
;
case
'<'
:
c
=
readCh
(
)
;
switch
(
c
)
{
case
'!'
:
c
=
readCh
(
)
;
switch
(
c
)
{
case
'-'
:
require
(
'-'
)
;
parseComment
(
)
;
break
;
case
'['
:
require
(
"CDATA["
)
;
parseCDSect
(
)
;
break
;
default
:
error
(
"expected comment or CDATA section"
,
c
,
null
)
;
break
;
}
break
;
case
'?'
:
dataBufferFlush
(
)
;
parsePI
(
)
;
break
;
case
'/'
:
dataBufferFlush
(
)
;
parseETag
(
)
;
return
;
default
:
dataBufferFlush
(
)
;
unread
(
c
)
;
parseElement
(
)
;
break
;
}
}
}
}
void
parseElementdecl
(
)
throws
java
.
lang
.
Exception
{
String
name
;
requireWhitespace
(
)
;
name
=
readNmtoken
(
true
)
;
requireWhitespace
(
)
;
parseContentspec
(
name
)
;
skipWhitespace
(
)
;
require
(
'>'
)
;
}
void
parseContentspec
(
String
name
)
throws
java
.
lang
.
Exception
{
if
(
tryRead
(
"EMPTY"
)
)
{
setElement
(
name
,
CONTENT_EMPTY
,
null
,
null
)
;
return
;
}
else
if
(
tryRead
(
"ANY"
)
)
{
setElement
(
name
,
CONTENT_ANY
,
null
,
null
)
;
return
;
}
else
{
require
(
'('
)
;
dataBufferAppend
(
'('
)
;
skipWhitespace
(
)
;
if
(
tryRead
(
"#PCDATA"
)
)
{
dataBufferAppend
(
"#PCDATA"
)
;
parseMixed
(
)
;
setElement
(
name
,
CONTENT_MIXED
,
dataBufferToString
(
)
,
null
)
;
}
else
{
parseElements
(
)
;
setElement
(
name
,
CONTENT_ELEMENTS
,
dataBufferToString
(
)
,
null
)
;
}
}
}
void
parseElements
(
)
throws
java
.
lang
.
Exception
{
char
c
;
char
sep
;
skipWhitespace
(
)
;
parseCp
(
)
;
skipWhitespace
(
)
;
c
=
readCh
(
)
;
switch
(
c
)
{
case
')'
:
dataBufferAppend
(
')'
)
;
c
=
readCh
(
)
;
switch
(
c
)
{
case
'*'
:
case
'+'
:
case
'?'
:
dataBufferAppend
(
c
)
;
break
;
default
:
unread
(
c
)
;
}
return
;
case
','
:
case
'|'
:
sep
=
c
;
dataBufferAppend
(
c
)
;
break
;
default
:
error
(
"bad separator in content model"
,
c
,
null
)
;
return
;
}
while
(
true
)
{
skipWhitespace
(
)
;
parseCp
(
)
;
skipWhitespace
(
)
;
c
=
readCh
(
)
;
if
(
c
==
')'
)
{
dataBufferAppend
(
')'
)
;
break
;
}
else
if
(
c
!=
sep
)
{
error
(
"bad separator in content model"
,
c
,
null
)
;
return
;
}
else
{
dataBufferAppend
(
c
)
;
}
}
c
=
readCh
(
)
;
switch
(
c
)
{
case
'?'
:
case
'*'
:
case
'+'
:
dataBufferAppend
(
c
)
;
return
;
default
:
unread
(
c
)
;
return
;
}
}
void
parseCp
(
)
throws
java
.
lang
.
Exception
{
char
c
;
if
(
tryRead
(
'('
)
)
{
dataBufferAppend
(
'('
)
;
parseElements
(
)
;
}
else
{
dataBufferAppend
(
readNmtoken
(
true
)
)
;
c
=
readCh
(
)
;
switch
(
c
)
{
case
'?'
:
case
'*'
:
case
'+'
:
dataBufferAppend
(
c
)
;
break
;
default
:
unread
(
c
)
;
break
;
}
}
}
void
parseMixed
(
)
throws
java
.
lang
.
Exception
{
char
c
;
skipWhitespace
(
)
;
if
(
tryRead
(
')'
)
)
{
dataBufferAppend
(
")*"
)
;
tryRead
(
'*'
)
;
return
;
}
skipWhitespace
(
)
;
while
(
!
tryRead
(
")*"
)
)
{
require
(
'|'
)
;
dataBufferAppend
(
'|'
)
;
skipWhitespace
(
)
;
dataBufferAppend
(
readNmtoken
(
true
)
)
;
skipWhitespace
(
)
;
}
dataBufferAppend
(
")*"
)
;
}
void
parseAttlistDecl
(
)
throws
java
.
lang
.
Exception
{
String
elementName
;
requireWhitespace
(
)
;
elementName
=
readNmtoken
(
true
)
;
requireWhitespace
(
)
;
while
(
!
tryRead
(
'>'
)
)
{
parseAttDef
(
elementName
)
;
skipWhitespace
(
)
;
}
}
void
parseAttDef
(
String
elementName
)
throws
java
.
lang
.
Exception
{
String
name
;
int
type
;
String
enumeration
=
null
;
name
=
readNmtoken
(
true
)
;
requireWhitespace
(
)
;
type
=
readAttType
(
)
;
if
(
type
==
ATTRIBUTE_ENUMERATED
||
type
==
ATTRIBUTE_NOTATION
)
{
enumeration
=
dataBufferToString
(
)
;
}
requireWhitespace
(
)
;
parseDefault
(
elementName
,
name
,
type
,
enumeration
)
;
}
int
readAttType
(
)
throws
java
.
lang
.
Exception
{
String
typeString
;
Integer
type
;
if
(
tryRead
(
'('
)
)
{
parseEnumeration
(
)
;
return
ATTRIBUTE_ENUMERATED
;
}
else
{
typeString
=
readNmtoken
(
true
)
;
if
(
typeString
.
equals
(
"NOTATION"
)
)
{
parseNotationType
(
)
;
}
type
=
(
Integer
)
attributeTypeHash
.
get
(
typeString
)
;
if
(
type
==
null
)
{
error
(
"illegal attribute type"
,
typeString
,
null
)
;
return
ATTRIBUTE_UNDECLARED
;
}
else
{
return
type
.
intValue
(
)
;
}
}
}
void
parseEnumeration
(
)
throws
java
.
lang
.
Exception
{
char
c
;
dataBufferAppend
(
'('
)
;
skipWhitespace
(
)
;
dataBufferAppend
(
readNmtoken
(
true
)
)
;
skipWhitespace
(
)
;
while
(
!
tryRead
(
')'
)
)
{
require
(
'|'
)
;
dataBufferAppend
(
'|'
)
;
skipWhitespace
(
)
;
dataBufferAppend
(
readNmtoken
(
true
)
)
;
skipWhitespace
(
)
;
}
dataBufferAppend
(
')'
)
;
}
void
parseNotationType
(
)
throws
java
.
lang
.
Exception
{
requireWhitespace
(
)
;
require
(
'('
)
;
parseEnumeration
(
)
;
}
void
parseDefault
(
String
elementName
,
String
name
,
int
type
,
String
enumeration
)
throws
java
.
lang
.
Exception
{
int
valueType
=
ATTRIBUTE_DEFAULT_SPECIFIED
;
String
value
=
null
;
boolean
normalizeWSFlag
;
if
(
tryRead
(
'#'
)
)
{
if
(
tryRead
(
"FIXED"
)
)
{
valueType
=
ATTRIBUTE_DEFAULT_FIXED
;
requireWhitespace
(
)
;
context
=
CONTEXT_ATTRIBUTEVALUE
;
value
=
readLiteral
(
LIT_CHAR_REF
)
;
context
=
CONTEXT_DTD
;
}
else
if
(
tryRead
(
"REQUIRED"
)
)
{
valueType
=
ATTRIBUTE_DEFAULT_REQUIRED
;
}
else
if
(
tryRead
(
"IMPLIED"
)
)
{
valueType
=
ATTRIBUTE_DEFAULT_IMPLIED
;
}
else
{
error
(
"illegal keyword for attribute default value"
,
null
,
null
)
;
}
}
else
{
context
=
CONTEXT_ATTRIBUTEVALUE
;
value
=
readLiteral
(
LIT_CHAR_REF
)
;
context
=
CONTEXT_DTD
;
}
setAttribute
(
elementName
,
name
,
type
,
enumeration
,
value
,
valueType
)
;
}
void
parseConditionalSect
(
)
throws
java
.
lang
.
Exception
{
skipWhitespace
(
)
;
if
(
tryRead
(
"INCLUDE"
)
)
{
skipWhitespace
(
)
;
require
(
'['
)
;
skipWhitespace
(
)
;
while
(
!
tryRead
(
"]]>"
)
)
{
parseMarkupdecl
(
)
;
skipWhitespace
(
)
;
}
}
else
if
(
tryRead
(
"IGNORE"
)
)
{
skipWhitespace
(
)
;
require
(
'['
)
;
int
nesting
=
1
;
char
c
;
for
(
int
nest
=
1
;
nest
>
0
;
)
{
c
=
readCh
(
)
;
switch
(
c
)
{
case
'<'
:
if
(
tryRead
(
"!["
)
)
{
nest
++
;
}
case
']'
:
if
(
tryRead
(
"]>"
)
)
{
nest
--
;
}
}
}
}
else
{
error
(
"conditional section must begin with INCLUDE or IGNORE"
,
null
,
null
)
;
}
}
void
parseCharRef
(
)
throws
java
.
lang
.
Exception
{
int
value
=
0
;
char
c
;
if
(
tryRead
(
'x'
)
)
{
loop1
:
while
(
true
)
{
c
=
readCh
(
)
;
switch
(
c
)
{
case
'0'
:
case
'1'
:
case
'2'
:
case
'3'
:
case
'4'
:
case
'5'
:
case
'6'
:
case
'7'
:
case
'8'
:
case
'9'
:
case
'a'
:
case
'A'
:
case
'b'
:
case
'B'
:
case
'c'
:
case
'C'
:
case
'd'
:
case
'D'
:
case
'e'
:
case
'E'
:
case
'f'
:
case
'F'
:
value
*=
16
;
value
+=
Integer
.
parseInt
(
new
Character
(
c
)
.
toString
(
)
,
16
)
;
break
;
case
';'
:
break
loop1
;
default
:
error
(
"illegal character in character reference"
,
c
,
null
)
;
break
loop1
;
}
}
}
else
{
loop2
:
while
(
true
)
{
c
=
readCh
(
)
;
switch
(
c
)
{
case
'0'
:
case
'1'
:
case
'2'
:
case
'3'
:
case
'4'
:
case
'5'
:
case
'6'
:
case
'7'
:
case
'8'
:
case
'9'
:
value
*=
10
;
value
+=
Integer
.
parseInt
(
new
Character
(
c
)
.
toString
(
)
,
10
)
;
break
;
case
';'
:
break
loop2
;
default
:
error
(
"illegal character in character reference"
,
c
,
null
)
;
break
loop2
;
}
}
}
if
(
value
<=
0x0000ffff
)
{
dataBufferAppend
(
(
char
)
value
)
;
}
else
if
(
value
<=
0x000fffff
)
{
dataBufferAppend
(
(
char
)
(
0xd8
|
(
(
value
&
0x000ffc00
)
>
>
10
)
)
)
;
dataBufferAppend
(
(
char
)
(
0xdc
|
(
value
&
0x0003ff
)
)
)
;
}
else
{
error
(
"character reference "
+
value
+
" is too large for UTF-16"
,
new
Integer
(
value
)
.
toString
(
)
,
null
)
;
}
}
void
parseEntityRef
(
boolean
externalAllowed
)
throws
java
.
lang
.
Exception
{
String
name
;
name
=
readNmtoken
(
true
)
;
require
(
';'
)
;
switch
(
getEntityType
(
name
)
)
{
case
ENTITY_UNDECLARED
:
error
(
"reference to undeclared entity"
,
name
,
null
)
;
break
;
case
ENTITY_INTERNAL
:
pushString
(
name
,
getEntityValue
(
name
)
)
;
break
;
case
ENTITY_TEXT
:
if
(
externalAllowed
)
{
pushURL
(
name
,
getEntityPublicId
(
name
)
,
getEntitySystemId
(
name
)
,
null
,
null
,
null
)
;
}
else
{
error
(
"reference to external entity in attribute value."
,
name
,
null
)
;
}
break
;
case
ENTITY_NDATA
:
if
(
externalAllowed
)
{
error
(
"data entity reference in content"
,
name
,
null
)
;
}
else
{
error
(
"reference to external entity in attribute value."
,
name
,
null
)
;
}
break
;
}
}
void
parsePEReference
(
boolean
isEntityValue
)
throws
java
.
lang
.
Exception
{
String
name
;
name
=
"%"
+
readNmtoken
(
true
)
;
require
(
';'
)
;
switch
(
getEntityType
(
name
)
)
{
case
ENTITY_UNDECLARED
:
error
(
"reference to undeclared parameter entity"
,
name
,
null
)
;
break
;
case
ENTITY_INTERNAL
:
if
(
isEntityValue
)
{
pushString
(
name
,
getEntityValue
(
name
)
)
;
}
else
{
pushString
(
name
,
" "
+
getEntityValue
(
name
)
+
' '
)
;
}
break
;
case
ENTITY_TEXT
:
if
(
isEntityValue
)
{
pushString
(
null
,
" "
)
;
}
pushURL
(
name
,
getEntityPublicId
(
name
)
,
getEntitySystemId
(
name
)
,
null
,
null
,
null
)
;
if
(
isEntityValue
)
{
pushString
(
null
,
" "
)
;
}
break
;
}
}
void
parseEntityDecl
(
)
throws
java
.
lang
.
Exception
{
char
c
;
boolean
peFlag
=
false
;
String
name
,
value
,
notationName
,
ids
[
]
;
requireWhitespace
(
)
;
if
(
tryRead
(
'%'
)
)
{
peFlag
=
true
;
requireWhitespace
(
)
;
}
name
=
readNmtoken
(
true
)
;
if
(
peFlag
)
{
name
=
"%"
+
name
;
}
requireWhitespace
(
)
;
c
=
readCh
(
)
;
unread
(
c
)
;
if
(
c
==
'"'
||
c
==
'\''
)
{
context
=
CONTEXT_ENTITYVALUE
;
value
=
readLiteral
(
LIT_CHAR_REF
|
LIT_PE_REF
)
;
context
=
CONTEXT_DTD
;
setInternalEntity
(
name
,
value
)
;
}
else
{
ids
=
readExternalIds
(
false
)
;
if
(
ids
[
1
]
==
null
)
{
error
(
"system identifer missing"
,
name
,
null
)
;
}
skipWhitespace
(
)
;
if
(
tryRead
(
"NDATA"
)
)
{
requireWhitespace
(
)
;
notationName
=
readNmtoken
(
true
)
;
setExternalDataEntity
(
name
,
ids
[
0
]
,
ids
[
1
]
,
notationName
)
;
}
else
{
setExternalTextEntity
(
name
,
ids
[
0
]
,
ids
[
1
]
)
;
}
}
skipWhitespace
(
)
;
require
(
'>'
)
;
}
void
parseNotationDecl
(
)
throws
java
.
lang
.
Exception
{
String
nname
,
ids
[
]
;
requireWhitespace
(
)
;
nname
=
readNmtoken
(
true
)
;
requireWhitespace
(
)
;
ids
=
readExternalIds
(
true
)
;
if
(
ids
[
0
]
==
null
&&
ids
[
1
]
==
null
)
{
error
(
"external identifer missing"
,
nname
,
null
)
;
}
setNotation
(
nname
,
ids
[
0
]
,
ids
[
1
]
)
;
skipWhitespace
(
)
;
require
(
'>'
)
;
}
void
parsePCData
(
)
throws
java
.
lang
.
Exception
{
char
c
;
if
(
USE_CHEATS
)
{
int
lineAugment
=
0
;
int
columnAugment
=
0
;
loop
:
for
(
int
i
=
readBufferPos
;
i
<
readBufferLength
;
i
++
)
{
switch
(
readBuffer
[
i
]
)
{
case
'\n'
:
lineAugment
++
;
columnAugment
=
0
;
break
;
case
'&'
:
case
'<'
:
int
start
=
readBufferPos
;
columnAugment
++
;
readBufferPos
=
i
;
if
(
lineAugment
>
0
)
{
line
+=
lineAugment
;
column
=
columnAugment
;
}
else
{
column
+=
columnAugment
;
}
dataBufferAppend
(
readBuffer
,
start
,
i
-
start
)
;
return
;
default
:
columnAugment
++
;
}
}
}
while
(
true
)
{
c
=
readCh
(
)
;
switch
(
c
)
{
case
'<'
:
case
'&'
:
unread
(
c
)
;
return
;
default
:
dataBufferAppend
(
c
)
;
break
;
}
}
}
void
requireWhitespace
(
)
throws
java
.
lang
.
Exception
{
char
c
=
readCh
(
)
;
if
(
isWhitespace
(
c
)
)
{
skipWhitespace
(
)
;
}
else
{
error
(
"whitespace expected"
,
c
,
null
)
;
}
}
void
parseWhitespace
(
)
throws
java
.
lang
.
Exception
{
char
c
=
readCh
(
)
;
while
(
isWhitespace
(
c
)
)
{
dataBufferAppend
(
c
)
;
c
=
readCh
(
)
;
}
unread
(
c
)
;
}
void
skipWhitespace
(
)
throws
java
.
lang
.
Exception
{
if
(
USE_CHEATS
)
{
int
lineAugment
=
0
;
int
columnAugment
=
0
;
loop
:
for
(
int
i
=
readBufferPos
;
i
<
readBufferLength
;
i
++
)
{
switch
(
readBuffer
[
i
]
)
{
case
' '
:
case
'\t'
:
case
'\r'
:
columnAugment
++
;
break
;
case
'\n'
:
lineAugment
++
;
columnAugment
=
0
;
break
;
case
'%'
:
if
(
context
==
CONTEXT_DTD
||
context
==
CONTEXT_ENTITYVALUE
)
{
break
loop
;
}
default
:
readBufferPos
=
i
;
if
(
lineAugment
>
0
)
{
line
+=
lineAugment
;
column
=
columnAugment
;
}
else
{
column
+=
columnAugment
;
}
return
;
}
}
}
char
c
=
readCh
(
)
;
while
(
isWhitespace
(
c
)
)
{
c
=
readCh
(
)
;
}
unread
(
c
)
;
}
String
readNmtoken
(
boolean
isName
)
throws
java
.
lang
.
Exception
{
char
c
;
if
(
USE_CHEATS
)
{
loop
:
for
(
int
i
=
readBufferPos
;
i
<
readBufferLength
;
i
++
)
{
switch
(
readBuffer
[
i
]
)
{
case
'%'
:
if
(
context
==
CONTEXT_DTD
||
context
==
CONTEXT_ENTITYVALUE
)
{
break
loop
;
}
case
'<'
:
case
'>'
:
case
'&'
:
case
','
:
case
'|'
:
case
'*'
:
case
'+'
:
case
'?'
:
case
')'
:
case
'='
:
case
'\''
:
case
'"'
:
case
'['
:
case
' '
:
case
'\t'
:
case
'\r'
:
case
'\n'
:
case
';'
:
case
'/'
:
case
'#'
:
int
start
=
readBufferPos
;
if
(
i
==
start
)
{
error
(
"name expected"
,
readBuffer
[
i
]
,
null
)
;
}
readBufferPos
=
i
;
return
intern
(
readBuffer
,
start
,
i
-
start
)
;
}
}
}
nameBufferPos
=
0
;
loop
:
while
(
true
)
{
c
=
readCh
(
)
;
switch
(
c
)
{
case
'%'
:
case
'<'
:
case
'>'
:
case
'&'
:
case
','
:
case
'|'
:
case
'*'
:
case
'+'
:
case
'?'
:
case
')'
:
case
'='
:
case
'\''
:
case
'"'
:
case
'['
:
case
' '
:
case
'\t'
:
case
'\n'
:
case
'\r'
:
case
';'
:
case
'/'
:
unread
(
c
)
;
if
(
nameBufferPos
==
0
)
{
error
(
"name expected"
,
null
,
null
)
;
}
String
s
=
intern
(
nameBuffer
,
0
,
nameBufferPos
)
;
nameBufferPos
=
0
;
return
s
;
default
:
nameBuffer
=
(
char
[
]
)
extendArray
(
nameBuffer
,
nameBuffer
.
length
,
nameBufferPos
)
;
nameBuffer
[
nameBufferPos
++
]
=
c
;
}
}
}
String
readLiteral
(
int
flags
)
throws
java
.
lang
.
Exception
{
char
delim
,
c
;
int
startLine
=
line
;
delim
=
readCh
(
)
;
if
(
delim
!=
'"'
&&
delim
!=
'\''
&&
delim
!=
(
char
)
0
)
{
error
(
"expected '\"' or \"'\""
,
delim
,
null
)
;
return
null
;
}
try
{
c
=
readCh
(
)
;
loop
:
while
(
c
!=
delim
)
{
switch
(
c
)
{
case
'\n'
:
case
'\r'
:
c
=
' '
;
break
;
case
'&'
:
if
(
(
flags
&
LIT_CHAR_REF
)
>
0
)
{
c
=
readCh
(
)
;
if
(
c
==
'#'
)
{
parseCharRef
(
)
;
c
=
readCh
(
)
;
continue
loop
;
}
else
if
(
(
flags
&
LIT_ENTITY_REF
)
>
0
)
{
unread
(
c
)
;
parseEntityRef
(
false
)
;
c
=
readCh
(
)
;
continue
loop
;
}
else
{
dataBufferAppend
(
'&'
)
;
}
}
break
;
default
:
break
;
}
dataBufferAppend
(
c
)
;
c
=
readCh
(
)
;
}
}
catch
(
EOFException
e
)
{
error
(
"end of input while looking for delimiter (started on line "
+
startLine
+
')'
,
null
,
new
Character
(
delim
)
.
toString
(
)
)
;
}
if
(
(
flags
&
LIT_NORMALIZE
)
>
0
)
{
dataBufferNormalize
(
)
;
}
return
dataBufferToString
(
)
;
}
String
[
]
readExternalIds
(
boolean
inNotation
)
throws
java
.
lang
.
Exception
{
char
c
;
String
ids
[
]
=
new
String
[
2
]
;
if
(
tryRead
(
"PUBLIC"
)
)
{
requireWhitespace
(
)
;
ids
[
0
]
=
readLiteral
(
LIT_NORMALIZE
)
;
if
(
inNotation
)
{
skipWhitespace
(
)
;
if
(
tryRead
(
'"'
)
||
tryRead
(
'\''
)
)
{
ids
[
1
]
=
readLiteral
(
0
)
;
}
}
else
{
requireWhitespace
(
)
;
ids
[
1
]
=
readLiteral
(
0
)
;
}
}
else
if
(
tryRead
(
"SYSTEM"
)
)
{
requireWhitespace
(
)
;
ids
[
1
]
=
readLiteral
(
0
)
;
}
return
ids
;
}
final
boolean
isWhitespace
(
char
c
)
{
switch
(
(
int
)
c
)
{
case
0x20
:
case
0x09
:
case
0x0d
:
case
0x0a
:
return
true
;
default
:
return
false
;
}
}
void
dataBufferAppend
(
char
c
)
{
dataBuffer
=
(
char
[
]
)
extendArray
(
dataBuffer
,
dataBuffer
.
length
,
dataBufferPos
)
;
dataBuffer
[
dataBufferPos
++
]
=
c
;
}
void
dataBufferAppend
(
String
s
)
{
dataBufferAppend
(
s
.
toCharArray
(
)
,
0
,
s
.
length
(
)
)
;
}
void
dataBufferAppend
(
char
ch
[
]
,
int
start
,
int
length
)
{
dataBuffer
=
(
char
[
]
)
extendArray
(
dataBuffer
,
dataBuffer
.
length
,
dataBufferPos
+
length
)
;
System
.
arraycopy
(
(
Object
)
ch
,
start
,
(
Object
)
dataBuffer
,
dataBufferPos
,
length
)
;
dataBufferPos
+=
length
;
}
void
dataBufferNormalize
(
)
{
int
i
=
0
;
int
j
=
0
;
int
end
=
dataBufferPos
;
while
(
j
<
end
&&
isWhitespace
(
dataBuffer
[
j
]
)
)
{
j
++
;
}
while
(
end
>
j
&&
isWhitespace
(
dataBuffer
[
end
-
1
]
)
)
{
end
--
;
}
while
(
j
<
end
)
{
char
c
=
dataBuffer
[
j
++
]
;
if
(
isWhitespace
(
c
)
)
{
while
(
j
<
end
&&
isWhitespace
(
dataBuffer
[
j
++
]
)
)
{
}
dataBuffer
[
i
++
]
=
' '
;
dataBuffer
[
i
++
]
=
dataBuffer
[
j
-
1
]
;
}
else
{
dataBuffer
[
i
++
]
=
c
;
}
}
dataBufferPos
=
i
;
}
String
dataBufferToString
(
)
{
String
s
=
new
String
(
dataBuffer
,
0
,
dataBufferPos
)
;
dataBufferPos
=
0
;
return
s
;
}
void
dataBufferFlush
(
)
throws
java
.
lang
.
Exception
{
if
(
dataBufferPos
>
0
)
{
switch
(
currentElementContent
)
{
case
CONTENT_UNDECLARED
:
case
CONTENT_EMPTY
:
break
;
case
CONTENT_MIXED
:
case
CONTENT_ANY
:
if
(
handler
!=
null
)
{
handler
.
charData
(
dataBuffer
,
0
,
dataBufferPos
)
;
}
break
;
case
CONTENT_ELEMENTS
:
if
(
handler
!=
null
)
{
handler
.
ignorableWhitespace
(
dataBuffer
,
0
,
dataBufferPos
)
;
}
break
;
}
dataBufferPos
=
0
;
}
}
void
require
(
String
delim
)
throws
java
.
lang
.
Exception
{
char
ch
[
]
=
delim
.
toCharArray
(
)
;
for
(
int
i
=
0
;
i
<
ch
.
length
;
i
++
)
{
require
(
ch
[
i
]
)
;
}
}
void
require
(
char
delim
)
throws
java
.
lang
.
Exception
{
char
c
=
readCh
(
)
;
if
(
c
!=
delim
)
{
error
(
"expected character"
,
c
,
new
Character
(
delim
)
.
toString
(
)
)
;
}
}
public
String
intern
(
String
s
)
{
char
ch
[
]
=
s
.
toCharArray
(
)
;
return
intern
(
ch
,
0
,
ch
.
length
)
;
}
public
String
intern
(
char
ch
[
]
,
int
start
,
int
length
)
{
int
index
;
int
hash
=
0
;
for
(
int
i
=
start
;
i
<
start
+
length
;
i
++
)
{
hash
=
(
(
hash
<<
1
)
&
0xffffff
)
+
(
int
)
ch
[
i
]
;
}
hash
=
hash
%
SYMBOL_TABLE_LENGTH
;
Object
bucket
[
]
=
(
Object
[
]
)
symbolTable
[
hash
]
;
if
(
bucket
==
null
)
{
symbolTable
[
hash
]
=
bucket
=
new
Object
[
8
]
;
}
for
(
index
=
0
;
index
<
bucket
.
length
;
index
+=
2
)
{
char
chFound
[
]
=
(
char
[
]
)
bucket
[
index
]
;
if
(
chFound
==
null
)
{
break
;
}
if
(
chFound
.
length
==
length
)
{
for
(
int
i
=
0
;
i
<
chFound
.
length
;
i
++
)
{
if
(
ch
[
start
+
i
]
!=
chFound
[
i
]
)
{
break
;
}
else
if
(
i
==
length
-
1
)
{
return
(
String
)
bucket
[
index
+
1
]
;
}
}
}
}
bucket
=
(
Object
[
]
)
extendArray
(
bucket
,
bucket
.
length
,
index
)
;
String
s
=
new
String
(
ch
,
start
,
length
)
;
bucket
[
index
]
=
s
.
toCharArray
(
)
;
bucket
[
index
+
1
]
=
s
;
symbolTable
[
hash
]
=
bucket
;
return
s
;
}
Object
extendArray
(
Object
array
,
int
currentSize
,
int
requiredSize
)
{
if
(
requiredSize
<
currentSize
)
{
return
array
;
}
else
{
Object
newArray
=
null
;
int
newSize
=
currentSize
*
2
;
if
(
newSize
<=
requiredSize
)
{
newSize
=
requiredSize
+
1
;
}
if
(
array
instanceof
char
[
]
)
{
newArray
=
new
char
[
newSize
]
;
}
else
if
(
array
instanceof
Object
[
]
)
{
newArray
=
new
Object
[
newSize
]
;
}
System
.
arraycopy
(
array
,
0
,
newArray
,
0
,
currentSize
)
;
return
newArray
;
}
}
public
Enumeration
declaredElements
(
)
{
return
elementInfo
.
keys
(
)
;
}
public
int
getElementContentType
(
String
name
)
{
Object
element
[
]
=
(
Object
[
]
)
elementInfo
.
get
(
name
)
;
if
(
element
==
null
)
{
return
CONTENT_UNDECLARED
;
}
else
{
return
(
(
Integer
)
element
[
0
]
)
.
intValue
(
)
;
}
}
public
String
getElementContentModel
(
String
name
)
{
Object
element
[
]
=
(
Object
[
]
)
elementInfo
.
get
(
name
)
;
if
(
element
==
null
)
{
return
null
;
}
else
{
return
(
String
)
element
[
1
]
;
}
}
void
setElement
(
String
name
,
int
contentType
,
String
contentModel
,
Hashtable
attributes
)
throws
java
.
lang
.
Exception
{
Object
element
[
]
;
element
=
(
Object
[
]
)
elementInfo
.
get
(
name
)
;
if
(
element
==
null
)
{
element
=
new
Object
[
3
]
;
element
[
0
]
=
new
Integer
(
CONTENT_UNDECLARED
)
;
element
[
1
]
=
null
;
element
[
2
]
=
null
;
}
else
if
(
contentType
!=
CONTENT_UNDECLARED
&&
(
(
Integer
)
element
[
0
]
)
.
intValue
(
)
!=
CONTENT_UNDECLARED
)
{
error
(
"multiple declarations for element type"
,
name
,
null
)
;
return
;
}
if
(
contentType
!=
CONTENT_UNDECLARED
)
{
element
[
0
]
=
new
Integer
(
contentType
)
;
}
if
(
contentModel
!=
null
)
{
element
[
1
]
=
contentModel
;
}
if
(
attributes
!=
null
)
{
element
[
2
]
=
attributes
;
}
elementInfo
.
put
(
name
,
element
)
;
}
Hashtable
getElementAttributes
(
String
name
)
{
Object
element
[
]
=
(
Object
[
]
)
elementInfo
.
get
(
name
)
;
if
(
element
==
null
)
{
return
null
;
}
else
{
return
(
Hashtable
)
element
[
2
]
;
}
}
public
Enumeration
declaredAttributes
(
String
elname
)
{
Hashtable
attlist
=
getElementAttributes
(
elname
)
;
if
(
attlist
==
null
)
{
return
null
;
}
else
{
return
attlist
.
keys
(
)
;
}
}
public
int
getAttributeType
(
String
name
,
String
aname
)
{
Object
attribute
[
]
=
getAttribute
(
name
,
aname
)
;
if
(
attribute
==
null
)
{
return
ATTRIBUTE_UNDECLARED
;
}
else
{
return
(
(
Integer
)
attribute
[
0
]
)
.
intValue
(
)
;
}
}
public
String
getAttributeEnumeration
(
String
name
,
String
aname
)
{
Object
attribute
[
]
=
getAttribute
(
name
,
aname
)
;
if
(
attribute
==
null
)
{
return
null
;
}
else
{
return
(
String
)
attribute
[
3
]
;
}
}
public
String
getAttributeDefaultValue
(
String
name
,
String
aname
)
{
Object
attribute
[
]
=
getAttribute
(
name
,
aname
)
;
if
(
attribute
==
null
)
{
return
null
;
}
else
{
return
(
String
)
attribute
[
1
]
;
}
}
public
String
getAttributeExpandedValue
(
String
name
,
String
aname
)
{
Object
attribute
[
]
=
getAttribute
(
name
,
aname
)
;
if
(
attribute
==
null
)
{
return
null
;
}
else
if
(
attribute
[
4
]
==
null
&&
attribute
[
1
]
!=
null
)
{
try
{
pushString
(
null
,
(
char
)
0
+
(
String
)
attribute
[
1
]
+
(
char
)
0
)
;
attribute
[
4
]
=
readLiteral
(
LIT_NORMALIZE
|
LIT_CHAR_REF
|
LIT_ENTITY_REF
)
;
}
catch
(
Exception
e
)
{
}
}
return
(
String
)
attribute
[
4
]
;
}
public
int
getAttributeDefaultValueType
(
String
name
,
String
aname
)
{
Object
attribute
[
]
=
getAttribute
(
name
,
aname
)
;
if
(
attribute
==
null
)
{
return
ATTRIBUTE_DEFAULT_UNDECLARED
;
}
else
{
return
(
(
Integer
)
attribute
[
2
]
)
.
intValue
(
)
;
}
}
void
setAttribute
(
String
elName
,
String
name
,
int
type
,
String
enumeration
,
String
value
,
int
valueType
)
throws
java
.
lang
.
Exception
{
Hashtable
attlist
;
Object
attribute
[
]
;
attlist
=
getElementAttributes
(
elName
)
;
if
(
attlist
==
null
)
{
attlist
=
new
Hashtable
(
)
;
}
if
(
attlist
.
get
(
name
)
!=
null
)
{
return
;
}
else
{
attribute
=
new
Object
[
5
]
;
attribute
[
0
]
=
new
Integer
(
type
)
;
attribute
[
1
]
=
value
;
attribute
[
2
]
=
new
Integer
(
valueType
)
;
attribute
[
3
]
=
enumeration
;
attribute
[
4
]
=
null
;
attlist
.
put
(
name
.
intern
(
)
,
attribute
)
;
setElement
(
elName
,
CONTENT_UNDECLARED
,
null
,
attlist
)
;
}
}
Object
[
]
getAttribute
(
String
elName
,
String
name
)
{
Hashtable
attlist
;
Object
attribute
[
]
;
attlist
=
getElementAttributes
(
elName
)
;
if
(
attlist
==
null
)
{
return
null
;
}
attribute
=
(
Object
[
]
)
attlist
.
get
(
name
)
;
return
attribute
;
}
public
Enumeration
declaredEntities
(
)
{
return
entityInfo
.
keys
(
)
;
}
public
int
getEntityType
(
String
ename
)
{
Object
entity
[
]
=
(
Object
[
]
)
entityInfo
.
get
(
ename
)
;
if
(
entity
==
null
)
{
return
ENTITY_UNDECLARED
;
}
else
{
return
(
(
Integer
)
entity
[
0
]
)
.
intValue
(
)
;
}
}
public
String
getEntityPublicId
(
String
ename
)
{
Object
entity
[
]
=
(
Object
[
]
)
entityInfo
.
get
(
ename
)
;
if
(
entity
==
null
)
{
return
null
;
}
else
{
return
(
String
)
entity
[
1
]
;
}
}
public
String
getEntitySystemId
(
String
ename
)
{
Object
entity
[
]
=
(
Object
[
]
)
entityInfo
.
get
(
ename
)
;
if
(
entity
==
null
)
{
return
null
;
}
else
{
return
(
String
)
entity
[
2
]
;
}
}
public
String
getEntityValue
(
String
ename
)
{
Object
entity
[
]
=
(
Object
[
]
)
entityInfo
.
get
(
ename
)
;
if
(
entity
==
null
)
{
return
null
;
}
else
{
return
(
String
)
entity
[
3
]
;
}
}
public
String
getEntityNotationName
(
String
eName
)
{
Object
entity
[
]
=
(
Object
[
]
)
entityInfo
.
get
(
eName
)
;
if
(
entity
==
null
)
{
return
null
;
}
else
{
return
(
String
)
entity
[
4
]
;
}
}
void
setInternalEntity
(
String
eName
,
String
value
)
{
setEntity
(
eName
,
ENTITY_INTERNAL
,
null
,
null
,
value
,
null
)
;
}
void
setExternalDataEntity
(
String
eName
,
String
pubid
,
String
sysid
,
String
nName
)
{
setEntity
(
eName
,
ENTITY_NDATA
,
pubid
,
sysid
,
null
,
nName
)
;
}
void
setExternalTextEntity
(
String
eName
,
String
pubid
,
String
sysid
)
{
setEntity
(
eName
,
ENTITY_TEXT
,
pubid
,
sysid
,
null
,
null
)
;
}
void
setEntity
(
String
eName
,
int
eClass
,
String
pubid
,
String
sysid
,
String
value
,
String
nName
)
{
Object
entity
[
]
;
if
(
entityInfo
.
get
(
eName
)
==
null
)
{
entity
=
new
Object
[
5
]
;
entity
[
0
]
=
new
Integer
(
eClass
)
;
entity
[
1
]
=
pubid
;
entity
[
2
]
=
sysid
;
entity
[
3
]
=
value
;
entity
[
4
]
=
nName
;
entityInfo
.
put
(
eName
,
entity
)
;
}
}
public
Enumeration
declaredNotations
(
)
{
return
notationInfo
.
keys
(
)
;
}
public
String
getNotationPublicId
(
String
nname
)
{
Object
notation
[
]
=
(
Object
[
]
)
notationInfo
.
get
(
nname
)
;
if
(
notation
==
null
)
{
return
null
;
}
else
{
return
(
String
)
notation
[
0
]
;
}
}
public
String
getNotationSystemId
(
String
nname
)
{
Object
notation
[
]
=
(
Object
[
]
)
notationInfo
.
get
(
nname
)
;
if
(
notation
==
null
)
{
return
null
;
}
else
{
return
(
String
)
notation
[
1
]
;
}
}
void
setNotation
(
String
nname
,
String
pubid
,
String
sysid
)
throws
java
.
lang
.
Exception
{
Object
notation
[
]
;
if
(
notationInfo
.
get
(
nname
)
==
null
)
{
notation
=
new
Object
[
2
]
;
notation
[
0
]
=
pubid
;
notation
[
1
]
=
sysid
;
notationInfo
.
put
(
nname
,
notation
)
;
}
else
{
error
(
"multiple declarations of notation"
,
nname
,
null
)
;
}
}
public
int
getLineNumber
(
)
{
return
line
;
}
public
int
getColumnNumber
(
)
{
return
column
;
}
char
readCh
(
)
throws
java
.
lang
.
Exception
{
char
c
;
while
(
readBufferPos
>=
readBufferLength
)
{
switch
(
sourceType
)
{
case
INPUT_READER
:
case
INPUT_EXTERNAL
:
case
INPUT_STREAM
:
readDataChunk
(
)
;
while
(
readBufferLength
<
1
)
{
popInput
(
)
;
if
(
readBufferLength
<
1
)
{
readDataChunk
(
)
;
}
}
break
;
default
:
popInput
(
)
;
break
;
}
}
c
=
readBuffer
[
readBufferPos
++
]
;
if
(
c
==
'%'
&&
(
context
==
CONTEXT_DTD
||
context
==
CONTEXT_ENTITYVALUE
)
)
{
char
c2
=
readCh
(
)
;
unread
(
c2
)
;
if
(
!
isWhitespace
(
c2
)
)
{
parsePEReference
(
context
==
CONTEXT_ENTITYVALUE
)
;
return
readCh
(
)
;
}
}
if
(
c
==
'\n'
)
{
line
++
;
column
=
0
;
}
else
{
column
++
;
}
return
c
;
}
void
unread
(
char
c
)
throws
java
.
lang
.
Exception
{
if
(
c
==
'\n'
)
{
line
--
;
column
=
-
1
;
}
if
(
readBufferPos
>
0
)
{
readBuffer
[
--
readBufferPos
]
=
c
;
}
else
{
pushString
(
null
,
new
Character
(
c
)
.
toString
(
)
)
;
}
}
void
unread
(
char
ch
[
]
,
int
length
)
throws
java
.
lang
.
Exception
{
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
if
(
ch
[
i
]
==
'\n'
)
{
line
--
;
column
=
-
1
;
}
}
if
(
length
<
readBufferPos
)
{
readBufferPos
-=
length
;
}
else
{
pushCharArray
(
null
,
ch
,
0
,
length
)
;
sourceType
=
INPUT_BUFFER
;
}
}
void
pushURL
(
String
ename
,
String
publicId
,
String
systemId
,
Reader
reader
,
InputStream
stream
,
String
encoding
)
throws
java
.
lang
.
Exception
{
URL
url
;
boolean
ignoreEncoding
=
false
;
pushInput
(
ename
)
;
readBuffer
=
new
char
[
READ_BUFFER_MAX
+
4
]
;
readBufferPos
=
0
;
readBufferLength
=
0
;
readBufferOverflow
=
-
1
;
is
=
null
;
line
=
1
;
currentByteCount
=
0
;
dataBufferFlush
(
)
;
if
(
systemId
!=
null
&&
externalEntity
!=
null
)
{
systemId
=
new
URL
(
externalEntity
.
getURL
(
)
,
systemId
)
.
toString
(
)
;
}
else
if
(
baseURI
!=
null
)
{
try
{
systemId
=
new
URL
(
new
URL
(
baseURI
)
,
systemId
)
.
toString
(
)
;
}
catch
(
Exception
e
)
{
}
}
if
(
systemId
!=
null
&&
handler
!=
null
)
{
Object
input
=
handler
.
resolveEntity
(
publicId
,
systemId
)
;
if
(
input
!=
null
)
{
if
(
input
instanceof
String
)
{
systemId
=
(
String
)
input
;
}
else
if
(
input
instanceof
InputStream
)
{
stream
=
(
InputStream
)
input
;
}
else
if
(
input
instanceof
Reader
)
{
reader
=
(
Reader
)
input
;
}
}
}
if
(
handler
!=
null
)
{
if
(
systemId
!=
null
)
{
handler
.
startExternalEntity
(
systemId
)
;
}
else
{
handler
.
startExternalEntity
(
"[external stream]"
)
;
}
}
if
(
reader
!=
null
)
{
sourceType
=
INPUT_READER
;
this
.
reader
=
reader
;
tryEncodingDecl
(
true
)
;
return
;
}
else
if
(
stream
!=
null
)
{
sourceType
=
INPUT_STREAM
;
is
=
stream
;
}
else
{
sourceType
=
INPUT_EXTERNAL
;
url
=
new
URL
(
systemId
)
;
externalEntity
=
url
.
openConnection
(
)
;
externalEntity
.
connect
(
)
;
is
=
externalEntity
.
getInputStream
(
)
;
}
if
(
!
is
.
markSupported
(
)
)
{
is
=
new
BufferedInputStream
(
is
)
;
}
if
(
encoding
==
null
&&
externalEntity
!=
null
)
{
encoding
=
externalEntity
.
getContentEncoding
(
)
;
}
if
(
encoding
!=
null
)
{
checkEncoding
(
encoding
,
false
)
;
ignoreEncoding
=
true
;
}
else
{
detectEncoding
(
)
;
ignoreEncoding
=
false
;
}
tryEncodingDecl
(
ignoreEncoding
)
;
}
void
tryEncodingDecl
(
boolean
ignoreEncoding
)
throws
java
.
lang
.
Exception
{
if
(
tryRead
(
"<?xml"
)
)
{
if
(
tryWhitespace
(
)
)
{
if
(
inputStack
.
size
(
)
>
0
)
{
parseTextDecl
(
ignoreEncoding
)
;
}
else
{
parseXMLDecl
(
ignoreEncoding
)
;
}
}
else
{
unread
(
"xml"
.
toCharArray
(
)
,
3
)
;
parsePI
(
)
;
}
}
}
void
detectEncoding
(
)
throws
java
.
lang
.
Exception
{
byte
signature
[
]
=
new
byte
[
4
]
;
is
.
mark
(
4
)
;
is
.
read
(
signature
)
;
is
.
reset
(
)
;
if
(
tryEncoding
(
signature
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x3c
)
)
{
encoding
=
ENCODING_UCS_4_1234
;
}
else
if
(
tryEncoding
(
signature
,
(
byte
)
0x3c
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
)
)
{
encoding
=
ENCODING_UCS_4_4321
;
}
else
if
(
tryEncoding
(
signature
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x3c
,
(
byte
)
0x00
)
)
{
encoding
=
ENCODING_UCS_4_2143
;
}
else
if
(
tryEncoding
(
signature
,
(
byte
)
0x00
,
(
byte
)
0x3c
,
(
byte
)
0x00
,
(
byte
)
0x00
)
)
{
encoding
=
ENCODING_UCS_4_3412
;
}
else
if
(
tryEncoding
(
signature
,
(
byte
)
0xfe
,
(
byte
)
0xff
)
)
{
encoding
=
ENCODING_UCS_2_12
;
is
.
read
(
)
;
is
.
read
(
)
;
}
else
if
(
tryEncoding
(
signature
,
(
byte
)
0xff
,
(
byte
)
0xfe
)
)
{
encoding
=
ENCODING_UCS_2_21
;
is
.
read
(
)
;
is
.
read
(
)
;
}
else
if
(
tryEncoding
(
signature
,
(
byte
)
0x00
,
(
byte
)
0x3c
,
(
byte
)
0x00
,
(
byte
)
0x3f
)
)
{
encoding
=
ENCODING_UCS_2_12
;
error
(
"no byte-order mark for UCS-2 entity"
,
null
,
null
)
;
}
else
if
(
tryEncoding
(
signature
,
(
byte
)
0x3c
,
(
byte
)
0x00
,
(
byte
)
0x3f
,
(
byte
)
0x00
)
)
{
encoding
=
ENCODING_UCS_2_21
;
error
(
"no byte-order mark for UCS-2 entity"
,
null
,
null
)
;
}
else
if
(
tryEncoding
(
signature
,
(
byte
)
0x3c
,
(
byte
)
0x3f
,
(
byte
)
0x78
,
(
byte
)
0x6d
)
)
{
encoding
=
ENCODING_UTF_8
;
read8bitEncodingDeclaration
(
)
;
}
else
{
encoding
=
ENCODING_UTF_8
;
}
}
boolean
tryEncoding
(
byte
sig
[
]
,
byte
b1
,
byte
b2
,
byte
b3
,
byte
b4
)
{
return
(
sig
[
0
]
==
b1
&&
sig
[
1
]
==
b2
&&
sig
[
2
]
==
b3
&&
sig
[
3
]
==
b4
)
;
}
boolean
tryEncoding
(
byte
sig
[
]
,
byte
b1
,
byte
b2
)
{
return
(
(
sig
[
0
]
==
b1
)
&&
(
sig
[
1
]
==
b2
)
)
;
}
void
pushString
(
String
ename
,
String
s
)
throws
java
.
lang
.
Exception
{
char
ch
[
]
=
s
.
toCharArray
(
)
;
pushCharArray
(
ename
,
ch
,
0
,
ch
.
length
)
;
}
void
pushCharArray
(
String
ename
,
char
ch
[
]
,
int
start
,
int
length
)
throws
java
.
lang
.
Exception
{
pushInput
(
ename
)
;
sourceType
=
INPUT_INTERNAL
;
readBuffer
=
ch
;
readBufferPos
=
start
;
readBufferLength
=
length
;
readBufferOverflow
=
-
1
;
}
void
pushInput
(
String
ename
)
throws
java
.
lang
.
Exception
{
Object
input
[
]
=
new
Object
[
12
]
;
if
(
ename
!=
null
)
{
Enumeration
entities
=
entityStack
.
elements
(
)
;
while
(
entities
.
hasMoreElements
(
)
)
{
String
e
=
(
String
)
entities
.
nextElement
(
)
;
if
(
e
==
ename
)
{
error
(
"recursive reference to entity"
,
ename
,
null
)
;
}
}
}
entityStack
.
push
(
ename
)
;
if
(
sourceType
==
INPUT_NONE
)
{
return
;
}
input
[
0
]
=
new
Integer
(
sourceType
)
;
input
[
1
]
=
externalEntity
;
input
[
2
]
=
readBuffer
;
input
[
3
]
=
new
Integer
(
readBufferPos
)
;
input
[
4
]
=
new
Integer
(
readBufferLength
)
;
input
[
5
]
=
new
Integer
(
line
)
;
input
[
6
]
=
new
Integer
(
encoding
)
;
input
[
7
]
=
new
Integer
(
readBufferOverflow
)
;
input
[
8
]
=
is
;
input
[
9
]
=
new
Integer
(
currentByteCount
)
;
input
[
10
]
=
new
Integer
(
column
)
;
input
[
11
]
=
reader
;
inputStack
.
push
(
input
)
;
}
void
popInput
(
)
throws
java
.
lang
.
Exception
{
Object
input
[
]
;
switch
(
sourceType
)
{
case
INPUT_EXTERNAL
:
dataBufferFlush
(
)
;
if
(
handler
!=
null
&&
externalEntity
!=
null
)
{
handler
.
endExternalEntity
(
externalEntity
.
getURL
(
)
.
toString
(
)
)
;
}
break
;
case
INPUT_STREAM
:
dataBufferFlush
(
)
;
if
(
baseURI
!=
null
)
{
if
(
handler
!=
null
)
{
handler
.
endExternalEntity
(
baseURI
)
;
}
}
break
;
case
INPUT_READER
:
dataBufferFlush
(
)
;
if
(
baseURI
!=
null
)
{
if
(
handler
!=
null
)
{
handler
.
endExternalEntity
(
baseURI
)
;
}
}
break
;
}
if
(
inputStack
.
isEmpty
(
)
)
{
throw
new
EOFException
(
)
;
}
else
{
String
s
;
input
=
(
Object
[
]
)
inputStack
.
pop
(
)
;
s
=
(
String
)
entityStack
.
pop
(
)
;
}
sourceType
=
(
(
Integer
)
input
[
0
]
)
.
intValue
(
)
;
externalEntity
=
(
URLConnection
)
input
[
1
]
;
readBuffer
=
(
char
[
]
)
input
[
2
]
;
readBufferPos
=
(
(
Integer
)
input
[
3
]
)
.
intValue
(
)
;
readBufferLength
=
(
(
Integer
)
input
[
4
]
)
.
intValue
(
)
;
line
=
(
(
Integer
)
input
[
5
]
)
.
intValue
(
)
;
encoding
=
(
(
Integer
)
input
[
6
]
)
.
intValue
(
)
;
readBufferOverflow
=
(
(
Integer
)
input
[
7
]
)
.
intValue
(
)
;
is
=
(
InputStream
)
input
[
8
]
;
currentByteCount
=
(
(
Integer
)
input
[
9
]
)
.
intValue
(
)
;
column
=
(
(
Integer
)
input
[
10
]
)
.
intValue
(
)
;
reader
=
(
Reader
)
input
[
11
]
;
}
boolean
tryRead
(
char
delim
)
throws
java
.
lang
.
Exception
{
char
c
;
c
=
readCh
(
)
;
if
(
c
==
delim
)
{
return
true
;
}
else
{
unread
(
c
)
;
return
false
;
}
}
boolean
tryRead
(
String
delim
)
throws
java
.
lang
.
Exception
{
char
ch
[
]
=
delim
.
toCharArray
(
)
;
char
c
;
for
(
int
i
=
0
;
i
<
ch
.
length
;
i
++
)
{
c
=
readCh
(
)
;
if
(
c
!=
ch
[
i
]
)
{
unread
(
c
)
;
if
(
i
!=
0
)
{
unread
(
ch
,
i
)
;
}
return
false
;
}
}
return
true
;
}
boolean
tryWhitespace
(
)
throws
java
.
lang
.
Exception
{
char
c
;
c
=
readCh
(
)
;
if
(
isWhitespace
(
c
)
)
{
skipWhitespace
(
)
;
return
true
;
}
else
{
unread
(
c
)
;
return
false
;
}
}
void
parseUntil
(
String
delim
)
throws
java
.
lang
.
Exception
{
char
c
;
int
startLine
=
line
;
try
{
while
(
!
tryRead
(
delim
)
)
{
c
=
readCh
(
)
;
dataBufferAppend
(
c
)
;
}
}
catch
(
EOFException
e
)
{
error
(
"end of input while looking for delimiter (started on line "
+
startLine
+
')'
,
null
,
delim
)
;
}
}
void
skipUntil
(
String
delim
)
throws
java
.
lang
.
Exception
{
while
(
!
tryRead
(
delim
)
)
{
readCh
(
)
;
}
}
void
read8bitEncodingDeclaration
(
)
throws
java
.
lang
.
Exception
{
int
ch
;
readBufferPos
=
readBufferLength
=
0
;
while
(
true
)
{
ch
=
is
.
read
(
)
;
readBuffer
[
readBufferLength
++
]
=
(
char
)
ch
;
switch
(
ch
)
{
case
(
int
)
'>'
:
return
;
case
-
1
:
error
(
"end of file before end of XML or encoding declaration."
,
null
,
"?>"
)
;
return
;
}
if
(
readBuffer
.
length
==
readBufferLength
)
{
error
(
"unfinished XML or encoding declaration"
,
null
,
null
)
;
}
}
}
void
readDataChunk
(
)
throws
java
.
lang
.
Exception
{
int
count
,
i
,
j
;
if
(
readBufferOverflow
>
-
1
)
{
readBuffer
[
0
]
=
(
char
)
readBufferOverflow
;
readBufferOverflow
=
-
1
;
readBufferPos
=
1
;
sawCR
=
true
;
}
else
{
readBufferPos
=
0
;
sawCR
=
false
;
}
if
(
sourceType
==
INPUT_READER
)
{
count
=
reader
.
read
(
readBuffer
,
readBufferPos
,
READ_BUFFER_MAX
-
1
)
;
if
(
count
<
0
)
{
readBufferLength
=
-
1
;
}
else
{
readBufferLength
=
readBufferPos
+
count
;
filterCR
(
)
;
sawCR
=
false
;
}
return
;
}
count
=
is
.
read
(
rawReadBuffer
,
0
,
READ_BUFFER_MAX
)
;
switch
(
encoding
)
{
case
ENCODING_UTF_8
:
copyUtf8ReadBuffer
(
count
)
;
break
;
case
ENCODING_ISO_8859_1
:
copyIso8859_1ReadBuffer
(
count
)
;
break
;
case
ENCODING_UCS_2_12
:
copyUcs2ReadBuffer
(
count
,
8
,
0
)
;
break
;
case
ENCODING_UCS_2_21
:
copyUcs2ReadBuffer
(
count
,
0
,
8
)
;
break
;
case
ENCODING_UCS_4_1234
:
copyUcs4ReadBuffer
(
count
,
24
,
16
,
8
,
0
)
;
break
;
case
ENCODING_UCS_4_4321
:
copyUcs4ReadBuffer
(
count
,
0
,
8
,
16
,
24
)
;
break
;
case
ENCODING_UCS_4_2143
:
copyUcs4ReadBuffer
(
count
,
16
,
24
,
0
,
8
)
;
break
;
case
ENCODING_UCS_4_3412
:
copyUcs4ReadBuffer
(
count
,
8
,
0
,
24
,
16
)
;
break
;
}
if
(
sawCR
)
{
filterCR
(
)
;
sawCR
=
false
;
}
readBufferPos
=
0
;
currentByteCount
+=
count
;
}
void
filterCR
(
)
{
int
i
,
j
;
readBufferOverflow
=
-
1
;
loop
:
for
(
i
=
0
,
j
=
0
;
j
<
readBufferLength
;
i
++
,
j
++
)
{
switch
(
readBuffer
[
j
]
)
{
case
'\r'
:
if
(
j
==
readBufferLength
-
1
)
{
readBufferOverflow
=
'\r'
;
readBufferLength
--
;
break
loop
;
}
else
if
(
readBuffer
[
j
+
1
]
==
'\n'
)
{
j
++
;
}
readBuffer
[
i
]
=
'\n'
;
break
;
case
'\n'
:
default
:
readBuffer
[
i
]
=
readBuffer
[
j
]
;
break
;
}
}
readBufferLength
=
i
;
}
void
copyUtf8ReadBuffer
(
int
count
)
throws
java
.
lang
.
Exception
{
int
i
=
0
;
int
j
=
readBufferPos
;
int
b1
;
boolean
isSurrogate
=
false
;
while
(
i
<
count
)
{
b1
=
rawReadBuffer
[
i
++
]
;
isSurrogate
=
false
;
if
(
(
b1
&
0x80
)
==
0
)
{
readBuffer
[
j
++
]
=
(
char
)
b1
;
}
else
if
(
(
b1
&
0xe0
)
==
0xc0
)
{
readBuffer
[
j
++
]
=
(
char
)
(
(
(
b1
&
0x1f
)
<<
6
)
|
getNextUtf8Byte
(
i
++
,
count
)
)
;
}
else
if
(
(
b1
&
0xf0
)
==
0xe0
)
{
readBuffer
[
j
++
]
=
(
char
)
(
(
(
b1
&
0x0f
)
<<
12
)
|
(
getNextUtf8Byte
(
i
++
,
count
)
<<
6
)
|
getNextUtf8Byte
(
i
++
,
count
)
)
;
}
else
if
(
(
b1
&
0xf8
)
==
0xf0
)
{
isSurrogate
=
true
;
int
b2
=
getNextUtf8Byte
(
i
++
,
count
)
;
int
b3
=
getNextUtf8Byte
(
i
++
,
count
)
;
int
b4
=
getNextUtf8Byte
(
i
++
,
count
)
;
readBuffer
[
j
++
]
=
(
char
)
(
0xd800
|
(
(
(
(
b1
&
0x07
)
<<
2
)
|
(
(
b2
&
0x30
)
>
>
4
)
-
1
)
<<
6
)
|
(
(
b2
&
0x0f
)
<<
2
)
|
(
(
b3
&
0x30
)
>
>
4
)
)
;
readBuffer
[
j
++
]
=
(
char
)
(
0xdc
|
(
(
b3
&
0x0f
)
<<
6
)
|
b4
)
;
}
else
{
encodingError
(
"bad start for UTF-8 multi-byte sequence"
,
b1
,
i
)
;
}
if
(
readBuffer
[
j
-
1
]
==
'\r'
)
{
sawCR
=
true
;
}
}
readBufferLength
=
j
;
}
int
getNextUtf8Byte
(
int
pos
,
int
count
)
throws
java
.
lang
.
Exception
{
int
val
;
if
(
pos
<
count
)
{
val
=
rawReadBuffer
[
pos
]
;
}
else
{
val
=
is
.
read
(
)
;
if
(
val
==
-
1
)
{
encodingError
(
"unfinished multi-byte UTF-8 sequence at EOF"
,
-
1
,
pos
)
;
}
}
if
(
(
val
&
0xc0
)
!=
0x80
)
{
encodingError
(
"bad continuation of multi-byte UTF-8 sequence"
,
val
,
pos
+
1
)
;
}
return
(
val
&
0x3f
)
;
}
void
copyIso8859_1ReadBuffer
(
int
count
)
{
int
i
,
j
;
for
(
i
=
0
,
j
=
readBufferPos
;
i
<
count
;
i
++
,
j
++
)
{
readBuffer
[
j
]
=
(
char
)
(
rawReadBuffer
[
i
]
&
0xff
)
;
if
(
readBuffer
[
j
]
==
'\r'
)
{
sawCR
=
true
;
}
}
readBufferLength
=
j
;
}
void
copyUcs2ReadBuffer
(
int
count
,
int
shift1
,
int
shift2
)
throws
java
.
lang
.
Exception
{
int
j
=
readBufferPos
;
if
(
count
>
0
&&
(
count
%
2
)
!=
0
)
{
encodingError
(
"odd number of bytes in UCS-2 encoding"
,
-
1
,
count
)
;
}
for
(
int
i
=
0
;
i
<
count
;
i
+=
2
)
{
readBuffer
[
j
++
]
=
(
char
)
(
(
(
rawReadBuffer
[
i
]
&
0xff
)
<<
shift1
)
|
(
(
rawReadBuffer
[
i
+
1
]
&
0xff
)
<<
shift2
)
)
;
if
(
readBuffer
[
j
-
1
]
==
'\r'
)
{
sawCR
=
true
;
}
}
readBufferLength
=
j
;
}
void
copyUcs4ReadBuffer
(
int
count
,
int
shift1
,
int
shift2
,
int
shift3
,
int
shift4
)
throws
java
.
lang
.
Exception
{
int
j
=
readBufferPos
;
int
value
;
if
(
count
>
0
&&
(
count
%
4
)
!=
0
)
{
encodingError
(
"number of bytes in UCS-4 encoding not divisible by 4"
,
-
1
,
count
)
;
}
for
(
int
i
=
0
;
i
<
count
;
i
+=
4
)
{
value
=
(
(
(
rawReadBuffer
[
i
]
&
0xff
)
<<
shift1
)
|
(
(
rawReadBuffer
[
i
+
1
]
&
0xff
)
<<
shift2
)
|
(
(
rawReadBuffer
[
i
+
2
]
&
0xff
)
<<
shift3
)
|
(
(
rawReadBuffer
[
i
+
3
]
&
0xff
)
<<
shift4
)
)
;
if
(
value
<
0x0000ffff
)
{
readBuffer
[
j
++
]
=
(
char
)
value
;
if
(
value
==
(
int
)
'\r'
)
{
sawCR
=
true
;
}
}
else
if
(
value
<
0x000fffff
)
{
readBuffer
[
j
++
]
=
(
char
)
(
0xd8
|
(
(
value
&
0x000ffc00
)
>
>
10
)
)
;
readBuffer
[
j
++
]
=
(
char
)
(
0xdc
|
(
value
&
0x0003ff
)
)
;
}
else
{
encodingError
(
"value cannot be represented in UTF-16"
,
value
,
i
)
;
}
}
readBufferLength
=
j
;
}
void
encodingError
(
String
message
,
int
value
,
int
offset
)
throws
java
.
lang
.
Exception
{
String
uri
;
if
(
value
>=
0
)
{
message
=
message
+
" (byte value: 0x"
+
Integer
.
toHexString
(
value
)
+
')'
;
}
if
(
externalEntity
!=
null
)
{
uri
=
externalEntity
.
getURL
(
)
.
toString
(
)
;
}
else
{
uri
=
baseURI
;
}
handler
.
error
(
message
,
uri
,
-
1
,
offset
+
currentByteCount
)
;
}
void
initializeVariables
(
)
{
errorCount
=
0
;
line
=
1
;
column
=
0
;
dataBufferPos
=
0
;
dataBuffer
=
new
char
[
DATA_BUFFER_INITIAL
]
;
nameBufferPos
=
0
;
nameBuffer
=
new
char
[
NAME_BUFFER_INITIAL
]
;
elementInfo
=
new
Hashtable
(
)
;
entityInfo
=
new
Hashtable
(
)
;
notationInfo
=
new
Hashtable
(
)
;
currentElement
=
null
;
currentElementContent
=
CONTENT_UNDECLARED
;
sourceType
=
INPUT_NONE
;
inputStack
=
new
Stack
(
)
;
entityStack
=
new
Stack
(
)
;
externalEntity
=
null
;
tagAttributePos
=
0
;
tagAttributes
=
new
String
[
100
]
;
rawReadBuffer
=
new
byte
[
READ_BUFFER_MAX
]
;
readBufferOverflow
=
-
1
;
context
=
CONTEXT_NONE
;
symbolTable
=
new
Object
[
SYMBOL_TABLE_LENGTH
]
;
}
void
cleanupVariables
(
)
{
errorCount
=
-
1
;
line
=
-
1
;
column
=
-
1
;
dataBuffer
=
null
;
nameBuffer
=
null
;
currentElement
=
null
;
currentElementContent
=
CONTENT_UNDECLARED
;
sourceType
=
INPUT_NONE
;
inputStack
=
null
;
externalEntity
=
null
;
entityStack
=
null
;
}
XmlHandler
handler
;
private
Reader
reader
;
private
InputStream
is
;
private
int
line
;
private
int
column
;
private
int
sourceType
;
private
Stack
inputStack
;
private
URLConnection
externalEntity
;
private
int
encoding
;
private
int
currentByteCount
;
private
int
errorCount
;
private
final
static
int
READ_BUFFER_MAX
=
16384
;
private
char
readBuffer
[
]
;
private
int
readBufferPos
;
private
int
readBufferLength
;
private
int
readBufferOverflow
;
private
byte
rawReadBuffer
[
]
;
private
static
int
DATA_BUFFER_INITIAL
=
4096
;
private
char
dataBuffer
[
]
;
private
int
dataBufferPos
;
private
static
int
NAME_BUFFER_INITIAL
=
1024
;
private
char
nameBuffer
[
]
;
private
int
nameBufferPos
;
private
Hashtable
elementInfo
;
private
Hashtable
entityInfo
;
private
Hashtable
notationInfo
;
private
String
currentElement
;
private
int
currentElementContent
;
private
String
basePublicId
;
private
String
baseURI
;
private
int
baseEncoding
;
private
Reader
baseReader
;
private
InputStream
baseInputStream
;
private
char
baseInputBuffer
[
]
;
private
int
baseInputBufferStart
;
private
int
baseInputBufferLength
;
private
Stack
entityStack
;
private
int
context
;
private
Object
symbolTable
[
]
;
private
final
static
int
SYMBOL_TABLE_LENGTH
=
1087
;
private
String
tagAttributes
[
]
;
private
int
tagAttributePos
;
private
boolean
sawCR
;
}
