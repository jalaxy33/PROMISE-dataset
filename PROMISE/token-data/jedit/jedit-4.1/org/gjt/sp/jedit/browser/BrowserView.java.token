package
org
.
gjt
.
sp
.
jedit
.
browser
;
import
javax
.
swing
.
border
.
EmptyBorder
;
import
javax
.
swing
.
event
.
*
;
import
javax
.
swing
.
tree
.
*
;
import
javax
.
swing
.
*
;
import
java
.
awt
.
event
.
*
;
import
java
.
awt
.
*
;
import
java
.
io
.
File
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Vector
;
import
org
.
gjt
.
sp
.
jedit
.
io
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
*
;
public
class
BrowserView
extends
JPanel
{
public
BrowserView
(
VFSBrowser
browser
,
final
boolean
splitHorizontally
)
{
this
.
browser
=
browser
;
this
.
splitHorizontally
=
splitHorizontally
;
parentModel
=
new
DefaultListModel
(
)
;
parentDirectories
=
new
JList
(
parentModel
)
;
parentDirectories
.
getSelectionModel
(
)
.
setSelectionMode
(
TreeSelectionModel
.
SINGLE_TREE_SELECTION
)
;
parentDirectories
.
setCellRenderer
(
new
ParentDirectoryRenderer
(
)
)
;
parentDirectories
.
setVisibleRowCount
(
5
)
;
parentDirectories
.
addMouseListener
(
new
MouseHandler
(
)
)
;
rootNode
=
new
DefaultMutableTreeNode
(
null
,
true
)
;
model
=
new
DefaultTreeModel
(
rootNode
,
true
)
;
tree
=
new
BrowserJTree
(
model
)
;
tree
.
setCellRenderer
(
renderer
)
;
tree
.
setEditable
(
false
)
;
tree
.
addTreeExpansionListener
(
new
TreeHandler
(
)
)
;
tree
.
putClientProperty
(
"JTree.lineStyle"
,
"Angled"
)
;
tree
.
setRootVisible
(
false
)
;
tree
.
setShowsRootHandles
(
true
)
;
tree
.
setVisibleRowCount
(
12
)
;
final
JScrollPane
parentScroller
=
new
JScrollPane
(
parentDirectories
)
;
parentScroller
.
setMinimumSize
(
new
Dimension
(
0
,
0
)
)
;
JScrollPane
treeScroller
=
new
JScrollPane
(
tree
)
;
treeScroller
.
setMinimumSize
(
new
Dimension
(
0
,
0
)
)
;
splitPane
=
new
JSplitPane
(
splitHorizontally
?
JSplitPane
.
HORIZONTAL_SPLIT
:
JSplitPane
.
VERTICAL_SPLIT
,
parentScroller
,
treeScroller
)
;
SwingUtilities
.
invokeLater
(
new
Runnable
(
)
{
public
void
run
(
)
{
String
prop
=
splitHorizontally
?
"vfs.browser.horizontalSplitter"
:
"vfs.browser.splitter"
;
int
loc
=
jEdit
.
getIntegerProperty
(
prop
,
-
1
)
;
if
(
loc
==
-
1
)
loc
=
parentScroller
.
getPreferredSize
(
)
.
height
;
splitPane
.
setDividerLocation
(
loc
)
;
parentDirectories
.
ensureIndexIsVisible
(
parentDirectories
.
getModel
(
)
.
getSize
(
)
)
;
}
}
)
;
tmpExpanded
=
new
Hashtable
(
)
;
if
(
browser
.
isMultipleSelectionEnabled
(
)
)
tree
.
getSelectionModel
(
)
.
setSelectionMode
(
TreeSelectionModel
.
DISCONTIGUOUS_TREE_SELECTION
)
;
else
tree
.
getSelectionModel
(
)
.
setSelectionMode
(
TreeSelectionModel
.
SINGLE_TREE_SELECTION
)
;
setLayout
(
new
BorderLayout
(
)
)
;
add
(
BorderLayout
.
CENTER
,
splitPane
)
;
propertiesChanged
(
)
;
}
public
boolean
requestDefaultFocus
(
)
{
tree
.
requestFocus
(
)
;
return
true
;
}
public
void
removeNotify
(
)
{
String
prop
=
splitHorizontally
?
"vfs.browser.horizontalSplitter"
:
"vfs.browser.splitter"
;
jEdit
.
setIntegerProperty
(
prop
,
splitPane
.
getDividerLocation
(
)
)
;
super
.
removeNotify
(
)
;
}
public
VFS
.
DirectoryEntry
[
]
getSelectedFiles
(
)
{
Vector
selected
=
new
Vector
(
tree
.
getSelectionCount
(
)
)
;
TreePath
[
]
paths
=
tree
.
getSelectionPaths
(
)
;
if
(
paths
==
null
)
return
new
VFS
.
DirectoryEntry
[
0
]
;
for
(
int
i
=
0
;
i
<
paths
.
length
;
i
++
)
{
DefaultMutableTreeNode
treeNode
=
(
DefaultMutableTreeNode
)
paths
[
i
]
.
getLastPathComponent
(
)
;
Object
obj
=
treeNode
.
getUserObject
(
)
;
if
(
obj
instanceof
VFS
.
DirectoryEntry
)
selected
.
addElement
(
obj
)
;
}
VFS
.
DirectoryEntry
[
]
retVal
=
new
VFS
.
DirectoryEntry
[
selected
.
size
(
)
]
;
selected
.
copyInto
(
retVal
)
;
return
retVal
;
}
public
void
selectNone
(
)
{
tree
.
setSelectionPaths
(
new
TreePath
[
0
]
)
;
}
public
void
directoryLoaded
(
DefaultMutableTreeNode
node
,
String
path
,
Vector
directory
)
{
if
(
node
==
rootNode
)
{
parentModel
.
removeAllElements
(
)
;
String
parent
=
path
;
if
(
parent
.
length
(
)
!=
1
&&
(
parent
.
endsWith
(
"/"
)
||
parent
.
endsWith
(
File
.
separator
)
)
)
parent
=
parent
.
substring
(
0
,
parent
.
length
(
)
-
1
)
;
for
(
;
;
)
{
parentModel
.
insertElementAt
(
parent
,
0
)
;
String
newParent
=
MiscUtilities
.
getParentOfPath
(
parent
)
;
if
(
newParent
.
length
(
)
!=
1
&&
(
newParent
.
endsWith
(
"/"
)
||
newParent
.
endsWith
(
File
.
separator
)
)
)
newParent
=
newParent
.
substring
(
0
,
newParent
.
length
(
)
-
1
)
;
if
(
newParent
==
null
||
parent
.
equals
(
newParent
)
)
break
;
else
parent
=
newParent
;
}
int
index
=
parentModel
.
getSize
(
)
-
1
;
parentDirectories
.
setSelectedIndex
(
index
)
;
parentDirectories
.
ensureIndexIsVisible
(
parentModel
.
getSize
(
)
-
1
)
;
}
node
.
removeAllChildren
(
)
;
Vector
toExpand
=
new
Vector
(
)
;
if
(
directory
!=
null
)
{
for
(
int
i
=
0
;
i
<
directory
.
size
(
)
;
i
++
)
{
VFS
.
DirectoryEntry
file
=
(
VFS
.
DirectoryEntry
)
directory
.
elementAt
(
i
)
;
boolean
allowsChildren
=
(
file
.
type
!=
VFS
.
DirectoryEntry
.
FILE
)
;
DefaultMutableTreeNode
newNode
=
new
DefaultMutableTreeNode
(
file
,
allowsChildren
)
;
node
.
add
(
newNode
)
;
if
(
tmpExpanded
.
get
(
file
.
path
)
!=
null
)
toExpand
.
addElement
(
new
TreePath
(
newNode
.
getPath
(
)
)
)
;
}
}
model
.
reload
(
node
)
;
tree
.
expandPath
(
new
TreePath
(
node
.
getPath
(
)
)
)
;
for
(
int
i
=
0
;
i
<
toExpand
.
size
(
)
;
i
++
)
{
TreePath
treePath
=
(
TreePath
)
toExpand
.
elementAt
(
i
)
;
tree
.
expandPath
(
treePath
)
;
}
timer
.
stop
(
)
;
typeSelectBuffer
.
setLength
(
0
)
;
}
public
void
updateFileView
(
)
{
tree
.
repaint
(
)
;
}
public
void
loadDirectory
(
String
path
)
{
tmpExpanded
.
clear
(
)
;
loadDirectory
(
rootNode
,
path
,
false
)
;
}
public
void
maybeReloadDirectory
(
String
path
)
{
tmpExpanded
.
clear
(
)
;
String
browserDir
=
browser
.
getDirectory
(
)
;
if
(
browserDir
.
startsWith
(
FavoritesVFS
.
PROTOCOL
)
)
maybeReloadDirectory
(
rootNode
,
path
)
;
else
if
(
browserDir
.
startsWith
(
FileRootsVFS
.
PROTOCOL
)
)
{
if
(
!
MiscUtilities
.
isURL
(
path
)
||
MiscUtilities
.
getProtocolOfURL
(
path
)
.
equals
(
"file"
)
)
maybeReloadDirectory
(
rootNode
,
path
)
;
}
else
if
(
path
.
startsWith
(
browserDir
)
)
maybeReloadDirectory
(
rootNode
,
path
)
;
}
public
Component
getDefaultFocusComponent
(
)
{
return
tree
;
}
public
void
propertiesChanged
(
)
{
showIcons
=
jEdit
.
getBooleanProperty
(
"vfs.browser.showIcons"
)
;
renderer
.
propertiesChanged
(
)
;
tree
.
setRowHeight
(
renderer
.
getTreeCellRendererComponent
(
tree
,
new
DefaultMutableTreeNode
(
"foo"
)
,
false
,
false
,
false
,
0
,
false
)
.
getSize
(
)
.
height
)
;
splitPane
.
setBorder
(
null
)
;
}
private
VFSBrowser
browser
;
private
JSplitPane
splitPane
;
private
JList
parentDirectories
;
private
DefaultListModel
parentModel
;
private
JTree
tree
;
private
Hashtable
tmpExpanded
;
private
DefaultTreeModel
model
;
private
DefaultMutableTreeNode
rootNode
;
private
BrowserCommandsMenu
popup
;
private
boolean
showIcons
;
private
boolean
splitHorizontally
;
private
FileCellRenderer
renderer
=
new
FileCellRenderer
(
)
;
private
StringBuffer
typeSelectBuffer
=
new
StringBuffer
(
)
;
private
Timer
timer
=
new
Timer
(
0
,
new
ClearTypeSelect
(
)
)
;
private
boolean
maybeReloadDirectory
(
DefaultMutableTreeNode
node
,
String
path
)
{
if
(
!
tree
.
isExpanded
(
new
TreePath
(
node
.
getPath
(
)
)
)
)
return
false
;
if
(
node
==
rootNode
&&
path
.
equals
(
browser
.
getDirectory
(
)
)
)
{
loadDirectory
(
rootNode
,
path
,
false
)
;
return
true
;
}
Object
userObject
=
node
.
getUserObject
(
)
;
if
(
userObject
instanceof
VFS
.
DirectoryEntry
)
{
VFS
.
DirectoryEntry
file
=
(
VFS
.
DirectoryEntry
)
userObject
;
if
(
file
.
type
==
VFS
.
DirectoryEntry
.
FILE
)
return
false
;
if
(
path
.
equals
(
file
.
path
)
)
{
loadDirectory
(
node
,
path
,
false
)
;
return
true
;
}
}
if
(
node
.
getChildCount
(
)
!=
0
)
{
Enumeration
children
=
node
.
children
(
)
;
while
(
children
.
hasMoreElements
(
)
)
{
DefaultMutableTreeNode
child
=
(
DefaultMutableTreeNode
)
children
.
nextElement
(
)
;
if
(
maybeReloadDirectory
(
child
,
path
)
)
return
true
;
}
}
return
false
;
}
private
void
loadDirectory
(
DefaultMutableTreeNode
node
,
String
path
,
boolean
showLoading
)
{
int
rowCount
=
tree
.
getRowCount
(
)
;
for
(
int
i
=
0
;
i
<
rowCount
;
i
++
)
{
TreePath
treePath
=
tree
.
getPathForRow
(
i
)
;
if
(
tree
.
isExpanded
(
treePath
)
)
{
DefaultMutableTreeNode
_node
=
(
DefaultMutableTreeNode
)
treePath
.
getLastPathComponent
(
)
;
VFS
.
DirectoryEntry
file
=
(
(
VFS
.
DirectoryEntry
)
_node
.
getUserObject
(
)
)
;
tmpExpanded
.
put
(
file
.
path
,
file
.
path
)
;
}
}
if
(
node
==
rootNode
)
{
parentModel
.
removeAllElements
(
)
;
parentModel
.
addElement
(
new
LoadingPlaceholder
(
)
)
;
}
if
(
showLoading
)
{
node
.
removeAllChildren
(
)
;
node
.
add
(
new
DefaultMutableTreeNode
(
new
LoadingPlaceholder
(
)
,
false
)
)
;
model
.
reload
(
node
)
;
}
browser
.
loadDirectory
(
node
,
path
,
node
==
rootNode
)
;
}
private
void
showFilePopup
(
VFS
.
DirectoryEntry
file
,
Point
point
)
{
popup
=
new
BrowserCommandsMenu
(
browser
,
file
)
;
GUIUtilities
.
showPopupMenu
(
popup
,
tree
,
point
.
x
+
1
,
point
.
y
+
1
)
;
}
class
ClearTypeSelect
implements
ActionListener
{
public
void
actionPerformed
(
ActionEvent
evt
)
{
typeSelectBuffer
.
setLength
(
0
)
;
browser
.
filesSelected
(
)
;
}
}
class
ParentDirectoryRenderer
extends
DefaultListCellRenderer
{
Font
plainFont
,
boldFont
;
ParentDirectoryRenderer
(
)
{
plainFont
=
UIManager
.
getFont
(
"Tree.font"
)
;
boldFont
=
new
Font
(
plainFont
.
getName
(
)
,
Font
.
BOLD
,
plainFont
.
getSize
(
)
)
;
}
public
Component
getListCellRendererComponent
(
JList
list
,
Object
value
,
int
index
,
boolean
isSelected
,
boolean
cellHasFocus
)
{
super
.
getListCellRendererComponent
(
list
,
value
,
index
,
isSelected
,
cellHasFocus
)
;
ParentDirectoryRenderer
.
this
.
setBorder
(
new
EmptyBorder
(
1
,
index
*
10
+
1
,
1
,
1
)
)
;
if
(
value
instanceof
LoadingPlaceholder
)
{
ParentDirectoryRenderer
.
this
.
setFont
(
plainFont
)
;
setIcon
(
showIcons
?
FileCellRenderer
.
loadingIcon
:
null
)
;
setText
(
jEdit
.
getProperty
(
"vfs.browser.tree.loading"
)
)
;
}
else
{
ParentDirectoryRenderer
.
this
.
setFont
(
boldFont
)
;
setIcon
(
showIcons
?
FileCellRenderer
.
openDirIcon
:
null
)
;
setText
(
MiscUtilities
.
getFileName
(
value
.
toString
(
)
)
)
;
}
return
this
;
}
}
class
MouseHandler
extends
MouseAdapter
{
public
void
mouseClicked
(
MouseEvent
evt
)
{
if
(
evt
.
getClickCount
(
)
==
2
)
return
;
int
row
=
parentDirectories
.
locationToIndex
(
evt
.
getPoint
(
)
)
;
if
(
row
!=
-
1
)
{
Object
obj
=
parentModel
.
getElementAt
(
row
)
;
if
(
obj
instanceof
String
)
{
browser
.
setDirectory
(
(
String
)
obj
)
;
requestDefaultFocus
(
)
;
}
}
}
}
class
BrowserJTree
extends
JTree
{
BrowserJTree
(
TreeModel
model
)
{
super
(
model
)
;
ToolTipManager
.
sharedInstance
(
)
.
registerComponent
(
this
)
;
}
public
final
String
getToolTipText
(
MouseEvent
evt
)
{
TreePath
path
=
getPathForLocation
(
evt
.
getX
(
)
,
evt
.
getY
(
)
)
;
if
(
path
!=
null
)
{
Rectangle
cellRect
=
getPathBounds
(
path
)
;
if
(
cellRect
!=
null
&&
!
cellRectIsVisible
(
cellRect
)
)
return
path
.
getLastPathComponent
(
)
.
toString
(
)
;
}
return
null
;
}
public
final
Point
getToolTipLocation
(
MouseEvent
evt
)
{
TreePath
path
=
getPathForLocation
(
evt
.
getX
(
)
,
evt
.
getY
(
)
)
;
if
(
path
!=
null
)
{
Rectangle
cellRect
=
getPathBounds
(
path
)
;
if
(
cellRect
!=
null
&&
!
cellRectIsVisible
(
cellRect
)
)
{
return
new
Point
(
cellRect
.
x
+
(
showIcons
?
14
:
-
4
)
,
cellRect
.
y
)
;
}
}
return
null
;
}
protected
void
processKeyEvent
(
KeyEvent
evt
)
{
if
(
evt
.
getID
(
)
==
KeyEvent
.
KEY_PRESSED
)
{
switch
(
evt
.
getKeyCode
(
)
)
{
case
KeyEvent
.
VK_ENTER
:
browser
.
filesActivated
(
evt
.
isShiftDown
(
)
,
false
)
;
evt
.
consume
(
)
;
break
;
case
KeyEvent
.
VK_LEFT
:
String
directory
=
browser
.
getDirectory
(
)
;
browser
.
setDirectory
(
MiscUtilities
.
getParentOfPath
(
directory
)
)
;
evt
.
consume
(
)
;
break
;
}
}
else
if
(
evt
.
getID
(
)
==
KeyEvent
.
KEY_TYPED
)
{
if
(
evt
.
isControlDown
(
)
||
evt
.
isAltDown
(
)
||
evt
.
isMetaDown
(
)
)
{
return
;
}
switch
(
evt
.
getKeyChar
(
)
)
{
case
'~'
:
browser
.
setDirectory
(
System
.
getProperty
(
"user.home"
)
)
;
break
;
case
'/'
:
browser
.
rootDirectory
(
)
;
break
;
case
'-'
:
View
view
=
browser
.
getView
(
)
;
Buffer
buffer
=
view
.
getBuffer
(
)
;
browser
.
setDirectory
(
MiscUtilities
.
getParentOfPath
(
buffer
.
getPath
(
)
)
)
;
break
;
default
:
typeSelectBuffer
.
append
(
evt
.
getKeyChar
(
)
)
;
doTypeSelect
(
typeSelectBuffer
.
toString
(
)
)
;
timer
.
stop
(
)
;
timer
.
setInitialDelay
(
750
)
;
timer
.
setRepeats
(
false
)
;
timer
.
start
(
)
;
break
;
}
return
;
}
if
(
!
evt
.
isConsumed
(
)
)
super
.
processKeyEvent
(
evt
)
;
}
protected
void
processMouseEvent
(
MouseEvent
evt
)
{
ToolTipManager
ttm
=
ToolTipManager
.
sharedInstance
(
)
;
switch
(
evt
.
getID
(
)
)
{
case
MouseEvent
.
MOUSE_ENTERED
:
toolTipInitialDelay
=
ttm
.
getInitialDelay
(
)
;
toolTipReshowDelay
=
ttm
.
getReshowDelay
(
)
;
ttm
.
setInitialDelay
(
200
)
;
ttm
.
setReshowDelay
(
0
)
;
super
.
processMouseEvent
(
evt
)
;
break
;
case
MouseEvent
.
MOUSE_EXITED
:
ttm
.
setInitialDelay
(
toolTipInitialDelay
)
;
ttm
.
setReshowDelay
(
toolTipReshowDelay
)
;
super
.
processMouseEvent
(
evt
)
;
break
;
case
MouseEvent
.
MOUSE_CLICKED
:
if
(
(
evt
.
getModifiers
(
)
&
MouseEvent
.
BUTTON2_MASK
)
!=
0
)
{
TreePath
path
=
getPathForLocation
(
evt
.
getX
(
)
,
evt
.
getY
(
)
)
;
if
(
path
==
null
)
{
super
.
processMouseEvent
(
evt
)
;
break
;
}
if
(
!
isPathSelected
(
path
)
)
setSelectionPath
(
path
)
;
browser
.
filesActivated
(
evt
.
isShiftDown
(
)
,
true
)
;
break
;
}
else
if
(
(
evt
.
getModifiers
(
)
&
MouseEvent
.
BUTTON1_MASK
)
!=
0
)
{
TreePath
path
=
getPathForLocation
(
evt
.
getX
(
)
,
evt
.
getY
(
)
)
;
if
(
path
==
null
)
{
super
.
processMouseEvent
(
evt
)
;
break
;
}
if
(
!
isPathSelected
(
path
)
)
setSelectionPath
(
path
)
;
if
(
evt
.
getClickCount
(
)
==
1
)
{
browser
.
filesSelected
(
)
;
super
.
processMouseEvent
(
evt
)
;
}
if
(
evt
.
getClickCount
(
)
==
2
)
{
browser
.
filesActivated
(
evt
.
isShiftDown
(
)
,
true
)
;
break
;
}
}
else
if
(
GUIUtilities
.
isPopupTrigger
(
evt
)
)
;
super
.
processMouseEvent
(
evt
)
;
break
;
case
MouseEvent
.
MOUSE_PRESSED
:
if
(
(
evt
.
getModifiers
(
)
&
MouseEvent
.
BUTTON1_MASK
)
!=
0
)
{
if
(
popup
!=
null
&&
popup
.
isVisible
(
)
)
popup
.
setVisible
(
false
)
;
if
(
evt
.
getClickCount
(
)
==
2
)
break
;
}
else
if
(
GUIUtilities
.
isPopupTrigger
(
evt
)
)
{
if
(
popup
!=
null
&&
popup
.
isVisible
(
)
)
{
popup
.
setVisible
(
false
)
;
break
;
}
TreePath
path
=
getPathForLocation
(
evt
.
getX
(
)
,
evt
.
getY
(
)
)
;
if
(
path
==
null
)
showFilePopup
(
null
,
evt
.
getPoint
(
)
)
;
else
{
setSelectionPath
(
path
)
;
browser
.
filesSelected
(
)
;
Object
userObject
=
(
(
DefaultMutableTreeNode
)
path
.
getLastPathComponent
(
)
)
.
getUserObject
(
)
;
if
(
userObject
instanceof
VFS
.
DirectoryEntry
)
{
VFS
.
DirectoryEntry
file
=
(
VFS
.
DirectoryEntry
)
userObject
;
showFilePopup
(
file
,
evt
.
getPoint
(
)
)
;
}
else
showFilePopup
(
null
,
evt
.
getPoint
(
)
)
;
}
break
;
}
super
.
processMouseEvent
(
evt
)
;
break
;
case
MouseEvent
.
MOUSE_RELEASED
:
if
(
evt
.
getClickCount
(
)
!=
2
)
super
.
processMouseEvent
(
evt
)
;
break
;
default
:
super
.
processMouseEvent
(
evt
)
;
break
;
}
}
private
int
toolTipInitialDelay
=
-
1
;
private
int
toolTipReshowDelay
=
-
1
;
private
boolean
cellRectIsVisible
(
Rectangle
cellRect
)
{
Rectangle
vr
=
BrowserJTree
.
this
.
getVisibleRect
(
)
;
return
vr
.
contains
(
cellRect
.
x
,
cellRect
.
y
)
&&
vr
.
contains
(
cellRect
.
x
+
cellRect
.
width
,
cellRect
.
y
+
cellRect
.
height
)
;
}
private
void
doTypeSelect
(
String
str
)
{
if
(
getSelectionCount
(
)
==
0
)
doTypeSelect
(
str
,
0
,
getRowCount
(
)
)
;
else
{
int
start
=
getMaxSelectionRow
(
)
;
boolean
retVal
=
doTypeSelect
(
str
,
start
,
getRowCount
(
)
)
;
if
(
!
retVal
)
{
doTypeSelect
(
str
,
0
,
start
)
;
}
}
}
private
boolean
doTypeSelect
(
String
str
,
int
start
,
int
end
)
{
for
(
int
i
=
start
;
i
<
end
;
i
++
)
{
DefaultMutableTreeNode
treeNode
=
(
DefaultMutableTreeNode
)
getPathForRow
(
i
)
.
getLastPathComponent
(
)
;
Object
obj
=
treeNode
.
getUserObject
(
)
;
if
(
obj
instanceof
VFS
.
DirectoryEntry
)
{
VFS
.
DirectoryEntry
file
=
(
VFS
.
DirectoryEntry
)
obj
;
if
(
file
.
name
.
regionMatches
(
true
,
0
,
str
,
0
,
str
.
length
(
)
)
)
{
setSelectionRow
(
i
)
;
scrollRowToVisible
(
i
)
;
return
true
;
}
}
}
return
false
;
}
}
class
TreeHandler
implements
TreeExpansionListener
{
public
void
treeExpanded
(
TreeExpansionEvent
evt
)
{
TreePath
path
=
evt
.
getPath
(
)
;
DefaultMutableTreeNode
treeNode
=
(
DefaultMutableTreeNode
)
path
.
getLastPathComponent
(
)
;
Object
userObject
=
treeNode
.
getUserObject
(
)
;
if
(
userObject
instanceof
VFS
.
DirectoryEntry
)
{
loadDirectory
(
treeNode
,
(
(
VFS
.
DirectoryEntry
)
userObject
)
.
path
,
true
)
;
}
}
public
void
treeCollapsed
(
TreeExpansionEvent
evt
)
{
TreePath
path
=
evt
.
getPath
(
)
;
DefaultMutableTreeNode
treeNode
=
(
DefaultMutableTreeNode
)
path
.
getLastPathComponent
(
)
;
if
(
treeNode
.
getUserObject
(
)
instanceof
VFS
.
DirectoryEntry
)
{
treeNode
.
removeAllChildren
(
)
;
treeNode
.
add
(
new
DefaultMutableTreeNode
(
new
LoadingPlaceholder
(
)
,
false
)
)
;
model
.
reload
(
treeNode
)
;
}
}
}
static
class
LoadingPlaceholder
{
}
}
