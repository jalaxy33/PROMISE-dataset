package
org
.
gjt
.
sp
.
jedit
.
textarea
;
import
javax
.
swing
.
text
.
*
;
import
javax
.
swing
.
JComponent
;
import
java
.
awt
.
event
.
MouseEvent
;
import
java
.
awt
.
font
.
*
;
import
java
.
awt
.
geom
.
*
;
import
java
.
awt
.
*
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
HashMap
;
import
org
.
gjt
.
sp
.
jedit
.
syntax
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
Buffer
;
import
org
.
gjt
.
sp
.
util
.
Log
;
public
class
TextAreaPainter
extends
JComponent
implements
TabExpander
{
public
static
final
int
LOWEST_LAYER
=
Integer
.
MIN_VALUE
;
public
static
final
int
BACKGROUND_LAYER
=
-
60
;
public
static
final
int
LINE_BACKGROUND_LAYER
=
-
50
;
public
static
final
int
BELOW_SELECTION_LAYER
=
-
40
;
public
static
final
int
SELECTION_LAYER
=
-
30
;
public
static
final
int
WRAP_GUIDE_LAYER
=
-
20
;
public
static
final
int
BELOW_MOST_EXTENSIONS_LAYER
=
-
10
;
public
static
final
int
DEFAULT_LAYER
=
0
;
public
static
final
int
BRACKET_HIGHLIGHT_LAYER
=
100
;
public
static
final
int
HIGHEST_LAYER
=
Integer
.
MAX_VALUE
;
public
TextAreaPainter
(
JEditTextArea
textArea
)
{
enableEvents
(
AWTEvent
.
FOCUS_EVENT_MASK
|
AWTEvent
.
KEY_EVENT_MASK
|
AWTEvent
.
MOUSE_EVENT_MASK
)
;
this
.
textArea
=
textArea
;
extensionMgr
=
new
ExtensionManager
(
)
;
setAutoscrolls
(
true
)
;
setOpaque
(
true
)
;
setCursor
(
Cursor
.
getPredefinedCursor
(
Cursor
.
TEXT_CURSOR
)
)
;
fontRenderContext
=
new
FontRenderContext
(
null
,
false
,
false
)
;
addExtension
(
LINE_BACKGROUND_LAYER
,
lineBackground
=
new
PaintLineBackground
(
)
)
;
addExtension
(
SELECTION_LAYER
,
new
PaintSelection
(
)
)
;
addExtension
(
WRAP_GUIDE_LAYER
,
new
WrapGuide
(
)
)
;
addExtension
(
BRACKET_HIGHLIGHT_LAYER
,
new
BracketHighlight
(
)
)
;
}
public
void
setBounds
(
int
x
,
int
y
,
int
width
,
int
height
)
{
if
(
x
==
getX
(
)
&&
y
==
getY
(
)
&&
width
==
getWidth
(
)
&&
height
==
getHeight
(
)
)
{
return
;
}
super
.
setBounds
(
x
,
y
,
width
,
height
)
;
textArea
.
recalculateVisibleLines
(
)
;
textArea
.
recalculateLastPhysicalLine
(
)
;
textArea
.
propertiesChanged
(
)
;
textArea
.
scrollBarsInitialized
=
true
;
}
public
boolean
isManagingFocus
(
)
{
return
false
;
}
public
boolean
getFocusTraversalKeysEnabled
(
)
{
return
false
;
}
public
final
SyntaxStyle
[
]
getStyles
(
)
{
return
styles
;
}
public
final
void
setStyles
(
SyntaxStyle
[
]
styles
)
{
this
.
styles
=
styles
;
styles
[
Token
.
NULL
]
=
new
SyntaxStyle
(
getForeground
(
)
,
null
,
getFont
(
)
)
;
repaint
(
)
;
}
public
final
Color
getCaretColor
(
)
{
return
caretColor
;
}
public
final
void
setCaretColor
(
Color
caretColor
)
{
this
.
caretColor
=
caretColor
;
if
(
textArea
.
getBuffer
(
)
!=
null
)
textArea
.
invalidateLine
(
textArea
.
getCaretLine
(
)
)
;
}
public
final
Color
getSelectionColor
(
)
{
return
selectionColor
;
}
public
final
void
setSelectionColor
(
Color
selectionColor
)
{
this
.
selectionColor
=
selectionColor
;
if
(
textArea
.
getBuffer
(
)
!=
null
)
textArea
.
invalidateSelectedLines
(
)
;
}
public
final
Color
getLineHighlightColor
(
)
{
return
lineHighlightColor
;
}
public
final
void
setLineHighlightColor
(
Color
lineHighlightColor
)
{
this
.
lineHighlightColor
=
lineHighlightColor
;
if
(
textArea
.
getBuffer
(
)
!=
null
)
textArea
.
invalidateLine
(
textArea
.
getCaretLine
(
)
)
;
}
public
final
boolean
isLineHighlightEnabled
(
)
{
return
lineHighlight
;
}
public
final
void
setLineHighlightEnabled
(
boolean
lineHighlight
)
{
this
.
lineHighlight
=
lineHighlight
;
if
(
textArea
.
getBuffer
(
)
!=
null
)
textArea
.
invalidateSelectedLines
(
)
;
}
public
final
Color
getFoldedLineColor
(
)
{
return
foldedLineColor
;
}
public
final
void
setFoldedLineColor
(
Color
foldedLineColor
)
{
this
.
foldedLineColor
=
foldedLineColor
;
repaint
(
)
;
}
public
final
Color
getBracketHighlightColor
(
)
{
return
bracketHighlightColor
;
}
public
final
void
setBracketHighlightColor
(
Color
bracketHighlightColor
)
{
this
.
bracketHighlightColor
=
bracketHighlightColor
;
if
(
textArea
.
getBuffer
(
)
!=
null
)
textArea
.
invalidateLine
(
textArea
.
getBracketLine
(
)
)
;
}
public
final
boolean
isBracketHighlightEnabled
(
)
{
return
bracketHighlight
;
}
public
final
void
setBracketHighlightEnabled
(
boolean
bracketHighlight
)
{
this
.
bracketHighlight
=
bracketHighlight
;
if
(
textArea
.
getBuffer
(
)
!=
null
)
textArea
.
invalidateLine
(
textArea
.
getBracketLine
(
)
)
;
}
public
final
boolean
isBlockCaretEnabled
(
)
{
return
blockCaret
;
}
public
final
void
setBlockCaretEnabled
(
boolean
blockCaret
)
{
this
.
blockCaret
=
blockCaret
;
if
(
textArea
.
getBuffer
(
)
!=
null
)
textArea
.
invalidateLine
(
textArea
.
getCaretLine
(
)
)
;
}
public
final
Color
getEOLMarkerColor
(
)
{
return
eolMarkerColor
;
}
public
final
void
setEOLMarkerColor
(
Color
eolMarkerColor
)
{
this
.
eolMarkerColor
=
eolMarkerColor
;
repaint
(
)
;
}
public
final
boolean
getEOLMarkersPainted
(
)
{
return
eolMarkers
;
}
public
final
void
setEOLMarkersPainted
(
boolean
eolMarkers
)
{
this
.
eolMarkers
=
eolMarkers
;
repaint
(
)
;
}
public
final
Color
getWrapGuideColor
(
)
{
return
wrapGuideColor
;
}
public
final
void
setWrapGuideColor
(
Color
wrapGuideColor
)
{
this
.
wrapGuideColor
=
wrapGuideColor
;
repaint
(
)
;
}
public
final
boolean
isWrapGuidePainted
(
)
{
return
wrapGuide
;
}
public
final
void
setWrapGuidePainted
(
boolean
wrapGuide
)
{
this
.
wrapGuide
=
wrapGuide
;
repaint
(
)
;
}
public
void
setAntiAliasEnabled
(
boolean
antiAlias
)
{
this
.
antiAlias
=
antiAlias
;
updateRenderingHints
(
)
;
}
public
boolean
isAntiAliasEnabled
(
)
{
return
antiAlias
;
}
public
void
setFractionalFontMetricsEnabled
(
boolean
fracFontMetrics
)
{
this
.
fracFontMetrics
=
fracFontMetrics
;
updateRenderingHints
(
)
;
}
public
boolean
isFractionalFontMetricsEnabled
(
)
{
return
fracFontMetrics
;
}
public
FontRenderContext
getFontRenderContext
(
)
{
return
fontRenderContext
;
}
public
void
addCustomHighlight
(
TextAreaHighlight
highlight
)
{
Log
.
log
(
Log
.
WARNING
,
this
,
"Old highlighter API not supported: "
+
highlight
)
;
}
public
void
removeCustomHighlight
(
TextAreaHighlight
highlight
)
{
Log
.
log
(
Log
.
WARNING
,
this
,
"Old highlighter API not supported: "
+
highlight
)
;
}
public
void
addExtension
(
TextAreaExtension
extension
)
{
extensionMgr
.
addExtension
(
DEFAULT_LAYER
,
extension
)
;
repaint
(
)
;
}
public
void
addExtension
(
int
layer
,
TextAreaExtension
extension
)
{
extensionMgr
.
addExtension
(
layer
,
extension
)
;
repaint
(
)
;
}
public
void
removeExtension
(
TextAreaExtension
extension
)
{
extensionMgr
.
removeExtension
(
extension
)
;
repaint
(
)
;
}
public
String
getToolTipText
(
MouseEvent
evt
)
{
if
(
!
textArea
.
getBuffer
(
)
.
isLoaded
(
)
)
return
null
;
return
extensionMgr
.
getToolTipText
(
evt
.
getX
(
)
,
evt
.
getY
(
)
)
;
}
public
FontMetrics
getFontMetrics
(
)
{
return
fm
;
}
public
void
setFont
(
Font
font
)
{
super
.
setFont
(
font
)
;
fm
=
getFontMetrics
(
font
)
;
textArea
.
recalculateVisibleLines
(
)
;
}
public
void
paintComponent
(
Graphics
_gfx
)
{
long
start
=
System
.
currentTimeMillis
(
)
;
Graphics2D
gfx
=
(
Graphics2D
)
_gfx
;
gfx
.
setRenderingHints
(
renderingHints
)
;
fontRenderContext
=
gfx
.
getFontRenderContext
(
)
;
Rectangle
clipRect
=
gfx
.
getClipBounds
(
)
;
gfx
.
setColor
(
getBackground
(
)
)
;
gfx
.
fillRect
(
clipRect
.
x
,
clipRect
.
y
,
clipRect
.
width
,
clipRect
.
height
)
;
Buffer
buffer
=
textArea
.
getBuffer
(
)
;
if
(
!
buffer
.
isLoaded
(
)
)
return
;
int
x
=
textArea
.
getHorizontalOffset
(
)
;
int
height
=
fm
.
getHeight
(
)
;
int
firstInvalid
=
clipRect
.
y
/
height
;
int
lastInvalid
=
(
clipRect
.
y
+
clipRect
.
height
-
1
)
/
height
;
textArea
.
chunkCache
.
updateChunksUpTo
(
lastInvalid
)
;
int
lineCount
=
textArea
.
getVirtualLineCount
(
)
;
int
y
=
(
clipRect
.
y
-
clipRect
.
y
%
height
)
;
try
{
boolean
updateMaxHorizontalScrollWidth
=
false
;
for
(
int
line
=
firstInvalid
;
line
<=
lastInvalid
;
line
++
)
{
ChunkCache
.
LineInfo
lineInfo
=
textArea
.
chunkCache
.
getLineInfo
(
line
)
;
if
(
!
lineInfo
.
chunksValid
)
System
.
err
.
println
(
"text area painter: not valid"
)
;
lineInfo
.
width
=
paintLine
(
gfx
,
buffer
,
lineInfo
,
line
,
x
,
y
)
-
x
;
if
(
lineInfo
.
width
>
textArea
.
maxHorizontalScrollWidth
)
updateMaxHorizontalScrollWidth
=
true
;
y
+=
height
;
}
if
(
buffer
.
isNextLineRequested
(
)
)
{
int
h
=
clipRect
.
y
+
clipRect
.
height
;
textArea
.
chunkCache
.
invalidateChunksFrom
(
lastInvalid
+
1
)
;
repaint
(
0
,
h
,
getWidth
(
)
,
getHeight
(
)
-
h
)
;
}
if
(
updateMaxHorizontalScrollWidth
)
textArea
.
updateMaxHorizontalScrollWidth
(
)
;
}
catch
(
Exception
e
)
{
Log
.
log
(
Log
.
ERROR
,
this
,
"Error repainting line"
+
" range {"
+
firstInvalid
+
","
+
lastInvalid
+
"}:"
)
;
Log
.
log
(
Log
.
ERROR
,
this
,
e
)
;
}
}
public
float
nextTabStop
(
float
x
,
int
tabOffset
)
{
int
ntabs
=
(
int
)
(
x
/
textArea
.
tabSize
)
;
return
(
ntabs
+
1
)
*
textArea
.
tabSize
;
}
public
Dimension
getPreferredSize
(
)
{
Dimension
dim
=
new
Dimension
(
)
;
char
[
]
foo
=
new
char
[
80
]
;
for
(
int
i
=
0
;
i
<
foo
.
length
;
i
++
)
foo
[
i
]
=
' '
;
dim
.
width
=
(
int
)
(
getFont
(
)
.
getStringBounds
(
foo
,
0
,
foo
.
length
,
fontRenderContext
)
.
getWidth
(
)
)
;
dim
.
height
=
fm
.
getHeight
(
)
*
25
;
return
dim
;
}
public
Dimension
getMinimumSize
(
)
{
return
getPreferredSize
(
)
;
}
private
JEditTextArea
textArea
;
private
SyntaxStyle
[
]
styles
;
private
Color
caretColor
;
private
Color
selectionColor
;
private
Color
lineHighlightColor
;
private
Color
foldedLineColor
;
private
Color
bracketHighlightColor
;
private
Color
eolMarkerColor
;
private
Color
wrapGuideColor
;
private
boolean
blockCaret
;
private
boolean
lineHighlight
;
private
boolean
bracketHighlight
;
private
boolean
eolMarkers
;
private
boolean
wrapGuide
;
private
boolean
antiAlias
;
private
boolean
fracFontMetrics
;
private
FontMetrics
fm
;
private
ExtensionManager
extensionMgr
;
private
PaintLineBackground
lineBackground
;
private
RenderingHints
renderingHints
;
private
FontRenderContext
fontRenderContext
;
private
void
updateRenderingHints
(
)
{
HashMap
hints
=
new
HashMap
(
)
;
if
(
antiAlias
)
{
hints
.
put
(
RenderingHints
.
KEY_RENDERING
,
RenderingHints
.
VALUE_RENDER_QUALITY
)
;
hints
.
put
(
RenderingHints
.
KEY_ANTIALIASING
,
RenderingHints
.
VALUE_ANTIALIAS_ON
)
;
hints
.
put
(
RenderingHints
.
KEY_TEXT_ANTIALIASING
,
RenderingHints
.
VALUE_TEXT_ANTIALIAS_ON
)
;
}
else
{
hints
.
put
(
RenderingHints
.
KEY_ANTIALIASING
,
RenderingHints
.
VALUE_ANTIALIAS_OFF
)
;
hints
.
put
(
RenderingHints
.
KEY_TEXT_ANTIALIASING
,
RenderingHints
.
VALUE_TEXT_ANTIALIAS_OFF
)
;
}
hints
.
put
(
RenderingHints
.
KEY_FRACTIONALMETRICS
,
fracFontMetrics
?
RenderingHints
.
VALUE_FRACTIONALMETRICS_ON
:
RenderingHints
.
VALUE_FRACTIONALMETRICS_OFF
)
;
renderingHints
=
new
RenderingHints
(
hints
)
;
fontRenderContext
=
new
FontRenderContext
(
null
,
antiAlias
,
fracFontMetrics
)
;
}
private
int
paintLine
(
Graphics2D
gfx
,
Buffer
buffer
,
ChunkCache
.
LineInfo
lineInfo
,
int
screenLine
,
int
x
,
int
y
)
{
int
physicalLine
=
lineInfo
.
physicalLine
;
if
(
physicalLine
==
-
1
)
extensionMgr
.
paintInvalidLine
(
gfx
,
screenLine
,
y
)
;
else
{
int
start
=
textArea
.
getScreenLineStartOffset
(
screenLine
)
;
int
end
=
textArea
.
getScreenLineEndOffset
(
screenLine
)
;
extensionMgr
.
paintValidLine
(
gfx
,
screenLine
,
physicalLine
,
start
,
end
,
y
)
;
Font
defaultFont
=
getFont
(
)
;
Color
defaultColor
=
getForeground
(
)
;
gfx
.
setFont
(
defaultFont
)
;
gfx
.
setColor
(
defaultColor
)
;
float
baseLine
=
y
+
fm
.
getHeight
(
)
-
fm
.
getLeading
(
)
-
fm
.
getDescent
(
)
;
if
(
lineInfo
.
chunks
!=
null
)
{
x
+=
ChunkCache
.
paintChunkList
(
lineInfo
.
chunks
,
gfx
,
x
,
baseLine
,
lineBackground
.
bgColor
,
true
)
;
}
gfx
.
setFont
(
defaultFont
)
;
gfx
.
setColor
(
eolMarkerColor
)
;
if
(
!
lineInfo
.
lastSubregion
)
{
gfx
.
drawString
(
":"
,
Math
.
max
(
x
,
textArea
.
getHorizontalOffset
(
)
+
textArea
.
wrapMargin
+
textArea
.
charWidth
)
,
baseLine
)
;
x
+=
textArea
.
charWidth
;
}
else
if
(
lineBackground
.
collapsedFold
)
{
int
nextLine
=
textArea
.
getFoldVisibilityManager
(
)
.
getNextVisibleLine
(
physicalLine
)
;
if
(
nextLine
==
-
1
)
nextLine
=
buffer
.
getLineCount
(
)
;
int
count
=
nextLine
-
physicalLine
-
1
;
String
str
=
" ["
+
count
+
" lines]"
;
gfx
.
drawString
(
str
,
x
,
baseLine
)
;
x
+=
(
int
)
(
getFont
(
)
.
getStringBounds
(
str
,
fontRenderContext
)
.
getWidth
(
)
)
;
}
else
if
(
eolMarkers
)
{
gfx
.
drawString
(
"."
,
x
,
baseLine
)
;
x
+=
textArea
.
charWidth
;
}
paintCaret
(
gfx
,
physicalLine
,
start
,
end
,
y
,
lineBackground
.
bgColor
)
;
}
return
x
;
}
private
void
paintCaret
(
Graphics2D
gfx
,
int
physicalLine
,
int
start
,
int
end
,
int
y
,
Color
bgColor
)
{
if
(
!
textArea
.
isCaretVisible
(
)
)
return
;
int
caret
=
textArea
.
getCaretPosition
(
)
;
if
(
caret
<
start
||
caret
>=
end
)
return
;
int
offset
=
caret
-
textArea
.
getLineStartOffset
(
physicalLine
)
;
textArea
.
offsetToXY
(
physicalLine
,
offset
,
textArea
.
returnValue
)
;
int
caretX
=
textArea
.
returnValue
.
x
;
int
height
=
fm
.
getHeight
(
)
;
gfx
.
setColor
(
caretColor
)
;
if
(
blockCaret
)
{
Graphics2D
blockgfx
=
(
Graphics2D
)
gfx
.
create
(
)
;
blockgfx
.
setXORMode
(
bgColor
)
;
if
(
textArea
.
isOverwriteEnabled
(
)
)
{
blockgfx
.
fillRect
(
caretX
,
y
+
height
-
height
/
3
,
textArea
.
charWidth
,
height
/
3
)
;
}
else
blockgfx
.
fillRect
(
caretX
,
y
,
textArea
.
charWidth
,
height
)
;
blockgfx
.
dispose
(
)
;
}
else
{
if
(
textArea
.
isOverwriteEnabled
(
)
)
{
gfx
.
drawLine
(
caretX
,
y
+
height
-
1
,
caretX
+
textArea
.
charWidth
,
y
+
height
-
1
)
;
}
else
gfx
.
drawLine
(
caretX
,
y
,
caretX
,
y
+
height
-
1
)
;
}
}
class
PaintLineBackground
extends
TextAreaExtension
{
boolean
collapsedFold
;
Color
bgColor
;
public
void
paintValidLine
(
Graphics2D
gfx
,
int
screenLine
,
int
physicalLine
,
int
start
,
int
end
,
int
y
)
{
JEditTextArea
textArea
=
TextAreaPainter
.
this
.
textArea
;
Buffer
buffer
=
textArea
.
getBuffer
(
)
;
collapsedFold
=
(
physicalLine
<
buffer
.
getLineCount
(
)
-
1
&&
buffer
.
isFoldStart
(
physicalLine
)
&&
!
textArea
.
getFoldVisibilityManager
(
)
.
isLineVisible
(
physicalLine
+
1
)
)
;
int
caret
=
textArea
.
getCaretPosition
(
)
;
boolean
paintLineHighlight
=
isLineHighlightEnabled
(
)
&&
caret
>=
start
&&
caret
<
end
&&
textArea
.
selection
.
size
(
)
==
0
;
if
(
paintLineHighlight
)
bgColor
=
lineHighlightColor
;
else
if
(
collapsedFold
)
bgColor
=
foldedLineColor
;
else
bgColor
=
getBackground
(
)
;
if
(
paintLineHighlight
||
collapsedFold
)
{
gfx
.
setColor
(
bgColor
)
;
gfx
.
fillRect
(
0
,
y
,
getWidth
(
)
,
fm
.
getHeight
(
)
)
;
}
}
}
class
PaintSelection
extends
TextAreaExtension
{
public
void
paintValidLine
(
Graphics2D
gfx
,
int
screenLine
,
int
physicalLine
,
int
start
,
int
end
,
int
y
)
{
if
(
textArea
.
selection
.
size
(
)
==
0
)
return
;
gfx
.
setColor
(
getSelectionColor
(
)
)
;
for
(
int
i
=
textArea
.
selection
.
size
(
)
-
1
;
i
>=
0
;
i
--
)
{
paintSelection
(
gfx
,
screenLine
,
physicalLine
,
start
,
end
,
y
,
(
Selection
)
textArea
.
selection
.
get
(
i
)
)
;
}
}
private
void
paintSelection
(
Graphics2D
gfx
,
int
screenLine
,
int
physicalLine
,
int
start
,
int
end
,
int
y
,
Selection
s
)
{
if
(
end
<=
s
.
start
||
start
>
s
.
end
)
return
;
int
selStartScreenLine
=
textArea
.
getScreenLineOfOffset
(
s
.
start
)
;
int
selEndScreenLine
=
textArea
.
getScreenLineOfOffset
(
s
.
end
)
;
int
lineStart
=
textArea
.
getLineStartOffset
(
physicalLine
)
;
start
-=
lineStart
;
end
-=
lineStart
;
int
x1
,
x2
;
if
(
s
instanceof
Selection
.
Rect
)
{
int
lineLen
=
textArea
.
getLineLength
(
physicalLine
)
;
int
startOffset
=
Math
.
min
(
lineLen
,
s
.
start
-
textArea
.
getLineStartOffset
(
s
.
startLine
)
)
;
int
endOffset
=
Math
.
min
(
lineLen
,
s
.
end
-
textArea
.
getLineStartOffset
(
s
.
endLine
)
)
;
if
(
end
<=
startOffset
||
start
>
endOffset
)
return
;
x1
=
(
startOffset
<
start
?
0
:
textArea
.
offsetToXY
(
physicalLine
,
startOffset
,
textArea
.
returnValue
)
.
x
)
;
x2
=
(
endOffset
>
end
?
getWidth
(
)
:
textArea
.
offsetToXY
(
physicalLine
,
endOffset
,
textArea
.
returnValue
)
.
x
)
;
if
(
x1
>
x2
)
{
int
tmp
=
x2
;
x2
=
x1
;
x1
=
tmp
;
}
}
else
if
(
selStartScreenLine
==
selEndScreenLine
&&
selStartScreenLine
!=
-
1
)
{
x1
=
textArea
.
offsetToXY
(
physicalLine
,
s
.
start
-
lineStart
,
textArea
.
returnValue
)
.
x
;
x2
=
textArea
.
offsetToXY
(
physicalLine
,
s
.
end
-
lineStart
,
textArea
.
returnValue
)
.
x
;
}
else
if
(
screenLine
==
selStartScreenLine
)
{
x1
=
textArea
.
offsetToXY
(
physicalLine
,
s
.
start
-
lineStart
,
textArea
.
returnValue
)
.
x
;
x2
=
getWidth
(
)
;
}
else
if
(
screenLine
==
selEndScreenLine
)
{
x1
=
0
;
x2
=
textArea
.
offsetToXY
(
physicalLine
,
s
.
end
-
lineStart
,
textArea
.
returnValue
)
.
x
;
}
else
{
x1
=
0
;
x2
=
getWidth
(
)
;
}
if
(
x1
==
x2
)
x2
++
;
gfx
.
fillRect
(
x1
,
y
,
x2
-
x1
,
fm
.
getHeight
(
)
)
;
}
}
class
WrapGuide
extends
TextAreaExtension
{
public
void
paintValidLine
(
Graphics2D
gfx
,
int
screenLine
,
int
physicalLine
,
int
start
,
int
end
,
int
y
)
{
paintInvalidLine
(
gfx
,
screenLine
,
y
)
;
}
public
void
paintInvalidLine
(
Graphics2D
gfx
,
int
screenLine
,
int
y
)
{
if
(
!
textArea
.
wrapToWidth
&&
textArea
.
wrapMargin
!=
0
&&
isWrapGuidePainted
(
)
)
{
gfx
.
setColor
(
getWrapGuideColor
(
)
)
;
int
x
=
textArea
.
getHorizontalOffset
(
)
+
textArea
.
wrapMargin
;
gfx
.
drawLine
(
x
,
y
,
x
,
y
+
fm
.
getHeight
(
)
)
;
}
}
public
String
getToolTipText
(
int
x
,
int
y
)
{
if
(
!
textArea
.
wrapToWidth
&&
textArea
.
wrapMargin
!=
0
&&
isWrapGuidePainted
(
)
)
{
int
wrapGuidePos
=
textArea
.
wrapMargin
+
textArea
.
getHorizontalOffset
(
)
;
if
(
Math
.
abs
(
x
-
wrapGuidePos
)
<
5
)
{
return
String
.
valueOf
(
textArea
.
getBuffer
(
)
.
getProperty
(
"maxLineLen"
)
)
;
}
}
return
null
;
}
}
class
BracketHighlight
extends
TextAreaExtension
{
public
void
paintValidLine
(
Graphics2D
gfx
,
int
screenLine
,
int
physicalLine
,
int
start
,
int
end
,
int
y
)
{
if
(
!
isBracketHighlightEnabled
(
)
||
!
textArea
.
isBracketHighlightVisible
(
)
)
return
;
int
bracketLine
=
textArea
.
getBracketLine
(
)
;
int
bracketOffset
=
textArea
.
getBracketPosition
(
)
;
if
(
bracketLine
==
-
1
||
bracketOffset
==
-
1
)
return
;
int
bracketLineStart
=
textArea
.
getLineStartOffset
(
bracketLine
)
;
if
(
bracketOffset
+
bracketLineStart
<
start
||
bracketOffset
+
bracketLineStart
>=
end
)
return
;
textArea
.
offsetToXY
(
bracketLine
,
bracketOffset
,
textArea
.
returnValue
)
;
gfx
.
setColor
(
getBracketHighlightColor
(
)
)
;
gfx
.
drawRect
(
textArea
.
returnValue
.
x
,
y
,
(
int
)
gfx
.
getFont
(
)
.
getStringBounds
(
"("
,
getFontRenderContext
(
)
)
.
getWidth
(
)
-
1
,
fm
.
getHeight
(
)
-
1
)
;
}
}
}
