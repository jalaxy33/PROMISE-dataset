package
org
.
gjt
.
sp
.
jedit
;
import
javax
.
swing
.
border
.
EmptyBorder
;
import
javax
.
swing
.
event
.
*
;
import
javax
.
swing
.
text
.
*
;
import
javax
.
swing
.
*
;
import
java
.
awt
.
*
;
import
java
.
awt
.
event
.
*
;
import
java
.
util
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
msg
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
gui
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
search
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
textarea
.
*
;
import
org
.
gjt
.
sp
.
util
.
Log
;
public
class
View
extends
JFrame
implements
EBComponent
{
public
static
final
int
TOP_GROUP
=
0
;
public
static
final
int
BOTTOM_GROUP
=
1
;
public
static
final
int
DEFAULT_GROUP
=
TOP_GROUP
;
public
static
final
int
TOP_LAYER
=
Integer
.
MAX_VALUE
;
public
static
final
int
DEFAULT_LAYER
=
0
;
public
static
final
int
BOTTOM_LAYER
=
Integer
.
MIN_VALUE
;
public
static
final
int
ABOVE_SYSTEM_BAR_LAYER
=
150
;
public
static
final
int
SYSTEM_BAR_LAYER
=
100
;
public
static
final
int
SEARCH_BAR_LAYER
=
75
;
public
static
final
int
BELOW_SEARCH_BAR_LAYER
=
50
;
public
static
final
int
ABOVE_STATUS_BAR_LAYER
=
-
50
;
public
static
final
int
STATUS_BAR_LAYER
=
-
100
;
public
static
final
int
BELOW_STATUS_BAR_LAYER
=
-
150
;
public
DockableWindowManager
getDockableWindowManager
(
)
{
return
dockableWindowManager
;
}
public
JToolBar
getToolBar
(
)
{
return
toolBar
;
}
public
void
addToolBar
(
Component
toolBar
)
{
addToolBar
(
DEFAULT_GROUP
,
DEFAULT_LAYER
,
toolBar
)
;
}
public
void
addToolBar
(
int
group
,
Component
toolBar
)
{
addToolBar
(
group
,
DEFAULT_LAYER
,
toolBar
)
;
}
public
void
addToolBar
(
int
group
,
int
layer
,
Component
toolBar
)
{
toolBarManager
.
addToolBar
(
group
,
layer
,
toolBar
)
;
getRootPane
(
)
.
revalidate
(
)
;
}
public
void
removeToolBar
(
Component
toolBar
)
{
toolBarManager
.
removeToolBar
(
toolBar
)
;
getRootPane
(
)
.
revalidate
(
)
;
}
public
synchronized
void
showWaitCursor
(
)
{
if
(
waitCount
++
==
0
)
{
Cursor
cursor
=
Cursor
.
getPredefinedCursor
(
Cursor
.
WAIT_CURSOR
)
;
setCursor
(
cursor
)
;
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
{
EditPane
editPane
=
editPanes
[
i
]
;
editPane
.
getTextArea
(
)
.
getPainter
(
)
.
setCursor
(
cursor
)
;
}
}
}
public
synchronized
void
hideWaitCursor
(
)
{
if
(
waitCount
>
0
)
waitCount
--
;
if
(
waitCount
==
0
)
{
Cursor
cursor
=
Cursor
.
getPredefinedCursor
(
Cursor
.
DEFAULT_CURSOR
)
;
setCursor
(
cursor
)
;
cursor
=
Cursor
.
getPredefinedCursor
(
Cursor
.
TEXT_CURSOR
)
;
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
{
EditPane
editPane
=
editPanes
[
i
]
;
editPane
.
getTextArea
(
)
.
getPainter
(
)
.
setCursor
(
cursor
)
;
}
}
}
public
final
SearchBar
getSearchBar
(
)
{
return
searchBar
;
}
public
StatusBar
getStatus
(
)
{
return
status
;
}
public
KeyListener
getKeyEventInterceptor
(
)
{
return
keyEventInterceptor
;
}
public
void
setKeyEventInterceptor
(
KeyListener
listener
)
{
this
.
keyEventInterceptor
=
listener
;
}
public
InputHandler
getInputHandler
(
)
{
return
inputHandler
;
}
public
void
setInputHandler
(
InputHandler
inputHandler
)
{
this
.
inputHandler
=
inputHandler
;
}
public
Macros
.
Recorder
getMacroRecorder
(
)
{
return
recorder
;
}
public
void
setMacroRecorder
(
Macros
.
Recorder
recorder
)
{
this
.
recorder
=
recorder
;
}
public
void
processKeyEvent
(
KeyEvent
evt
)
{
if
(
isClosed
(
)
)
return
;
if
(
getFocusOwner
(
)
instanceof
JComponent
)
{
JComponent
comp
=
(
JComponent
)
getFocusOwner
(
)
;
InputMap
map
=
comp
.
getInputMap
(
)
;
ActionMap
am
=
comp
.
getActionMap
(
)
;
if
(
map
!=
null
&&
am
!=
null
&&
comp
.
isEnabled
(
)
)
{
Object
binding
=
map
.
get
(
KeyStroke
.
getKeyStrokeForEvent
(
evt
)
)
;
if
(
binding
!=
null
&&
am
.
get
(
binding
)
!=
null
)
{
return
;
}
}
}
if
(
getFocusOwner
(
)
instanceof
JTextComponent
)
{
if
(
evt
.
getID
(
)
==
KeyEvent
.
KEY_PRESSED
)
{
switch
(
evt
.
getKeyCode
(
)
)
{
case
KeyEvent
.
VK_BACK_SPACE
:
case
KeyEvent
.
VK_TAB
:
case
KeyEvent
.
VK_ENTER
:
return
;
}
}
Keymap
keymap
=
(
(
JTextComponent
)
getFocusOwner
(
)
)
.
getKeymap
(
)
;
if
(
keymap
.
getAction
(
KeyStroke
.
getKeyStrokeForEvent
(
evt
)
)
!=
null
)
return
;
}
if
(
evt
.
isConsumed
(
)
)
return
;
evt
=
KeyEventWorkaround
.
processKeyEvent
(
evt
)
;
if
(
evt
==
null
)
return
;
switch
(
evt
.
getID
(
)
)
{
case
KeyEvent
.
KEY_TYPED
:
if
(
keyEventInterceptor
!=
null
)
;
else
if
(
inputHandler
.
isPrefixActive
(
)
&&
!
getTextArea
(
)
.
hasFocus
(
)
)
inputHandler
.
keyTyped
(
evt
)
;
break
;
case
KeyEvent
.
KEY_PRESSED
:
if
(
keyEventInterceptor
!=
null
)
keyEventInterceptor
.
keyPressed
(
evt
)
;
else
inputHandler
.
keyPressed
(
evt
)
;
break
;
case
KeyEvent
.
KEY_RELEASED
:
if
(
keyEventInterceptor
!=
null
)
keyEventInterceptor
.
keyReleased
(
evt
)
;
else
inputHandler
.
keyReleased
(
evt
)
;
break
;
}
if
(
!
evt
.
isConsumed
(
)
)
super
.
processKeyEvent
(
evt
)
;
}
public
void
splitHorizontally
(
)
{
split
(
JSplitPane
.
VERTICAL_SPLIT
)
;
}
public
void
splitVertically
(
)
{
split
(
JSplitPane
.
HORIZONTAL_SPLIT
)
;
}
public
void
split
(
int
orientation
)
{
editPane
.
saveCaretInfo
(
)
;
EditPane
oldEditPane
=
editPane
;
setEditPane
(
createEditPane
(
oldEditPane
.
getBuffer
(
)
)
)
;
editPane
.
loadCaretInfo
(
)
;
JComponent
oldParent
=
(
JComponent
)
oldEditPane
.
getParent
(
)
;
if
(
oldParent
instanceof
JSplitPane
)
{
JSplitPane
oldSplitPane
=
(
JSplitPane
)
oldParent
;
int
dividerPos
=
oldSplitPane
.
getDividerLocation
(
)
;
Component
left
=
oldSplitPane
.
getLeftComponent
(
)
;
final
JSplitPane
newSplitPane
=
new
JSplitPane
(
orientation
,
oldEditPane
,
editPane
)
;
if
(
left
==
oldEditPane
)
oldSplitPane
.
setLeftComponent
(
newSplitPane
)
;
else
oldSplitPane
.
setRightComponent
(
newSplitPane
)
;
oldSplitPane
.
setDividerLocation
(
dividerPos
)
;
SwingUtilities
.
invokeLater
(
new
Runnable
(
)
{
public
void
run
(
)
{
newSplitPane
.
setDividerLocation
(
0.5
)
;
editPane
.
focusOnTextArea
(
)
;
}
}
)
;
}
else
{
JSplitPane
newSplitPane
=
splitPane
=
new
JSplitPane
(
orientation
,
oldEditPane
,
editPane
)
;
newSplitPane
.
setBorder
(
null
)
;
oldParent
.
add
(
splitPane
)
;
oldParent
.
revalidate
(
)
;
Dimension
size
;
if
(
oldParent
instanceof
JSplitPane
)
size
=
oldParent
.
getSize
(
)
;
else
size
=
oldEditPane
.
getSize
(
)
;
newSplitPane
.
setDividerLocation
(
(
(
orientation
==
JSplitPane
.
VERTICAL_SPLIT
)
?
size
.
height
:
size
.
width
)
/
2
)
;
SwingUtilities
.
invokeLater
(
new
Runnable
(
)
{
public
void
run
(
)
{
editPane
.
focusOnTextArea
(
)
;
}
}
)
;
}
}
public
void
unsplit
(
)
{
if
(
splitPane
!=
null
)
{
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
{
EditPane
_editPane
=
editPanes
[
i
]
;
if
(
editPane
!=
_editPane
)
_editPane
.
close
(
)
;
}
JComponent
parent
=
(
JComponent
)
splitPane
.
getParent
(
)
;
parent
.
remove
(
splitPane
)
;
parent
.
add
(
editPane
)
;
parent
.
revalidate
(
)
;
splitPane
=
null
;
updateTitle
(
)
;
}
SwingUtilities
.
invokeLater
(
new
Runnable
(
)
{
public
void
run
(
)
{
editPane
.
focusOnTextArea
(
)
;
}
}
)
;
}
public
void
nextTextArea
(
)
{
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
{
if
(
editPane
==
editPanes
[
i
]
)
{
if
(
i
==
editPanes
.
length
-
1
)
editPanes
[
0
]
.
focusOnTextArea
(
)
;
else
editPanes
[
i
+
1
]
.
focusOnTextArea
(
)
;
break
;
}
}
}
public
void
prevTextArea
(
)
{
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
{
if
(
editPane
==
editPanes
[
i
]
)
{
if
(
i
==
0
)
editPanes
[
editPanes
.
length
-
1
]
.
focusOnTextArea
(
)
;
else
editPanes
[
i
-
1
]
.
focusOnTextArea
(
)
;
break
;
}
}
}
public
JSplitPane
getSplitPane
(
)
{
return
splitPane
;
}
public
Buffer
getBuffer
(
)
{
return
editPane
.
getBuffer
(
)
;
}
public
void
setBuffer
(
Buffer
buffer
)
{
editPane
.
setBuffer
(
buffer
)
;
}
public
JEditTextArea
getTextArea
(
)
{
return
editPane
.
getTextArea
(
)
;
}
public
EditPane
getEditPane
(
)
{
return
editPane
;
}
public
EditPane
[
]
getEditPanes
(
)
{
if
(
splitPane
==
null
)
{
EditPane
[
]
ep
=
{
editPane
}
;
return
ep
;
}
else
{
Vector
vec
=
new
Vector
(
)
;
getEditPanes
(
vec
,
splitPane
)
;
EditPane
[
]
ep
=
new
EditPane
[
vec
.
size
(
)
]
;
vec
.
copyInto
(
ep
)
;
return
ep
;
}
}
public
String
getSplitConfig
(
)
{
StringBuffer
splitConfig
=
new
StringBuffer
(
)
;
splitConfig
.
append
(
getBuffer
(
)
.
getPath
(
)
)
;
return
splitConfig
.
toString
(
)
;
}
public
void
updateGutterBorders
(
)
{
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
editPanes
[
i
]
.
getTextArea
(
)
.
getGutter
(
)
.
updateBorder
(
)
;
}
public
boolean
isSynchroScrollEnabled
(
)
{
return
synchroScroll
;
}
public
void
toggleSynchroScrollEnabled
(
)
{
setSynchroScrollEnabled
(
!
synchroScroll
)
;
}
public
void
setSynchroScrollEnabled
(
boolean
synchroScroll
)
{
this
.
synchroScroll
=
synchroScroll
;
JEditTextArea
textArea
=
getTextArea
(
)
;
int
firstLine
=
textArea
.
getFirstLine
(
)
;
int
horizontalOffset
=
textArea
.
getHorizontalOffset
(
)
;
synchroScrollVertical
(
textArea
,
firstLine
)
;
synchroScrollHorizontal
(
textArea
,
horizontalOffset
)
;
}
public
void
synchroScrollVertical
(
JEditTextArea
textArea
,
int
firstLine
)
{
if
(
!
synchroScroll
)
return
;
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
{
if
(
editPanes
[
i
]
.
getTextArea
(
)
!=
textArea
)
editPanes
[
i
]
.
getTextArea
(
)
.
_setFirstLine
(
firstLine
)
;
}
}
public
void
synchroScrollHorizontal
(
JEditTextArea
textArea
,
int
horizontalOffset
)
{
if
(
!
synchroScroll
)
return
;
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
{
if
(
editPanes
[
i
]
.
getTextArea
(
)
!=
textArea
)
editPanes
[
i
]
.
getTextArea
(
)
.
_setHorizontalOffset
(
horizontalOffset
)
;
}
}
public
void
quickIncrementalSearch
(
boolean
word
)
{
if
(
searchBar
==
null
)
{
getToolkit
(
)
.
beep
(
)
;
return
;
}
JEditTextArea
textArea
=
getTextArea
(
)
;
String
text
=
textArea
.
getSelectedText
(
)
;
if
(
text
==
null
&&
word
)
{
textArea
.
selectWord
(
)
;
text
=
textArea
.
getSelectedText
(
)
;
}
else
if
(
text
!=
null
&&
text
.
indexOf
(
'\n'
)
!=
-
1
)
text
=
null
;
searchBar
.
setHyperSearch
(
false
)
;
searchBar
.
getField
(
)
.
setText
(
text
)
;
searchBar
.
getField
(
)
.
requestFocus
(
)
;
searchBar
.
getField
(
)
.
selectAll
(
)
;
}
public
void
quickHyperSearch
(
boolean
word
)
{
JEditTextArea
textArea
=
getTextArea
(
)
;
String
text
=
textArea
.
getSelectedText
(
)
;
if
(
text
==
null
&&
word
)
{
textArea
.
selectWord
(
)
;
text
=
textArea
.
getSelectedText
(
)
;
}
if
(
text
!=
null
&&
text
.
indexOf
(
'\n'
)
==
-
1
)
{
HistoryModel
.
getModel
(
"find"
)
.
addItem
(
text
)
;
SearchAndReplace
.
setSearchString
(
text
)
;
SearchAndReplace
.
setSearchFileSet
(
new
CurrentBufferSet
(
)
)
;
SearchAndReplace
.
hyperSearch
(
this
)
;
}
else
{
if
(
searchBar
==
null
)
{
getToolkit
(
)
.
beep
(
)
;
return
;
}
searchBar
.
setHyperSearch
(
true
)
;
searchBar
.
getField
(
)
.
setText
(
null
)
;
searchBar
.
getField
(
)
.
requestFocus
(
)
;
searchBar
.
getField
(
)
.
selectAll
(
)
;
}
}
public
boolean
isClosed
(
)
{
return
closed
;
}
public
View
getNext
(
)
{
return
next
;
}
public
View
getPrev
(
)
{
return
prev
;
}
public
void
handleMessage
(
EBMessage
msg
)
{
if
(
msg
instanceof
PropertiesChanged
)
propertiesChanged
(
)
;
else
if
(
msg
instanceof
SearchSettingsChanged
)
{
if
(
searchBar
!=
null
)
searchBar
.
update
(
)
;
}
else
if
(
msg
instanceof
BufferUpdate
)
handleBufferUpdate
(
(
BufferUpdate
)
msg
)
;
else
if
(
msg
instanceof
EditPaneUpdate
)
handleEditPaneUpdate
(
(
EditPaneUpdate
)
msg
)
;
else
if
(
msg
instanceof
MultiSelectStatusChanged
)
status
.
updateMiscStatus
(
)
;
}
View
prev
;
View
next
;
View
(
Buffer
buffer
,
String
splitConfig
)
{
enableEvents
(
AWTEvent
.
KEY_EVENT_MASK
)
;
setIconImage
(
GUIUtilities
.
getEditorIcon
(
)
)
;
dockableWindowManager
=
new
DockableWindowManager
(
this
)
;
JPanel
topToolBars
=
new
JPanel
(
new
VariableGridLayout
(
VariableGridLayout
.
FIXED_NUM_COLUMNS
,
1
)
)
;
JPanel
bottomToolBars
=
new
JPanel
(
new
VariableGridLayout
(
VariableGridLayout
.
FIXED_NUM_COLUMNS
,
1
)
)
;
toolBarManager
=
new
ToolBarManager
(
topToolBars
,
bottomToolBars
)
;
getContentPane
(
)
.
add
(
BorderLayout
.
NORTH
,
topToolBars
)
;
getContentPane
(
)
.
add
(
BorderLayout
.
CENTER
,
dockableWindowManager
)
;
getContentPane
(
)
.
add
(
BorderLayout
.
SOUTH
,
bottomToolBars
)
;
status
=
new
StatusBar
(
this
)
;
addToolBar
(
BOTTOM_GROUP
,
STATUS_BAR_LAYER
,
status
)
;
setJMenuBar
(
GUIUtilities
.
loadMenuBar
(
"view.mbar"
)
)
;
inputHandler
=
new
DefaultInputHandler
(
this
,
(
DefaultInputHandler
)
jEdit
.
getInputHandler
(
)
)
;
Component
comp
=
restoreSplitConfig
(
buffer
,
splitConfig
)
;
dockableWindowManager
.
add
(
comp
)
;
status
.
updateBufferStatus
(
)
;
status
.
updateMiscStatus
(
)
;
EditBus
.
addToBus
(
this
)
;
propertiesChanged
(
)
;
setDefaultCloseOperation
(
DO_NOTHING_ON_CLOSE
)
;
addWindowListener
(
new
WindowHandler
(
)
)
;
dockableWindowManager
.
init
(
)
;
}
void
close
(
)
{
closed
=
true
;
dockableWindowManager
.
close
(
)
;
GUIUtilities
.
saveGeometry
(
this
,
"view"
)
;
EditBus
.
removeFromBus
(
this
)
;
dispose
(
)
;
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
editPanes
[
i
]
.
close
(
)
;
toolBarManager
=
null
;
toolBar
=
null
;
searchBar
=
null
;
splitPane
=
null
;
inputHandler
=
null
;
recorder
=
null
;
setContentPane
(
new
JPanel
(
)
)
;
}
void
updateTitle
(
)
{
Vector
buffers
=
new
Vector
(
)
;
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
{
Buffer
buffer
=
editPanes
[
i
]
.
getBuffer
(
)
;
if
(
buffers
.
indexOf
(
buffer
)
==
-
1
)
buffers
.
addElement
(
buffer
)
;
}
StringBuffer
title
=
new
StringBuffer
(
jEdit
.
getProperty
(
"view.title"
)
)
;
for
(
int
i
=
0
;
i
<
buffers
.
size
(
)
;
i
++
)
{
if
(
i
!=
0
)
title
.
append
(
", "
)
;
Buffer
buffer
=
(
Buffer
)
buffers
.
elementAt
(
i
)
;
title
.
append
(
(
showFullPath
&&
!
buffer
.
isNewFile
(
)
)
?
buffer
.
getPath
(
)
:
buffer
.
getName
(
)
)
;
}
setTitle
(
title
.
toString
(
)
)
;
}
private
boolean
closed
;
private
DockableWindowManager
dockableWindowManager
;
private
ToolBarManager
toolBarManager
;
private
JToolBar
toolBar
;
private
SearchBar
searchBar
;
private
boolean
synchroScroll
;
private
EditPane
editPane
;
private
JSplitPane
splitPane
;
private
StatusBar
status
;
private
KeyListener
keyEventInterceptor
;
private
InputHandler
inputHandler
;
private
Macros
.
Recorder
recorder
;
private
int
waitCount
;
private
boolean
showFullPath
;
private
void
getEditPanes
(
Vector
vec
,
Component
comp
)
{
if
(
comp
instanceof
EditPane
)
vec
.
addElement
(
comp
)
;
else
if
(
comp
instanceof
JSplitPane
)
{
JSplitPane
split
=
(
JSplitPane
)
comp
;
getEditPanes
(
vec
,
split
.
getLeftComponent
(
)
)
;
getEditPanes
(
vec
,
split
.
getRightComponent
(
)
)
;
}
}
private
void
getSplitConfig
(
JSplitPane
splitPane
,
StringBuffer
splitConfig
)
{
Component
left
=
splitPane
.
getLeftComponent
(
)
;
if
(
left
instanceof
JSplitPane
)
getSplitConfig
(
(
JSplitPane
)
left
,
splitConfig
)
;
else
{
splitConfig
.
append
(
'\t'
)
;
splitConfig
.
append
(
(
(
EditPane
)
left
)
.
getBuffer
(
)
.
getPath
(
)
)
;
}
Component
right
=
splitPane
.
getRightComponent
(
)
;
if
(
right
instanceof
JSplitPane
)
getSplitConfig
(
(
JSplitPane
)
right
,
splitConfig
)
;
else
{
splitConfig
.
append
(
'\t'
)
;
splitConfig
.
append
(
(
(
EditPane
)
right
)
.
getBuffer
(
)
.
getPath
(
)
)
;
}
splitConfig
.
append
(
splitPane
.
getOrientation
(
)
==
JSplitPane
.
VERTICAL_SPLIT
?
"\tvertical"
:
"\thorizontal"
)
;
}
private
Component
restoreSplitConfig
(
Buffer
buffer
,
String
splitConfig
)
{
if
(
buffer
!=
null
)
return
(
editPane
=
createEditPane
(
buffer
)
)
;
else
if
(
splitConfig
==
null
)
return
(
editPane
=
createEditPane
(
jEdit
.
getFirstBuffer
(
)
)
)
;
Stack
stack
=
new
Stack
(
)
;
StringTokenizer
st
=
new
StringTokenizer
(
splitConfig
,
"\t"
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
String
token
=
st
.
nextToken
(
)
;
if
(
token
.
equals
(
"vertical"
)
)
{
stack
.
push
(
splitPane
=
new
JSplitPane
(
JSplitPane
.
VERTICAL_SPLIT
,
(
Component
)
stack
.
pop
(
)
,
(
Component
)
stack
.
pop
(
)
)
)
;
splitPane
.
setBorder
(
null
)
;
splitPane
.
setDividerLocation
(
0.5
)
;
}
else
if
(
token
.
equals
(
"horizontal"
)
)
{
stack
.
push
(
splitPane
=
new
JSplitPane
(
JSplitPane
.
HORIZONTAL_SPLIT
,
(
Component
)
stack
.
pop
(
)
,
(
Component
)
stack
.
pop
(
)
)
)
;
splitPane
.
setBorder
(
null
)
;
splitPane
.
setDividerLocation
(
0.5
)
;
}
else
{
buffer
=
jEdit
.
getBuffer
(
token
)
;
if
(
buffer
==
null
)
buffer
=
jEdit
.
getFirstBuffer
(
)
;
stack
.
push
(
editPane
=
createEditPane
(
buffer
)
)
;
}
}
return
(
Component
)
stack
.
peek
(
)
;
}
private
void
propertiesChanged
(
)
{
loadToolBars
(
)
;
showFullPath
=
jEdit
.
getBooleanProperty
(
"view.showFullPath"
)
;
updateTitle
(
)
;
dockableWindowManager
.
propertiesChanged
(
)
;
SwingUtilities
.
updateComponentTreeUI
(
getRootPane
(
)
)
;
}
private
void
loadToolBars
(
)
{
if
(
jEdit
.
getBooleanProperty
(
"view.showToolbar"
)
)
{
if
(
toolBar
!=
null
)
toolBarManager
.
removeToolBar
(
toolBar
)
;
toolBar
=
GUIUtilities
.
loadToolBar
(
"view.toolbar"
)
;
addToolBar
(
TOP_GROUP
,
SYSTEM_BAR_LAYER
,
toolBar
)
;
}
else
if
(
toolBar
!=
null
)
{
removeToolBar
(
toolBar
)
;
toolBar
=
null
;
}
if
(
jEdit
.
getBooleanProperty
(
"view.showSearchbar"
)
)
{
if
(
searchBar
==
null
)
{
searchBar
=
new
SearchBar
(
this
)
;
addToolBar
(
TOP_GROUP
,
SEARCH_BAR_LAYER
,
searchBar
)
;
}
}
else
if
(
searchBar
!=
null
)
{
removeToolBar
(
searchBar
)
;
searchBar
=
null
;
}
}
private
EditPane
createEditPane
(
Buffer
buffer
)
{
EditPane
editPane
=
new
EditPane
(
this
,
buffer
)
;
JEditTextArea
textArea
=
editPane
.
getTextArea
(
)
;
textArea
.
addFocusListener
(
new
FocusHandler
(
)
)
;
textArea
.
addCaretListener
(
new
CaretHandler
(
)
)
;
textArea
.
addScrollListener
(
new
ScrollHandler
(
)
)
;
EditBus
.
send
(
new
EditPaneUpdate
(
editPane
,
EditPaneUpdate
.
CREATED
)
)
;
return
editPane
;
}
private
void
setEditPane
(
EditPane
editPane
)
{
this
.
editPane
=
editPane
;
status
.
repaintCaretStatus
(
)
;
status
.
updateBufferStatus
(
)
;
status
.
updateMiscStatus
(
)
;
}
private
void
handleBufferUpdate
(
BufferUpdate
msg
)
{
Buffer
buffer
=
msg
.
getBuffer
(
)
;
if
(
msg
.
getWhat
(
)
==
BufferUpdate
.
DIRTY_CHANGED
)
{
if
(
!
buffer
.
isDirty
(
)
)
{
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
{
if
(
editPanes
[
i
]
.
getBuffer
(
)
==
buffer
)
{
updateTitle
(
)
;
break
;
}
}
}
}
}
private
void
handleEditPaneUpdate
(
EditPaneUpdate
msg
)
{
if
(
msg
.
getEditPane
(
)
.
getView
(
)
==
this
&&
msg
.
getWhat
(
)
==
EditPaneUpdate
.
BUFFER_CHANGED
)
{
status
.
repaintCaretStatus
(
)
;
status
.
updateBufferStatus
(
)
;
status
.
updateMiscStatus
(
)
;
}
}
class
CaretHandler
implements
CaretListener
{
public
void
caretUpdate
(
CaretEvent
evt
)
{
status
.
repaintCaretStatus
(
)
;
status
.
updateMiscStatus
(
)
;
}
}
class
FocusHandler
extends
FocusAdapter
{
public
void
focusGained
(
FocusEvent
evt
)
{
Component
comp
=
(
Component
)
evt
.
getSource
(
)
;
while
(
!
(
comp
instanceof
EditPane
)
)
{
if
(
comp
==
null
)
return
;
comp
=
comp
.
getParent
(
)
;
}
setEditPane
(
(
EditPane
)
comp
)
;
}
}
class
ScrollHandler
implements
ScrollListener
{
public
void
scrolledVertically
(
JEditTextArea
textArea
)
{
if
(
getTextArea
(
)
==
textArea
)
status
.
repaintCaretStatus
(
)
;
}
public
void
scrolledHorizontally
(
JEditTextArea
textArea
)
{
}
}
class
WindowHandler
extends
WindowAdapter
{
public
void
windowActivated
(
WindowEvent
evt
)
{
final
Vector
buffers
=
new
Vector
(
)
;
EditPane
[
]
editPanes
=
getEditPanes
(
)
;
for
(
int
i
=
0
;
i
<
editPanes
.
length
;
i
++
)
{
Buffer
buffer
=
(
(
EditPane
)
editPanes
[
i
]
)
.
getBuffer
(
)
;
if
(
buffers
.
contains
(
buffer
)
)
continue
;
else
buffers
.
addElement
(
buffer
)
;
}
SwingUtilities
.
invokeLater
(
new
Runnable
(
)
{
public
void
run
(
)
{
for
(
int
i
=
0
;
i
<
buffers
.
size
(
)
;
i
++
)
{
(
(
Buffer
)
buffers
.
elementAt
(
i
)
)
.
checkModTime
(
View
.
this
)
;
}
}
}
)
;
}
public
void
windowClosing
(
WindowEvent
evt
)
{
jEdit
.
closeView
(
View
.
this
)
;
}
}
}
