package
org
.
gjt
.
sp
.
jedit
;
import
gnu
.
regexp
.
RE
;
import
javax
.
swing
.
JMenuItem
;
import
java
.
io
.
*
;
import
java
.
util
.
*
;
import
org
.
gjt
.
sp
.
jedit
.
io
.
*
;
import
org
.
gjt
.
sp
.
util
.
Log
;
public
class
MiscUtilities
{
public
static
String
canonPath
(
String
path
)
{
if
(
File
.
separatorChar
==
'\\'
)
{
path
=
path
.
replace
(
'/'
,
'\\'
)
;
}
if
(
path
.
startsWith
(
"~"
+
File
.
separator
)
)
{
path
=
path
.
substring
(
2
)
;
String
home
=
System
.
getProperty
(
"user.home"
)
;
if
(
home
.
endsWith
(
File
.
separator
)
)
return
home
+
path
;
else
return
home
+
File
.
separator
+
path
;
}
else
if
(
path
.
equals
(
"~"
)
)
return
System
.
getProperty
(
"user.home"
)
;
else
return
path
;
}
public
static
String
constructPath
(
String
parent
,
String
path
)
{
if
(
MiscUtilities
.
isURL
(
path
)
)
return
path
;
else
if
(
path
.
startsWith
(
"~"
)
)
return
path
;
else
{
if
(
OperatingSystem
.
isDOSDerived
(
)
)
{
if
(
path
.
length
(
)
==
2
&&
path
.
charAt
(
1
)
==
':'
)
return
path
;
else
if
(
path
.
length
(
)
>
2
&&
path
.
charAt
(
1
)
==
':'
)
{
if
(
path
.
charAt
(
2
)
!=
'\\'
)
{
path
=
path
.
substring
(
0
,
2
)
+
'\\'
+
path
.
substring
(
2
)
;
}
return
resolveSymlinks
(
path
)
;
}
else
if
(
path
.
startsWith
(
"\\\\"
)
)
return
resolveSymlinks
(
path
)
;
}
else
if
(
OperatingSystem
.
isUnix
(
)
)
{
if
(
path
.
length
(
)
>
0
&&
path
.
charAt
(
0
)
==
'/'
)
return
resolveSymlinks
(
path
)
;
}
}
if
(
parent
==
null
)
parent
=
System
.
getProperty
(
"user.dir"
)
;
if
(
OperatingSystem
.
isDOSDerived
(
)
&&
path
.
startsWith
(
"\\"
)
)
parent
=
parent
.
substring
(
0
,
2
)
;
VFS
vfs
=
VFSManager
.
getVFSForPath
(
parent
)
;
return
vfs
.
constructPath
(
parent
,
path
)
;
}
public
static
String
constructPath
(
String
parent
,
String
path1
,
String
path2
)
{
return
constructPath
(
constructPath
(
parent
,
path1
)
,
path2
)
;
}
public
static
String
concatPath
(
String
parent
,
String
path
)
{
parent
=
canonPath
(
parent
)
;
path
=
canonPath
(
path
)
;
if
(
path
.
startsWith
(
File
.
separator
)
)
path
=
path
.
substring
(
1
)
;
else
if
(
(
path
.
length
(
)
>=
3
)
&&
(
path
.
charAt
(
1
)
==
':'
)
)
path
=
path
.
replace
(
':'
,
File
.
separatorChar
)
;
if
(
parent
==
null
)
parent
=
System
.
getProperty
(
"user.dir"
)
;
if
(
parent
.
endsWith
(
File
.
separator
)
)
return
parent
+
path
;
else
return
parent
+
File
.
separator
+
path
;
}
public
static
String
getFileExtension
(
String
name
)
{
int
index
=
name
.
indexOf
(
'.'
)
;
if
(
index
==
-
1
)
return
""
;
else
return
name
.
substring
(
index
)
;
}
public
static
String
getFileName
(
String
path
)
{
return
VFSManager
.
getVFSForPath
(
path
)
.
getFileName
(
path
)
;
}
public
static
String
getFileNameNoExtension
(
String
path
)
{
String
name
=
getFileName
(
path
)
;
int
index
=
name
.
lastIndexOf
(
'.'
)
;
if
(
index
==
-
1
)
return
name
;
else
return
name
.
substring
(
0
,
index
)
;
}
public
static
String
getFileParent
(
String
path
)
{
return
getParentOfPath
(
path
)
;
}
public
static
String
getParentOfPath
(
String
path
)
{
return
VFSManager
.
getVFSForPath
(
path
)
.
getParentOfPath
(
path
)
;
}
public
static
String
getFileProtocol
(
String
url
)
{
return
getProtocolOfURL
(
url
)
;
}
public
static
String
getProtocolOfURL
(
String
url
)
{
return
url
.
substring
(
0
,
url
.
indexOf
(
':'
)
)
;
}
public
static
boolean
isURL
(
String
str
)
{
int
fsIndex
=
Math
.
max
(
str
.
indexOf
(
File
.
separatorChar
)
,
str
.
indexOf
(
'/'
)
)
;
if
(
fsIndex
==
0
)
return
false
;
else
if
(
fsIndex
==
2
)
return
false
;
int
cIndex
=
str
.
indexOf
(
':'
)
;
if
(
cIndex
<=
1
)
return
false
;
else
if
(
fsIndex
!=
-
1
&&
cIndex
>
fsIndex
)
return
false
;
return
true
;
}
public
static
void
saveBackup
(
File
file
,
int
backups
,
String
backupPrefix
,
String
backupSuffix
,
String
backupDirectory
)
{
if
(
backupPrefix
==
null
)
backupPrefix
=
""
;
if
(
backupSuffix
==
null
)
backupSuffix
=
""
;
String
name
=
file
.
getName
(
)
;
if
(
backups
==
1
)
{
file
.
renameTo
(
new
File
(
backupDirectory
,
backupPrefix
+
name
+
backupSuffix
)
)
;
}
else
{
new
File
(
backupDirectory
,
backupPrefix
+
name
+
backupSuffix
+
backups
+
backupSuffix
)
.
delete
(
)
;
for
(
int
i
=
backups
-
1
;
i
>
0
;
i
--
)
{
File
backup
=
new
File
(
backupDirectory
,
backupPrefix
+
name
+
backupSuffix
+
i
+
backupSuffix
)
;
backup
.
renameTo
(
new
File
(
backupDirectory
,
backupPrefix
+
name
+
backupSuffix
+
(
i
+
1
)
+
backupSuffix
)
)
;
}
file
.
renameTo
(
new
File
(
backupDirectory
,
backupPrefix
+
name
+
backupSuffix
+
"1"
+
backupSuffix
)
)
;
}
}
public
static
int
getLeadingWhiteSpace
(
String
str
)
{
int
whitespace
=
0
;
loop
:
for
(
;
whitespace
<
str
.
length
(
)
;
)
{
switch
(
str
.
charAt
(
whitespace
)
)
{
case
' '
:
case
'\t'
:
whitespace
++
;
break
;
default
:
break
loop
;
}
}
return
whitespace
;
}
public
static
int
getTrailingWhiteSpace
(
String
str
)
{
int
whitespace
=
0
;
loop
:
for
(
int
i
=
str
.
length
(
)
-
1
;
i
>=
0
;
i
--
)
{
switch
(
str
.
charAt
(
i
)
)
{
case
' '
:
case
'\t'
:
whitespace
++
;
break
;
default
:
break
loop
;
}
}
return
whitespace
;
}
public
static
int
getLeadingWhiteSpaceWidth
(
String
str
,
int
tabSize
)
{
int
whitespace
=
0
;
loop
:
for
(
int
i
=
0
;
i
<
str
.
length
(
)
;
i
++
)
{
switch
(
str
.
charAt
(
i
)
)
{
case
' '
:
whitespace
++
;
break
;
case
'\t'
:
whitespace
+=
(
tabSize
-
whitespace
%
tabSize
)
;
break
;
default
:
break
loop
;
}
}
return
whitespace
;
}
public
static
String
createWhiteSpace
(
int
len
,
int
tabSize
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
if
(
tabSize
==
0
)
{
while
(
len
--
>
0
)
buf
.
append
(
' '
)
;
}
else
{
int
count
=
len
/
tabSize
;
while
(
count
--
>
0
)
buf
.
append
(
'\t'
)
;
count
=
len
%
tabSize
;
while
(
count
--
>
0
)
buf
.
append
(
' '
)
;
}
return
buf
.
toString
(
)
;
}
public
static
String
globToRE
(
String
glob
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
boolean
backslash
=
false
;
boolean
insideGroup
=
false
;
boolean
insideNegativeLookahead
=
false
;
for
(
int
i
=
0
;
i
<
glob
.
length
(
)
;
i
++
)
{
char
c
=
glob
.
charAt
(
i
)
;
if
(
backslash
)
{
buf
.
append
(
'\\'
)
;
buf
.
append
(
c
)
;
backslash
=
false
;
continue
;
}
switch
(
c
)
{
case
'\\'
:
backslash
=
true
;
break
;
case
'?'
:
buf
.
append
(
'.'
)
;
break
;
case
'.'
:
buf
.
append
(
"\\."
)
;
break
;
case
'*'
:
buf
.
append
(
".*"
)
;
break
;
case
'{'
:
buf
.
append
(
'('
)
;
if
(
i
+
1
!=
glob
.
length
(
)
&&
glob
.
charAt
(
i
+
1
)
==
'!'
)
{
buf
.
append
(
'?'
)
;
insideNegativeLookahead
=
true
;
}
else
insideGroup
=
true
;
break
;
case
','
:
if
(
insideGroup
)
{
if
(
insideNegativeLookahead
)
{
buf
.
append
(
").*"
)
;
insideNegativeLookahead
=
false
;
}
buf
.
append
(
'|'
)
;
}
else
buf
.
append
(
','
)
;
break
;
case
'}'
:
if
(
insideNegativeLookahead
)
{
buf
.
append
(
").*"
)
;
insideNegativeLookahead
=
false
;
}
else
if
(
insideGroup
)
{
buf
.
append
(
')'
)
;
insideGroup
=
false
;
}
else
buf
.
append
(
'}'
)
;
break
;
default
:
buf
.
append
(
c
)
;
}
}
return
buf
.
toString
(
)
;
}
public
static
String
escapesToChars
(
String
str
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
str
.
length
(
)
;
i
++
)
{
char
c
=
str
.
charAt
(
i
)
;
switch
(
c
)
{
case
'\\'
:
if
(
i
==
str
.
length
(
)
-
1
)
{
buf
.
append
(
'\\'
)
;
break
;
}
c
=
str
.
charAt
(
++
i
)
;
switch
(
c
)
{
case
'n'
:
buf
.
append
(
'\n'
)
;
break
;
case
't'
:
buf
.
append
(
'\t'
)
;
break
;
default
:
buf
.
append
(
c
)
;
break
;
}
break
;
default
:
buf
.
append
(
c
)
;
}
}
return
buf
.
toString
(
)
;
}
public
static
String
charsToEscapes
(
String
str
)
{
return
charsToEscapes
(
str
,
false
)
;
}
public
static
String
charsToEscapes
(
String
str
,
boolean
history
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
str
.
length
(
)
;
i
++
)
{
char
c
=
str
.
charAt
(
i
)
;
switch
(
c
)
{
case
'\n'
:
buf
.
append
(
"\\n"
)
;
break
;
case
'\t'
:
buf
.
append
(
"\\t"
)
;
break
;
case
'['
:
if
(
history
)
buf
.
append
(
"\\["
)
;
else
buf
.
append
(
c
)
;
break
;
case
']'
:
if
(
history
)
buf
.
append
(
"\\]"
)
;
else
buf
.
append
(
c
)
;
break
;
case
'"'
:
if
(
history
)
buf
.
append
(
c
)
;
else
buf
.
append
(
"\\\""
)
;
break
;
case
'\''
:
if
(
history
)
buf
.
append
(
c
)
;
else
buf
.
append
(
"\\\'"
)
;
break
;
case
'\\'
:
buf
.
append
(
"\\\\"
)
;
break
;
default
:
buf
.
append
(
c
)
;
break
;
}
}
return
buf
.
toString
(
)
;
}
public
static
int
compareVersions
(
String
v1
,
String
v2
)
{
return
compareStrings
(
v1
,
v2
,
false
)
;
}
public
static
int
compareStrings
(
String
str1
,
String
str2
,
boolean
ignoreCase
)
{
char
[
]
char1
=
str1
.
toCharArray
(
)
;
char
[
]
char2
=
str2
.
toCharArray
(
)
;
int
len
=
Math
.
min
(
char1
.
length
,
char2
.
length
)
;
for
(
int
i
=
0
,
j
=
0
;
i
<
len
&&
j
<
len
;
i
++
,
j
++
)
{
char
ch1
=
char1
[
i
]
;
char
ch2
=
char2
[
j
]
;
if
(
Character
.
isDigit
(
ch1
)
&&
Character
.
isDigit
(
ch2
)
&&
ch1
!=
'0'
&&
ch2
!=
'0'
)
{
int
_i
=
i
+
1
;
int
_j
=
j
+
1
;
for
(
;
_i
<
char1
.
length
;
_i
++
)
{
if
(
!
Character
.
isDigit
(
char1
[
_i
]
)
)
{
break
;
}
}
for
(
;
_j
<
char2
.
length
;
_j
++
)
{
if
(
!
Character
.
isDigit
(
char2
[
_j
]
)
)
{
break
;
}
}
int
len1
=
_i
-
i
;
int
len2
=
_j
-
j
;
if
(
len1
>
len2
)
return
1
;
else
if
(
len1
<
len2
)
return
-
1
;
else
{
for
(
int
k
=
0
;
k
<
len1
;
k
++
)
{
ch1
=
char1
[
i
+
k
]
;
ch2
=
char2
[
j
+
k
]
;
if
(
ch1
!=
ch2
)
return
ch1
-
ch2
;
}
}
i
=
_i
-
1
;
j
=
_j
-
1
;
}
else
{
if
(
ignoreCase
)
{
ch1
=
Character
.
toLowerCase
(
ch1
)
;
ch2
=
Character
.
toLowerCase
(
ch2
)
;
}
if
(
ch1
!=
ch2
)
return
ch1
-
ch2
;
}
}
return
char1
.
length
-
char2
.
length
;
}
public
static
void
quicksort
(
Object
[
]
obj
,
Comparator
compare
)
{
Arrays
.
sort
(
obj
,
compare
)
;
}
public
static
void
quicksort
(
Vector
vector
,
Comparator
compare
)
{
Collections
.
sort
(
vector
,
compare
)
;
}
public
static
void
quicksort
(
List
list
,
Comparator
compare
)
{
Collections
.
sort
(
list
,
compare
)
;
}
public
static
void
quicksort
(
Object
[
]
obj
,
Compare
compare
)
{
Arrays
.
sort
(
obj
,
compare
)
;
}
public
static
void
quicksort
(
Vector
vector
,
Compare
compare
)
{
Collections
.
sort
(
vector
,
compare
)
;
}
public
interface
Compare
extends
Comparator
{
int
compare
(
Object
obj1
,
Object
obj2
)
;
}
public
static
class
StringCompare
implements
Compare
{
public
int
compare
(
Object
obj1
,
Object
obj2
)
{
return
compareStrings
(
obj1
.
toString
(
)
,
obj2
.
toString
(
)
,
false
)
;
}
}
public
static
class
StringICaseCompare
implements
Compare
{
public
int
compare
(
Object
obj1
,
Object
obj2
)
{
return
compareStrings
(
obj1
.
toString
(
)
,
obj2
.
toString
(
)
,
true
)
;
}
}
public
static
class
MenuItemCompare
implements
Compare
{
public
int
compare
(
Object
obj1
,
Object
obj2
)
{
return
compareStrings
(
(
(
JMenuItem
)
obj1
)
.
getText
(
)
,
(
(
JMenuItem
)
obj2
)
.
getText
(
)
,
true
)
;
}
}
public
static
String
fileToClass
(
String
name
)
{
char
[
]
clsName
=
name
.
toCharArray
(
)
;
for
(
int
i
=
clsName
.
length
-
6
;
i
>=
0
;
i
--
)
if
(
clsName
[
i
]
==
'/'
)
clsName
[
i
]
=
'.'
;
return
new
String
(
clsName
,
0
,
clsName
.
length
-
6
)
;
}
public
static
String
classToFile
(
String
name
)
{
return
name
.
replace
(
'.'
,
'/'
)
.
concat
(
".class"
)
;
}
public
static
String
buildToVersion
(
String
build
)
{
if
(
build
.
length
(
)
!=
11
)
return
"<unknown version: "
+
build
+
">"
;
int
major
=
Integer
.
parseInt
(
build
.
substring
(
0
,
2
)
)
;
int
minor
=
Integer
.
parseInt
(
build
.
substring
(
3
,
5
)
)
;
int
beta
=
Integer
.
parseInt
(
build
.
substring
(
6
,
8
)
)
;
int
bugfix
=
Integer
.
parseInt
(
build
.
substring
(
9
,
11
)
)
;
return
""
+
major
+
"."
+
minor
+
(
beta
!=
99
?
"pre"
+
beta
:
(
bugfix
!=
0
?
"."
+
bugfix
:
"final"
)
)
;
}
public
static
boolean
isToolsJarAvailable
(
)
{
Log
.
log
(
Log
.
DEBUG
,
MiscUtilities
.
class
,
"Searching for tools.jar..."
)
;
Vector
paths
=
new
Vector
(
)
;
paths
.
addElement
(
"System classpath: "
+
System
.
getProperty
(
"java.class.path"
)
)
;
try
{
try
{
Class
.
forName
(
"sun.tools.javac.Main"
)
;
}
catch
(
ClassNotFoundException
e1
)
{
Class
.
forName
(
"com.sun.tools.javac.Main"
)
;
}
Log
.
log
(
Log
.
DEBUG
,
MiscUtilities
.
class
,
"- is in classpath. Fine."
)
;
return
true
;
}
catch
(
ClassNotFoundException
e
)
{
}
String
settingsDir
=
jEdit
.
getSettingsDirectory
(
)
;
if
(
settingsDir
!=
null
)
{
String
toolsPath
=
constructPath
(
settingsDir
,
"jars"
,
"tools.jar"
)
;
paths
.
addElement
(
toolsPath
)
;
if
(
new
File
(
toolsPath
)
.
exists
(
)
)
{
Log
.
log
(
Log
.
DEBUG
,
MiscUtilities
.
class
,
"- is in the user's jars folder. Fine."
)
;
return
true
;
}
}
String
jEditDir
=
jEdit
.
getJEditHome
(
)
;
if
(
jEditDir
!=
null
)
{
String
toolsPath
=
constructPath
(
jEditDir
,
"jars"
,
"tools.jar"
)
;
paths
.
addElement
(
toolsPath
)
;
if
(
new
File
(
toolsPath
)
.
exists
(
)
)
{
Log
.
log
(
Log
.
DEBUG
,
MiscUtilities
.
class
,
"- is in jEdit's system jars folder. Fine."
)
;
return
true
;
}
}
String
toolsPath
=
System
.
getProperty
(
"java.home"
)
;
if
(
toolsPath
.
toLowerCase
(
)
.
endsWith
(
File
.
separator
+
"jre"
)
)
toolsPath
=
toolsPath
.
substring
(
0
,
toolsPath
.
length
(
)
-
4
)
;
toolsPath
=
constructPath
(
toolsPath
,
"lib"
,
"tools.jar"
)
;
paths
.
addElement
(
toolsPath
)
;
if
(
!
(
new
File
(
toolsPath
)
.
exists
(
)
)
)
{
Log
.
log
(
Log
.
WARNING
,
MiscUtilities
.
class
,
"Could not find tools.jar.\n"
+
"I checked the following locations:\n"
+
paths
.
toString
(
)
)
;
return
false
;
}
EditPlugin
.
JAR
jar
=
jEdit
.
getPluginJAR
(
toolsPath
)
;
if
(
jar
==
null
)
{
Log
.
log
(
Log
.
DEBUG
,
MiscUtilities
.
class
,
"- adding "
+
toolsPath
+
" to jEdit plugins."
)
;
try
{
jEdit
.
addPluginJAR
(
new
EditPlugin
.
JAR
(
toolsPath
,
new
JARClassLoader
(
toolsPath
)
)
)
;
}
catch
(
IOException
ioex
)
{
Log
.
log
(
Log
.
ERROR
,
MiscUtilities
.
class
,
"- I/O error loading "
+
toolsPath
)
;
Log
.
log
(
Log
.
ERROR
,
MiscUtilities
.
class
,
ioex
)
;
return
false
;
}
}
else
Log
.
log
(
Log
.
DEBUG
,
MiscUtilities
.
class
,
"- has been loaded before."
)
;
return
true
;
}
public
static
String
[
]
listDirectory
(
String
directory
,
String
glob
,
boolean
recurse
)
{
Log
.
log
(
Log
.
DEBUG
,
MiscUtilities
.
class
,
"Listing "
+
directory
)
;
Vector
files
=
new
Vector
(
100
)
;
RE
filter
;
try
{
filter
=
new
RE
(
globToRE
(
glob
)
)
;
}
catch
(
Exception
e
)
{
Log
.
log
(
Log
.
ERROR
,
MiscUtilities
.
class
,
e
)
;
return
null
;
}
listDirectory
(
new
Vector
(
)
,
files
,
new
File
(
directory
)
,
filter
,
recurse
)
;
String
[
]
retVal
=
new
String
[
files
.
size
(
)
]
;
files
.
copyInto
(
retVal
)
;
quicksort
(
retVal
,
new
StringICaseCompare
(
)
)
;
return
retVal
;
}
private
MiscUtilities
(
)
{
}
private
static
void
listDirectory
(
Vector
stack
,
Vector
files
,
File
directory
,
RE
filter
,
boolean
recurse
)
{
if
(
stack
.
contains
(
directory
)
)
{
Log
.
log
(
Log
.
ERROR
,
MiscUtilities
.
class
,
"Recursion in listDirectory(): "
+
directory
.
getPath
(
)
)
;
return
;
}
else
stack
.
addElement
(
directory
)
;
File
[
]
_files
=
directory
.
listFiles
(
)
;
if
(
_files
==
null
)
return
;
for
(
int
i
=
0
;
i
<
_files
.
length
;
i
++
)
{
File
file
=
_files
[
i
]
;
if
(
file
.
isDirectory
(
)
)
{
if
(
recurse
)
{
try
{
file
=
new
File
(
file
.
getCanonicalPath
(
)
)
;
}
catch
(
IOException
io
)
{
}
listDirectory
(
stack
,
files
,
file
,
filter
,
recurse
)
;
}
}
else
{
if
(
!
filter
.
isMatch
(
file
.
getName
(
)
)
)
continue
;
String
path
=
file
.
getPath
(
)
;
Log
.
log
(
Log
.
DEBUG
,
MiscUtilities
.
class
,
path
)
;
files
.
addElement
(
path
)
;
}
}
}
private
static
String
resolveSymlinks
(
String
path
)
{
try
{
return
new
File
(
path
)
.
getCanonicalPath
(
)
;
}
catch
(
IOException
io
)
{
return
path
;
}
}
}
