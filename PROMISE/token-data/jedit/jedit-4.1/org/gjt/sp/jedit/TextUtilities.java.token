package
org
.
gjt
.
sp
.
jedit
;
import
java
.
awt
.
*
;
import
java
.
util
.
*
;
import
javax
.
swing
.
text
.
Segment
;
import
org
.
gjt
.
sp
.
jedit
.
syntax
.
*
;
public
class
TextUtilities
{
public
static
Token
getTokenAtOffset
(
Token
tokens
,
int
offset
)
{
if
(
offset
==
0
&&
tokens
.
id
==
Token
.
END
)
return
tokens
;
int
tokenListOffset
=
0
;
for
(
;
;
)
{
if
(
tokens
.
id
==
Token
.
END
)
throw
new
ArrayIndexOutOfBoundsException
(
"offset > line length"
)
;
if
(
tokenListOffset
+
tokens
.
length
>
offset
)
return
tokens
;
else
{
tokenListOffset
+=
tokens
.
length
;
tokens
=
tokens
.
next
;
}
}
}
public
static
int
findMatchingBracket
(
Buffer
buffer
,
int
line
,
int
offset
)
{
return
findMatchingBracket
(
buffer
,
line
,
offset
,
0
,
buffer
.
getLineCount
(
)
-
1
)
;
}
public
static
int
findMatchingBracket
(
Buffer
buffer
,
int
line
,
int
offset
,
int
startLine
,
int
endLine
)
{
if
(
offset
<
0
||
offset
>=
buffer
.
getLineLength
(
line
)
)
{
throw
new
ArrayIndexOutOfBoundsException
(
offset
+
":"
+
buffer
.
getLineLength
(
line
)
)
;
}
Segment
lineText
=
new
Segment
(
)
;
buffer
.
getLineText
(
line
,
lineText
)
;
char
c
=
lineText
.
array
[
lineText
.
offset
+
offset
]
;
char
cprime
;
boolean
direction
;
switch
(
c
)
{
case
'('
:
cprime
=
')'
;
direction
=
true
;
break
;
case
')'
:
cprime
=
'('
;
direction
=
false
;
break
;
case
'['
:
cprime
=
']'
;
direction
=
true
;
break
;
case
']'
:
cprime
=
'['
;
direction
=
false
;
break
;
case
'{'
:
cprime
=
'}'
;
direction
=
true
;
break
;
case
'}'
:
cprime
=
'{'
;
direction
=
false
;
break
;
default
:
return
-
1
;
}
int
count
=
1
;
Buffer
.
TokenList
tokenList
=
buffer
.
markTokens
(
line
)
;
byte
idOfBracket
=
getTokenAtOffset
(
tokenList
.
getFirstToken
(
)
,
offset
)
.
id
;
boolean
haveTokens
=
true
;
if
(
direction
)
{
offset
++
;
for
(
;
;
)
{
for
(
int
i
=
offset
;
i
<
lineText
.
count
;
i
++
)
{
char
ch
=
lineText
.
array
[
lineText
.
offset
+
i
]
;
if
(
ch
==
c
)
{
if
(
!
haveTokens
)
{
tokenList
=
buffer
.
markTokens
(
line
)
;
haveTokens
=
true
;
}
if
(
getTokenAtOffset
(
tokenList
.
getFirstToken
(
)
,
i
)
.
id
==
idOfBracket
)
count
++
;
}
else
if
(
ch
==
cprime
)
{
if
(
!
haveTokens
)
{
tokenList
=
buffer
.
markTokens
(
line
)
;
haveTokens
=
true
;
}
if
(
getTokenAtOffset
(
tokenList
.
getFirstToken
(
)
,
i
)
.
id
==
idOfBracket
)
{
count
--
;
if
(
count
==
0
)
return
buffer
.
getLineStartOffset
(
line
)
+
i
;
}
}
}
line
++
;
if
(
line
>
endLine
)
break
;
buffer
.
getLineText
(
line
,
lineText
)
;
offset
=
0
;
haveTokens
=
false
;
}
}
else
{
offset
--
;
for
(
;
;
)
{
for
(
int
i
=
offset
;
i
>=
0
;
i
--
)
{
char
ch
=
lineText
.
array
[
lineText
.
offset
+
i
]
;
if
(
ch
==
c
)
{
if
(
!
haveTokens
)
{
tokenList
=
buffer
.
markTokens
(
line
)
;
haveTokens
=
true
;
}
if
(
getTokenAtOffset
(
tokenList
.
getFirstToken
(
)
,
i
)
.
id
==
idOfBracket
)
count
++
;
}
else
if
(
ch
==
cprime
)
{
if
(
!
haveTokens
)
{
tokenList
=
buffer
.
markTokens
(
line
)
;
haveTokens
=
true
;
}
if
(
getTokenAtOffset
(
tokenList
.
getFirstToken
(
)
,
i
)
.
id
==
idOfBracket
)
{
count
--
;
if
(
count
==
0
)
return
buffer
.
getLineStartOffset
(
line
)
+
i
;
}
}
}
line
--
;
if
(
line
<
startLine
)
break
;
buffer
.
getLineText
(
line
,
lineText
)
;
offset
=
lineText
.
count
-
1
;
haveTokens
=
false
;
}
}
return
-
1
;
}
public
static
int
findWordStart
(
String
line
,
int
pos
,
String
noWordSep
)
{
char
ch
=
line
.
charAt
(
pos
)
;
if
(
noWordSep
==
null
)
noWordSep
=
""
;
int
type
;
if
(
Character
.
isWhitespace
(
ch
)
)
type
=
WHITESPACE
;
else
if
(
Character
.
isLetterOrDigit
(
ch
)
||
noWordSep
.
indexOf
(
ch
)
!=
-
1
)
type
=
WORD_CHAR
;
else
type
=
SYMBOL
;
int
whiteSpaceEnd
=
0
;
loop
:
for
(
int
i
=
pos
;
i
>=
0
;
i
--
)
{
ch
=
line
.
charAt
(
i
)
;
switch
(
type
)
{
case
WHITESPACE
:
if
(
Character
.
isWhitespace
(
ch
)
)
break
;
else
return
i
+
1
;
case
WORD_CHAR
:
if
(
Character
.
isLetterOrDigit
(
ch
)
||
noWordSep
.
indexOf
(
ch
)
!=
-
1
)
{
break
;
}
else
return
i
+
1
;
case
SYMBOL
:
if
(
Character
.
isWhitespace
(
ch
)
)
{
return
i
+
1
;
}
else
if
(
Character
.
isLetterOrDigit
(
ch
)
||
noWordSep
.
indexOf
(
ch
)
!=
-
1
)
{
return
i
+
1
;
}
else
{
break
;
}
}
}
return
whiteSpaceEnd
;
}
public
static
int
findWordEnd
(
String
line
,
int
pos
,
String
noWordSep
)
{
if
(
pos
!=
0
)
pos
--
;
char
ch
=
line
.
charAt
(
pos
)
;
if
(
noWordSep
==
null
)
noWordSep
=
""
;
int
type
;
if
(
Character
.
isWhitespace
(
ch
)
)
type
=
WHITESPACE
;
else
if
(
Character
.
isLetterOrDigit
(
ch
)
||
noWordSep
.
indexOf
(
ch
)
!=
-
1
)
type
=
WORD_CHAR
;
else
type
=
SYMBOL
;
boolean
seenWhiteSpace
=
false
;
loop
:
for
(
int
i
=
pos
;
i
<
line
.
length
(
)
;
i
++
)
{
ch
=
line
.
charAt
(
i
)
;
switch
(
type
)
{
case
WHITESPACE
:
if
(
Character
.
isWhitespace
(
ch
)
)
break
;
else
return
i
;
case
WORD_CHAR
:
if
(
Character
.
isLetterOrDigit
(
ch
)
||
noWordSep
.
indexOf
(
ch
)
!=
-
1
)
{
break
;
}
else
return
i
;
case
SYMBOL
:
if
(
Character
.
isWhitespace
(
ch
)
)
{
return
i
;
}
else
if
(
Character
.
isLetterOrDigit
(
ch
)
||
noWordSep
.
indexOf
(
ch
)
!=
-
1
)
return
i
;
else
{
break
;
}
}
}
return
line
.
length
(
)
;
}
public
static
boolean
regionMatches
(
boolean
ignoreCase
,
Segment
text
,
int
offset
,
char
[
]
match
)
{
int
length
=
offset
+
match
.
length
;
char
[
]
textArray
=
text
.
array
;
if
(
length
>
text
.
offset
+
text
.
count
)
return
false
;
for
(
int
i
=
offset
,
j
=
0
;
i
<
length
;
i
++
,
j
++
)
{
char
c1
=
textArray
[
i
]
;
char
c2
=
match
[
j
]
;
if
(
ignoreCase
)
{
c1
=
Character
.
toUpperCase
(
c1
)
;
c2
=
Character
.
toUpperCase
(
c2
)
;
}
if
(
c1
!=
c2
)
return
false
;
}
return
true
;
}
public
static
String
spacesToTabs
(
String
in
,
int
tabSize
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
int
width
=
0
;
int
whitespace
=
0
;
for
(
int
i
=
0
;
i
<
in
.
length
(
)
;
i
++
)
{
switch
(
in
.
charAt
(
i
)
)
{
case
' '
:
whitespace
++
;
width
++
;
break
;
case
'\t'
:
int
tab
=
tabSize
-
(
width
%
tabSize
)
;
width
+=
tab
;
whitespace
+=
tab
;
break
;
case
'\n'
:
if
(
whitespace
!=
0
)
{
buf
.
append
(
MiscUtilities
.
createWhiteSpace
(
whitespace
,
tabSize
)
)
;
}
whitespace
=
0
;
width
=
0
;
buf
.
append
(
'\n'
)
;
break
;
default
:
if
(
whitespace
!=
0
)
{
buf
.
append
(
MiscUtilities
.
createWhiteSpace
(
whitespace
,
tabSize
)
)
;
whitespace
=
0
;
}
buf
.
append
(
in
.
charAt
(
i
)
)
;
width
++
;
break
;
}
}
if
(
whitespace
!=
0
)
{
buf
.
append
(
MiscUtilities
.
createWhiteSpace
(
whitespace
,
tabSize
)
)
;
}
return
buf
.
toString
(
)
;
}
public
static
String
tabsToSpaces
(
String
in
,
int
tabSize
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
int
width
=
0
;
for
(
int
i
=
0
;
i
<
in
.
length
(
)
;
i
++
)
{
switch
(
in
.
charAt
(
i
)
)
{
case
'\t'
:
int
count
=
tabSize
-
(
width
%
tabSize
)
;
width
+=
count
;
while
(
--
count
>=
0
)
buf
.
append
(
' '
)
;
break
;
case
'\n'
:
width
=
0
;
buf
.
append
(
in
.
charAt
(
i
)
)
;
break
;
default
:
width
++
;
buf
.
append
(
in
.
charAt
(
i
)
)
;
break
;
}
}
return
buf
.
toString
(
)
;
}
public
static
String
format
(
String
text
,
int
maxLineLength
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
StringBuffer
word
=
new
StringBuffer
(
)
;
int
lineLength
=
0
;
boolean
newline
=
true
;
boolean
space
=
false
;
char
[
]
chars
=
text
.
toCharArray
(
)
;
for
(
int
i
=
0
;
i
<
chars
.
length
;
i
++
)
{
char
c
=
chars
[
i
]
;
switch
(
c
)
{
case
'\n'
:
if
(
i
==
0
||
chars
.
length
-
i
<=
2
)
{
if
(
lineLength
+
word
.
length
(
)
>=
maxLineLength
)
buf
.
append
(
'\n'
)
;
else
if
(
space
&&
word
.
length
(
)
!=
0
)
buf
.
append
(
' '
)
;
buf
.
append
(
word
)
;
word
.
setLength
(
0
)
;
buf
.
append
(
'\n'
)
;
newline
=
true
;
space
=
false
;
break
;
}
else
if
(
newline
)
{
if
(
lineLength
+
word
.
length
(
)
>=
maxLineLength
)
buf
.
append
(
'\n'
)
;
else
if
(
space
&&
word
.
length
(
)
!=
0
)
buf
.
append
(
' '
)
;
buf
.
append
(
word
)
;
word
.
setLength
(
0
)
;
buf
.
append
(
"\n\n"
)
;
newline
=
space
=
false
;
lineLength
=
0
;
break
;
}
else
newline
=
true
;
case
' '
:
if
(
lineLength
+
word
.
length
(
)
>=
maxLineLength
)
{
buf
.
append
(
'\n'
)
;
lineLength
=
0
;
newline
=
true
;
}
else
if
(
space
&&
lineLength
!=
0
&&
word
.
length
(
)
!=
0
)
{
buf
.
append
(
' '
)
;
lineLength
++
;
space
=
false
;
}
else
space
=
true
;
buf
.
append
(
word
)
;
lineLength
+=
word
.
length
(
)
;
word
.
setLength
(
0
)
;
break
;
default
:
newline
=
false
;
if
(
lineLength
!=
0
)
space
=
true
;
word
.
append
(
c
)
;
break
;
}
}
if
(
lineLength
+
word
.
length
(
)
>=
maxLineLength
)
buf
.
append
(
'\n'
)
;
else
if
(
space
&&
word
.
length
(
)
!=
0
)
buf
.
append
(
' '
)
;
buf
.
append
(
word
)
;
return
buf
.
toString
(
)
;
}
public
static
final
int
MIXED
=
0
;
public
static
final
int
LOWER_CASE
=
1
;
public
static
final
int
UPPER_CASE
=
2
;
public
static
final
int
TITLE_CASE
=
3
;
public
static
int
getStringCase
(
String
str
)
{
if
(
str
.
length
(
)
==
0
)
return
MIXED
;
int
state
=
-
1
;
char
ch
=
str
.
charAt
(
0
)
;
if
(
Character
.
isLetter
(
ch
)
)
{
if
(
Character
.
isUpperCase
(
ch
)
)
state
=
UPPER_CASE
;
else
state
=
LOWER_CASE
;
}
for
(
int
i
=
1
;
i
<
str
.
length
(
)
;
i
++
)
{
ch
=
str
.
charAt
(
i
)
;
if
(
!
Character
.
isLetter
(
ch
)
)
continue
;
switch
(
state
)
{
case
UPPER_CASE
:
if
(
Character
.
isLowerCase
(
ch
)
)
{
if
(
i
==
1
)
state
=
TITLE_CASE
;
else
return
MIXED
;
}
break
;
case
LOWER_CASE
:
case
TITLE_CASE
:
if
(
Character
.
isUpperCase
(
ch
)
)
return
MIXED
;
break
;
}
}
return
state
;
}
public
static
String
toTitleCase
(
String
str
)
{
if
(
str
.
length
(
)
==
0
)
return
str
;
else
{
return
Character
.
toUpperCase
(
str
.
charAt
(
0
)
)
+
str
.
substring
(
1
)
.
toLowerCase
(
)
;
}
}
private
static
final
int
WHITESPACE
=
0
;
private
static
final
int
WORD_CHAR
=
1
;
private
static
final
int
SYMBOL
=
2
;
}
