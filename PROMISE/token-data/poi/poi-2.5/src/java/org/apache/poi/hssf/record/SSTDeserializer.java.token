package
org
.
apache
.
poi
.
hssf
.
record
;
import
org
.
apache
.
poi
.
util
.
BinaryTree
;
import
org
.
apache
.
poi
.
util
.
LittleEndian
;
import
org
.
apache
.
poi
.
util
.
LittleEndianConsts
;
class
SSTDeserializer
{
private
BinaryTree
strings
;
private
int
continuationReadChars
;
private
String
unfinishedString
;
private
boolean
wideChar
;
private
boolean
richText
;
private
boolean
extendedText
;
private
short
runCount
;
private
int
charCount
;
private
int
extensionLength
;
private
int
continueSkipBytes
=
0
;
public
SSTDeserializer
(
BinaryTree
strings
)
{
this
.
strings
=
strings
;
initVars
(
)
;
}
private
void
initVars
(
)
{
runCount
=
0
;
continuationReadChars
=
0
;
unfinishedString
=
""
;
wideChar
=
false
;
richText
=
false
;
extendedText
=
false
;
continueSkipBytes
=
0
;
}
public
void
manufactureStrings
(
final
byte
[
]
data
,
final
int
initialOffset
)
{
initVars
(
)
;
int
offset
=
initialOffset
;
final
int
dataSize
=
data
.
length
;
while
(
offset
<
dataSize
)
{
int
remaining
=
dataSize
-
offset
;
if
(
(
remaining
>
0
)
&&
(
remaining
<
LittleEndianConsts
.
SHORT_SIZE
)
)
{
throw
new
RecordFormatException
(
"Cannot get length of the last string in SSTRecord"
)
;
}
if
(
remaining
==
LittleEndianConsts
.
SHORT_SIZE
)
{
setContinuationCharsRead
(
0
)
;
unfinishedString
=
""
;
break
;
}
charCount
=
LittleEndian
.
getUShort
(
data
,
offset
)
;
int
charsRead
=
charCount
;
readStringHeader
(
data
,
offset
)
;
boolean
stringContinuesOverContinuation
=
remaining
<
totalStringSize
(
)
;
if
(
stringContinuesOverContinuation
)
{
int
remainingBytes
=
dataSize
-
offset
-
stringHeaderOverhead
(
)
;
charsRead
=
Math
.
min
(
charsRead
,
calculateCharCount
(
remainingBytes
)
)
;
setContinuationCharsRead
(
charsRead
)
;
if
(
charsRead
==
charCount
)
{
continueSkipBytes
=
offsetForContinuedRecord
(
0
)
-
(
remainingBytes
-
calculateByteCount
(
charsRead
)
)
;
}
}
processString
(
data
,
offset
,
charsRead
)
;
offset
+=
totalStringSize
(
)
;
if
(
stringContinuesOverContinuation
)
{
break
;
}
}
}
private
void
readStringHeader
(
final
byte
[
]
data
,
final
int
index
)
{
byte
optionFlag
=
data
[
index
+
LittleEndianConsts
.
SHORT_SIZE
]
;
wideChar
=
(
optionFlag
&
1
)
==
1
;
extendedText
=
(
optionFlag
&
4
)
==
4
;
richText
=
(
optionFlag
&
8
)
==
8
;
runCount
=
0
;
if
(
richText
)
{
runCount
=
LittleEndian
.
getShort
(
data
,
index
+
SSTRecord
.
STRING_MINIMAL_OVERHEAD
)
;
}
extensionLength
=
0
;
if
(
extendedText
)
{
extensionLength
=
LittleEndian
.
getInt
(
data
,
index
+
SSTRecord
.
STRING_MINIMAL_OVERHEAD
+
(
richText
?
LittleEndianConsts
.
SHORT_SIZE
:
0
)
)
;
}
}
private
int
processString
(
final
byte
[
]
data
,
final
int
dataIndex
,
final
int
characters
)
{
int
length
=
SSTRecord
.
STRING_MINIMAL_OVERHEAD
+
calculateByteCount
(
characters
)
;
byte
[
]
unicodeStringBuffer
=
new
byte
[
length
]
;
int
offset
=
0
;
LittleEndian
.
putUShort
(
unicodeStringBuffer
,
offset
,
characters
)
;
offset
+=
LittleEndianConsts
.
SHORT_SIZE
;
unicodeStringBuffer
[
offset
]
=
data
[
dataIndex
+
offset
]
;
int
bytesRead
=
unicodeStringBuffer
.
length
-
SSTRecord
.
STRING_MINIMAL_OVERHEAD
;
arraycopy
(
data
,
dataIndex
+
stringHeaderOverhead
(
)
,
unicodeStringBuffer
,
SSTRecord
.
STRING_MINIMAL_OVERHEAD
,
bytesRead
)
;
UnicodeString
string
=
new
UnicodeString
(
UnicodeString
.
sid
,
(
short
)
unicodeStringBuffer
.
length
,
unicodeStringBuffer
)
;
setContinuationCharsRead
(
calculateCharCount
(
bytesRead
)
)
;
if
(
isStringFinished
(
)
)
{
Integer
integer
=
new
Integer
(
strings
.
size
(
)
)
;
addToStringTable
(
strings
,
integer
,
string
)
;
}
else
{
unfinishedString
=
string
.
getString
(
)
;
}
return
bytesRead
;
}
private
boolean
isStringFinished
(
)
{
return
getContinuationCharsRead
(
)
==
charCount
;
}
static
public
void
addToStringTable
(
BinaryTree
strings
,
Integer
integer
,
UnicodeString
string
)
{
if
(
string
.
isRichText
(
)
)
string
.
setOptionFlags
(
(
byte
)
(
string
.
getOptionFlags
(
)
&
(
~
8
)
)
)
;
if
(
string
.
isExtendedText
(
)
)
string
.
setOptionFlags
(
(
byte
)
(
string
.
getOptionFlags
(
)
&
(
~
4
)
)
)
;
boolean
added
=
false
;
while
(
added
==
false
)
{
try
{
strings
.
put
(
integer
,
string
)
;
added
=
true
;
}
catch
(
Exception
ignore
)
{
string
.
setString
(
string
.
getString
(
)
+
" "
)
;
}
}
}
private
int
calculateCharCount
(
final
int
byte_count
)
{
return
byte_count
/
(
wideChar
?
LittleEndianConsts
.
SHORT_SIZE
:
LittleEndianConsts
.
BYTE_SIZE
)
;
}
public
void
processContinueRecord
(
final
byte
[
]
record
)
{
if
(
isStringFinished
(
)
)
{
final
int
offset
=
continueSkipBytes
;
initVars
(
)
;
manufactureStrings
(
record
,
offset
)
;
}
else
{
wideChar
=
(
record
[
0
]
&
1
)
==
1
;
if
(
stringSpansContinuation
(
record
.
length
-
LittleEndianConsts
.
BYTE_SIZE
)
)
{
processEntireContinuation
(
record
)
;
}
else
{
readStringRemainder
(
record
)
;
}
}
}
private
void
readStringRemainder
(
final
byte
[
]
record
)
{
int
stringRemainderSizeInBytes
=
calculateByteCount
(
charCount
-
getContinuationCharsRead
(
)
)
;
byte
[
]
unicodeStringData
=
new
byte
[
SSTRecord
.
STRING_MINIMAL_OVERHEAD
+
stringRemainderSizeInBytes
]
;
LittleEndian
.
putShort
(
unicodeStringData
,
0
,
(
short
)
(
charCount
-
getContinuationCharsRead
(
)
)
)
;
unicodeStringData
[
LittleEndianConsts
.
SHORT_SIZE
]
=
createOptionByte
(
wideChar
,
richText
,
extendedText
)
;
arraycopy
(
record
,
LittleEndianConsts
.
BYTE_SIZE
,
unicodeStringData
,
SSTRecord
.
STRING_MINIMAL_OVERHEAD
,
stringRemainderSizeInBytes
)
;
UnicodeString
string
=
new
UnicodeString
(
UnicodeString
.
sid
,
(
short
)
unicodeStringData
.
length
,
unicodeStringData
,
unfinishedString
)
;
Integer
integer
=
new
Integer
(
strings
.
size
(
)
)
;
addToStringTable
(
strings
,
integer
,
string
)
;
int
newOffset
=
offsetForContinuedRecord
(
stringRemainderSizeInBytes
)
;
manufactureStrings
(
record
,
newOffset
)
;
}
private
int
stringSizeInBytes
(
)
{
return
calculateByteCount
(
charCount
)
;
}
private
int
totalStringSize
(
)
{
return
stringSizeInBytes
(
)
+
stringHeaderOverhead
(
)
+
LittleEndianConsts
.
INT_SIZE
*
runCount
+
extensionLength
;
}
private
int
stringHeaderOverhead
(
)
{
return
SSTRecord
.
STRING_MINIMAL_OVERHEAD
+
(
richText
?
LittleEndianConsts
.
SHORT_SIZE
:
0
)
+
(
extendedText
?
LittleEndianConsts
.
INT_SIZE
:
0
)
;
}
private
int
offsetForContinuedRecord
(
int
stringRemainderSizeInBytes
)
{
int
offset
=
stringRemainderSizeInBytes
+
runCount
*
LittleEndianConsts
.
INT_SIZE
+
extensionLength
;
if
(
stringRemainderSizeInBytes
!=
0
)
offset
+=
+
LittleEndianConsts
.
BYTE_SIZE
;
return
offset
;
}
private
byte
createOptionByte
(
boolean
wideChar
,
boolean
richText
,
boolean
farEast
)
{
return
(
byte
)
(
(
wideChar
?
1
:
0
)
+
(
farEast
?
4
:
0
)
+
(
richText
?
8
:
0
)
)
;
}
private
void
processEntireContinuation
(
final
byte
[
]
record
)
{
int
dataLengthInBytes
=
record
.
length
-
LittleEndianConsts
.
BYTE_SIZE
;
byte
[
]
unicodeStringData
=
new
byte
[
record
.
length
+
LittleEndianConsts
.
SHORT_SIZE
]
;
int
charsRead
=
calculateCharCount
(
dataLengthInBytes
)
;
LittleEndian
.
putShort
(
unicodeStringData
,
(
byte
)
0
,
(
short
)
charsRead
)
;
arraycopy
(
record
,
0
,
unicodeStringData
,
LittleEndianConsts
.
SHORT_SIZE
,
record
.
length
)
;
UnicodeString
ucs
=
new
UnicodeString
(
UnicodeString
.
sid
,
(
short
)
unicodeStringData
.
length
,
unicodeStringData
,
unfinishedString
)
;
unfinishedString
=
ucs
.
getString
(
)
;
setContinuationCharsRead
(
getContinuationCharsRead
(
)
+
charsRead
)
;
if
(
getContinuationCharsRead
(
)
==
charCount
)
{
Integer
integer
=
new
Integer
(
strings
.
size
(
)
)
;
addToStringTable
(
strings
,
integer
,
ucs
)
;
}
}
private
boolean
stringSpansContinuation
(
int
continuationSizeInBytes
)
{
return
calculateByteCount
(
charCount
-
getContinuationCharsRead
(
)
)
>
continuationSizeInBytes
;
}
int
getContinuationCharsRead
(
)
{
return
continuationReadChars
;
}
private
void
setContinuationCharsRead
(
final
int
count
)
{
continuationReadChars
=
count
;
}
private
int
calculateByteCount
(
final
int
character_count
)
{
return
character_count
*
(
wideChar
?
LittleEndianConsts
.
SHORT_SIZE
:
LittleEndianConsts
.
BYTE_SIZE
)
;
}
private
void
arraycopy
(
byte
[
]
src
,
int
src_position
,
byte
[
]
dst
,
int
dst_position
,
int
length
)
{
System
.
arraycopy
(
src
,
src_position
,
dst
,
dst_position
,
length
)
;
}
String
getUnfinishedString
(
)
{
return
unfinishedString
;
}
boolean
isWideChar
(
)
{
return
wideChar
;
}
}
