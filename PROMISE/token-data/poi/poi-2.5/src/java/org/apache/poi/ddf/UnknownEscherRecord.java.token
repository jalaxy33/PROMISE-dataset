package
org
.
apache
.
poi
.
ddf
;
import
org
.
apache
.
poi
.
util
.
HexDump
;
import
org
.
apache
.
poi
.
util
.
LittleEndian
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
ArrayList
;
public
class
UnknownEscherRecord
extends
EscherRecord
{
private
static
final
byte
[
]
NO_BYTES
=
new
byte
[
0
]
;
private
byte
[
]
thedata
=
NO_BYTES
;
private
List
childRecords
=
new
ArrayList
(
)
;
public
UnknownEscherRecord
(
)
{
}
public
int
fillFields
(
byte
[
]
data
,
int
offset
,
EscherRecordFactory
recordFactory
)
{
int
bytesRemaining
=
readHeader
(
data
,
offset
)
;
if
(
isContainerRecord
(
)
)
{
int
bytesWritten
=
0
;
thedata
=
new
byte
[
0
]
;
offset
+=
8
;
bytesWritten
+=
8
;
while
(
bytesRemaining
>
0
)
{
EscherRecord
child
=
recordFactory
.
createRecord
(
data
,
offset
)
;
int
childBytesWritten
=
child
.
fillFields
(
data
,
offset
,
recordFactory
)
;
bytesWritten
+=
childBytesWritten
;
offset
+=
childBytesWritten
;
bytesRemaining
-=
childBytesWritten
;
getChildRecords
(
)
.
add
(
child
)
;
}
return
bytesWritten
;
}
else
{
thedata
=
new
byte
[
bytesRemaining
]
;
System
.
arraycopy
(
data
,
offset
+
8
,
thedata
,
0
,
bytesRemaining
)
;
return
bytesRemaining
+
8
;
}
}
public
int
serialize
(
int
offset
,
byte
[
]
data
,
EscherSerializationListener
listener
)
{
listener
.
beforeRecordSerialize
(
offset
,
getRecordId
(
)
,
this
)
;
LittleEndian
.
putShort
(
data
,
offset
,
getOptions
(
)
)
;
LittleEndian
.
putShort
(
data
,
offset
+
2
,
getRecordId
(
)
)
;
int
remainingBytes
=
thedata
.
length
;
for
(
Iterator
iterator
=
getChildRecords
(
)
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
EscherRecord
r
=
(
EscherRecord
)
iterator
.
next
(
)
;
remainingBytes
+=
r
.
getRecordSize
(
)
;
}
LittleEndian
.
putInt
(
data
,
offset
+
4
,
remainingBytes
)
;
System
.
arraycopy
(
thedata
,
0
,
data
,
offset
+
8
,
thedata
.
length
)
;
int
pos
=
offset
+
8
+
thedata
.
length
;
for
(
Iterator
iterator
=
getChildRecords
(
)
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
EscherRecord
r
=
(
EscherRecord
)
iterator
.
next
(
)
;
pos
+=
r
.
serialize
(
pos
,
data
,
listener
)
;
}
listener
.
afterRecordSerialize
(
pos
,
getRecordId
(
)
,
pos
-
offset
,
this
)
;
return
pos
-
offset
;
}
public
byte
[
]
getData
(
)
{
return
thedata
;
}
public
int
getRecordSize
(
)
{
return
8
+
thedata
.
length
;
}
public
List
getChildRecords
(
)
{
return
childRecords
;
}
public
void
setChildRecords
(
List
childRecords
)
{
this
.
childRecords
=
childRecords
;
}
public
Object
clone
(
)
{
return
super
.
clone
(
)
;
}
public
String
getRecordName
(
)
{
return
"Unknown 0x"
+
HexDump
.
toHex
(
getRecordId
(
)
)
;
}
public
String
toString
(
)
{
String
nl
=
System
.
getProperty
(
"line.separator"
)
;
StringBuffer
children
=
new
StringBuffer
(
)
;
if
(
getChildRecords
(
)
.
size
(
)
>
0
)
{
children
.
append
(
"  children: "
+
nl
)
;
for
(
Iterator
iterator
=
getChildRecords
(
)
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
EscherRecord
record
=
(
EscherRecord
)
iterator
.
next
(
)
;
children
.
append
(
record
.
toString
(
)
)
;
children
.
append
(
nl
)
;
}
}
String
theDumpHex
=
""
;
try
{
if
(
thedata
.
length
!=
0
)
{
theDumpHex
=
"  Extra Data:"
+
nl
;
theDumpHex
+=
HexDump
.
dump
(
thedata
,
0
,
0
)
;
}
}
catch
(
Exception
e
)
{
theDumpHex
=
"Error!!"
;
}
return
getClass
(
)
.
getName
(
)
+
":"
+
nl
+
"  isContainer: "
+
isContainerRecord
(
)
+
nl
+
"  options: 0x"
+
HexDump
.
toHex
(
getOptions
(
)
)
+
nl
+
"  recordId: 0x"
+
HexDump
.
toHex
(
getRecordId
(
)
)
+
nl
+
"  numchildren: "
+
getChildRecords
(
)
.
size
(
)
+
nl
+
theDumpHex
+
children
.
toString
(
)
;
}
public
void
addChildRecord
(
EscherRecord
childRecord
)
{
getChildRecords
(
)
.
add
(
childRecord
)
;
}
}
