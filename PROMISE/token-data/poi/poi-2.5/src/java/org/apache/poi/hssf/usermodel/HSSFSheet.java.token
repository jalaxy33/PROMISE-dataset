package
org
.
apache
.
poi
.
hssf
.
usermodel
;
import
org
.
apache
.
poi
.
ddf
.
EscherRecord
;
import
org
.
apache
.
poi
.
hssf
.
model
.
Sheet
;
import
org
.
apache
.
poi
.
hssf
.
model
.
Workbook
;
import
org
.
apache
.
poi
.
hssf
.
record
.
*
;
import
org
.
apache
.
poi
.
hssf
.
util
.
Region
;
import
org
.
apache
.
poi
.
util
.
POILogFactory
;
import
org
.
apache
.
poi
.
util
.
POILogger
;
import
java
.
io
.
PrintWriter
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
TreeMap
;
public
class
HSSFSheet
{
private
static
final
int
DEBUG
=
POILogger
.
DEBUG
;
public
static
final
short
LeftMargin
=
Sheet
.
LeftMargin
;
public
static
final
short
RightMargin
=
Sheet
.
RightMargin
;
public
static
final
short
TopMargin
=
Sheet
.
TopMargin
;
public
static
final
short
BottomMargin
=
Sheet
.
BottomMargin
;
public
static
final
byte
PANE_LOWER_RIGHT
=
(
byte
)
0
;
public
static
final
byte
PANE_UPPER_RIGHT
=
(
byte
)
1
;
public
static
final
byte
PANE_LOWER_LEFT
=
(
byte
)
2
;
public
static
final
byte
PANE_UPPER_LEFT
=
(
byte
)
3
;
public
final
static
int
INITIAL_CAPACITY
=
20
;
private
Sheet
sheet
;
private
TreeMap
rows
;
private
Workbook
book
;
private
int
firstrow
;
private
int
lastrow
;
private
static
POILogger
log
=
POILogFactory
.
getLogger
(
HSSFSheet
.
class
)
;
protected
HSSFSheet
(
Workbook
book
)
{
sheet
=
Sheet
.
createSheet
(
)
;
rows
=
new
TreeMap
(
)
;
this
.
book
=
book
;
}
protected
HSSFSheet
(
Workbook
book
,
Sheet
sheet
)
{
this
.
sheet
=
sheet
;
rows
=
new
TreeMap
(
)
;
this
.
book
=
book
;
setPropertiesFromSheet
(
sheet
)
;
}
HSSFSheet
cloneSheet
(
Workbook
book
)
{
return
new
HSSFSheet
(
book
,
sheet
.
cloneSheet
(
)
)
;
}
private
void
setPropertiesFromSheet
(
Sheet
sheet
)
{
int
sloc
=
sheet
.
getLoc
(
)
;
RowRecord
row
=
sheet
.
getNextRow
(
)
;
while
(
row
!=
null
)
{
createRowFromRecord
(
row
)
;
row
=
sheet
.
getNextRow
(
)
;
}
sheet
.
setLoc
(
sloc
)
;
CellValueRecordInterface
cval
=
sheet
.
getNextValueRecord
(
)
;
long
timestart
=
System
.
currentTimeMillis
(
)
;
if
(
log
.
check
(
POILogger
.
DEBUG
)
)
log
.
log
(
DEBUG
,
"Time at start of cell creating in HSSF sheet = "
,
new
Long
(
timestart
)
)
;
HSSFRow
lastrow
=
null
;
while
(
cval
!=
null
)
{
long
cellstart
=
System
.
currentTimeMillis
(
)
;
HSSFRow
hrow
=
lastrow
;
if
(
(
lastrow
==
null
)
||
(
lastrow
.
getRowNum
(
)
!=
cval
.
getRow
(
)
)
)
{
hrow
=
getRow
(
cval
.
getRow
(
)
)
;
}
if
(
hrow
!=
null
)
{
lastrow
=
hrow
;
if
(
log
.
check
(
POILogger
.
DEBUG
)
)
log
.
log
(
DEBUG
,
"record id = "
+
Integer
.
toHexString
(
(
(
Record
)
cval
)
.
getSid
(
)
)
)
;
hrow
.
createCellFromRecord
(
cval
)
;
cval
=
sheet
.
getNextValueRecord
(
)
;
if
(
log
.
check
(
POILogger
.
DEBUG
)
)
log
.
log
(
DEBUG
,
"record took "
,
new
Long
(
System
.
currentTimeMillis
(
)
-
cellstart
)
)
;
}
else
{
cval
=
null
;
}
}
if
(
log
.
check
(
POILogger
.
DEBUG
)
)
log
.
log
(
DEBUG
,
"total sheet cell creation took "
,
new
Long
(
System
.
currentTimeMillis
(
)
-
timestart
)
)
;
}
public
HSSFRow
createRow
(
int
rownum
)
{
HSSFRow
row
=
new
HSSFRow
(
book
,
sheet
,
rownum
)
;
addRow
(
row
,
true
)
;
return
row
;
}
private
HSSFRow
createRowFromRecord
(
RowRecord
row
)
{
HSSFRow
hrow
=
new
HSSFRow
(
book
,
sheet
,
row
)
;
addRow
(
hrow
,
false
)
;
return
hrow
;
}
public
void
removeRow
(
HSSFRow
row
)
{
sheet
.
setLoc
(
sheet
.
getDimsLoc
(
)
)
;
if
(
rows
.
size
(
)
>
0
)
{
rows
.
remove
(
row
)
;
if
(
row
.
getRowNum
(
)
==
getLastRowNum
(
)
)
{
lastrow
=
findLastRow
(
lastrow
)
;
}
if
(
row
.
getRowNum
(
)
==
getFirstRowNum
(
)
)
{
firstrow
=
findFirstRow
(
firstrow
)
;
}
Iterator
iter
=
row
.
cellIterator
(
)
;
while
(
iter
.
hasNext
(
)
)
{
HSSFCell
cell
=
(
HSSFCell
)
iter
.
next
(
)
;
sheet
.
removeValueRecord
(
row
.
getRowNum
(
)
,
cell
.
getCellValueRecord
(
)
)
;
}
sheet
.
removeRow
(
row
.
getRowRecord
(
)
)
;
}
}
private
int
findLastRow
(
int
lastrow
)
{
int
rownum
=
lastrow
-
1
;
HSSFRow
r
=
getRow
(
rownum
)
;
while
(
r
==
null
&&
rownum
>=
0
)
{
r
=
getRow
(
--
rownum
)
;
}
return
rownum
;
}
private
int
findFirstRow
(
int
firstrow
)
{
int
rownum
=
firstrow
+
1
;
HSSFRow
r
=
getRow
(
rownum
)
;
while
(
r
==
null
&&
rownum
<=
getLastRowNum
(
)
)
{
r
=
getRow
(
++
rownum
)
;
}
if
(
rownum
>
getLastRowNum
(
)
)
return
-
1
;
return
rownum
;
}
private
void
addRow
(
HSSFRow
row
,
boolean
addLow
)
{
rows
.
put
(
row
,
row
)
;
if
(
addLow
)
{
sheet
.
addRow
(
row
.
getRowRecord
(
)
)
;
}
if
(
row
.
getRowNum
(
)
>
getLastRowNum
(
)
)
{
lastrow
=
row
.
getRowNum
(
)
;
}
if
(
row
.
getRowNum
(
)
<
getFirstRowNum
(
)
)
{
firstrow
=
row
.
getRowNum
(
)
;
}
}
public
HSSFRow
getRow
(
int
rownum
)
{
HSSFRow
row
=
new
HSSFRow
(
)
;
row
.
setRowNum
(
rownum
)
;
return
(
HSSFRow
)
rows
.
get
(
row
)
;
}
public
int
getPhysicalNumberOfRows
(
)
{
return
rows
.
size
(
)
;
}
public
int
getFirstRowNum
(
)
{
return
firstrow
;
}
public
int
getLastRowNum
(
)
{
return
lastrow
;
}
public
void
setColumnWidth
(
short
column
,
short
width
)
{
sheet
.
setColumnWidth
(
column
,
width
)
;
}
public
short
getColumnWidth
(
short
column
)
{
return
sheet
.
getColumnWidth
(
column
)
;
}
public
short
getDefaultColumnWidth
(
)
{
return
sheet
.
getDefaultColumnWidth
(
)
;
}
public
short
getDefaultRowHeight
(
)
{
return
sheet
.
getDefaultRowHeight
(
)
;
}
public
float
getDefaultRowHeightInPoints
(
)
{
return
(
sheet
.
getDefaultRowHeight
(
)
/
20
)
;
}
public
void
setDefaultColumnWidth
(
short
width
)
{
sheet
.
setDefaultColumnWidth
(
width
)
;
}
public
void
setDefaultRowHeight
(
short
height
)
{
sheet
.
setDefaultRowHeight
(
height
)
;
}
public
void
setDefaultRowHeightInPoints
(
float
height
)
{
sheet
.
setDefaultRowHeight
(
(
short
)
(
height
*
20
)
)
;
}
public
boolean
isGridsPrinted
(
)
{
return
sheet
.
isGridsPrinted
(
)
;
}
public
void
setGridsPrinted
(
boolean
value
)
{
sheet
.
setGridsPrinted
(
value
)
;
}
public
int
addMergedRegion
(
Region
region
)
{
return
sheet
.
addMergedRegion
(
region
.
getRowFrom
(
)
,
region
.
getColumnFrom
(
)
,
region
.
getRowTo
(
)
,
region
.
getColumnTo
(
)
)
;
}
public
void
setVerticallyCenter
(
boolean
value
)
{
VCenterRecord
record
=
(
VCenterRecord
)
sheet
.
findFirstRecordBySid
(
VCenterRecord
.
sid
)
;
record
.
setVCenter
(
value
)
;
}
public
boolean
getVerticallyCenter
(
boolean
value
)
{
VCenterRecord
record
=
(
VCenterRecord
)
sheet
.
findFirstRecordBySid
(
VCenterRecord
.
sid
)
;
return
record
.
getVCenter
(
)
;
}
public
void
setHorizontallyCenter
(
boolean
value
)
{
HCenterRecord
record
=
(
HCenterRecord
)
sheet
.
findFirstRecordBySid
(
HCenterRecord
.
sid
)
;
record
.
setHCenter
(
value
)
;
}
public
boolean
getHorizontallyCenter
(
)
{
HCenterRecord
record
=
(
HCenterRecord
)
sheet
.
findFirstRecordBySid
(
HCenterRecord
.
sid
)
;
return
record
.
getHCenter
(
)
;
}
public
void
removeMergedRegion
(
int
index
)
{
sheet
.
removeMergedRegion
(
index
)
;
}
public
int
getNumMergedRegions
(
)
{
return
sheet
.
getNumMergedRegions
(
)
;
}
public
Region
getMergedRegionAt
(
int
index
)
{
return
new
Region
(
sheet
.
getMergedRegionAt
(
index
)
)
;
}
public
Iterator
rowIterator
(
)
{
return
rows
.
values
(
)
.
iterator
(
)
;
}
protected
Sheet
getSheet
(
)
{
return
sheet
;
}
public
void
setAlternativeExpression
(
boolean
b
)
{
WSBoolRecord
record
=
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
;
record
.
setAlternateExpression
(
b
)
;
}
public
void
setAlternativeFormula
(
boolean
b
)
{
WSBoolRecord
record
=
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
;
record
.
setAlternateFormula
(
b
)
;
}
public
void
setAutobreaks
(
boolean
b
)
{
WSBoolRecord
record
=
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
;
record
.
setAutobreaks
(
b
)
;
}
public
void
setDialog
(
boolean
b
)
{
WSBoolRecord
record
=
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
;
record
.
setDialog
(
b
)
;
}
public
void
setDisplayGuts
(
boolean
b
)
{
WSBoolRecord
record
=
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
;
record
.
setDisplayGuts
(
b
)
;
}
public
void
setFitToPage
(
boolean
b
)
{
WSBoolRecord
record
=
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
;
record
.
setFitToPage
(
b
)
;
}
public
void
setRowSumsBelow
(
boolean
b
)
{
WSBoolRecord
record
=
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
;
record
.
setRowSumsBelow
(
b
)
;
}
public
void
setRowSumsRight
(
boolean
b
)
{
WSBoolRecord
record
=
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
;
record
.
setRowSumsRight
(
b
)
;
}
public
boolean
getAlternateExpression
(
)
{
return
(
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
)
.
getAlternateExpression
(
)
;
}
public
boolean
getAlternateFormula
(
)
{
return
(
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
)
.
getAlternateFormula
(
)
;
}
public
boolean
getAutobreaks
(
)
{
return
(
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
)
.
getAutobreaks
(
)
;
}
public
boolean
getDialog
(
)
{
return
(
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
)
.
getDialog
(
)
;
}
public
boolean
getDisplayGuts
(
)
{
return
(
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
)
.
getDisplayGuts
(
)
;
}
public
boolean
getFitToPage
(
)
{
return
(
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
)
.
getFitToPage
(
)
;
}
public
boolean
getRowSumsBelow
(
)
{
return
(
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
)
.
getRowSumsBelow
(
)
;
}
public
boolean
getRowSumsRight
(
)
{
return
(
(
WSBoolRecord
)
sheet
.
findFirstRecordBySid
(
WSBoolRecord
.
sid
)
)
.
getRowSumsRight
(
)
;
}
public
boolean
isPrintGridlines
(
)
{
return
getSheet
(
)
.
getPrintGridlines
(
)
.
getPrintGridlines
(
)
;
}
public
void
setPrintGridlines
(
boolean
newPrintGridlines
)
{
getSheet
(
)
.
getPrintGridlines
(
)
.
setPrintGridlines
(
newPrintGridlines
)
;
}
public
HSSFPrintSetup
getPrintSetup
(
)
{
return
new
HSSFPrintSetup
(
getSheet
(
)
.
getPrintSetup
(
)
)
;
}
public
HSSFHeader
getHeader
(
)
{
return
new
HSSFHeader
(
getSheet
(
)
.
getHeader
(
)
)
;
}
public
HSSFFooter
getFooter
(
)
{
return
new
HSSFFooter
(
getSheet
(
)
.
getFooter
(
)
)
;
}
public
void
setSelected
(
boolean
sel
)
{
getSheet
(
)
.
setSelected
(
sel
)
;
}
public
double
getMargin
(
short
margin
)
{
return
getSheet
(
)
.
getMargin
(
margin
)
;
}
public
void
setMargin
(
short
margin
,
double
size
)
{
getSheet
(
)
.
setMargin
(
margin
,
size
)
;
}
public
boolean
getProtect
(
)
{
return
getSheet
(
)
.
getProtect
(
)
.
getProtect
(
)
;
}
public
void
setProtect
(
boolean
protect
)
{
getSheet
(
)
.
getProtect
(
)
.
setProtect
(
protect
)
;
}
public
void
setZoom
(
int
numerator
,
int
denominator
)
{
if
(
numerator
<
1
||
numerator
>
65535
)
throw
new
IllegalArgumentException
(
"Numerator must be greater than 1 and less than 65536"
)
;
if
(
denominator
<
1
||
denominator
>
65535
)
throw
new
IllegalArgumentException
(
"Denominator must be greater than 1 and less than 65536"
)
;
SCLRecord
sclRecord
=
new
SCLRecord
(
)
;
sclRecord
.
setNumerator
(
(
short
)
numerator
)
;
sclRecord
.
setDenominator
(
(
short
)
denominator
)
;
getSheet
(
)
.
setSCLRecord
(
sclRecord
)
;
}
protected
void
shiftMerged
(
int
startRow
,
int
endRow
,
int
n
,
boolean
isRow
)
{
List
shiftedRegions
=
new
ArrayList
(
)
;
for
(
int
i
=
0
;
i
<
this
.
getNumMergedRegions
(
)
;
i
++
)
{
Region
merged
=
this
.
getMergedRegionAt
(
i
)
;
boolean
inStart
=
(
merged
.
getRowFrom
(
)
>=
startRow
||
merged
.
getRowTo
(
)
>=
startRow
)
;
boolean
inEnd
=
(
merged
.
getRowTo
(
)
<=
endRow
||
merged
.
getRowFrom
(
)
<=
endRow
)
;
if
(
!
(
inStart
&&
inEnd
)
)
continue
;
if
(
!
merged
.
contains
(
startRow
-
1
,
(
short
)
0
)
&&
!
merged
.
contains
(
endRow
+
1
,
(
short
)
0
)
)
{
merged
.
setRowFrom
(
merged
.
getRowFrom
(
)
+
n
)
;
merged
.
setRowTo
(
merged
.
getRowTo
(
)
+
n
)
;
shiftedRegions
.
add
(
merged
)
;
this
.
removeMergedRegion
(
i
)
;
i
=
i
-
1
;
}
}
Iterator
iterator
=
shiftedRegions
.
iterator
(
)
;
while
(
iterator
.
hasNext
(
)
)
{
Region
region
=
(
Region
)
iterator
.
next
(
)
;
this
.
addMergedRegion
(
region
)
;
}
}
public
void
shiftRows
(
int
startRow
,
int
endRow
,
int
n
)
{
shiftRows
(
startRow
,
endRow
,
n
,
false
,
false
)
;
}
public
void
shiftRows
(
int
startRow
,
int
endRow
,
int
n
,
boolean
copyRowHeight
,
boolean
resetOriginalRowHeight
)
{
int
s
,
e
,
inc
;
if
(
n
<
0
)
{
s
=
startRow
;
e
=
endRow
;
inc
=
1
;
}
else
{
s
=
endRow
;
e
=
startRow
;
inc
=
-
1
;
}
shiftMerged
(
startRow
,
endRow
,
n
,
true
)
;
sheet
.
shiftRowBreaks
(
startRow
,
endRow
,
n
)
;
for
(
int
rowNum
=
s
;
rowNum
>=
startRow
&&
rowNum
<=
endRow
&&
rowNum
>=
0
&&
rowNum
<
65536
;
rowNum
+=
inc
)
{
HSSFRow
row
=
getRow
(
rowNum
)
;
HSSFRow
row2Replace
=
getRow
(
rowNum
+
n
)
;
if
(
row2Replace
==
null
)
row2Replace
=
createRow
(
rowNum
+
n
)
;
HSSFCell
cell
;
for
(
short
col
=
row2Replace
.
getFirstCellNum
(
)
;
col
<=
row2Replace
.
getLastCellNum
(
)
;
col
++
)
{
cell
=
row2Replace
.
getCell
(
col
)
;
if
(
cell
!=
null
)
row2Replace
.
removeCell
(
cell
)
;
}
if
(
row
==
null
)
continue
;
else
{
if
(
copyRowHeight
)
{
row2Replace
.
setHeight
(
row
.
getHeight
(
)
)
;
}
if
(
resetOriginalRowHeight
)
{
row
.
setHeight
(
(
short
)
0xff
)
;
}
}
for
(
short
col
=
row
.
getFirstCellNum
(
)
;
col
<=
row
.
getLastCellNum
(
)
;
col
++
)
{
cell
=
row
.
getCell
(
col
)
;
if
(
cell
!=
null
)
{
row
.
removeCell
(
cell
)
;
CellValueRecordInterface
cellRecord
=
cell
.
getCellValueRecord
(
)
;
cellRecord
.
setRow
(
rowNum
+
n
)
;
row2Replace
.
createCellFromRecord
(
cellRecord
)
;
sheet
.
addValueRecord
(
rowNum
+
n
,
cellRecord
)
;
}
}
}
if
(
endRow
==
lastrow
||
endRow
+
n
>
lastrow
)
lastrow
=
Math
.
min
(
endRow
+
n
,
65535
)
;
if
(
startRow
==
firstrow
||
startRow
+
n
<
firstrow
)
firstrow
=
Math
.
max
(
startRow
+
n
,
0
)
;
}
protected
void
insertChartRecords
(
List
records
)
{
int
window2Loc
=
sheet
.
findFirstRecordLocBySid
(
WindowTwoRecord
.
sid
)
;
sheet
.
getRecords
(
)
.
addAll
(
window2Loc
,
records
)
;
}
public
void
createFreezePane
(
int
colSplit
,
int
rowSplit
,
int
leftmostColumn
,
int
topRow
)
{
if
(
colSplit
<
0
||
colSplit
>
255
)
throw
new
IllegalArgumentException
(
"Column must be between 0 and 255"
)
;
if
(
rowSplit
<
0
||
rowSplit
>
65535
)
throw
new
IllegalArgumentException
(
"Row must be between 0 and 65535"
)
;
if
(
leftmostColumn
<
colSplit
)
throw
new
IllegalArgumentException
(
"leftmostColumn parameter must not be less than colSplit parameter"
)
;
if
(
topRow
<
rowSplit
)
throw
new
IllegalArgumentException
(
"topRow parameter must not be less than leftmostColumn parameter"
)
;
getSheet
(
)
.
createFreezePane
(
colSplit
,
rowSplit
,
topRow
,
leftmostColumn
)
;
}
public
void
createFreezePane
(
int
colSplit
,
int
rowSplit
)
{
createFreezePane
(
colSplit
,
rowSplit
,
colSplit
,
rowSplit
)
;
}
public
void
createSplitPane
(
int
xSplitPos
,
int
ySplitPos
,
int
leftmostColumn
,
int
topRow
,
int
activePane
)
{
getSheet
(
)
.
createSplitPane
(
xSplitPos
,
ySplitPos
,
topRow
,
leftmostColumn
,
activePane
)
;
}
public
void
setDisplayGridlines
(
boolean
show
)
{
sheet
.
setDisplayGridlines
(
show
)
;
}
public
boolean
isDisplayGridlines
(
)
{
return
sheet
.
isDisplayGridlines
(
)
;
}
public
void
setDisplayFormulas
(
boolean
show
)
{
sheet
.
setDisplayFormulas
(
show
)
;
}
public
boolean
isDisplayFormulas
(
)
{
return
sheet
.
isDisplayFormulas
(
)
;
}
public
void
setDisplayRowColHeadings
(
boolean
show
)
{
sheet
.
setDisplayRowColHeadings
(
show
)
;
}
public
boolean
isDisplayRowColHeadings
(
)
{
return
sheet
.
isDisplayRowColHeadings
(
)
;
}
public
void
setRowBreak
(
int
row
)
{
validateRow
(
row
)
;
sheet
.
setRowBreak
(
row
,
(
short
)
0
,
(
short
)
255
)
;
}
public
boolean
isRowBroken
(
int
row
)
{
return
sheet
.
isRowBroken
(
row
)
;
}
public
void
removeRowBreak
(
int
row
)
{
sheet
.
removeRowBreak
(
row
)
;
}
public
int
[
]
getRowBreaks
(
)
{
int
[
]
returnValue
=
new
int
[
sheet
.
getNumRowBreaks
(
)
]
;
Iterator
iterator
=
sheet
.
getRowBreaks
(
)
;
int
i
=
0
;
while
(
iterator
.
hasNext
(
)
)
{
PageBreakRecord
.
Break
breakItem
=
(
PageBreakRecord
.
Break
)
iterator
.
next
(
)
;
returnValue
[
i
++
]
=
(
int
)
breakItem
.
main
;
}
return
returnValue
;
}
public
short
[
]
getColumnBreaks
(
)
{
short
[
]
returnValue
=
new
short
[
sheet
.
getNumColumnBreaks
(
)
]
;
Iterator
iterator
=
sheet
.
getColumnBreaks
(
)
;
int
i
=
0
;
while
(
iterator
.
hasNext
(
)
)
{
PageBreakRecord
.
Break
breakItem
=
(
PageBreakRecord
.
Break
)
iterator
.
next
(
)
;
returnValue
[
i
++
]
=
breakItem
.
main
;
}
return
returnValue
;
}
public
void
setColumnBreak
(
short
column
)
{
validateColumn
(
column
)
;
sheet
.
setColumnBreak
(
column
,
(
short
)
0
,
(
short
)
65535
)
;
}
public
boolean
isColumnBroken
(
short
column
)
{
return
sheet
.
isColumnBroken
(
column
)
;
}
public
void
removeColumnBreak
(
short
column
)
{
sheet
.
removeColumnBreak
(
column
)
;
}
protected
void
validateRow
(
int
row
)
{
if
(
row
>
65535
)
throw
new
IllegalArgumentException
(
"Maximum row number is 65535"
)
;
if
(
row
<
0
)
throw
new
IllegalArgumentException
(
"Minumum row number is 0"
)
;
}
protected
void
validateColumn
(
short
column
)
{
if
(
column
>
255
)
throw
new
IllegalArgumentException
(
"Maximum column number is 255"
)
;
if
(
column
<
0
)
throw
new
IllegalArgumentException
(
"Minimum column number is 0"
)
;
}
public
void
dumpDrawingRecords
(
)
{
sheet
.
aggregateDrawingRecords
(
book
.
getDrawingManager
(
)
)
;
EscherAggregate
r
=
(
EscherAggregate
)
getSheet
(
)
.
findFirstRecordBySid
(
EscherAggregate
.
sid
)
;
List
escherRecords
=
r
.
getEscherRecords
(
)
;
for
(
Iterator
iterator
=
escherRecords
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
EscherRecord
escherRecord
=
(
EscherRecord
)
iterator
.
next
(
)
;
PrintWriter
w
=
new
PrintWriter
(
System
.
out
)
;
escherRecord
.
display
(
w
,
0
)
;
w
.
close
(
)
;
}
}
public
HSSFPatriarch
createDrawingPatriarch
(
)
{
book
.
createDrawingGroup
(
)
;
sheet
.
aggregateDrawingRecords
(
book
.
getDrawingManager
(
)
)
;
EscherAggregate
agg
=
(
EscherAggregate
)
sheet
.
findFirstRecordBySid
(
EscherAggregate
.
sid
)
;
HSSFPatriarch
patriarch
=
new
HSSFPatriarch
(
this
)
;
agg
.
clear
(
)
;
agg
.
setPatriarch
(
patriarch
)
;
return
patriarch
;
}
public
void
setColumnGroupCollapsed
(
short
columnNumber
,
boolean
collapsed
)
{
sheet
.
setColumnGroupCollapsed
(
columnNumber
,
collapsed
)
;
}
public
void
groupColumn
(
short
fromColumn
,
short
toColumn
)
{
sheet
.
groupColumnRange
(
fromColumn
,
toColumn
,
true
)
;
}
public
void
ungroupColumn
(
short
fromColumn
,
short
toColumn
)
{
sheet
.
groupColumnRange
(
fromColumn
,
toColumn
,
false
)
;
}
public
void
groupRow
(
int
fromRow
,
int
toRow
)
{
sheet
.
groupRowRange
(
fromRow
,
toRow
,
true
)
;
}
public
void
ungroupRow
(
int
fromRow
,
int
toRow
)
{
sheet
.
groupRowRange
(
fromRow
,
toRow
,
false
)
;
}
public
void
setRowGroupCollapsed
(
int
row
,
boolean
collapse
)
{
sheet
.
setRowGroupCollapsed
(
row
,
collapse
)
;
}
}
