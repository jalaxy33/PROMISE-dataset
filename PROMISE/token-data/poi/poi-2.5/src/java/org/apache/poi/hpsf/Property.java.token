package
org
.
apache
.
poi
.
hpsf
;
import
java
.
util
.
*
;
import
org
.
apache
.
poi
.
util
.
LittleEndian
;
public
class
Property
{
private
static
int
CP_UNICODE
=
1200
;
private
int
id
;
public
int
getID
(
)
{
return
id
;
}
private
long
type
;
public
long
getType
(
)
{
return
type
;
}
private
Object
value
;
public
Object
getValue
(
)
{
return
value
;
}
public
Property
(
final
int
id
,
final
byte
[
]
src
,
final
long
offset
,
int
length
,
int
codepage
)
{
this
.
id
=
id
;
if
(
id
==
0
)
{
value
=
readDictionary
(
src
,
offset
,
length
,
codepage
)
;
return
;
}
int
o
=
(
int
)
offset
;
type
=
LittleEndian
.
getUInt
(
src
,
o
)
;
o
+=
LittleEndian
.
INT_SIZE
;
try
{
value
=
TypeReader
.
read
(
src
,
o
,
length
,
(
int
)
type
)
;
}
catch
(
Throwable
t
)
{
t
.
printStackTrace
(
)
;
value
=
"*** null ***"
;
}
}
protected
Map
readDictionary
(
final
byte
[
]
src
,
final
long
offset
,
final
int
length
,
final
int
codepage
)
{
if
(
offset
<
0
||
offset
>
src
.
length
)
throw
new
HPSFRuntimeException
(
"Illegal offset "
+
offset
+
" while HPSF stream contains "
+
length
+
" bytes."
)
;
int
o
=
(
int
)
offset
;
final
long
nrEntries
=
LittleEndian
.
getUInt
(
src
,
o
)
;
o
+=
LittleEndian
.
INT_SIZE
;
final
Map
m
=
new
HashMap
(
(
int
)
nrEntries
,
(
float
)
1.0
)
;
for
(
int
i
=
0
;
i
<
nrEntries
;
i
++
)
{
final
Long
id
=
new
Long
(
LittleEndian
.
getUInt
(
src
,
o
)
)
;
o
+=
LittleEndian
.
INT_SIZE
;
long
sLength
=
LittleEndian
.
getUInt
(
src
,
o
)
;
o
+=
LittleEndian
.
INT_SIZE
;
StringBuffer
b
=
new
StringBuffer
(
(
int
)
sLength
)
;
for
(
int
j
=
0
;
j
<
sLength
;
j
++
)
if
(
codepage
==
CP_UNICODE
)
{
final
int
i1
=
o
+
(
j
*
2
)
;
final
int
i2
=
i1
+
1
;
b
.
append
(
(
char
)
(
(
src
[
i2
]
<<
8
)
+
src
[
i1
]
)
)
;
}
else
b
.
append
(
(
char
)
src
[
o
+
j
]
)
;
while
(
b
.
charAt
(
b
.
length
(
)
-
1
)
==
0x00
)
b
.
setLength
(
b
.
length
(
)
-
1
)
;
if
(
codepage
==
CP_UNICODE
)
{
if
(
sLength
%
2
==
1
)
sLength
++
;
o
+=
(
sLength
+
sLength
)
;
}
else
o
+=
sLength
;
m
.
put
(
id
,
b
.
toString
(
)
)
;
}
return
m
;
}
}
