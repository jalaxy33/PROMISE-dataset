package
org
.
apache
.
poi
.
hssf
.
usermodel
;
import
org
.
apache
.
poi
.
hssf
.
record
.
PaletteRecord
;
import
org
.
apache
.
poi
.
hssf
.
util
.
HSSFColor
;
public
class
HSSFPalette
{
private
PaletteRecord
palette
;
protected
HSSFPalette
(
PaletteRecord
palette
)
{
this
.
palette
=
palette
;
}
public
HSSFColor
getColor
(
short
index
)
{
byte
[
]
b
=
palette
.
getColor
(
index
)
;
if
(
b
!=
null
)
{
return
new
CustomColor
(
index
,
b
)
;
}
return
null
;
}
public
HSSFColor
findColor
(
byte
red
,
byte
green
,
byte
blue
)
{
byte
[
]
b
=
palette
.
getColor
(
PaletteRecord
.
FIRST_COLOR_INDEX
)
;
for
(
short
i
=
(
short
)
PaletteRecord
.
FIRST_COLOR_INDEX
;
b
!=
null
;
b
=
palette
.
getColor
(
++
i
)
)
{
if
(
b
[
0
]
==
red
&&
b
[
1
]
==
green
&&
b
[
2
]
==
blue
)
{
return
new
CustomColor
(
i
,
b
)
;
}
}
return
null
;
}
public
HSSFColor
findSimilarColor
(
byte
red
,
byte
green
,
byte
blue
)
{
HSSFColor
result
=
null
;
int
minColorDistance
=
Integer
.
MAX_VALUE
;
byte
[
]
b
=
palette
.
getColor
(
PaletteRecord
.
FIRST_COLOR_INDEX
)
;
for
(
short
i
=
(
short
)
PaletteRecord
.
FIRST_COLOR_INDEX
;
b
!=
null
;
b
=
palette
.
getColor
(
++
i
)
)
{
int
colorDistance
=
red
-
b
[
0
]
+
green
-
b
[
1
]
+
blue
-
b
[
2
]
;
if
(
colorDistance
<
minColorDistance
)
{
result
=
getColor
(
i
)
;
}
}
return
result
;
}
public
void
setColorAtIndex
(
short
index
,
byte
red
,
byte
green
,
byte
blue
)
{
palette
.
setColor
(
index
,
red
,
green
,
blue
)
;
}
public
HSSFColor
addColor
(
byte
red
,
byte
green
,
byte
blue
)
{
byte
[
]
b
=
palette
.
getColor
(
PaletteRecord
.
FIRST_COLOR_INDEX
)
;
short
i
;
for
(
i
=
(
short
)
PaletteRecord
.
FIRST_COLOR_INDEX
;
i
<
PaletteRecord
.
STANDARD_PALETTE_SIZE
+
PaletteRecord
.
FIRST_COLOR_INDEX
;
b
=
palette
.
getColor
(
++
i
)
)
{
if
(
b
==
null
)
{
setColorAtIndex
(
i
,
red
,
green
,
blue
)
;
return
getColor
(
i
)
;
}
}
throw
new
RuntimeException
(
"Could not find free color index"
)
;
}
private
static
class
CustomColor
extends
HSSFColor
{
private
short
byteOffset
;
private
byte
red
;
private
byte
green
;
private
byte
blue
;
private
CustomColor
(
short
byteOffset
,
byte
[
]
colors
)
{
this
(
byteOffset
,
colors
[
0
]
,
colors
[
1
]
,
colors
[
2
]
)
;
}
private
CustomColor
(
short
byteOffset
,
byte
red
,
byte
green
,
byte
blue
)
{
this
.
byteOffset
=
byteOffset
;
this
.
red
=
red
;
this
.
green
=
green
;
this
.
blue
=
blue
;
}
public
short
getIndex
(
)
{
return
byteOffset
;
}
public
short
[
]
getTriplet
(
)
{
return
new
short
[
]
{
(
short
)
(
red
&
0xff
)
,
(
short
)
(
green
&
0xff
)
,
(
short
)
(
blue
&
0xff
)
}
;
}
public
String
getHexString
(
)
{
StringBuffer
sb
=
new
StringBuffer
(
)
;
sb
.
append
(
getGnumericPart
(
red
)
)
;
sb
.
append
(
':'
)
;
sb
.
append
(
getGnumericPart
(
green
)
)
;
sb
.
append
(
':'
)
;
sb
.
append
(
getGnumericPart
(
blue
)
)
;
return
sb
.
toString
(
)
;
}
private
String
getGnumericPart
(
byte
color
)
{
String
s
;
if
(
color
==
0
)
{
s
=
"0"
;
}
else
{
int
c
=
color
&
0xff
;
c
=
(
c
<<
8
)
|
c
;
s
=
Integer
.
toHexString
(
c
)
.
toUpperCase
(
)
;
while
(
s
.
length
(
)
<
4
)
{
s
=
"0"
+
s
;
}
}
return
s
;
}
}
}
