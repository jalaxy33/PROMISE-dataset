package
org
.
apache
.
poi
.
util
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
text
.
NumberFormat
;
import
java
.
text
.
FieldPosition
;
public
class
StringUtil
{
private
final
static
String
ENCODING
=
"ISO-8859-1"
;
private
StringUtil
(
)
{
}
public
static
String
getFromUnicodeHigh
(
final
byte
[
]
string
,
final
int
offset
,
final
int
len
)
throws
ArrayIndexOutOfBoundsException
,
IllegalArgumentException
{
if
(
(
offset
<
0
)
||
(
offset
>=
string
.
length
)
)
{
throw
new
ArrayIndexOutOfBoundsException
(
"Illegal offset"
)
;
}
if
(
(
len
<
0
)
||
(
(
(
string
.
length
-
offset
)
/
2
)
<
len
)
)
{
throw
new
IllegalArgumentException
(
"Illegal length"
)
;
}
char
[
]
chars
=
new
char
[
len
]
;
for
(
int
i
=
0
;
i
<
chars
.
length
;
i
++
)
{
chars
[
i
]
=
(
char
)
(
string
[
offset
+
(
2
*
i
)
]
&
0xFF
|
(
string
[
offset
+
(
2
*
i
+
1
)
]
<<
8
)
)
;
}
return
new
String
(
chars
)
;
}
public
static
String
getFromUnicodeHigh
(
final
byte
[
]
string
)
{
return
getFromUnicodeHigh
(
string
,
0
,
string
.
length
/
2
)
;
}
public
static
String
getFromUnicode
(
final
byte
[
]
string
,
final
int
offset
,
final
int
len
)
throws
ArrayIndexOutOfBoundsException
,
IllegalArgumentException
{
if
(
(
offset
<
0
)
||
(
offset
>=
string
.
length
)
)
{
throw
new
ArrayIndexOutOfBoundsException
(
"Illegal offset"
)
;
}
if
(
(
len
<
0
)
||
(
(
(
string
.
length
-
offset
)
/
2
)
<
len
)
)
{
throw
new
IllegalArgumentException
(
"Illegal length"
)
;
}
char
[
]
chars
=
new
char
[
len
]
;
for
(
int
i
=
0
;
i
<
chars
.
length
;
i
++
)
{
chars
[
i
]
=
(
char
)
(
(
string
[
offset
+
(
2
*
i
)
]
<<
8
)
+
string
[
offset
+
(
2
*
i
+
1
)
]
)
;
}
return
new
String
(
chars
)
;
}
public
static
String
getFromUnicode
(
final
byte
[
]
string
)
{
return
getFromUnicode
(
string
,
0
,
string
.
length
/
2
)
;
}
public
static
String
getFromCompressedUnicode
(
final
byte
[
]
string
,
final
int
offset
,
final
int
len
)
{
try
{
return
new
String
(
string
,
offset
,
len
,
"ISO-8859-1"
)
;
}
catch
(
UnsupportedEncodingException
e
)
{
throw
new
InternalError
(
)
;
}
}
public
static
void
putCompressedUnicode
(
final
String
input
,
final
byte
[
]
output
,
final
int
offset
)
{
int
strlen
=
input
.
length
(
)
;
for
(
int
k
=
0
;
k
<
strlen
;
k
++
)
{
output
[
offset
+
k
]
=
(
byte
)
input
.
charAt
(
k
)
;
}
}
public
static
void
putUncompressedUnicode
(
final
String
input
,
final
byte
[
]
output
,
final
int
offset
)
{
int
strlen
=
input
.
length
(
)
;
for
(
int
k
=
0
;
k
<
strlen
;
k
++
)
{
char
c
=
input
.
charAt
(
k
)
;
output
[
offset
+
(
2
*
k
)
]
=
(
byte
)
c
;
output
[
offset
+
(
2
*
k
)
+
1
]
=
(
byte
)
(
c
>
>
8
)
;
}
}
public
static
void
putUncompressedUnicodeHigh
(
final
String
input
,
final
byte
[
]
output
,
final
int
offset
)
{
int
strlen
=
input
.
length
(
)
;
for
(
int
k
=
0
;
k
<
strlen
;
k
++
)
{
char
c
=
input
.
charAt
(
k
)
;
output
[
offset
+
(
2
*
k
)
]
=
(
byte
)
(
c
>
>
8
)
;
output
[
offset
+
(
2
*
k
)
]
=
(
byte
)
c
;
}
}
public
static
String
format
(
String
message
,
Object
[
]
params
)
{
int
currentParamNumber
=
0
;
StringBuffer
formattedMessage
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
message
.
length
(
)
;
i
++
)
{
if
(
message
.
charAt
(
i
)
==
'%'
)
{
if
(
currentParamNumber
>=
params
.
length
)
{
formattedMessage
.
append
(
"?missing data?"
)
;
}
else
if
(
(
params
[
currentParamNumber
]
instanceof
Number
)
&&
(
i
+
1
<
message
.
length
(
)
)
)
{
i
+=
matchOptionalFormatting
(
(
Number
)
params
[
currentParamNumber
++
]
,
message
.
substring
(
i
+
1
)
,
formattedMessage
)
;
}
else
{
formattedMessage
.
append
(
params
[
currentParamNumber
++
]
.
toString
(
)
)
;
}
}
else
{
if
(
(
message
.
charAt
(
i
)
==
'\\'
)
&&
(
i
+
1
<
message
.
length
(
)
)
&&
(
message
.
charAt
(
i
+
1
)
==
'%'
)
)
{
formattedMessage
.
append
(
'%'
)
;
i
++
;
}
else
{
formattedMessage
.
append
(
message
.
charAt
(
i
)
)
;
}
}
}
return
formattedMessage
.
toString
(
)
;
}
private
static
int
matchOptionalFormatting
(
Number
number
,
String
formatting
,
StringBuffer
outputTo
)
{
NumberFormat
numberFormat
=
NumberFormat
.
getInstance
(
)
;
if
(
(
0
<
formatting
.
length
(
)
)
&&
Character
.
isDigit
(
formatting
.
charAt
(
0
)
)
)
{
numberFormat
.
setMinimumIntegerDigits
(
Integer
.
parseInt
(
formatting
.
charAt
(
0
)
+
""
)
)
;
if
(
(
2
<
formatting
.
length
(
)
)
&&
(
formatting
.
charAt
(
1
)
==
'.'
)
&&
Character
.
isDigit
(
formatting
.
charAt
(
2
)
)
)
{
numberFormat
.
setMaximumFractionDigits
(
Integer
.
parseInt
(
formatting
.
charAt
(
2
)
+
""
)
)
;
numberFormat
.
format
(
number
,
outputTo
,
new
FieldPosition
(
0
)
)
;
return
3
;
}
numberFormat
.
format
(
number
,
outputTo
,
new
FieldPosition
(
0
)
)
;
return
1
;
}
else
if
(
(
0
<
formatting
.
length
(
)
)
&&
(
formatting
.
charAt
(
0
)
==
'.'
)
)
{
if
(
(
1
<
formatting
.
length
(
)
)
&&
Character
.
isDigit
(
formatting
.
charAt
(
1
)
)
)
{
numberFormat
.
setMaximumFractionDigits
(
Integer
.
parseInt
(
formatting
.
charAt
(
1
)
+
""
)
)
;
numberFormat
.
format
(
number
,
outputTo
,
new
FieldPosition
(
0
)
)
;
return
2
;
}
}
numberFormat
.
format
(
number
,
outputTo
,
new
FieldPosition
(
0
)
)
;
return
1
;
}
public
static
String
getPreferredEncoding
(
)
{
return
ENCODING
;
}
}
