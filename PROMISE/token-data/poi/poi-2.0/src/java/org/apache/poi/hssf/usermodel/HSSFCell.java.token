package
org
.
apache
.
poi
.
hssf
.
usermodel
;
import
org
.
apache
.
poi
.
hssf
.
model
.
Workbook
;
import
org
.
apache
.
poi
.
hssf
.
model
.
Sheet
;
import
org
.
apache
.
poi
.
hssf
.
model
.
FormulaParser
;
import
org
.
apache
.
poi
.
hssf
.
record
.
CellValueRecordInterface
;
import
org
.
apache
.
poi
.
hssf
.
record
.
Record
;
import
org
.
apache
.
poi
.
hssf
.
record
.
FormulaRecord
;
import
org
.
apache
.
poi
.
hssf
.
record
.
LabelSSTRecord
;
import
org
.
apache
.
poi
.
hssf
.
record
.
NumberRecord
;
import
org
.
apache
.
poi
.
hssf
.
record
.
BlankRecord
;
import
org
.
apache
.
poi
.
hssf
.
record
.
BoolErrRecord
;
import
org
.
apache
.
poi
.
hssf
.
record
.
ExtendedFormatRecord
;
import
org
.
apache
.
poi
.
hssf
.
record
.
aggregates
.
FormulaRecordAggregate
;
import
org
.
apache
.
poi
.
hssf
.
record
.
formula
.
Ptg
;
import
org
.
apache
.
poi
.
hssf
.
util
.
SheetReferences
;
import
java
.
util
.
Date
;
import
java
.
util
.
Calendar
;
public
class
HSSFCell
{
public
final
static
int
CELL_TYPE_NUMERIC
=
0
;
public
final
static
int
CELL_TYPE_STRING
=
1
;
public
final
static
int
CELL_TYPE_FORMULA
=
2
;
public
final
static
int
CELL_TYPE_BLANK
=
3
;
public
final
static
int
CELL_TYPE_BOOLEAN
=
4
;
public
final
static
int
CELL_TYPE_ERROR
=
5
;
public
final
static
short
ENCODING_COMPRESSED_UNICODE
=
0
;
public
final
static
short
ENCODING_UTF_16
=
1
;
private
short
cellNum
;
private
int
cellType
;
private
HSSFCellStyle
cellStyle
;
private
double
cellValue
;
private
String
stringValue
;
private
boolean
booleanValue
;
private
byte
errorValue
;
private
short
encoding
=
ENCODING_COMPRESSED_UNICODE
;
private
Workbook
book
;
private
Sheet
sheet
;
private
int
row
;
private
CellValueRecordInterface
record
;
protected
HSSFCell
(
Workbook
book
,
Sheet
sheet
,
int
row
,
short
col
)
{
checkBounds
(
col
)
;
cellNum
=
col
;
this
.
row
=
row
;
cellStyle
=
null
;
cellValue
=
0
;
stringValue
=
null
;
booleanValue
=
false
;
errorValue
=
(
byte
)
0
;
this
.
book
=
book
;
this
.
sheet
=
sheet
;
setCellType
(
CELL_TYPE_BLANK
,
false
)
;
ExtendedFormatRecord
xf
=
book
.
getExFormatAt
(
0xf
)
;
setCellStyle
(
new
HSSFCellStyle
(
(
short
)
0xf
,
xf
)
)
;
}
protected
HSSFCell
(
Workbook
book
,
Sheet
sheet
,
int
row
,
short
col
,
int
type
)
{
checkBounds
(
col
)
;
cellNum
=
col
;
this
.
row
=
row
;
cellType
=
type
;
cellStyle
=
null
;
cellValue
=
0
;
stringValue
=
null
;
booleanValue
=
false
;
errorValue
=
(
byte
)
0
;
this
.
book
=
book
;
this
.
sheet
=
sheet
;
switch
(
type
)
{
case
CELL_TYPE_NUMERIC
:
record
=
new
NumberRecord
(
)
;
(
(
NumberRecord
)
record
)
.
setColumn
(
col
)
;
(
(
NumberRecord
)
record
)
.
setRow
(
row
)
;
(
(
NumberRecord
)
record
)
.
setValue
(
(
short
)
0
)
;
(
(
NumberRecord
)
record
)
.
setXFIndex
(
(
short
)
0
)
;
break
;
case
CELL_TYPE_STRING
:
record
=
new
LabelSSTRecord
(
)
;
(
(
LabelSSTRecord
)
record
)
.
setColumn
(
col
)
;
(
(
LabelSSTRecord
)
record
)
.
setRow
(
row
)
;
(
(
LabelSSTRecord
)
record
)
.
setXFIndex
(
(
short
)
0
)
;
break
;
case
CELL_TYPE_BLANK
:
record
=
new
BlankRecord
(
)
;
(
(
BlankRecord
)
record
)
.
setColumn
(
col
)
;
(
(
BlankRecord
)
record
)
.
setRow
(
row
)
;
(
(
BlankRecord
)
record
)
.
setXFIndex
(
(
short
)
0
)
;
break
;
case
CELL_TYPE_FORMULA
:
FormulaRecord
formulaRecord
=
new
FormulaRecord
(
)
;
record
=
new
FormulaRecordAggregate
(
formulaRecord
,
null
)
;
formulaRecord
.
setColumn
(
col
)
;
formulaRecord
.
setRow
(
row
)
;
formulaRecord
.
setXFIndex
(
(
short
)
0
)
;
case
CELL_TYPE_BOOLEAN
:
record
=
new
BoolErrRecord
(
)
;
(
(
BoolErrRecord
)
record
)
.
setColumn
(
col
)
;
(
(
BoolErrRecord
)
record
)
.
setRow
(
row
)
;
(
(
BoolErrRecord
)
record
)
.
setXFIndex
(
(
short
)
0
)
;
(
(
BoolErrRecord
)
record
)
.
setValue
(
false
)
;
break
;
case
CELL_TYPE_ERROR
:
record
=
new
BoolErrRecord
(
)
;
(
(
BoolErrRecord
)
record
)
.
setColumn
(
col
)
;
(
(
BoolErrRecord
)
record
)
.
setRow
(
row
)
;
(
(
BoolErrRecord
)
record
)
.
setXFIndex
(
(
short
)
0
)
;
(
(
BoolErrRecord
)
record
)
.
setValue
(
(
byte
)
0
)
;
break
;
}
ExtendedFormatRecord
xf
=
book
.
getExFormatAt
(
0xf
)
;
setCellStyle
(
new
HSSFCellStyle
(
(
short
)
0xf
,
xf
)
)
;
}
protected
HSSFCell
(
Workbook
book
,
Sheet
sheet
,
int
row
,
CellValueRecordInterface
cval
)
{
cellNum
=
cval
.
getColumn
(
)
;
record
=
cval
;
this
.
row
=
row
;
cellType
=
determineType
(
cval
)
;
cellStyle
=
null
;
stringValue
=
null
;
this
.
book
=
book
;
this
.
sheet
=
sheet
;
switch
(
cellType
)
{
case
CELL_TYPE_NUMERIC
:
cellValue
=
(
(
NumberRecord
)
cval
)
.
getValue
(
)
;
break
;
case
CELL_TYPE_STRING
:
stringValue
=
book
.
getSSTString
(
(
(
LabelSSTRecord
)
cval
)
.
getSSTIndex
(
)
)
;
break
;
case
CELL_TYPE_BLANK
:
break
;
case
CELL_TYPE_FORMULA
:
cellValue
=
(
(
FormulaRecordAggregate
)
cval
)
.
getFormulaRecord
(
)
.
getValue
(
)
;
stringValue
=
(
(
FormulaRecordAggregate
)
cval
)
.
getStringValue
(
)
;
break
;
case
CELL_TYPE_BOOLEAN
:
booleanValue
=
(
(
BoolErrRecord
)
cval
)
.
getBooleanValue
(
)
;
break
;
case
CELL_TYPE_ERROR
:
errorValue
=
(
(
BoolErrRecord
)
cval
)
.
getErrorValue
(
)
;
break
;
}
ExtendedFormatRecord
xf
=
book
.
getExFormatAt
(
cval
.
getXFIndex
(
)
)
;
setCellStyle
(
new
HSSFCellStyle
(
(
short
)
cval
.
getXFIndex
(
)
,
xf
)
)
;
}
private
HSSFCell
(
)
{
}
private
int
determineType
(
CellValueRecordInterface
cval
)
{
Record
record
=
(
Record
)
cval
;
int
sid
=
record
.
getSid
(
)
;
int
retval
=
0
;
switch
(
sid
)
{
case
NumberRecord
.
sid
:
retval
=
HSSFCell
.
CELL_TYPE_NUMERIC
;
break
;
case
BlankRecord
.
sid
:
retval
=
HSSFCell
.
CELL_TYPE_BLANK
;
break
;
case
LabelSSTRecord
.
sid
:
retval
=
HSSFCell
.
CELL_TYPE_STRING
;
break
;
case
FormulaRecordAggregate
.
sid
:
retval
=
HSSFCell
.
CELL_TYPE_FORMULA
;
break
;
case
BoolErrRecord
.
sid
:
BoolErrRecord
boolErrRecord
=
(
BoolErrRecord
)
record
;
retval
=
(
boolErrRecord
.
isBoolean
(
)
)
?
HSSFCell
.
CELL_TYPE_BOOLEAN
:
HSSFCell
.
CELL_TYPE_ERROR
;
break
;
}
return
retval
;
}
public
void
setCellNum
(
short
num
)
{
cellNum
=
num
;
record
.
setColumn
(
num
)
;
}
public
short
getCellNum
(
)
{
return
cellNum
;
}
public
void
setCellType
(
int
cellType
)
{
setCellType
(
cellType
,
true
)
;
}
private
void
setCellType
(
int
cellType
,
boolean
setValue
)
{
if
(
cellType
>
CELL_TYPE_ERROR
)
{
throw
new
RuntimeException
(
"I have no idea what type that is!"
)
;
}
switch
(
cellType
)
{
case
CELL_TYPE_FORMULA
:
FormulaRecordAggregate
frec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
frec
=
new
FormulaRecordAggregate
(
new
FormulaRecord
(
)
,
null
)
;
}
else
{
frec
=
(
FormulaRecordAggregate
)
record
;
}
frec
.
setColumn
(
getCellNum
(
)
)
;
if
(
setValue
)
{
frec
.
getFormulaRecord
(
)
.
setValue
(
getNumericCellValue
(
)
)
;
}
frec
.
setXFIndex
(
(
short
)
cellStyle
.
getIndex
(
)
)
;
frec
.
setRow
(
row
)
;
record
=
frec
;
break
;
case
CELL_TYPE_NUMERIC
:
NumberRecord
nrec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
nrec
=
new
NumberRecord
(
)
;
}
else
{
nrec
=
(
NumberRecord
)
record
;
}
nrec
.
setColumn
(
getCellNum
(
)
)
;
if
(
setValue
)
{
nrec
.
setValue
(
getNumericCellValue
(
)
)
;
}
nrec
.
setXFIndex
(
(
short
)
cellStyle
.
getIndex
(
)
)
;
nrec
.
setRow
(
row
)
;
record
=
nrec
;
break
;
case
CELL_TYPE_STRING
:
LabelSSTRecord
lrec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
lrec
=
new
LabelSSTRecord
(
)
;
}
else
{
lrec
=
(
LabelSSTRecord
)
record
;
}
lrec
.
setColumn
(
getCellNum
(
)
)
;
lrec
.
setRow
(
row
)
;
lrec
.
setXFIndex
(
(
short
)
cellStyle
.
getIndex
(
)
)
;
if
(
setValue
)
{
if
(
(
getStringCellValue
(
)
!=
null
)
&&
(
!
getStringCellValue
(
)
.
equals
(
""
)
)
)
{
int
sst
=
0
;
if
(
encoding
==
ENCODING_COMPRESSED_UNICODE
)
{
sst
=
book
.
addSSTString
(
getStringCellValue
(
)
)
;
}
if
(
encoding
==
ENCODING_UTF_16
)
{
sst
=
book
.
addSSTString
(
getStringCellValue
(
)
,
true
)
;
}
lrec
.
setSSTIndex
(
sst
)
;
}
}
record
=
lrec
;
break
;
case
CELL_TYPE_BLANK
:
BlankRecord
brec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
brec
=
new
BlankRecord
(
)
;
}
else
{
brec
=
(
BlankRecord
)
record
;
}
brec
.
setColumn
(
getCellNum
(
)
)
;
if
(
cellStyle
!=
null
)
{
brec
.
setXFIndex
(
(
short
)
cellStyle
.
getIndex
(
)
)
;
}
else
{
brec
.
setXFIndex
(
(
short
)
0
)
;
}
brec
.
setRow
(
row
)
;
record
=
brec
;
break
;
case
CELL_TYPE_BOOLEAN
:
BoolErrRecord
boolRec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
boolRec
=
new
BoolErrRecord
(
)
;
}
else
{
boolRec
=
(
BoolErrRecord
)
record
;
}
boolRec
.
setColumn
(
getCellNum
(
)
)
;
if
(
setValue
)
{
boolRec
.
setValue
(
getBooleanCellValue
(
)
)
;
}
boolRec
.
setXFIndex
(
(
short
)
cellStyle
.
getIndex
(
)
)
;
boolRec
.
setRow
(
row
)
;
record
=
boolRec
;
break
;
case
CELL_TYPE_ERROR
:
BoolErrRecord
errRec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
errRec
=
new
BoolErrRecord
(
)
;
}
else
{
errRec
=
(
BoolErrRecord
)
record
;
}
errRec
.
setColumn
(
getCellNum
(
)
)
;
if
(
setValue
)
{
errRec
.
setValue
(
getErrorCellValue
(
)
)
;
}
errRec
.
setXFIndex
(
(
short
)
cellStyle
.
getIndex
(
)
)
;
errRec
.
setRow
(
row
)
;
record
=
errRec
;
break
;
}
if
(
cellType
!=
this
.
cellType
)
{
int
loc
=
sheet
.
getLoc
(
)
;
sheet
.
replaceValueRecord
(
record
)
;
sheet
.
setLoc
(
loc
)
;
}
this
.
cellType
=
cellType
;
}
public
int
getCellType
(
)
{
return
cellType
;
}
public
void
setCellValue
(
double
value
)
{
if
(
(
cellType
!=
CELL_TYPE_NUMERIC
)
&&
(
cellType
!=
CELL_TYPE_FORMULA
)
)
{
setCellType
(
CELL_TYPE_NUMERIC
,
false
)
;
}
(
(
NumberRecord
)
record
)
.
setValue
(
value
)
;
cellValue
=
value
;
}
public
void
setCellValue
(
Date
value
)
{
setCellValue
(
HSSFDateUtil
.
getExcelDate
(
value
)
)
;
}
public
void
setCellValue
(
Calendar
value
)
{
setCellValue
(
value
.
getTime
(
)
)
;
}
public
void
setCellValue
(
String
value
)
{
if
(
value
==
null
)
{
setCellType
(
CELL_TYPE_BLANK
,
false
)
;
}
else
{
if
(
(
cellType
!=
CELL_TYPE_STRING
)
&&
(
cellType
!=
CELL_TYPE_FORMULA
)
)
{
setCellType
(
CELL_TYPE_STRING
,
false
)
;
}
int
index
=
0
;
if
(
encoding
==
ENCODING_COMPRESSED_UNICODE
)
{
index
=
book
.
addSSTString
(
value
)
;
}
if
(
encoding
==
ENCODING_UTF_16
)
{
index
=
book
.
addSSTString
(
value
,
true
)
;
}
(
(
LabelSSTRecord
)
record
)
.
setSSTIndex
(
index
)
;
stringValue
=
value
;
}
}
public
void
setCellFormula
(
String
formula
)
{
if
(
formula
==
null
)
{
setCellType
(
CELL_TYPE_BLANK
,
false
)
;
}
else
{
setCellType
(
CELL_TYPE_FORMULA
,
false
)
;
FormulaRecordAggregate
rec
=
(
FormulaRecordAggregate
)
record
;
rec
.
getFormulaRecord
(
)
.
setOptions
(
(
short
)
2
)
;
rec
.
getFormulaRecord
(
)
.
setValue
(
0
)
;
if
(
rec
.
getXFIndex
(
)
==
(
short
)
0
)
rec
.
setXFIndex
(
(
short
)
0x0f
)
;
FormulaParser
fp
=
new
FormulaParser
(
formula
+
";"
,
book
)
;
fp
.
parse
(
)
;
Ptg
[
]
ptg
=
fp
.
getRPNPtg
(
)
;
int
size
=
0
;
for
(
int
k
=
0
;
k
<
ptg
.
length
;
k
++
)
{
size
+=
ptg
[
k
]
.
getSize
(
)
;
rec
.
getFormulaRecord
(
)
.
pushExpressionToken
(
ptg
[
k
]
)
;
}
rec
.
getFormulaRecord
(
)
.
setExpressionLength
(
(
short
)
size
)
;
}
}
public
String
getCellFormula
(
)
{
String
retval
=
FormulaParser
.
toFormulaString
(
book
,
(
(
FormulaRecordAggregate
)
record
)
.
getFormulaRecord
(
)
.
getParsedExpression
(
)
)
;
return
retval
;
}
public
double
getNumericCellValue
(
)
{
if
(
cellType
==
CELL_TYPE_BLANK
)
{
return
0
;
}
if
(
cellType
==
CELL_TYPE_STRING
)
{
throw
new
NumberFormatException
(
"You cannot get a numeric value from a String based cell"
)
;
}
if
(
cellType
==
CELL_TYPE_BOOLEAN
)
{
throw
new
NumberFormatException
(
"You cannot get a numeric value from a boolean cell"
)
;
}
if
(
cellType
==
CELL_TYPE_ERROR
)
{
throw
new
NumberFormatException
(
"You cannot get a numeric value from an error cell"
)
;
}
return
cellValue
;
}
public
Date
getDateCellValue
(
)
{
if
(
cellType
==
CELL_TYPE_BLANK
)
{
return
null
;
}
if
(
cellType
==
CELL_TYPE_STRING
)
{
throw
new
NumberFormatException
(
"You cannot get a date value from a String based cell"
)
;
}
if
(
cellType
==
CELL_TYPE_BOOLEAN
)
{
throw
new
NumberFormatException
(
"You cannot get a date value from a boolean cell"
)
;
}
if
(
cellType
==
CELL_TYPE_ERROR
)
{
throw
new
NumberFormatException
(
"You cannot get a date value from an error cell"
)
;
}
if
(
book
.
isUsing1904DateWindowing
(
)
)
{
return
HSSFDateUtil
.
getJavaDate
(
cellValue
,
true
)
;
}
else
{
return
HSSFDateUtil
.
getJavaDate
(
cellValue
,
false
)
;
}
}
public
String
getStringCellValue
(
)
{
if
(
cellType
==
CELL_TYPE_BLANK
)
{
return
""
;
}
if
(
cellType
==
CELL_TYPE_NUMERIC
)
{
throw
new
NumberFormatException
(
"You cannot get a string value from a numeric cell"
)
;
}
if
(
cellType
==
CELL_TYPE_BOOLEAN
)
{
throw
new
NumberFormatException
(
"You cannot get a string value from a boolean cell"
)
;
}
if
(
cellType
==
CELL_TYPE_ERROR
)
{
throw
new
NumberFormatException
(
"You cannot get a string value from an error cell"
)
;
}
if
(
cellType
==
CELL_TYPE_FORMULA
)
{
if
(
stringValue
==
null
)
return
""
;
}
return
stringValue
;
}
public
void
setCellValue
(
boolean
value
)
{
if
(
(
cellType
!=
CELL_TYPE_BOOLEAN
)
&&
(
cellType
!=
CELL_TYPE_FORMULA
)
)
{
setCellType
(
CELL_TYPE_BOOLEAN
,
false
)
;
}
(
(
BoolErrRecord
)
record
)
.
setValue
(
value
)
;
booleanValue
=
value
;
}
public
void
setCellErrorValue
(
byte
value
)
{
if
(
(
cellType
!=
CELL_TYPE_ERROR
)
&&
(
cellType
!=
CELL_TYPE_FORMULA
)
)
{
setCellType
(
CELL_TYPE_ERROR
,
false
)
;
}
(
(
BoolErrRecord
)
record
)
.
setValue
(
value
)
;
errorValue
=
value
;
}
public
boolean
getBooleanCellValue
(
)
{
if
(
cellType
==
CELL_TYPE_BOOLEAN
)
{
return
booleanValue
;
}
if
(
cellType
==
CELL_TYPE_BLANK
)
{
return
false
;
}
throw
new
NumberFormatException
(
"You cannot get a boolean value from a non-boolean cell"
)
;
}
public
byte
getErrorCellValue
(
)
{
if
(
cellType
==
CELL_TYPE_ERROR
)
{
return
errorValue
;
}
if
(
cellType
==
CELL_TYPE_BLANK
)
{
return
(
byte
)
0
;
}
throw
new
NumberFormatException
(
"You cannot get an error value from a non-error cell"
)
;
}
public
void
setCellStyle
(
HSSFCellStyle
style
)
{
cellStyle
=
style
;
record
.
setXFIndex
(
style
.
getIndex
(
)
)
;
}
public
HSSFCellStyle
getCellStyle
(
)
{
return
cellStyle
;
}
public
short
getEncoding
(
)
{
return
encoding
;
}
public
void
setEncoding
(
short
encoding
)
{
this
.
encoding
=
encoding
;
}
protected
CellValueRecordInterface
getCellValueRecord
(
)
{
return
record
;
}
private
void
checkBounds
(
int
cellNum
)
{
if
(
cellNum
>
255
)
{
throw
new
RuntimeException
(
"You cannot have more than 255 columns "
+
"in a given row (IV).  Because Excel can't handle it"
)
;
}
else
if
(
cellNum
<
0
)
{
throw
new
RuntimeException
(
"You cannot reference columns with an index of less then 0."
)
;
}
}
public
void
setAsActiveCell
(
)
{
this
.
sheet
.
setActiveCellRow
(
this
.
row
)
;
this
.
sheet
.
setActiveCellCol
(
this
.
cellNum
)
;
}
}
