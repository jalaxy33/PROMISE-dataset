package
org
.
apache
.
poi
.
hssf
.
record
;
import
org
.
apache
.
poi
.
util
.
BinaryTree
;
import
org
.
apache
.
poi
.
util
.
LittleEndian
;
import
org
.
apache
.
poi
.
util
.
LittleEndianConsts
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
public
class
SSTRecord
extends
Record
{
static
final
int
MAX_RECORD_SIZE
=
8228
;
static
final
int
STD_RECORD_OVERHEAD
=
2
*
LittleEndianConsts
.
SHORT_SIZE
;
static
final
int
SST_RECORD_OVERHEAD
=
(
STD_RECORD_OVERHEAD
+
(
2
*
LittleEndianConsts
.
INT_SIZE
)
)
;
static
final
int
MAX_DATA_SPACE
=
MAX_RECORD_SIZE
-
SST_RECORD_OVERHEAD
;
static
final
int
STRING_MINIMAL_OVERHEAD
=
LittleEndianConsts
.
SHORT_SIZE
+
LittleEndianConsts
.
BYTE_SIZE
;
public
static
final
short
sid
=
0xfc
;
private
int
field_1_num_strings
;
private
int
field_2_num_unique_strings
;
private
BinaryTree
field_3_strings
;
private
List
_record_lengths
=
null
;
private
SSTDeserializer
deserializer
;
int
[
]
bucketAbsoluteOffsets
;
int
[
]
bucketRelativeOffsets
;
public
SSTRecord
(
)
{
field_1_num_strings
=
0
;
field_2_num_unique_strings
=
0
;
field_3_strings
=
new
BinaryTree
(
)
;
deserializer
=
new
SSTDeserializer
(
field_3_strings
)
;
}
public
SSTRecord
(
final
short
id
,
final
short
size
,
final
byte
[
]
data
)
{
super
(
id
,
size
,
data
)
;
}
public
SSTRecord
(
final
short
id
,
final
short
size
,
final
byte
[
]
data
,
int
offset
)
{
super
(
id
,
size
,
data
,
offset
)
;
}
public
int
addString
(
final
String
string
)
{
int
rval
;
if
(
string
==
null
)
{
rval
=
addString
(
""
,
false
)
;
}
else
{
boolean
useUTF16
=
false
;
int
strlen
=
string
.
length
(
)
;
for
(
int
j
=
0
;
j
<
strlen
;
j
++
)
{
if
(
string
.
charAt
(
j
)
>
255
)
{
useUTF16
=
true
;
break
;
}
}
rval
=
addString
(
string
,
useUTF16
)
;
}
return
rval
;
}
public
int
addString
(
final
String
string
,
final
boolean
useUTF16
)
{
field_1_num_strings
++
;
String
str
=
(
string
==
null
)
?
""
:
string
;
int
rval
;
UnicodeString
ucs
=
new
UnicodeString
(
)
;
ucs
.
setString
(
str
)
;
ucs
.
setCharCount
(
(
short
)
str
.
length
(
)
)
;
ucs
.
setOptionFlags
(
(
byte
)
(
useUTF16
?
1
:
0
)
)
;
Integer
integer
=
(
Integer
)
field_3_strings
.
getKeyForValue
(
ucs
)
;
if
(
integer
!=
null
)
{
rval
=
integer
.
intValue
(
)
;
}
else
{
rval
=
field_3_strings
.
size
(
)
;
field_2_num_unique_strings
++
;
integer
=
new
Integer
(
rval
)
;
SSTDeserializer
.
addToStringTable
(
field_3_strings
,
integer
,
ucs
)
;
}
return
rval
;
}
public
int
getNumStrings
(
)
{
return
field_1_num_strings
;
}
public
int
getNumUniqueStrings
(
)
{
return
field_2_num_unique_strings
;
}
public
void
setNumStrings
(
final
int
count
)
{
field_1_num_strings
=
count
;
}
public
void
setNumUniqueStrings
(
final
int
count
)
{
field_2_num_unique_strings
=
count
;
}
public
String
getString
(
final
int
id
)
{
return
(
(
UnicodeString
)
field_3_strings
.
get
(
new
Integer
(
id
)
)
)
.
getString
(
)
;
}
public
boolean
isString16bit
(
final
int
id
)
{
UnicodeString
unicodeString
=
(
(
UnicodeString
)
field_3_strings
.
get
(
new
Integer
(
id
)
)
)
;
return
(
(
unicodeString
.
getOptionFlags
(
)
&
0x01
)
==
1
)
;
}
public
String
toString
(
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
buffer
.
append
(
"[SST]\n"
)
;
buffer
.
append
(
"    .numstrings     = "
)
.
append
(
Integer
.
toHexString
(
getNumStrings
(
)
)
)
.
append
(
"\n"
)
;
buffer
.
append
(
"    .uniquestrings  = "
)
.
append
(
Integer
.
toHexString
(
getNumUniqueStrings
(
)
)
)
.
append
(
"\n"
)
;
for
(
int
k
=
0
;
k
<
field_3_strings
.
size
(
)
;
k
++
)
{
buffer
.
append
(
"    .string_"
+
k
+
"      = "
)
.
append
(
(
field_3_strings
.
get
(
new
Integer
(
k
)
)
)
.
toString
(
)
)
.
append
(
"\n"
)
;
}
buffer
.
append
(
"[/SST]\n"
)
;
return
buffer
.
toString
(
)
;
}
public
short
getSid
(
)
{
return
sid
;
}
public
int
hashCode
(
)
{
return
field_2_num_unique_strings
;
}
public
boolean
equals
(
Object
o
)
{
if
(
(
o
==
null
)
||
(
o
.
getClass
(
)
!=
this
.
getClass
(
)
)
)
{
return
false
;
}
SSTRecord
other
=
(
SSTRecord
)
o
;
return
(
(
field_1_num_strings
==
other
.
field_1_num_strings
)
&&
(
field_2_num_unique_strings
==
other
.
field_2_num_unique_strings
)
&&
field_3_strings
.
equals
(
other
.
field_3_strings
)
)
;
}
protected
void
validateSid
(
final
short
id
)
throws
RecordFormatException
{
if
(
id
!=
sid
)
{
throw
new
RecordFormatException
(
"NOT An SST RECORD"
)
;
}
}
protected
void
fillFields
(
final
byte
[
]
data
,
final
short
size
,
int
offset
)
{
field_1_num_strings
=
LittleEndian
.
getInt
(
data
,
0
+
offset
)
;
field_2_num_unique_strings
=
LittleEndian
.
getInt
(
data
,
4
+
offset
)
;
field_3_strings
=
new
BinaryTree
(
)
;
deserializer
=
new
SSTDeserializer
(
field_3_strings
)
;
deserializer
.
manufactureStrings
(
data
,
8
+
offset
)
;
}
Iterator
getStrings
(
)
{
return
field_3_strings
.
values
(
)
.
iterator
(
)
;
}
int
countStrings
(
)
{
return
field_3_strings
.
size
(
)
;
}
public
int
serialize
(
int
offset
,
byte
[
]
data
)
{
SSTSerializer
serializer
=
new
SSTSerializer
(
_record_lengths
,
field_3_strings
,
getNumStrings
(
)
,
getNumUniqueStrings
(
)
)
;
int
bytes
=
serializer
.
serialize
(
getRecordSize
(
)
,
offset
,
data
)
;
bucketAbsoluteOffsets
=
serializer
.
getBucketAbsoluteOffsets
(
)
;
bucketRelativeOffsets
=
serializer
.
getBucketRelativeOffsets
(
)
;
return
bytes
;
}
public
int
getRecordSize
(
)
{
SSTRecordSizeCalculator
calculator
=
new
SSTRecordSizeCalculator
(
field_3_strings
)
;
int
recordSize
=
calculator
.
getRecordSize
(
)
;
_record_lengths
=
calculator
.
getRecordLengths
(
)
;
return
recordSize
;
}
SSTDeserializer
getDeserializer
(
)
{
return
deserializer
;
}
public
void
processContinueRecord
(
byte
[
]
record
)
{
deserializer
.
processContinueRecord
(
record
)
;
}
public
ExtSSTRecord
createExtSSTRecord
(
int
sstOffset
)
{
if
(
bucketAbsoluteOffsets
==
null
||
bucketAbsoluteOffsets
==
null
)
throw
new
IllegalStateException
(
"SST record has not yet been serialized."
)
;
ExtSSTRecord
extSST
=
new
ExtSSTRecord
(
)
;
extSST
.
setNumStringsPerBucket
(
(
short
)
8
)
;
int
[
]
absoluteOffsets
=
(
int
[
]
)
bucketAbsoluteOffsets
.
clone
(
)
;
int
[
]
relativeOffsets
=
(
int
[
]
)
bucketRelativeOffsets
.
clone
(
)
;
for
(
int
i
=
0
;
i
<
absoluteOffsets
.
length
;
i
++
)
absoluteOffsets
[
i
]
+=
sstOffset
;
extSST
.
setBucketOffsets
(
absoluteOffsets
,
relativeOffsets
)
;
return
extSST
;
}
public
int
calcExtSSTRecordSize
(
)
{
return
ExtSSTRecord
.
getRecordSizeForStrings
(
field_3_strings
.
size
(
)
)
;
}
}
