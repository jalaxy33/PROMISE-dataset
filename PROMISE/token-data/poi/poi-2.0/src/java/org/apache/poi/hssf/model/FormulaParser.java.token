package
org
.
apache
.
poi
.
hssf
.
model
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
import
org
.
apache
.
poi
.
hssf
.
record
.
formula
.
*
;
public
class
FormulaParser
{
public
static
int
FORMULA_TYPE_CELL
=
0
;
public
static
int
FORMULA_TYPE_SHARED
=
1
;
public
static
int
FORMULA_TYPE_ARRAY
=
2
;
public
static
int
FORMULA_TYPE_CONDFOMRAT
=
3
;
public
static
int
FORMULA_TYPE_NAMEDRANGE
=
4
;
private
String
formulaString
;
private
int
pointer
=
0
;
private
int
formulaLength
;
private
List
tokens
=
new
java
.
util
.
Stack
(
)
;
private
List
functionTokens
=
new
LinkedList
(
)
;
private
List
result
=
new
ArrayList
(
)
;
private
int
numParen
;
private
static
char
TAB
=
'\t'
;
private
static
char
CR
=
'\n'
;
private
char
look
;
private
boolean
inFunction
=
false
;
private
Workbook
book
;
public
FormulaParser
(
String
formula
,
Workbook
book
)
{
formulaString
=
formula
;
pointer
=
0
;
this
.
book
=
book
;
formulaLength
=
formulaString
.
length
(
)
;
}
private
void
GetChar
(
)
{
if
(
pointer
==
formulaLength
)
{
look
=
(
char
)
0
;
return
;
}
look
=
formulaString
.
charAt
(
pointer
++
)
;
}
private
void
Error
(
String
s
)
{
System
.
out
.
println
(
"Error: "
+
s
)
;
}
private
void
Abort
(
String
s
)
{
Error
(
s
)
;
throw
new
RuntimeException
(
"Cannot Parse, sorry : "
+
s
)
;
}
private
void
Expected
(
String
s
)
{
Abort
(
s
+
" Expected"
)
;
}
private
boolean
IsAlpha
(
char
c
)
{
return
Character
.
isLetter
(
c
)
||
c
==
'$'
;
}
private
boolean
IsDigit
(
char
c
)
{
return
Character
.
isDigit
(
c
)
;
}
private
boolean
IsAlNum
(
char
c
)
{
return
(
IsAlpha
(
c
)
||
IsDigit
(
c
)
)
;
}
private
boolean
IsAddop
(
char
c
)
{
return
(
c
==
'+'
||
c
==
'-'
)
;
}
private
boolean
IsWhite
(
char
c
)
{
return
(
c
==
' '
||
c
==
TAB
)
;
}
private
boolean
IsSpecialChar
(
char
c
)
{
return
(
c
==
'>'
||
c
==
'<'
||
c
==
'='
||
c
==
'&'
||
c
==
'['
||
c
==
']'
)
;
}
private
void
SkipWhite
(
)
{
while
(
IsWhite
(
look
)
)
{
GetChar
(
)
;
}
}
private
void
Match
(
char
x
)
{
if
(
look
!=
x
)
{
Expected
(
""
+
x
+
""
)
;
}
else
{
GetChar
(
)
;
SkipWhite
(
)
;
}
}
private
String
GetName
(
)
{
StringBuffer
Token
=
new
StringBuffer
(
)
;
if
(
!
IsAlpha
(
look
)
&&
look
!=
'\''
)
{
Expected
(
"Name"
)
;
}
if
(
look
==
'\''
)
{
Match
(
'\''
)
;
boolean
done
=
look
==
'\''
;
while
(
!
done
)
{
Token
.
append
(
Character
.
toUpperCase
(
look
)
)
;
GetChar
(
)
;
if
(
look
==
'\''
)
{
Match
(
'\''
)
;
done
=
look
!=
'\''
;
}
}
}
else
{
while
(
IsAlNum
(
look
)
)
{
Token
.
append
(
Character
.
toUpperCase
(
look
)
)
;
GetChar
(
)
;
}
}
SkipWhite
(
)
;
return
Token
.
toString
(
)
;
}
private
String
GetNameAsIs
(
)
{
StringBuffer
Token
=
new
StringBuffer
(
)
;
while
(
IsAlNum
(
look
)
||
IsWhite
(
look
)
||
IsSpecialChar
(
look
)
)
{
Token
=
Token
.
append
(
look
)
;
GetChar
(
)
;
}
return
Token
.
toString
(
)
;
}
private
String
GetNum
(
)
{
String
Value
=
""
;
if
(
!
IsDigit
(
look
)
)
Expected
(
"Integer"
)
;
while
(
IsDigit
(
look
)
)
{
Value
=
Value
+
look
;
GetChar
(
)
;
}
SkipWhite
(
)
;
return
Value
;
}
private
void
Emit
(
String
s
)
{
System
.
out
.
print
(
TAB
+
s
)
;
}
private
void
EmitLn
(
String
s
)
{
Emit
(
s
)
;
System
.
out
.
println
(
)
;
;
}
private
void
Ident
(
)
{
String
name
;
name
=
GetName
(
)
;
if
(
look
==
'('
)
{
function
(
name
)
;
}
else
if
(
look
==
':'
)
{
String
first
=
name
;
Match
(
':'
)
;
String
second
=
GetName
(
)
;
tokens
.
add
(
new
AreaPtg
(
first
+
":"
+
second
)
)
;
}
else
if
(
look
==
'!'
)
{
Match
(
'!'
)
;
String
sheetName
=
name
;
String
first
=
GetName
(
)
;
short
externIdx
=
book
.
checkExternSheet
(
book
.
getSheetIndex
(
sheetName
)
)
;
if
(
look
==
':'
)
{
Match
(
':'
)
;
String
second
=
GetName
(
)
;
tokens
.
add
(
new
Area3DPtg
(
first
+
":"
+
second
,
externIdx
)
)
;
}
else
{
tokens
.
add
(
new
Ref3DPtg
(
first
,
externIdx
)
)
;
}
}
else
{
boolean
cellRef
=
true
;
boolean
boolLit
=
(
name
.
equals
(
"TRUE"
)
||
name
.
equals
(
"FALSE"
)
)
;
if
(
boolLit
)
{
tokens
.
add
(
new
BoolPtg
(
name
)
)
;
}
else
if
(
cellRef
)
{
tokens
.
add
(
new
ReferencePtg
(
name
)
)
;
}
else
{
}
}
}
private
void
addArgumentPointer
(
)
{
if
(
this
.
functionTokens
.
size
(
)
>
0
)
{
List
arguments
=
(
List
)
this
.
functionTokens
.
get
(
0
)
;
arguments
.
add
(
tokens
.
get
(
tokens
.
size
(
)
-
1
)
)
;
}
}
private
void
function
(
String
name
)
{
this
.
functionTokens
.
add
(
0
,
new
ArrayList
(
2
)
)
;
Match
(
'('
)
;
int
numArgs
=
Arguments
(
)
;
Match
(
')'
)
;
AbstractFunctionPtg
functionPtg
=
getFunction
(
name
,
(
byte
)
numArgs
)
;
tokens
.
add
(
functionPtg
)
;
if
(
functionPtg
.
getName
(
)
.
equals
(
"externalflag"
)
)
{
tokens
.
add
(
new
NamePtg
(
name
,
this
.
book
)
)
;
}
this
.
functionTokens
.
remove
(
0
)
;
}
private
int
getPtgSize
(
int
index
)
{
int
count
=
0
;
Iterator
ptgIterator
=
tokens
.
listIterator
(
index
)
;
while
(
ptgIterator
.
hasNext
(
)
)
{
Ptg
ptg
=
(
Ptg
)
ptgIterator
.
next
(
)
;
count
+=
ptg
.
getSize
(
)
;
}
return
count
;
}
private
int
getPtgSize
(
int
start
,
int
end
)
{
int
count
=
0
;
int
index
=
start
;
Iterator
ptgIterator
=
tokens
.
listIterator
(
index
)
;
while
(
ptgIterator
.
hasNext
(
)
&&
index
<=
end
)
{
Ptg
ptg
=
(
Ptg
)
ptgIterator
.
next
(
)
;
count
+=
ptg
.
getSize
(
)
;
index
++
;
}
return
count
;
}
private
AbstractFunctionPtg
getFunction
(
String
name
,
byte
numArgs
)
{
AbstractFunctionPtg
retval
=
null
;
if
(
name
.
equals
(
"IF"
)
)
{
retval
=
new
FuncVarPtg
(
AbstractFunctionPtg
.
ATTR_NAME
,
numArgs
)
;
List
argumentPointers
=
(
List
)
this
.
functionTokens
.
get
(
0
)
;
AttrPtg
ifPtg
=
new
AttrPtg
(
)
;
ifPtg
.
setData
(
(
short
)
7
)
;
ifPtg
.
setOptimizedIf
(
true
)
;
if
(
argumentPointers
.
size
(
)
!=
2
&&
argumentPointers
.
size
(
)
!=
3
)
{
throw
new
IllegalArgumentException
(
"["
+
argumentPointers
.
size
(
)
+
"] Arguments Found - An IF formula requires 2 or 3 arguments. IF(CONDITION, TRUE_VALUE, FALSE_VALUE [OPTIONAL]"
)
;
}
int
ifIndex
=
tokens
.
indexOf
(
argumentPointers
.
get
(
0
)
)
+
1
;
tokens
.
add
(
ifIndex
,
ifPtg
)
;
int
gotoIndex
=
tokens
.
indexOf
(
argumentPointers
.
get
(
1
)
)
+
1
;
AttrPtg
goto1Ptg
=
new
AttrPtg
(
)
;
goto1Ptg
.
setGoto
(
true
)
;
tokens
.
add
(
gotoIndex
,
goto1Ptg
)
;
if
(
numArgs
>
2
)
{
AttrPtg
goto2Ptg
=
new
AttrPtg
(
)
;
goto2Ptg
.
setGoto
(
true
)
;
goto2Ptg
.
setData
(
(
short
)
(
retval
.
getSize
(
)
-
1
)
)
;
tokens
.
add
(
goto2Ptg
)
;
}
ifPtg
.
setData
(
(
short
)
(
getPtgSize
(
ifIndex
+
1
,
gotoIndex
)
)
)
;
int
ptgCount
=
this
.
getPtgSize
(
gotoIndex
)
-
goto1Ptg
.
getSize
(
)
+
retval
.
getSize
(
)
;
if
(
ptgCount
>
(
int
)
Short
.
MAX_VALUE
)
{
throw
new
RuntimeException
(
"Ptg Size exceeds short when being specified for a goto ptg in an if"
)
;
}
goto1Ptg
.
setData
(
(
short
)
(
ptgCount
-
1
)
)
;
}
else
{
retval
=
new
FuncVarPtg
(
name
,
numArgs
)
;
}
return
retval
;
}
private
int
Arguments
(
)
{
int
numArgs
=
0
;
if
(
look
!=
')'
)
{
numArgs
++
;
Expression
(
)
;
addArgumentPointer
(
)
;
}
while
(
look
==
','
||
look
==
';'
)
{
if
(
look
==
','
)
{
Match
(
','
)
;
}
else
{
Match
(
';'
)
;
}
Expression
(
)
;
addArgumentPointer
(
)
;
numArgs
++
;
}
return
numArgs
;
}
private
void
Factor
(
)
{
if
(
look
==
'-'
)
{
Match
(
'-'
)
;
Factor
(
)
;
tokens
.
add
(
new
UnaryMinusPtg
(
)
)
;
}
else
if
(
look
==
'('
)
{
Match
(
'('
)
;
Expression
(
)
;
Match
(
')'
)
;
tokens
.
add
(
new
ParenthesisPtg
(
)
)
;
}
else
if
(
IsAlpha
(
look
)
||
look
==
'\''
)
{
Ident
(
)
;
}
else
if
(
look
==
'"'
)
{
StringLiteral
(
)
;
}
else
{
String
number
=
GetNum
(
)
;
if
(
look
==
'.'
)
{
Match
(
'.'
)
;
String
decimalPart
=
null
;
if
(
IsDigit
(
look
)
)
number
=
number
+
"."
+
GetNum
(
)
;
tokens
.
add
(
new
NumberPtg
(
number
)
)
;
}
else
{
tokens
.
add
(
new
IntPtg
(
number
)
)
;
}
}
}
private
void
StringLiteral
(
)
{
if
(
look
!=
'"'
)
Expected
(
"\""
)
;
else
{
GetChar
(
)
;
StringBuffer
Token
=
new
StringBuffer
(
)
;
for
(
;
;
)
{
if
(
look
==
'"'
)
{
GetChar
(
)
;
SkipWhite
(
)
;
if
(
look
==
'"'
)
Token
.
append
(
"\""
)
;
else
break
;
}
else
if
(
look
==
0
)
{
break
;
}
else
{
Token
.
append
(
look
)
;
GetChar
(
)
;
}
}
tokens
.
add
(
new
StringPtg
(
Token
.
toString
(
)
)
)
;
}
}
private
void
Multiply
(
)
{
Match
(
'*'
)
;
Factor
(
)
;
tokens
.
add
(
new
MultiplyPtg
(
)
)
;
}
private
void
Divide
(
)
{
Match
(
'/'
)
;
Factor
(
)
;
tokens
.
add
(
new
DividePtg
(
)
)
;
}
private
void
Term
(
)
{
Factor
(
)
;
while
(
look
==
'*'
||
look
==
'/'
||
look
==
'^'
||
look
==
'&'
)
{
if
(
look
==
'*'
)
Multiply
(
)
;
else
if
(
look
==
'/'
)
Divide
(
)
;
else
if
(
look
==
'^'
)
Power
(
)
;
else
if
(
look
==
'&'
)
Concat
(
)
;
}
}
private
void
Add
(
)
{
Match
(
'+'
)
;
Term
(
)
;
tokens
.
add
(
new
AddPtg
(
)
)
;
}
private
void
Concat
(
)
{
Match
(
'&'
)
;
Term
(
)
;
tokens
.
add
(
new
ConcatPtg
(
)
)
;
}
private
void
Equal
(
)
{
Match
(
'='
)
;
Expression
(
)
;
tokens
.
add
(
new
EqualPtg
(
)
)
;
}
private
void
Subtract
(
)
{
Match
(
'-'
)
;
Term
(
)
;
tokens
.
add
(
new
SubtractPtg
(
)
)
;
}
private
void
Power
(
)
{
Match
(
'^'
)
;
Term
(
)
;
tokens
.
add
(
new
PowerPtg
(
)
)
;
}
private
void
Expression
(
)
{
Term
(
)
;
while
(
IsAddop
(
look
)
)
{
if
(
look
==
'+'
)
Add
(
)
;
else
if
(
look
==
'-'
)
Subtract
(
)
;
}
if
(
look
==
'='
||
look
==
'>'
||
look
==
'<'
)
{
if
(
look
==
'='
)
Equal
(
)
;
else
if
(
look
==
'>'
)
GreaterThan
(
)
;
else
if
(
look
==
'<'
)
LessThan
(
)
;
return
;
}
}
private
void
GreaterThan
(
)
{
Match
(
'>'
)
;
if
(
look
==
'='
)
GreaterEqual
(
)
;
else
{
Expression
(
)
;
tokens
.
add
(
new
GreaterThanPtg
(
)
)
;
}
}
private
void
LessThan
(
)
{
Match
(
'<'
)
;
if
(
look
==
'='
)
LessEqual
(
)
;
else
if
(
look
==
'>'
)
NotEqual
(
)
;
else
{
Expression
(
)
;
tokens
.
add
(
new
LessThanPtg
(
)
)
;
}
}
private
void
GreaterEqual
(
)
{
Match
(
'='
)
;
Expression
(
)
;
tokens
.
add
(
new
GreaterEqualPtg
(
)
)
;
}
private
void
LessEqual
(
)
{
Match
(
'='
)
;
Expression
(
)
;
tokens
.
add
(
new
LessEqualPtg
(
)
)
;
}
private
void
NotEqual
(
)
{
Match
(
'>'
)
;
Expression
(
)
;
tokens
.
add
(
new
NotEqualPtg
(
)
)
;
}
private
void
init
(
)
{
GetChar
(
)
;
SkipWhite
(
)
;
}
public
void
parse
(
)
{
synchronized
(
tokens
)
{
init
(
)
;
Expression
(
)
;
}
}
public
Ptg
[
]
getRPNPtg
(
)
{
return
getRPNPtg
(
FORMULA_TYPE_CELL
)
;
}
public
Ptg
[
]
getRPNPtg
(
int
formulaType
)
{
Node
node
=
createTree
(
)
;
setRootLevelRVA
(
node
,
formulaType
)
;
setParameterRVA
(
node
,
formulaType
)
;
return
(
Ptg
[
]
)
tokens
.
toArray
(
new
Ptg
[
0
]
)
;
}
private
void
setRootLevelRVA
(
Node
n
,
int
formulaType
)
{
Ptg
p
=
(
Ptg
)
n
.
getValue
(
)
;
if
(
formulaType
==
FormulaParser
.
FORMULA_TYPE_NAMEDRANGE
)
{
if
(
p
.
getDefaultOperandClass
(
)
==
Ptg
.
CLASS_REF
)
{
setClass
(
n
,
Ptg
.
CLASS_REF
)
;
}
else
{
setClass
(
n
,
Ptg
.
CLASS_ARRAY
)
;
}
}
else
{
setClass
(
n
,
Ptg
.
CLASS_VALUE
)
;
}
}
private
void
setParameterRVA
(
Node
n
,
int
formulaType
)
{
Ptg
p
=
(
Ptg
)
n
.
getValue
(
)
;
if
(
p
instanceof
AbstractFunctionPtg
)
{
int
numOperands
=
n
.
getNumChildren
(
)
;
for
(
int
i
=
0
;
i
<
n
.
getNumChildren
(
)
;
i
++
)
{
setParameterRVA
(
n
.
getChild
(
i
)
,
(
(
AbstractFunctionPtg
)
p
)
.
getParameterClass
(
i
)
,
formulaType
)
;
if
(
n
.
getChild
(
i
)
.
getValue
(
)
instanceof
AbstractFunctionPtg
)
{
setParameterRVA
(
n
.
getChild
(
i
)
,
formulaType
)
;
}
}
}
else
{
for
(
int
i
=
0
;
i
<
n
.
getNumChildren
(
)
;
i
++
)
{
setParameterRVA
(
n
.
getChild
(
i
)
,
formulaType
)
;
}
}
}
private
void
setParameterRVA
(
Node
n
,
int
expectedClass
,
int
formulaType
)
{
Ptg
p
=
(
Ptg
)
n
.
getValue
(
)
;
if
(
expectedClass
==
Ptg
.
CLASS_REF
)
{
if
(
p
.
getDefaultOperandClass
(
)
==
Ptg
.
CLASS_REF
)
{
setClass
(
n
,
Ptg
.
CLASS_REF
)
;
}
if
(
p
.
getDefaultOperandClass
(
)
==
Ptg
.
CLASS_VALUE
)
{
if
(
formulaType
==
FORMULA_TYPE_CELL
||
formulaType
==
FORMULA_TYPE_SHARED
)
{
setClass
(
n
,
Ptg
.
CLASS_VALUE
)
;
}
else
{
setClass
(
n
,
Ptg
.
CLASS_ARRAY
)
;
}
}
if
(
p
.
getDefaultOperandClass
(
)
==
Ptg
.
CLASS_ARRAY
)
{
setClass
(
n
,
Ptg
.
CLASS_ARRAY
)
;
}
}
else
if
(
expectedClass
==
Ptg
.
CLASS_VALUE
)
{
if
(
formulaType
==
FORMULA_TYPE_NAMEDRANGE
)
{
setClass
(
n
,
Ptg
.
CLASS_ARRAY
)
;
}
else
{
setClass
(
n
,
Ptg
.
CLASS_VALUE
)
;
}
}
else
{
if
(
p
.
getDefaultOperandClass
(
)
==
Ptg
.
CLASS_VALUE
&&
(
formulaType
==
FORMULA_TYPE_CELL
||
formulaType
==
FORMULA_TYPE_SHARED
)
)
{
setClass
(
n
,
Ptg
.
CLASS_VALUE
)
;
}
else
{
setClass
(
n
,
Ptg
.
CLASS_ARRAY
)
;
}
}
}
private
void
setClass
(
Node
n
,
byte
theClass
)
{
Ptg
p
=
(
Ptg
)
n
.
getValue
(
)
;
if
(
p
instanceof
AbstractFunctionPtg
||
!
(
p
instanceof
OperationPtg
)
)
{
p
.
setClass
(
theClass
)
;
}
else
{
for
(
int
i
=
0
;
i
<
n
.
getNumChildren
(
)
;
i
++
)
{
setClass
(
n
.
getChild
(
i
)
,
theClass
)
;
}
}
}
public
static
String
toFormulaString
(
Workbook
book
,
List
lptgs
)
{
String
retval
=
null
;
if
(
lptgs
==
null
||
lptgs
.
size
(
)
==
0
)
return
"#NAME"
;
Ptg
[
]
ptgs
=
new
Ptg
[
lptgs
.
size
(
)
]
;
ptgs
=
(
Ptg
[
]
)
lptgs
.
toArray
(
ptgs
)
;
retval
=
toFormulaString
(
book
,
ptgs
)
;
return
retval
;
}
public
static
String
toFormulaString
(
Workbook
book
,
Ptg
[
]
ptgs
)
{
if
(
ptgs
==
null
||
ptgs
.
length
==
0
)
return
"#NAME"
;
java
.
util
.
Stack
stack
=
new
java
.
util
.
Stack
(
)
;
AttrPtg
ifptg
=
null
;
stack
.
push
(
ptgs
[
0
]
.
toFormulaString
(
book
)
)
;
for
(
int
i
=
1
;
i
<
ptgs
.
length
;
i
++
)
{
if
(
!
(
ptgs
[
i
]
instanceof
OperationPtg
)
)
{
stack
.
push
(
ptgs
[
i
]
.
toFormulaString
(
book
)
)
;
continue
;
}
if
(
ptgs
[
i
]
instanceof
AttrPtg
&&
(
(
AttrPtg
)
ptgs
[
i
]
)
.
isOptimizedIf
(
)
)
{
ifptg
=
(
AttrPtg
)
ptgs
[
i
]
;
continue
;
}
final
OperationPtg
o
=
(
OperationPtg
)
ptgs
[
i
]
;
final
String
[
]
operands
=
new
String
[
o
.
getNumberOfOperands
(
)
]
;
for
(
int
j
=
operands
.
length
;
j
>
0
;
j
--
)
{
operands
[
j
-
1
]
=
(
String
)
stack
.
pop
(
)
;
}
stack
.
push
(
o
.
toFormulaString
(
operands
)
)
;
if
(
!
(
o
instanceof
AbstractFunctionPtg
)
)
continue
;
final
AbstractFunctionPtg
f
=
(
AbstractFunctionPtg
)
o
;
final
String
fname
=
f
.
getName
(
)
;
if
(
fname
==
null
)
continue
;
if
(
(
ifptg
!=
null
)
&&
(
fname
.
equals
(
"specialflag"
)
)
)
{
stack
.
push
(
ifptg
.
toFormulaString
(
new
String
[
]
{
(
String
)
stack
.
pop
(
)
}
)
)
;
continue
;
}
if
(
fname
.
equals
(
"externalflag"
)
)
{
final
String
top
=
(
String
)
stack
.
pop
(
)
;
final
int
paren
=
top
.
indexOf
(
'('
)
;
final
int
comma
=
top
.
indexOf
(
','
)
;
if
(
comma
==
-
1
)
{
final
int
rparen
=
top
.
indexOf
(
')'
)
;
stack
.
push
(
top
.
substring
(
paren
+
1
,
rparen
)
+
"()"
)
;
}
else
{
stack
.
push
(
top
.
substring
(
paren
+
1
,
comma
)
+
'('
+
top
.
substring
(
comma
+
1
)
)
;
}
}
}
return
(
String
)
stack
.
pop
(
)
;
}
private
Node
createTree
(
)
{
java
.
util
.
Stack
stack
=
new
java
.
util
.
Stack
(
)
;
int
numPtgs
=
tokens
.
size
(
)
;
OperationPtg
o
;
int
numOperands
;
Node
[
]
operands
;
for
(
int
i
=
0
;
i
<
numPtgs
;
i
++
)
{
if
(
tokens
.
get
(
i
)
instanceof
OperationPtg
)
{
o
=
(
OperationPtg
)
tokens
.
get
(
i
)
;
numOperands
=
o
.
getNumberOfOperands
(
)
;
operands
=
new
Node
[
numOperands
]
;
for
(
int
j
=
0
;
j
<
numOperands
;
j
++
)
{
operands
[
numOperands
-
j
-
1
]
=
(
Node
)
stack
.
pop
(
)
;
}
Node
result
=
new
Node
(
o
)
;
result
.
setChildren
(
operands
)
;
stack
.
push
(
result
)
;
}
else
{
stack
.
push
(
new
Node
(
(
Ptg
)
tokens
.
get
(
i
)
)
)
;
}
}
return
(
Node
)
stack
.
pop
(
)
;
}
public
String
toString
(
)
{
StringBuffer
buf
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
tokens
.
size
(
)
;
i
++
)
{
buf
.
append
(
(
(
Ptg
)
tokens
.
get
(
i
)
)
.
toFormulaString
(
book
)
)
;
buf
.
append
(
' '
)
;
}
return
buf
.
toString
(
)
;
}
}
class
Node
{
private
Ptg
value
=
null
;
private
Node
[
]
children
=
new
Node
[
0
]
;
private
int
numChild
=
0
;
public
Node
(
Ptg
val
)
{
value
=
val
;
}
public
void
setChildren
(
Node
[
]
child
)
{
children
=
child
;
numChild
=
child
.
length
;
}
public
int
getNumChildren
(
)
{
return
numChild
;
}
public
Node
getChild
(
int
number
)
{
return
children
[
number
]
;
}
public
Ptg
getValue
(
)
{
return
value
;
}
}
