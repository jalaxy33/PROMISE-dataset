package
org
.
apache
.
poi
.
hpsf
;
import
java
.
io
.
*
;
import
java
.
util
.
*
;
import
org
.
apache
.
poi
.
hpsf
.
wellknown
.
*
;
import
org
.
apache
.
poi
.
poifs
.
filesystem
.
*
;
import
org
.
apache
.
poi
.
util
.
LittleEndian
;
public
class
PropertySet
{
final
static
byte
[
]
BYTE_ORDER_ASSERTION
=
new
byte
[
]
{
(
byte
)
0xFE
,
(
byte
)
0xFF
}
;
protected
int
byteOrder
;
public
int
getByteOrder
(
)
{
return
byteOrder
;
}
final
static
byte
[
]
FORMAT_ASSERTION
=
new
byte
[
]
{
(
byte
)
0x00
,
(
byte
)
0x00
}
;
protected
int
format
;
public
int
getFormat
(
)
{
return
format
;
}
protected
int
osVersion
;
public
final
static
int
OS_WIN16
=
0x0000
;
public
final
static
int
OS_MACINTOSH
=
0x0001
;
public
final
static
int
OS_WIN32
=
0x0002
;
public
long
getOSVersion
(
)
{
return
osVersion
;
}
protected
ClassID
classID
;
public
ClassID
getClassID
(
)
{
return
classID
;
}
protected
int
sectionCount
;
public
long
getSectionCount
(
)
{
return
sectionCount
;
}
protected
List
sections
;
public
List
getSections
(
)
{
return
sections
;
}
protected
PropertySet
(
)
{
}
public
PropertySet
(
final
InputStream
stream
)
throws
NoPropertySetStreamException
,
MarkUnsupportedException
,
IOException
{
if
(
isPropertySetStream
(
stream
)
)
{
final
int
avail
=
stream
.
available
(
)
;
final
byte
[
]
buffer
=
new
byte
[
avail
]
;
stream
.
read
(
buffer
,
0
,
buffer
.
length
)
;
init
(
buffer
,
0
,
buffer
.
length
)
;
}
else
throw
new
NoPropertySetStreamException
(
)
;
}
public
PropertySet
(
final
byte
[
]
stream
,
final
int
offset
,
final
int
length
)
throws
NoPropertySetStreamException
{
if
(
isPropertySetStream
(
stream
,
offset
,
length
)
)
init
(
stream
,
offset
,
length
)
;
else
throw
new
NoPropertySetStreamException
(
)
;
}
public
PropertySet
(
final
byte
[
]
stream
)
throws
NoPropertySetStreamException
{
this
(
stream
,
0
,
stream
.
length
)
;
}
public
static
boolean
isPropertySetStream
(
final
InputStream
stream
)
throws
MarkUnsupportedException
,
IOException
{
final
int
BUFFER_SIZE
=
50
;
if
(
!
stream
.
markSupported
(
)
)
throw
new
MarkUnsupportedException
(
stream
.
getClass
(
)
.
getName
(
)
)
;
stream
.
mark
(
BUFFER_SIZE
)
;
final
byte
[
]
buffer
=
new
byte
[
BUFFER_SIZE
]
;
final
int
bytes
=
stream
.
read
(
buffer
,
0
,
Math
.
min
(
buffer
.
length
,
stream
.
available
(
)
)
)
;
final
boolean
isPropertySetStream
=
isPropertySetStream
(
buffer
,
0
,
bytes
)
;
stream
.
reset
(
)
;
return
isPropertySetStream
;
}
public
static
boolean
isPropertySetStream
(
final
byte
[
]
src
,
int
offset
,
final
int
length
)
{
final
int
byteOrder
=
LittleEndian
.
getUShort
(
src
,
offset
)
;
offset
+=
LittleEndian
.
SHORT_SIZE
;
byte
[
]
temp
=
new
byte
[
LittleEndian
.
SHORT_SIZE
]
;
LittleEndian
.
putShort
(
temp
,
(
short
)
byteOrder
)
;
if
(
!
Util
.
equal
(
temp
,
BYTE_ORDER_ASSERTION
)
)
return
false
;
final
int
format
=
LittleEndian
.
getUShort
(
src
,
offset
)
;
offset
+=
LittleEndian
.
SHORT_SIZE
;
temp
=
new
byte
[
LittleEndian
.
SHORT_SIZE
]
;
LittleEndian
.
putShort
(
temp
,
(
short
)
format
)
;
if
(
!
Util
.
equal
(
temp
,
FORMAT_ASSERTION
)
)
return
false
;
final
long
osVersion
=
LittleEndian
.
getUInt
(
src
,
offset
)
;
offset
+=
LittleEndian
.
INT_SIZE
;
final
ClassID
classID
=
new
ClassID
(
src
,
offset
)
;
offset
+=
ClassID
.
LENGTH
;
final
long
sectionCount
=
LittleEndian
.
getUInt
(
src
,
offset
)
;
offset
+=
LittleEndian
.
INT_SIZE
;
if
(
sectionCount
<
1
)
return
false
;
return
true
;
}
private
void
init
(
final
byte
[
]
src
,
int
offset
,
final
int
length
)
{
byteOrder
=
LittleEndian
.
getUShort
(
src
,
offset
)
;
offset
+=
LittleEndian
.
SHORT_SIZE
;
format
=
LittleEndian
.
getUShort
(
src
,
offset
)
;
offset
+=
LittleEndian
.
SHORT_SIZE
;
osVersion
=
(
int
)
LittleEndian
.
getUInt
(
src
,
offset
)
;
offset
+=
LittleEndian
.
INT_SIZE
;
classID
=
new
ClassID
(
src
,
offset
)
;
offset
+=
ClassID
.
LENGTH
;
sectionCount
=
LittleEndian
.
getInt
(
src
,
offset
)
;
offset
+=
LittleEndian
.
INT_SIZE
;
if
(
sectionCount
<=
0
)
throw
new
HPSFRuntimeException
(
"Section count "
+
sectionCount
+
" must be greater than 0."
)
;
sections
=
new
ArrayList
(
2
)
;
for
(
int
i
=
0
;
i
<
sectionCount
;
i
++
)
{
final
Section
s
=
new
Section
(
src
,
offset
)
;
offset
+=
ClassID
.
LENGTH
+
LittleEndian
.
INT_SIZE
;
sections
.
add
(
s
)
;
}
}
public
boolean
isSummaryInformation
(
)
{
return
Util
.
equal
(
(
(
Section
)
sections
.
get
(
0
)
)
.
getFormatID
(
)
.
getBytes
(
)
,
SectionIDMap
.
SUMMARY_INFORMATION_ID
)
;
}
public
boolean
isDocumentSummaryInformation
(
)
{
return
Util
.
equal
(
(
(
Section
)
sections
.
get
(
0
)
)
.
getFormatID
(
)
.
getBytes
(
)
,
SectionIDMap
.
DOCUMENT_SUMMARY_INFORMATION_ID
)
;
}
public
Property
[
]
getProperties
(
)
throws
NoSingleSectionException
{
return
getSingleSection
(
)
.
getProperties
(
)
;
}
protected
Object
getProperty
(
final
int
id
)
throws
NoSingleSectionException
{
return
getSingleSection
(
)
.
getProperty
(
id
)
;
}
protected
boolean
getPropertyBooleanValue
(
final
int
id
)
throws
NoSingleSectionException
{
return
getSingleSection
(
)
.
getPropertyBooleanValue
(
id
)
;
}
protected
int
getPropertyIntValue
(
final
int
id
)
throws
NoSingleSectionException
{
return
getSingleSection
(
)
.
getPropertyIntValue
(
id
)
;
}
public
boolean
wasNull
(
)
throws
NoSingleSectionException
{
return
getSingleSection
(
)
.
wasNull
(
)
;
}
public
Section
getSingleSection
(
)
{
if
(
sectionCount
!=
1
)
throw
new
NoSingleSectionException
(
"Property set contains "
+
sectionCount
+
" sections."
)
;
return
(
(
Section
)
sections
.
get
(
0
)
)
;
}
}
