package
org
.
apache
.
poi
.
poifs
.
storage
;
import
java
.
io
.
IOException
;
import
java
.
util
.
*
;
import
org
.
apache
.
poi
.
poifs
.
common
.
POIFSConstants
;
import
org
.
apache
.
poi
.
util
.
IntList
;
import
org
.
apache
.
poi
.
util
.
LittleEndian
;
import
org
.
apache
.
poi
.
util
.
LittleEndianConsts
;
public
class
BlockAllocationTableReader
{
private
IntList
_entries
;
public
BlockAllocationTableReader
(
final
int
block_count
,
final
int
[
]
block_array
,
final
int
xbat_count
,
final
int
xbat_index
,
final
BlockList
raw_block_list
)
throws
IOException
{
this
(
)
;
if
(
block_count
<=
0
)
{
throw
new
IOException
(
"Illegal block count; minimum count is 1, got "
+
block_count
+
" instead"
)
;
}
RawDataBlock
blocks
[
]
=
new
RawDataBlock
[
block_count
]
;
int
limit
=
Math
.
min
(
block_count
,
block_array
.
length
)
;
int
block_index
;
for
(
block_index
=
0
;
block_index
<
limit
;
block_index
++
)
{
blocks
[
block_index
]
=
(
RawDataBlock
)
raw_block_list
.
remove
(
block_array
[
block_index
]
)
;
}
if
(
block_index
<
block_count
)
{
if
(
xbat_index
<
0
)
{
throw
new
IOException
(
"BAT count exceeds limit, yet XBAT index indicates no valid entries"
)
;
}
int
chain_index
=
xbat_index
;
int
max_entries_per_block
=
BATBlock
.
entriesPerXBATBlock
(
)
;
int
chain_index_offset
=
BATBlock
.
getXBATChainOffset
(
)
;
for
(
int
j
=
0
;
j
<
xbat_count
;
j
++
)
{
limit
=
Math
.
min
(
block_count
-
block_index
,
max_entries_per_block
)
;
byte
[
]
data
=
raw_block_list
.
remove
(
chain_index
)
.
getData
(
)
;
int
offset
=
0
;
for
(
int
k
=
0
;
k
<
limit
;
k
++
)
{
blocks
[
block_index
++
]
=
(
RawDataBlock
)
raw_block_list
.
remove
(
LittleEndian
.
getInt
(
data
,
offset
)
)
;
offset
+=
LittleEndianConsts
.
INT_SIZE
;
}
chain_index
=
LittleEndian
.
getInt
(
data
,
chain_index_offset
)
;
if
(
chain_index
==
POIFSConstants
.
END_OF_CHAIN
)
{
break
;
}
}
}
if
(
block_index
!=
block_count
)
{
throw
new
IOException
(
"Could not find all blocks"
)
;
}
setEntries
(
blocks
,
raw_block_list
)
;
}
BlockAllocationTableReader
(
final
ListManagedBlock
[
]
blocks
,
final
BlockList
raw_block_list
)
throws
IOException
{
this
(
)
;
setEntries
(
blocks
,
raw_block_list
)
;
}
BlockAllocationTableReader
(
)
{
_entries
=
new
IntList
(
)
;
}
ListManagedBlock
[
]
fetchBlocks
(
final
int
startBlock
,
final
BlockList
blockList
)
throws
IOException
{
List
blocks
=
new
ArrayList
(
)
;
int
currentBlock
=
startBlock
;
while
(
currentBlock
!=
POIFSConstants
.
END_OF_CHAIN
)
{
blocks
.
add
(
blockList
.
remove
(
currentBlock
)
)
;
currentBlock
=
_entries
.
get
(
currentBlock
)
;
}
return
(
ListManagedBlock
[
]
)
blocks
.
toArray
(
new
ListManagedBlock
[
0
]
)
;
}
boolean
isUsed
(
final
int
index
)
{
boolean
rval
=
false
;
try
{
rval
=
_entries
.
get
(
index
)
!=
-
1
;
}
catch
(
IndexOutOfBoundsException
ignored
)
{
}
return
rval
;
}
int
getNextBlockIndex
(
final
int
index
)
throws
IOException
{
if
(
isUsed
(
index
)
)
{
return
_entries
.
get
(
index
)
;
}
else
{
throw
new
IOException
(
"index "
+
index
+
" is unused"
)
;
}
}
private
void
setEntries
(
final
ListManagedBlock
[
]
blocks
,
final
BlockList
raw_blocks
)
throws
IOException
{
int
limit
=
BATBlock
.
entriesPerBlock
(
)
;
for
(
int
block_index
=
0
;
block_index
<
blocks
.
length
;
block_index
++
)
{
byte
[
]
data
=
blocks
[
block_index
]
.
getData
(
)
;
int
offset
=
0
;
for
(
int
k
=
0
;
k
<
limit
;
k
++
)
{
int
entry
=
LittleEndian
.
getInt
(
data
,
offset
)
;
if
(
entry
==
POIFSConstants
.
UNUSED_BLOCK
)
{
raw_blocks
.
zap
(
_entries
.
size
(
)
)
;
}
_entries
.
add
(
entry
)
;
offset
+=
LittleEndianConsts
.
INT_SIZE
;
}
blocks
[
block_index
]
=
null
;
}
raw_blocks
.
setBAT
(
this
)
;
}
}
