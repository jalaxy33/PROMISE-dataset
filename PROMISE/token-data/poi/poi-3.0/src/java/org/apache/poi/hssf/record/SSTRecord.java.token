package
org
.
apache
.
poi
.
hssf
.
record
;
import
org
.
apache
.
poi
.
util
.
IntMapper
;
import
org
.
apache
.
poi
.
util
.
LittleEndianConsts
;
import
java
.
util
.
Iterator
;
public
class
SSTRecord
extends
Record
{
private
static
UnicodeString
EMPTY_STRING
=
new
UnicodeString
(
""
)
;
static
final
int
MAX_RECORD_SIZE
=
8228
;
static
final
int
STD_RECORD_OVERHEAD
=
2
*
LittleEndianConsts
.
SHORT_SIZE
;
static
final
int
SST_RECORD_OVERHEAD
=
(
STD_RECORD_OVERHEAD
+
(
2
*
LittleEndianConsts
.
INT_SIZE
)
)
;
static
final
int
MAX_DATA_SPACE
=
MAX_RECORD_SIZE
-
SST_RECORD_OVERHEAD
;
static
final
int
STRING_MINIMAL_OVERHEAD
=
LittleEndianConsts
.
SHORT_SIZE
+
LittleEndianConsts
.
BYTE_SIZE
;
public
static
final
short
sid
=
0xfc
;
private
int
field_1_num_strings
;
private
int
field_2_num_unique_strings
;
private
IntMapper
field_3_strings
;
private
SSTDeserializer
deserializer
;
int
[
]
bucketAbsoluteOffsets
;
int
[
]
bucketRelativeOffsets
;
public
SSTRecord
(
)
{
field_1_num_strings
=
0
;
field_2_num_unique_strings
=
0
;
field_3_strings
=
new
IntMapper
(
)
;
deserializer
=
new
SSTDeserializer
(
field_3_strings
)
;
}
public
SSTRecord
(
RecordInputStream
in
)
{
super
(
in
)
;
}
public
int
addString
(
final
UnicodeString
string
)
{
field_1_num_strings
++
;
UnicodeString
ucs
=
(
string
==
null
)
?
EMPTY_STRING
:
string
;
int
rval
;
int
index
=
field_3_strings
.
getIndex
(
ucs
)
;
if
(
index
!=
-
1
)
{
rval
=
index
;
}
else
{
rval
=
field_3_strings
.
size
(
)
;
field_2_num_unique_strings
++
;
SSTDeserializer
.
addToStringTable
(
field_3_strings
,
ucs
)
;
}
return
rval
;
}
public
int
getNumStrings
(
)
{
return
field_1_num_strings
;
}
public
int
getNumUniqueStrings
(
)
{
return
field_2_num_unique_strings
;
}
public
void
setNumStrings
(
final
int
count
)
{
field_1_num_strings
=
count
;
}
public
void
setNumUniqueStrings
(
final
int
count
)
{
field_2_num_unique_strings
=
count
;
}
public
UnicodeString
getString
(
final
int
id
)
{
return
(
UnicodeString
)
field_3_strings
.
get
(
id
)
;
}
public
boolean
isString16bit
(
final
int
id
)
{
UnicodeString
unicodeString
=
(
(
UnicodeString
)
field_3_strings
.
get
(
id
)
)
;
return
(
(
unicodeString
.
getOptionFlags
(
)
&
0x01
)
==
1
)
;
}
public
String
toString
(
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
buffer
.
append
(
"[SST]\n"
)
;
buffer
.
append
(
"    .numstrings     = "
)
.
append
(
Integer
.
toHexString
(
getNumStrings
(
)
)
)
.
append
(
"\n"
)
;
buffer
.
append
(
"    .uniquestrings  = "
)
.
append
(
Integer
.
toHexString
(
getNumUniqueStrings
(
)
)
)
.
append
(
"\n"
)
;
for
(
int
k
=
0
;
k
<
field_3_strings
.
size
(
)
;
k
++
)
{
UnicodeString
s
=
(
UnicodeString
)
field_3_strings
.
get
(
k
)
;
buffer
.
append
(
"    .string_"
+
k
+
"      = "
)
.
append
(
s
.
getDebugInfo
(
)
)
.
append
(
"\n"
)
;
}
buffer
.
append
(
"[/SST]\n"
)
;
return
buffer
.
toString
(
)
;
}
public
short
getSid
(
)
{
return
sid
;
}
public
int
hashCode
(
)
{
return
field_2_num_unique_strings
;
}
public
boolean
equals
(
Object
o
)
{
if
(
(
o
==
null
)
||
(
o
.
getClass
(
)
!=
this
.
getClass
(
)
)
)
{
return
false
;
}
SSTRecord
other
=
(
SSTRecord
)
o
;
return
(
(
field_1_num_strings
==
other
.
field_1_num_strings
)
&&
(
field_2_num_unique_strings
==
other
.
field_2_num_unique_strings
)
&&
field_3_strings
.
equals
(
other
.
field_3_strings
)
)
;
}
protected
void
validateSid
(
final
short
id
)
throws
RecordFormatException
{
if
(
id
!=
sid
)
{
throw
new
RecordFormatException
(
"NOT An SST RECORD"
)
;
}
}
protected
void
fillFields
(
RecordInputStream
in
)
{
field_1_num_strings
=
in
.
readInt
(
)
;
field_2_num_unique_strings
=
in
.
readInt
(
)
;
field_3_strings
=
new
IntMapper
(
)
;
deserializer
=
new
SSTDeserializer
(
field_3_strings
)
;
deserializer
.
manufactureStrings
(
field_2_num_unique_strings
,
in
)
;
}
Iterator
getStrings
(
)
{
return
field_3_strings
.
iterator
(
)
;
}
int
countStrings
(
)
{
return
field_3_strings
.
size
(
)
;
}
public
int
serialize
(
int
offset
,
byte
[
]
data
)
{
SSTSerializer
serializer
=
new
SSTSerializer
(
field_3_strings
,
getNumStrings
(
)
,
getNumUniqueStrings
(
)
)
;
int
bytes
=
serializer
.
serialize
(
offset
,
data
)
;
bucketAbsoluteOffsets
=
serializer
.
getBucketAbsoluteOffsets
(
)
;
bucketRelativeOffsets
=
serializer
.
getBucketRelativeOffsets
(
)
;
return
bytes
;
}
public
int
getRecordSize
(
)
{
SSTRecordSizeCalculator
calculator
=
new
SSTRecordSizeCalculator
(
field_3_strings
)
;
int
recordSize
=
calculator
.
getRecordSize
(
)
;
return
recordSize
;
}
SSTDeserializer
getDeserializer
(
)
{
return
deserializer
;
}
public
ExtSSTRecord
createExtSSTRecord
(
int
sstOffset
)
{
if
(
bucketAbsoluteOffsets
==
null
||
bucketAbsoluteOffsets
==
null
)
throw
new
IllegalStateException
(
"SST record has not yet been serialized."
)
;
ExtSSTRecord
extSST
=
new
ExtSSTRecord
(
)
;
extSST
.
setNumStringsPerBucket
(
(
short
)
8
)
;
int
[
]
absoluteOffsets
=
(
int
[
]
)
bucketAbsoluteOffsets
.
clone
(
)
;
int
[
]
relativeOffsets
=
(
int
[
]
)
bucketRelativeOffsets
.
clone
(
)
;
for
(
int
i
=
0
;
i
<
absoluteOffsets
.
length
;
i
++
)
absoluteOffsets
[
i
]
+=
sstOffset
;
extSST
.
setBucketOffsets
(
absoluteOffsets
,
relativeOffsets
)
;
return
extSST
;
}
public
int
calcExtSSTRecordSize
(
)
{
return
ExtSSTRecord
.
getRecordSizeForStrings
(
field_3_strings
.
size
(
)
)
;
}
}
