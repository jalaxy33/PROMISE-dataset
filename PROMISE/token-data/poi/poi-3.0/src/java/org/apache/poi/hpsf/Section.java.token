package
org
.
apache
.
poi
.
hpsf
;
import
java
.
io
.
UnsupportedEncodingException
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Collections
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
org
.
apache
.
poi
.
hpsf
.
wellknown
.
PropertyIDMap
;
import
org
.
apache
.
poi
.
hpsf
.
wellknown
.
SectionIDMap
;
import
org
.
apache
.
poi
.
util
.
LittleEndian
;
public
class
Section
{
protected
Map
dictionary
;
protected
ClassID
formatID
;
public
ClassID
getFormatID
(
)
{
return
formatID
;
}
protected
long
offset
;
public
long
getOffset
(
)
{
return
offset
;
}
protected
int
size
;
public
int
getSize
(
)
{
return
size
;
}
public
int
getPropertyCount
(
)
{
return
properties
.
length
;
}
protected
Property
[
]
properties
;
public
Property
[
]
getProperties
(
)
{
return
properties
;
}
protected
Section
(
)
{
}
public
Section
(
final
byte
[
]
src
,
final
int
offset
)
throws
UnsupportedEncodingException
{
int
o1
=
offset
;
formatID
=
new
ClassID
(
src
,
o1
)
;
o1
+=
ClassID
.
LENGTH
;
this
.
offset
=
LittleEndian
.
getUInt
(
src
,
o1
)
;
o1
=
(
int
)
this
.
offset
;
size
=
(
int
)
LittleEndian
.
getUInt
(
src
,
o1
)
;
o1
+=
LittleEndian
.
INT_SIZE
;
final
int
propertyCount
=
(
int
)
LittleEndian
.
getUInt
(
src
,
o1
)
;
o1
+=
LittleEndian
.
INT_SIZE
;
properties
=
new
Property
[
propertyCount
]
;
int
pass1Offset
=
o1
;
List
propertyList
=
new
ArrayList
(
propertyCount
)
;
PropertyListEntry
ple
;
for
(
int
i
=
0
;
i
<
properties
.
length
;
i
++
)
{
ple
=
new
PropertyListEntry
(
)
;
ple
.
id
=
(
int
)
LittleEndian
.
getUInt
(
src
,
pass1Offset
)
;
pass1Offset
+=
LittleEndian
.
INT_SIZE
;
ple
.
offset
=
(
int
)
LittleEndian
.
getUInt
(
src
,
pass1Offset
)
;
pass1Offset
+=
LittleEndian
.
INT_SIZE
;
propertyList
.
add
(
ple
)
;
}
Collections
.
sort
(
propertyList
)
;
for
(
int
i
=
0
;
i
<
propertyCount
-
1
;
i
++
)
{
final
PropertyListEntry
ple1
=
(
PropertyListEntry
)
propertyList
.
get
(
i
)
;
final
PropertyListEntry
ple2
=
(
PropertyListEntry
)
propertyList
.
get
(
i
+
1
)
;
ple1
.
length
=
ple2
.
offset
-
ple1
.
offset
;
}
if
(
propertyCount
>
0
)
{
ple
=
(
PropertyListEntry
)
propertyList
.
get
(
propertyCount
-
1
)
;
ple
.
length
=
size
-
ple
.
offset
;
}
int
codepage
=
-
1
;
for
(
final
Iterator
i
=
propertyList
.
iterator
(
)
;
codepage
==
-
1
&&
i
.
hasNext
(
)
;
)
{
ple
=
(
PropertyListEntry
)
i
.
next
(
)
;
if
(
ple
.
id
==
PropertyIDMap
.
PID_CODEPAGE
)
{
int
o
=
(
int
)
(
this
.
offset
+
ple
.
offset
)
;
final
long
type
=
LittleEndian
.
getUInt
(
src
,
o
)
;
o
+=
LittleEndian
.
INT_SIZE
;
if
(
type
!=
Variant
.
VT_I2
)
throw
new
HPSFRuntimeException
(
"Value type of property ID 1 is not VT_I2 but "
+
type
+
"."
)
;
codepage
=
LittleEndian
.
getUShort
(
src
,
o
)
;
}
}
int
i1
=
0
;
for
(
final
Iterator
i
=
propertyList
.
iterator
(
)
;
i
.
hasNext
(
)
;
)
{
ple
=
(
PropertyListEntry
)
i
.
next
(
)
;
Property
p
=
new
Property
(
ple
.
id
,
src
,
this
.
offset
+
ple
.
offset
,
ple
.
length
,
codepage
)
;
if
(
p
.
getID
(
)
==
PropertyIDMap
.
PID_CODEPAGE
)
p
=
new
Property
(
p
.
getID
(
)
,
p
.
getType
(
)
,
new
Integer
(
codepage
)
)
;
properties
[
i1
++
]
=
p
;
}
dictionary
=
(
Map
)
getProperty
(
0
)
;
}
class
PropertyListEntry
implements
Comparable
{
int
id
;
int
offset
;
int
length
;
public
int
compareTo
(
final
Object
o
)
{
if
(
!
(
o
instanceof
PropertyListEntry
)
)
throw
new
ClassCastException
(
o
.
toString
(
)
)
;
final
int
otherOffset
=
(
(
PropertyListEntry
)
o
)
.
offset
;
if
(
offset
<
otherOffset
)
return
-
1
;
else
if
(
offset
==
otherOffset
)
return
0
;
else
return
1
;
}
}
public
Object
getProperty
(
final
long
id
)
{
wasNull
=
false
;
for
(
int
i
=
0
;
i
<
properties
.
length
;
i
++
)
if
(
id
==
properties
[
i
]
.
getID
(
)
)
return
properties
[
i
]
.
getValue
(
)
;
wasNull
=
true
;
return
null
;
}
protected
int
getPropertyIntValue
(
final
long
id
)
{
final
Number
i
;
final
Object
o
=
getProperty
(
id
)
;
if
(
o
==
null
)
return
0
;
if
(
!
(
o
instanceof
Long
||
o
instanceof
Integer
)
)
throw
new
HPSFRuntimeException
(
"This property is not an integer type, but "
+
o
.
getClass
(
)
.
getName
(
)
+
"."
)
;
i
=
(
Number
)
o
;
return
i
.
intValue
(
)
;
}
protected
boolean
getPropertyBooleanValue
(
final
int
id
)
{
final
Boolean
b
=
(
Boolean
)
getProperty
(
id
)
;
if
(
b
!=
null
)
return
b
.
booleanValue
(
)
;
else
return
false
;
}
private
boolean
wasNull
;
public
boolean
wasNull
(
)
{
return
wasNull
;
}
public
String
getPIDString
(
final
long
pid
)
{
String
s
=
null
;
if
(
dictionary
!=
null
)
s
=
(
String
)
dictionary
.
get
(
new
Long
(
pid
)
)
;
if
(
s
==
null
)
s
=
SectionIDMap
.
getPIDString
(
getFormatID
(
)
.
getBytes
(
)
,
pid
)
;
if
(
s
==
null
)
s
=
SectionIDMap
.
UNDEFINED
;
return
s
;
}
public
boolean
equals
(
final
Object
o
)
{
if
(
o
==
null
||
!
(
o
instanceof
Section
)
)
return
false
;
final
Section
s
=
(
Section
)
o
;
if
(
!
s
.
getFormatID
(
)
.
equals
(
getFormatID
(
)
)
)
return
false
;
Property
[
]
pa1
=
new
Property
[
getProperties
(
)
.
length
]
;
Property
[
]
pa2
=
new
Property
[
s
.
getProperties
(
)
.
length
]
;
System
.
arraycopy
(
getProperties
(
)
,
0
,
pa1
,
0
,
pa1
.
length
)
;
System
.
arraycopy
(
s
.
getProperties
(
)
,
0
,
pa2
,
0
,
pa2
.
length
)
;
Property
p10
=
null
;
Property
p20
=
null
;
for
(
int
i
=
0
;
i
<
pa1
.
length
;
i
++
)
{
final
long
id
=
pa1
[
i
]
.
getID
(
)
;
if
(
id
==
0
)
{
p10
=
pa1
[
i
]
;
pa1
=
remove
(
pa1
,
i
)
;
i
--
;
}
if
(
id
==
1
)
{
pa1
=
remove
(
pa1
,
i
)
;
i
--
;
}
}
for
(
int
i
=
0
;
i
<
pa2
.
length
;
i
++
)
{
final
long
id
=
pa2
[
i
]
.
getID
(
)
;
if
(
id
==
0
)
{
p20
=
pa2
[
i
]
;
pa2
=
remove
(
pa2
,
i
)
;
i
--
;
}
if
(
id
==
1
)
{
pa2
=
remove
(
pa2
,
i
)
;
i
--
;
}
}
if
(
pa1
.
length
!=
pa2
.
length
)
return
false
;
boolean
dictionaryEqual
=
true
;
if
(
p10
!=
null
&&
p20
!=
null
)
dictionaryEqual
=
p10
.
getValue
(
)
.
equals
(
p20
.
getValue
(
)
)
;
else
if
(
p10
!=
null
||
p20
!=
null
)
dictionaryEqual
=
false
;
if
(
!
dictionaryEqual
)
return
false
;
else
return
Util
.
equals
(
pa1
,
pa2
)
;
}
private
Property
[
]
remove
(
final
Property
[
]
pa
,
final
int
i
)
{
final
Property
[
]
h
=
new
Property
[
pa
.
length
-
1
]
;
if
(
i
>
0
)
System
.
arraycopy
(
pa
,
0
,
h
,
0
,
i
)
;
System
.
arraycopy
(
pa
,
i
+
1
,
h
,
i
,
h
.
length
-
i
)
;
return
h
;
}
public
int
hashCode
(
)
{
long
hashCode
=
0
;
hashCode
+=
getFormatID
(
)
.
hashCode
(
)
;
final
Property
[
]
pa
=
getProperties
(
)
;
for
(
int
i
=
0
;
i
<
pa
.
length
;
i
++
)
hashCode
+=
pa
[
i
]
.
hashCode
(
)
;
final
int
returnHashCode
=
(
int
)
(
hashCode
&
0x0ffffffffL
)
;
return
returnHashCode
;
}
public
String
toString
(
)
{
final
StringBuffer
b
=
new
StringBuffer
(
)
;
final
Property
[
]
pa
=
getProperties
(
)
;
b
.
append
(
getClass
(
)
.
getName
(
)
)
;
b
.
append
(
'['
)
;
b
.
append
(
"formatID: "
)
;
b
.
append
(
getFormatID
(
)
)
;
b
.
append
(
", offset: "
)
;
b
.
append
(
getOffset
(
)
)
;
b
.
append
(
", propertyCount: "
)
;
b
.
append
(
getPropertyCount
(
)
)
;
b
.
append
(
", size: "
)
;
b
.
append
(
getSize
(
)
)
;
b
.
append
(
", properties: [\n"
)
;
for
(
int
i
=
0
;
i
<
pa
.
length
;
i
++
)
{
b
.
append
(
pa
[
i
]
.
toString
(
)
)
;
b
.
append
(
",\n"
)
;
}
b
.
append
(
']'
)
;
b
.
append
(
']'
)
;
return
b
.
toString
(
)
;
}
public
Map
getDictionary
(
)
{
return
dictionary
;
}
public
int
getCodepage
(
)
{
final
Integer
codepage
=
(
Integer
)
getProperty
(
PropertyIDMap
.
PID_CODEPAGE
)
;
if
(
codepage
==
null
)
return
-
1
;
int
cp
=
codepage
.
intValue
(
)
;
return
cp
;
}
}
