package
org
.
apache
.
poi
.
hssf
.
record
.
formula
;
import
java
.
util
.
List
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Stack
;
import
org
.
apache
.
poi
.
hssf
.
model
.
Workbook
;
import
org
.
apache
.
poi
.
hssf
.
record
.
RecordInputStream
;
public
abstract
class
Ptg
{
public
static
Stack
createParsedExpressionTokens
(
short
size
,
RecordInputStream
in
)
{
Stack
stack
=
new
Stack
(
)
;
int
pos
=
0
;
List
arrayPtgs
=
null
;
while
(
pos
<
size
)
{
Ptg
ptg
=
Ptg
.
createPtg
(
in
)
;
if
(
ptg
instanceof
ArrayPtg
)
{
if
(
arrayPtgs
==
null
)
arrayPtgs
=
new
ArrayList
(
5
)
;
arrayPtgs
.
add
(
ptg
)
;
pos
+=
8
;
}
else
pos
+=
ptg
.
getSize
(
)
;
stack
.
push
(
ptg
)
;
}
if
(
arrayPtgs
!=
null
)
{
for
(
int
i
=
0
;
i
<
arrayPtgs
.
size
(
)
;
i
++
)
{
ArrayPtg
p
=
(
ArrayPtg
)
arrayPtgs
.
get
(
i
)
;
p
.
readTokenValues
(
in
)
;
}
}
return
stack
;
}
public
static
Ptg
createPtg
(
RecordInputStream
in
)
{
byte
id
=
in
.
readByte
(
)
;
Ptg
retval
=
null
;
switch
(
id
)
{
case
ExpPtg
.
sid
:
retval
=
new
ExpPtg
(
in
)
;
break
;
case
AddPtg
.
sid
:
retval
=
new
AddPtg
(
in
)
;
break
;
case
SubtractPtg
.
sid
:
retval
=
new
SubtractPtg
(
in
)
;
break
;
case
MultiplyPtg
.
sid
:
retval
=
new
MultiplyPtg
(
in
)
;
break
;
case
DividePtg
.
sid
:
retval
=
new
DividePtg
(
in
)
;
break
;
case
PowerPtg
.
sid
:
retval
=
new
PowerPtg
(
in
)
;
break
;
case
ConcatPtg
.
sid
:
retval
=
new
ConcatPtg
(
in
)
;
break
;
case
LessThanPtg
.
sid
:
retval
=
new
LessThanPtg
(
in
)
;
break
;
case
LessEqualPtg
.
sid
:
retval
=
new
LessEqualPtg
(
in
)
;
break
;
case
EqualPtg
.
sid
:
retval
=
new
EqualPtg
(
in
)
;
break
;
case
GreaterEqualPtg
.
sid
:
retval
=
new
GreaterEqualPtg
(
in
)
;
break
;
case
GreaterThanPtg
.
sid
:
retval
=
new
GreaterThanPtg
(
in
)
;
break
;
case
NotEqualPtg
.
sid
:
retval
=
new
NotEqualPtg
(
in
)
;
break
;
case
IntersectionPtg
.
sid
:
retval
=
new
IntersectionPtg
(
in
)
;
break
;
case
UnionPtg
.
sid
:
retval
=
new
UnionPtg
(
in
)
;
break
;
case
RangePtg
.
sid
:
retval
=
new
RangePtg
(
in
)
;
break
;
case
UnaryPlusPtg
.
sid
:
retval
=
new
UnaryPlusPtg
(
in
)
;
break
;
case
UnaryMinusPtg
.
sid
:
retval
=
new
UnaryMinusPtg
(
in
)
;
break
;
case
PercentPtg
.
sid
:
retval
=
new
PercentPtg
(
in
)
;
break
;
case
ParenthesisPtg
.
sid
:
retval
=
new
ParenthesisPtg
(
in
)
;
break
;
case
MissingArgPtg
.
sid
:
retval
=
new
MissingArgPtg
(
in
)
;
break
;
case
StringPtg
.
sid
:
retval
=
new
StringPtg
(
in
)
;
break
;
case
AttrPtg
.
sid
:
retval
=
new
AttrPtg
(
in
)
;
break
;
case
ErrPtg
.
sid
:
retval
=
new
ErrPtg
(
in
)
;
break
;
case
BoolPtg
.
sid
:
retval
=
new
BoolPtg
(
in
)
;
break
;
case
IntPtg
.
sid
:
retval
=
new
IntPtg
(
in
)
;
break
;
case
NumberPtg
.
sid
:
retval
=
new
NumberPtg
(
in
)
;
break
;
case
ArrayPtg
.
sid
:
retval
=
new
ArrayPtg
(
in
)
;
break
;
case
ArrayPtgV
.
sid
:
retval
=
new
ArrayPtgV
(
in
)
;
break
;
case
ArrayPtgA
.
sid
:
retval
=
new
ArrayPtgA
(
in
)
;
break
;
case
FuncPtg
.
sid
:
case
FuncPtg
.
sid
+
0x20
:
case
FuncPtg
.
sid
+
0x40
:
retval
=
new
FuncPtg
(
in
)
;
break
;
case
FuncVarPtg
.
sid
:
case
FuncVarPtg
.
sid
+
0x20
:
case
FuncVarPtg
.
sid
+
0x40
:
retval
=
new
FuncVarPtg
(
in
)
;
break
;
case
ReferencePtg
.
sid
:
retval
=
new
ReferencePtg
(
in
)
;
break
;
case
RefAPtg
.
sid
:
retval
=
new
RefAPtg
(
in
)
;
break
;
case
RefVPtg
.
sid
:
retval
=
new
RefVPtg
(
in
)
;
break
;
case
RefNAPtg
.
sid
:
retval
=
new
RefNAPtg
(
in
)
;
break
;
case
RefNPtg
.
sid
:
retval
=
new
RefNPtg
(
in
)
;
break
;
case
RefNVPtg
.
sid
:
retval
=
new
RefNVPtg
(
in
)
;
break
;
case
AreaPtg
.
sid
:
retval
=
new
AreaPtg
(
in
)
;
break
;
case
AreaVPtg
.
sid
:
retval
=
new
AreaVPtg
(
in
)
;
break
;
case
AreaAPtg
.
sid
:
retval
=
new
AreaAPtg
(
in
)
;
break
;
case
AreaNAPtg
.
sid
:
retval
=
new
AreaNAPtg
(
in
)
;
break
;
case
AreaNPtg
.
sid
:
retval
=
new
AreaNPtg
(
in
)
;
break
;
case
AreaNVPtg
.
sid
:
retval
=
new
AreaNVPtg
(
in
)
;
break
;
case
MemAreaPtg
.
sid
:
case
MemAreaPtg
.
sid
+
0x40
:
case
MemAreaPtg
.
sid
+
0x20
:
retval
=
new
MemAreaPtg
(
in
)
;
break
;
case
MemErrPtg
.
sid
:
case
MemErrPtg
.
sid
+
0x20
:
case
MemErrPtg
.
sid
+
0x40
:
retval
=
new
MemErrPtg
(
in
)
;
break
;
case
MemFuncPtg
.
sid
:
retval
=
new
MemFuncPtg
(
in
)
;
break
;
case
RefErrorPtg
.
sid
:
case
RefErrorPtg
.
sid
+
0x20
:
case
RefErrorPtg
.
sid
+
0x40
:
retval
=
new
RefErrorPtg
(
in
)
;
break
;
case
AreaErrPtg
.
sid
:
case
AreaErrPtg
.
sid
+
0x20
:
case
AreaErrPtg
.
sid
+
0x40
:
retval
=
new
AreaErrPtg
(
in
)
;
break
;
case
NamePtg
.
sid
:
case
NamePtg
.
sid
+
0x20
:
case
NamePtg
.
sid
+
0x40
:
retval
=
new
NamePtg
(
in
)
;
break
;
case
NameXPtg
.
sid
:
case
NameXPtg
.
sid
+
0x20
:
case
NameXPtg
.
sid
+
0x40
:
retval
=
new
NameXPtg
(
in
)
;
break
;
case
Area3DPtg
.
sid
:
case
Area3DPtg
.
sid
+
0x20
:
case
Area3DPtg
.
sid
+
0x40
:
retval
=
new
Area3DPtg
(
in
)
;
break
;
case
Ref3DPtg
.
sid
:
case
Ref3DPtg
.
sid
+
0x20
:
case
Ref3DPtg
.
sid
+
0x40
:
retval
=
new
Ref3DPtg
(
in
)
;
break
;
case
DeletedRef3DPtg
.
sid
:
case
DeletedRef3DPtg
.
sid
+
0x20
:
case
DeletedRef3DPtg
.
sid
+
0x40
:
retval
=
new
DeletedRef3DPtg
(
in
)
;
break
;
case
DeletedArea3DPtg
.
sid
:
case
DeletedArea3DPtg
.
sid
+
0x20
:
case
DeletedArea3DPtg
.
sid
+
0x40
:
retval
=
new
DeletedArea3DPtg
(
in
)
;
break
;
default
:
throw
new
java
.
lang
.
UnsupportedOperationException
(
" Unknown Ptg in Formula: 0x"
+
Integer
.
toHexString
(
(
int
)
id
)
+
" ("
+
(
int
)
id
+
")"
)
;
}
if
(
id
>
0x60
)
{
retval
.
setClass
(
CLASS_ARRAY
)
;
}
else
if
(
id
>
0x40
)
{
retval
.
setClass
(
CLASS_VALUE
)
;
}
else
{
retval
.
setClass
(
CLASS_REF
)
;
}
return
retval
;
}
public
static
int
serializePtgStack
(
Stack
expression
,
byte
[
]
array
,
int
offset
)
{
int
pos
=
0
;
int
size
=
0
;
if
(
expression
!=
null
)
size
=
expression
.
size
(
)
;
List
arrayPtgs
=
null
;
for
(
int
k
=
0
;
k
<
size
;
k
++
)
{
Ptg
ptg
=
(
Ptg
)
expression
.
get
(
k
)
;
ptg
.
writeBytes
(
array
,
pos
+
offset
)
;
if
(
ptg
instanceof
ArrayPtg
)
{
if
(
arrayPtgs
==
null
)
arrayPtgs
=
new
ArrayList
(
5
)
;
arrayPtgs
.
add
(
ptg
)
;
pos
+=
8
;
}
else
pos
+=
ptg
.
getSize
(
)
;
}
if
(
arrayPtgs
!=
null
)
{
for
(
int
i
=
0
;
i
<
arrayPtgs
.
size
(
)
;
i
++
)
{
ArrayPtg
p
=
(
ArrayPtg
)
arrayPtgs
.
get
(
i
)
;
pos
+=
p
.
writeTokenValueBytes
(
array
,
pos
+
offset
)
;
}
}
return
pos
;
}
public
abstract
int
getSize
(
)
;
public
final
byte
[
]
getBytes
(
)
{
int
size
=
getSize
(
)
;
byte
[
]
bytes
=
new
byte
[
size
]
;
writeBytes
(
bytes
,
0
)
;
return
bytes
;
}
public
abstract
void
writeBytes
(
byte
[
]
array
,
int
offset
)
;
public
abstract
String
toFormulaString
(
Workbook
book
)
;
public
String
toDebugString
(
)
{
byte
[
]
ba
=
new
byte
[
getSize
(
)
]
;
String
retval
=
null
;
writeBytes
(
ba
,
0
)
;
try
{
retval
=
org
.
apache
.
poi
.
util
.
HexDump
.
dump
(
ba
,
0
,
0
)
;
}
catch
(
Exception
e
)
{
e
.
printStackTrace
(
)
;
}
return
retval
;
}
public
String
toString
(
)
{
return
this
.
getClass
(
)
.
toString
(
)
;
}
public
static
final
byte
CLASS_REF
=
0x00
;
public
static
final
byte
CLASS_VALUE
=
0x20
;
public
static
final
byte
CLASS_ARRAY
=
0x40
;
protected
byte
ptgClass
=
CLASS_REF
;
public
void
setClass
(
byte
thePtgClass
)
{
ptgClass
=
thePtgClass
;
}
public
byte
getPtgClass
(
)
{
return
ptgClass
;
}
public
abstract
byte
getDefaultOperandClass
(
)
;
public
abstract
Object
clone
(
)
;
}
