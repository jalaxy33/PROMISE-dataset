package
org
.
apache
.
poi
.
hssf
.
usermodel
;
import
org
.
apache
.
poi
.
hssf
.
model
.
FormulaParser
;
import
org
.
apache
.
poi
.
hssf
.
model
.
Sheet
;
import
org
.
apache
.
poi
.
hssf
.
model
.
Workbook
;
import
org
.
apache
.
poi
.
hssf
.
record
.
*
;
import
org
.
apache
.
poi
.
hssf
.
record
.
aggregates
.
FormulaRecordAggregate
;
import
org
.
apache
.
poi
.
hssf
.
record
.
formula
.
Ptg
;
import
java
.
text
.
DateFormat
;
import
java
.
text
.
SimpleDateFormat
;
import
java
.
util
.
*
;
public
class
HSSFCell
{
public
final
static
int
CELL_TYPE_NUMERIC
=
0
;
public
final
static
int
CELL_TYPE_STRING
=
1
;
public
final
static
int
CELL_TYPE_FORMULA
=
2
;
public
final
static
int
CELL_TYPE_BLANK
=
3
;
public
final
static
int
CELL_TYPE_BOOLEAN
=
4
;
public
final
static
int
CELL_TYPE_ERROR
=
5
;
public
final
static
short
ENCODING_UNCHANGED
=
-
1
;
public
final
static
short
ENCODING_COMPRESSED_UNICODE
=
0
;
public
final
static
short
ENCODING_UTF_16
=
1
;
private
int
cellType
;
private
HSSFRichTextString
stringValue
;
private
short
encoding
=
ENCODING_UNCHANGED
;
private
Workbook
book
;
private
Sheet
sheet
;
private
CellValueRecordInterface
record
;
private
HSSFComment
comment
;
protected
HSSFCell
(
Workbook
book
,
Sheet
sheet
,
int
row
,
short
col
)
{
checkBounds
(
col
)
;
stringValue
=
null
;
this
.
book
=
book
;
this
.
sheet
=
sheet
;
short
xfindex
=
sheet
.
getXFIndexForColAt
(
col
)
;
setCellType
(
CELL_TYPE_BLANK
,
false
,
row
,
col
,
xfindex
)
;
}
protected
HSSFCell
(
Workbook
book
,
Sheet
sheet
,
int
row
,
short
col
,
int
type
)
{
checkBounds
(
col
)
;
cellType
=
-
1
;
stringValue
=
null
;
this
.
book
=
book
;
this
.
sheet
=
sheet
;
short
xfindex
=
sheet
.
getXFIndexForColAt
(
col
)
;
setCellType
(
type
,
false
,
row
,
col
,
xfindex
)
;
}
protected
HSSFCell
(
Workbook
book
,
Sheet
sheet
,
int
row
,
CellValueRecordInterface
cval
)
{
record
=
cval
;
cellType
=
determineType
(
cval
)
;
stringValue
=
null
;
this
.
book
=
book
;
this
.
sheet
=
sheet
;
switch
(
cellType
)
{
case
CELL_TYPE_STRING
:
stringValue
=
new
HSSFRichTextString
(
book
,
(
LabelSSTRecord
)
cval
)
;
break
;
case
CELL_TYPE_BLANK
:
break
;
case
CELL_TYPE_FORMULA
:
stringValue
=
new
HSSFRichTextString
(
(
(
FormulaRecordAggregate
)
cval
)
.
getStringValue
(
)
)
;
break
;
}
ExtendedFormatRecord
xf
=
book
.
getExFormatAt
(
cval
.
getXFIndex
(
)
)
;
setCellStyle
(
new
HSSFCellStyle
(
(
short
)
cval
.
getXFIndex
(
)
,
xf
)
)
;
}
private
HSSFCell
(
)
{
}
private
int
determineType
(
CellValueRecordInterface
cval
)
{
Record
record
=
(
Record
)
cval
;
int
sid
=
record
.
getSid
(
)
;
int
retval
=
0
;
switch
(
sid
)
{
case
NumberRecord
.
sid
:
retval
=
HSSFCell
.
CELL_TYPE_NUMERIC
;
break
;
case
BlankRecord
.
sid
:
retval
=
HSSFCell
.
CELL_TYPE_BLANK
;
break
;
case
LabelSSTRecord
.
sid
:
retval
=
HSSFCell
.
CELL_TYPE_STRING
;
break
;
case
FormulaRecordAggregate
.
sid
:
retval
=
HSSFCell
.
CELL_TYPE_FORMULA
;
break
;
case
BoolErrRecord
.
sid
:
BoolErrRecord
boolErrRecord
=
(
BoolErrRecord
)
record
;
retval
=
(
boolErrRecord
.
isBoolean
(
)
)
?
HSSFCell
.
CELL_TYPE_BOOLEAN
:
HSSFCell
.
CELL_TYPE_ERROR
;
break
;
}
return
retval
;
}
public
void
setCellNum
(
short
num
)
{
record
.
setColumn
(
num
)
;
}
public
short
getCellNum
(
)
{
return
record
.
getColumn
(
)
;
}
public
void
setCellType
(
int
cellType
)
{
int
row
=
record
.
getRow
(
)
;
short
col
=
record
.
getColumn
(
)
;
short
styleIndex
=
record
.
getXFIndex
(
)
;
setCellType
(
cellType
,
true
,
row
,
col
,
styleIndex
)
;
}
private
void
setCellType
(
int
cellType
,
boolean
setValue
,
int
row
,
short
col
,
short
styleIndex
)
{
if
(
cellType
>
CELL_TYPE_ERROR
)
{
throw
new
RuntimeException
(
"I have no idea what type that is!"
)
;
}
switch
(
cellType
)
{
case
CELL_TYPE_FORMULA
:
FormulaRecordAggregate
frec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
frec
=
new
FormulaRecordAggregate
(
new
FormulaRecord
(
)
,
null
)
;
}
else
{
frec
=
(
FormulaRecordAggregate
)
record
;
}
frec
.
setColumn
(
col
)
;
if
(
setValue
)
{
frec
.
getFormulaRecord
(
)
.
setValue
(
getNumericCellValue
(
)
)
;
}
frec
.
setXFIndex
(
styleIndex
)
;
frec
.
setRow
(
row
)
;
record
=
frec
;
break
;
case
CELL_TYPE_NUMERIC
:
NumberRecord
nrec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
nrec
=
new
NumberRecord
(
)
;
}
else
{
nrec
=
(
NumberRecord
)
record
;
}
nrec
.
setColumn
(
col
)
;
if
(
setValue
)
{
nrec
.
setValue
(
getNumericCellValue
(
)
)
;
}
nrec
.
setXFIndex
(
styleIndex
)
;
nrec
.
setRow
(
row
)
;
record
=
nrec
;
break
;
case
CELL_TYPE_STRING
:
LabelSSTRecord
lrec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
lrec
=
new
LabelSSTRecord
(
)
;
}
else
{
lrec
=
(
LabelSSTRecord
)
record
;
}
lrec
.
setColumn
(
col
)
;
lrec
.
setRow
(
row
)
;
lrec
.
setXFIndex
(
styleIndex
)
;
if
(
setValue
)
{
if
(
(
getStringCellValue
(
)
!=
null
)
&&
(
!
getStringCellValue
(
)
.
equals
(
""
)
)
)
{
int
sst
=
0
;
UnicodeString
str
=
getRichStringCellValue
(
)
.
getUnicodeString
(
)
;
sst
=
book
.
addSSTString
(
str
)
;
lrec
.
setSSTIndex
(
sst
)
;
getRichStringCellValue
(
)
.
setUnicodeString
(
book
.
getSSTString
(
sst
)
)
;
}
}
record
=
lrec
;
break
;
case
CELL_TYPE_BLANK
:
BlankRecord
brec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
brec
=
new
BlankRecord
(
)
;
}
else
{
brec
=
(
BlankRecord
)
record
;
}
brec
.
setColumn
(
col
)
;
brec
.
setXFIndex
(
styleIndex
)
;
brec
.
setRow
(
row
)
;
record
=
brec
;
break
;
case
CELL_TYPE_BOOLEAN
:
BoolErrRecord
boolRec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
boolRec
=
new
BoolErrRecord
(
)
;
}
else
{
boolRec
=
(
BoolErrRecord
)
record
;
}
boolRec
.
setColumn
(
col
)
;
if
(
setValue
)
{
boolRec
.
setValue
(
getBooleanCellValue
(
)
)
;
}
boolRec
.
setXFIndex
(
styleIndex
)
;
boolRec
.
setRow
(
row
)
;
record
=
boolRec
;
break
;
case
CELL_TYPE_ERROR
:
BoolErrRecord
errRec
=
null
;
if
(
cellType
!=
this
.
cellType
)
{
errRec
=
new
BoolErrRecord
(
)
;
}
else
{
errRec
=
(
BoolErrRecord
)
record
;
}
errRec
.
setColumn
(
col
)
;
if
(
setValue
)
{
errRec
.
setValue
(
getErrorCellValue
(
)
)
;
}
errRec
.
setXFIndex
(
styleIndex
)
;
errRec
.
setRow
(
row
)
;
record
=
errRec
;
break
;
}
if
(
cellType
!=
this
.
cellType
&&
this
.
cellType
!=
-
1
)
{
int
loc
=
sheet
.
getLoc
(
)
;
sheet
.
replaceValueRecord
(
record
)
;
sheet
.
setLoc
(
loc
)
;
}
this
.
cellType
=
cellType
;
}
public
int
getCellType
(
)
{
return
cellType
;
}
public
void
setCellValue
(
double
value
)
{
int
row
=
record
.
getRow
(
)
;
short
col
=
record
.
getColumn
(
)
;
short
styleIndex
=
record
.
getXFIndex
(
)
;
if
(
(
cellType
!=
CELL_TYPE_NUMERIC
)
&&
(
cellType
!=
CELL_TYPE_FORMULA
)
)
{
setCellType
(
CELL_TYPE_NUMERIC
,
false
,
row
,
col
,
styleIndex
)
;
}
(
(
NumberRecord
)
record
)
.
setValue
(
value
)
;
}
public
void
setCellValue
(
Date
value
)
{
setCellValue
(
HSSFDateUtil
.
getExcelDate
(
value
)
)
;
}
public
void
setCellValue
(
Calendar
value
)
{
setCellValue
(
value
.
getTime
(
)
)
;
}
public
void
setCellValue
(
String
value
)
{
HSSFRichTextString
str
=
new
HSSFRichTextString
(
value
)
;
setCellValue
(
str
)
;
}
public
void
setCellValue
(
HSSFRichTextString
value
)
{
int
row
=
record
.
getRow
(
)
;
short
col
=
record
.
getColumn
(
)
;
short
styleIndex
=
record
.
getXFIndex
(
)
;
if
(
value
==
null
)
{
setCellType
(
CELL_TYPE_BLANK
,
false
,
row
,
col
,
styleIndex
)
;
}
else
{
if
(
(
cellType
!=
CELL_TYPE_STRING
)
&&
(
cellType
!=
CELL_TYPE_FORMULA
)
)
{
setCellType
(
CELL_TYPE_STRING
,
false
,
row
,
col
,
styleIndex
)
;
}
int
index
=
0
;
UnicodeString
str
=
value
.
getUnicodeString
(
)
;
index
=
book
.
addSSTString
(
str
)
;
(
(
LabelSSTRecord
)
record
)
.
setSSTIndex
(
index
)
;
stringValue
=
value
;
stringValue
.
setWorkbookReferences
(
book
,
(
(
LabelSSTRecord
)
record
)
)
;
stringValue
.
setUnicodeString
(
book
.
getSSTString
(
index
)
)
;
}
}
public
void
setCellFormula
(
String
formula
)
{
int
row
=
record
.
getRow
(
)
;
short
col
=
record
.
getColumn
(
)
;
short
styleIndex
=
record
.
getXFIndex
(
)
;
if
(
formula
==
null
)
{
setCellType
(
CELL_TYPE_BLANK
,
false
,
row
,
col
,
styleIndex
)
;
}
else
{
setCellType
(
CELL_TYPE_FORMULA
,
false
,
row
,
col
,
styleIndex
)
;
FormulaRecordAggregate
rec
=
(
FormulaRecordAggregate
)
record
;
FormulaRecord
frec
=
rec
.
getFormulaRecord
(
)
;
frec
.
setOptions
(
(
short
)
2
)
;
frec
.
setValue
(
0
)
;
if
(
rec
.
getXFIndex
(
)
==
(
short
)
0
)
rec
.
setXFIndex
(
(
short
)
0x0f
)
;
FormulaParser
fp
=
new
FormulaParser
(
formula
+
";"
,
book
)
;
fp
.
parse
(
)
;
Ptg
[
]
ptg
=
fp
.
getRPNPtg
(
)
;
int
size
=
0
;
for
(
int
i
=
0
,
iSize
=
frec
.
getNumberOfExpressionTokens
(
)
;
i
<
iSize
;
i
++
)
{
frec
.
popExpressionToken
(
)
;
}
for
(
int
k
=
0
;
k
<
ptg
.
length
;
k
++
)
{
size
+=
ptg
[
k
]
.
getSize
(
)
;
frec
.
pushExpressionToken
(
ptg
[
k
]
)
;
}
rec
.
getFormulaRecord
(
)
.
setExpressionLength
(
(
short
)
size
)
;
}
}
public
String
getCellFormula
(
)
{
String
retval
=
FormulaParser
.
toFormulaString
(
book
,
(
(
FormulaRecordAggregate
)
record
)
.
getFormulaRecord
(
)
.
getParsedExpression
(
)
)
;
return
retval
;
}
public
double
getNumericCellValue
(
)
{
if
(
cellType
==
CELL_TYPE_BLANK
)
{
return
0
;
}
if
(
cellType
==
CELL_TYPE_STRING
)
{
throw
new
NumberFormatException
(
"You cannot get a numeric value from a String based cell"
)
;
}
if
(
cellType
==
CELL_TYPE_BOOLEAN
)
{
throw
new
NumberFormatException
(
"You cannot get a numeric value from a boolean cell"
)
;
}
if
(
cellType
==
CELL_TYPE_ERROR
)
{
throw
new
NumberFormatException
(
"You cannot get a numeric value from an error cell"
)
;
}
if
(
cellType
==
CELL_TYPE_NUMERIC
)
{
return
(
(
NumberRecord
)
record
)
.
getValue
(
)
;
}
if
(
cellType
==
CELL_TYPE_FORMULA
)
{
return
(
(
FormulaRecordAggregate
)
record
)
.
getFormulaRecord
(
)
.
getValue
(
)
;
}
throw
new
NumberFormatException
(
"Unknown Record Type in Cell:"
+
cellType
)
;
}
public
Date
getDateCellValue
(
)
{
if
(
cellType
==
CELL_TYPE_BLANK
)
{
return
null
;
}
if
(
cellType
==
CELL_TYPE_STRING
)
{
throw
new
NumberFormatException
(
"You cannot get a date value from a String based cell"
)
;
}
if
(
cellType
==
CELL_TYPE_BOOLEAN
)
{
throw
new
NumberFormatException
(
"You cannot get a date value from a boolean cell"
)
;
}
if
(
cellType
==
CELL_TYPE_ERROR
)
{
throw
new
NumberFormatException
(
"You cannot get a date value from an error cell"
)
;
}
double
value
=
this
.
getNumericCellValue
(
)
;
if
(
book
.
isUsing1904DateWindowing
(
)
)
{
return
HSSFDateUtil
.
getJavaDate
(
value
,
true
)
;
}
else
{
return
HSSFDateUtil
.
getJavaDate
(
value
,
false
)
;
}
}
public
String
getStringCellValue
(
)
{
HSSFRichTextString
str
=
getRichStringCellValue
(
)
;
return
str
.
getString
(
)
;
}
public
HSSFRichTextString
getRichStringCellValue
(
)
{
if
(
cellType
==
CELL_TYPE_BLANK
)
{
return
new
HSSFRichTextString
(
""
)
;
}
if
(
cellType
==
CELL_TYPE_NUMERIC
)
{
throw
new
NumberFormatException
(
"You cannot get a string value from a numeric cell"
)
;
}
if
(
cellType
==
CELL_TYPE_BOOLEAN
)
{
throw
new
NumberFormatException
(
"You cannot get a string value from a boolean cell"
)
;
}
if
(
cellType
==
CELL_TYPE_ERROR
)
{
throw
new
NumberFormatException
(
"You cannot get a string value from an error cell"
)
;
}
if
(
cellType
==
CELL_TYPE_FORMULA
)
{
if
(
stringValue
==
null
)
return
new
HSSFRichTextString
(
""
)
;
}
return
stringValue
;
}
public
void
setCellValue
(
boolean
value
)
{
int
row
=
record
.
getRow
(
)
;
short
col
=
record
.
getColumn
(
)
;
short
styleIndex
=
record
.
getXFIndex
(
)
;
if
(
(
cellType
!=
CELL_TYPE_BOOLEAN
)
&&
(
cellType
!=
CELL_TYPE_FORMULA
)
)
{
setCellType
(
CELL_TYPE_BOOLEAN
,
false
,
row
,
col
,
styleIndex
)
;
}
(
(
BoolErrRecord
)
record
)
.
setValue
(
value
)
;
}
public
void
setCellErrorValue
(
byte
value
)
{
int
row
=
record
.
getRow
(
)
;
short
col
=
record
.
getColumn
(
)
;
short
styleIndex
=
record
.
getXFIndex
(
)
;
if
(
(
cellType
!=
CELL_TYPE_ERROR
)
&&
(
cellType
!=
CELL_TYPE_FORMULA
)
)
{
setCellType
(
CELL_TYPE_ERROR
,
false
,
row
,
col
,
styleIndex
)
;
}
(
(
BoolErrRecord
)
record
)
.
setValue
(
value
)
;
}
public
boolean
getBooleanCellValue
(
)
{
if
(
cellType
==
CELL_TYPE_BOOLEAN
)
{
return
(
(
BoolErrRecord
)
record
)
.
getBooleanValue
(
)
;
}
if
(
cellType
==
CELL_TYPE_BLANK
)
{
return
false
;
}
throw
new
NumberFormatException
(
"You cannot get a boolean value from a non-boolean cell"
)
;
}
public
byte
getErrorCellValue
(
)
{
if
(
cellType
==
CELL_TYPE_ERROR
)
{
return
(
(
BoolErrRecord
)
record
)
.
getErrorValue
(
)
;
}
if
(
cellType
==
CELL_TYPE_BLANK
)
{
return
(
byte
)
0
;
}
throw
new
NumberFormatException
(
"You cannot get an error value from a non-error cell"
)
;
}
public
void
setCellStyle
(
HSSFCellStyle
style
)
{
record
.
setXFIndex
(
style
.
getIndex
(
)
)
;
}
public
HSSFCellStyle
getCellStyle
(
)
{
short
styleIndex
=
record
.
getXFIndex
(
)
;
ExtendedFormatRecord
xf
=
book
.
getExFormatAt
(
styleIndex
)
;
return
new
HSSFCellStyle
(
styleIndex
,
xf
)
;
}
public
short
getEncoding
(
)
{
return
encoding
;
}
public
void
setEncoding
(
short
encoding
)
{
this
.
encoding
=
encoding
;
}
protected
CellValueRecordInterface
getCellValueRecord
(
)
{
return
record
;
}
private
void
checkBounds
(
int
cellNum
)
{
if
(
cellNum
>
255
)
{
throw
new
RuntimeException
(
"You cannot have more than 255 columns "
+
"in a given row (IV).  Because Excel can't handle it"
)
;
}
else
if
(
cellNum
<
0
)
{
throw
new
RuntimeException
(
"You cannot reference columns with an index of less then 0."
)
;
}
}
public
void
setAsActiveCell
(
)
{
int
row
=
record
.
getRow
(
)
;
short
col
=
record
.
getColumn
(
)
;
this
.
sheet
.
setActiveCellRow
(
row
)
;
this
.
sheet
.
setActiveCellCol
(
col
)
;
}
public
String
toString
(
)
{
switch
(
getCellType
(
)
)
{
case
CELL_TYPE_BLANK
:
return
""
;
case
CELL_TYPE_BOOLEAN
:
return
getBooleanCellValue
(
)
?
"TRUE"
:
"FALSE"
;
case
CELL_TYPE_ERROR
:
return
"#ERR"
+
getErrorCellValue
(
)
;
case
CELL_TYPE_FORMULA
:
return
getCellFormula
(
)
;
case
CELL_TYPE_NUMERIC
:
if
(
HSSFDateUtil
.
isCellDateFormatted
(
this
)
)
{
DateFormat
sdf
=
new
SimpleDateFormat
(
"dd-MMM-yyyy"
)
;
return
sdf
.
format
(
getDateCellValue
(
)
)
;
}
else
{
return
getNumericCellValue
(
)
+
""
;
}
case
CELL_TYPE_STRING
:
return
getStringCellValue
(
)
;
default
:
return
"Unknown Cell Type: "
+
getCellType
(
)
;
}
}
public
void
setCellComment
(
HSSFComment
comment
)
{
comment
.
setRow
(
(
short
)
record
.
getRow
(
)
)
;
comment
.
setColumn
(
record
.
getColumn
(
)
)
;
this
.
comment
=
comment
;
}
public
HSSFComment
getCellComment
(
)
{
if
(
comment
==
null
)
{
comment
=
findCellComment
(
sheet
,
record
.
getRow
(
)
,
record
.
getColumn
(
)
)
;
}
return
comment
;
}
protected
static
HSSFComment
findCellComment
(
Sheet
sheet
,
int
row
,
int
column
)
{
HSSFComment
comment
=
null
;
HashMap
txshapes
=
new
HashMap
(
)
;
for
(
Iterator
it
=
sheet
.
getRecords
(
)
.
iterator
(
)
;
it
.
hasNext
(
)
;
)
{
Record
rec
=
(
Record
)
it
.
next
(
)
;
if
(
rec
instanceof
NoteRecord
)
{
NoteRecord
note
=
(
NoteRecord
)
rec
;
if
(
note
.
getRow
(
)
==
row
&&
note
.
getColumn
(
)
==
column
)
{
TextObjectRecord
txo
=
(
TextObjectRecord
)
txshapes
.
get
(
new
Integer
(
note
.
getShapeId
(
)
)
)
;
comment
=
new
HSSFComment
(
note
,
txo
)
;
comment
.
setRow
(
note
.
getRow
(
)
)
;
comment
.
setColumn
(
note
.
getColumn
(
)
)
;
comment
.
setAuthor
(
note
.
getAuthor
(
)
)
;
comment
.
setVisible
(
note
.
getFlags
(
)
==
NoteRecord
.
NOTE_VISIBLE
)
;
comment
.
setString
(
txo
.
getStr
(
)
)
;
break
;
}
}
else
if
(
rec
instanceof
ObjRecord
)
{
ObjRecord
obj
=
(
ObjRecord
)
rec
;
SubRecord
sub
=
(
SubRecord
)
obj
.
getSubRecords
(
)
.
get
(
0
)
;
if
(
sub
instanceof
CommonObjectDataSubRecord
)
{
CommonObjectDataSubRecord
cmo
=
(
CommonObjectDataSubRecord
)
sub
;
if
(
cmo
.
getObjectType
(
)
==
CommonObjectDataSubRecord
.
OBJECT_TYPE_COMMENT
)
{
while
(
it
.
hasNext
(
)
)
{
rec
=
(
Record
)
it
.
next
(
)
;
if
(
rec
instanceof
TextObjectRecord
)
{
txshapes
.
put
(
new
Integer
(
cmo
.
getObjectId
(
)
)
,
rec
)
;
break
;
}
}
}
}
}
}
return
comment
;
}
}
