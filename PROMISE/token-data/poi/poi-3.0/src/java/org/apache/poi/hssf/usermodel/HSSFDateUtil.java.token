package
org
.
apache
.
poi
.
hssf
.
usermodel
;
import
java
.
util
.
Calendar
;
import
java
.
util
.
Date
;
import
java
.
util
.
GregorianCalendar
;
public
class
HSSFDateUtil
{
private
HSSFDateUtil
(
)
{
}
private
static
final
int
BAD_DATE
=
-
1
;
private
static
final
long
DAY_MILLISECONDS
=
24
*
60
*
60
*
1000
;
private
static
final
double
CAL_1900_ABSOLUTE
=
(
double
)
absoluteDay
(
new
GregorianCalendar
(
1900
,
Calendar
.
JANUARY
,
1
)
)
-
2.0
;
public
static
double
getExcelDate
(
Date
date
)
{
Calendar
calStart
=
new
GregorianCalendar
(
)
;
calStart
.
setTime
(
date
)
;
if
(
calStart
.
get
(
Calendar
.
YEAR
)
<
1900
)
{
return
BAD_DATE
;
}
else
{
double
fraction
=
(
(
(
calStart
.
get
(
Calendar
.
HOUR_OF_DAY
)
*
60
+
calStart
.
get
(
Calendar
.
MINUTE
)
)
*
60
+
calStart
.
get
(
Calendar
.
SECOND
)
)
*
1000
+
calStart
.
get
(
Calendar
.
MILLISECOND
)
)
/
(
double
)
DAY_MILLISECONDS
;
calStart
=
dayStart
(
calStart
)
;
return
fraction
+
(
double
)
absoluteDay
(
calStart
)
-
CAL_1900_ABSOLUTE
;
}
}
public
static
Date
getJavaDate
(
double
date
)
{
return
getJavaDate
(
date
,
false
)
;
}
public
static
Date
getJavaDate
(
double
date
,
boolean
use1904windowing
)
{
if
(
isValidExcelDate
(
date
)
)
{
int
startYear
=
1900
;
int
dayAdjust
=
-
1
;
int
wholeDays
=
(
int
)
Math
.
floor
(
date
)
;
if
(
use1904windowing
)
{
startYear
=
1904
;
dayAdjust
=
1
;
}
else
if
(
wholeDays
<
61
)
{
dayAdjust
=
0
;
}
GregorianCalendar
calendar
=
new
GregorianCalendar
(
startYear
,
0
,
wholeDays
+
dayAdjust
)
;
int
millisecondsInDay
=
(
int
)
(
(
date
-
Math
.
floor
(
date
)
)
*
(
double
)
DAY_MILLISECONDS
+
0.5
)
;
calendar
.
set
(
GregorianCalendar
.
MILLISECOND
,
millisecondsInDay
)
;
return
calendar
.
getTime
(
)
;
}
else
{
return
null
;
}
}
public
static
boolean
isInternalDateFormat
(
int
format
)
{
boolean
retval
=
false
;
switch
(
format
)
{
case
0x0e
:
case
0x0f
:
case
0x10
:
case
0x11
:
case
0x12
:
case
0x13
:
case
0x14
:
case
0x15
:
case
0x16
:
case
0x2d
:
case
0x2e
:
case
0x2f
:
retval
=
true
;
break
;
default
:
retval
=
false
;
break
;
}
return
retval
;
}
public
static
boolean
isCellDateFormatted
(
HSSFCell
cell
)
{
if
(
cell
==
null
)
return
false
;
boolean
bDate
=
false
;
double
d
=
cell
.
getNumericCellValue
(
)
;
if
(
HSSFDateUtil
.
isValidExcelDate
(
d
)
)
{
HSSFCellStyle
style
=
cell
.
getCellStyle
(
)
;
int
i
=
style
.
getDataFormat
(
)
;
bDate
=
isInternalDateFormat
(
i
)
;
}
return
bDate
;
}
public
static
boolean
isValidExcelDate
(
double
value
)
{
return
(
value
>
-
Double
.
MIN_VALUE
)
;
}
private
static
int
absoluteDay
(
Calendar
cal
)
{
return
cal
.
get
(
Calendar
.
DAY_OF_YEAR
)
+
daysInPriorYears
(
cal
.
get
(
Calendar
.
YEAR
)
)
;
}
private
static
int
daysInPriorYears
(
int
yr
)
{
if
(
yr
<
1601
)
{
throw
new
IllegalArgumentException
(
"'year' must be 1601 or greater"
)
;
}
int
y
=
yr
-
1601
;
int
days
=
365
*
y
+
y
/
4
-
y
/
100
+
y
/
400
;
return
days
;
}
private
static
Calendar
dayStart
(
final
Calendar
cal
)
{
cal
.
get
(
Calendar
.
HOUR_OF_DAY
)
;
cal
.
set
(
Calendar
.
HOUR_OF_DAY
,
0
)
;
cal
.
set
(
Calendar
.
MINUTE
,
0
)
;
cal
.
set
(
Calendar
.
SECOND
,
0
)
;
cal
.
set
(
Calendar
.
MILLISECOND
,
0
)
;
cal
.
get
(
Calendar
.
HOUR_OF_DAY
)
;
return
cal
;
}
}
