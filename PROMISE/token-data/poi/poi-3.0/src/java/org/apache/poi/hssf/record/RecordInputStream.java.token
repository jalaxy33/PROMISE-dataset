package
org
.
apache
.
poi
.
hssf
.
record
;
import
org
.
apache
.
poi
.
util
.
LittleEndian
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
ByteArrayOutputStream
;
public
class
RecordInputStream
extends
InputStream
{
public
final
static
short
MAX_RECORD_DATA_SIZE
=
8224
;
private
InputStream
in
;
protected
short
currentSid
;
protected
short
currentLength
=
-
1
;
protected
short
nextSid
=
-
1
;
protected
byte
[
]
data
=
new
byte
[
MAX_RECORD_DATA_SIZE
]
;
protected
short
recordOffset
;
protected
long
pos
;
private
boolean
autoContinue
=
true
;
public
RecordInputStream
(
InputStream
in
)
throws
RecordFormatException
{
this
.
in
=
in
;
try
{
nextSid
=
LittleEndian
.
readShort
(
in
)
;
}
catch
(
IOException
ex
)
{
throw
new
RecordFormatException
(
"Error reading bytes"
,
ex
)
;
}
}
public
int
read
(
)
throws
IOException
{
checkRecordPosition
(
)
;
byte
result
=
data
[
recordOffset
]
;
recordOffset
+=
1
;
pos
+=
1
;
return
result
;
}
public
short
getSid
(
)
{
return
currentSid
;
}
public
short
getLength
(
)
{
return
currentLength
;
}
public
short
getRecordOffset
(
)
{
return
recordOffset
;
}
public
long
getPos
(
)
{
return
pos
;
}
public
boolean
hasNextRecord
(
)
{
return
(
nextSid
!=
0
)
;
}
public
void
nextRecord
(
)
throws
RecordFormatException
{
if
(
(
currentLength
!=
-
1
)
&&
(
currentLength
!=
recordOffset
)
)
{
System
.
out
.
println
(
"WARN. Unread "
+
remaining
(
)
+
" bytes of record 0x"
+
Integer
.
toHexString
(
currentSid
)
)
;
}
currentSid
=
nextSid
;
pos
+=
LittleEndian
.
SHORT_SIZE
;
autoContinue
=
true
;
try
{
recordOffset
=
0
;
currentLength
=
LittleEndian
.
readShort
(
in
)
;
if
(
currentLength
>
MAX_RECORD_DATA_SIZE
)
throw
new
RecordFormatException
(
"The content of an excel record cannot exceed "
+
MAX_RECORD_DATA_SIZE
+
" bytes"
)
;
pos
+=
LittleEndian
.
SHORT_SIZE
;
in
.
read
(
data
,
0
,
currentLength
)
;
nextSid
=
LittleEndian
.
readShort
(
in
)
;
}
catch
(
IOException
ex
)
{
throw
new
RecordFormatException
(
"Error reading bytes"
,
ex
)
;
}
}
public
void
setAutoContinue
(
boolean
enable
)
{
this
.
autoContinue
=
enable
;
}
public
boolean
getAutoContinue
(
)
{
return
autoContinue
;
}
protected
void
checkRecordPosition
(
)
{
if
(
remaining
(
)
<=
0
)
{
if
(
isContinueNext
(
)
&&
autoContinue
)
{
nextRecord
(
)
;
}
else
throw
new
ArrayIndexOutOfBoundsException
(
)
;
}
}
public
byte
readByte
(
)
{
checkRecordPosition
(
)
;
byte
result
=
data
[
recordOffset
]
;
recordOffset
+=
1
;
pos
+=
1
;
return
result
;
}
public
short
readShort
(
)
{
checkRecordPosition
(
)
;
short
result
=
LittleEndian
.
getShort
(
data
,
recordOffset
)
;
recordOffset
+=
LittleEndian
.
SHORT_SIZE
;
pos
+=
LittleEndian
.
SHORT_SIZE
;
return
result
;
}
public
int
readInt
(
)
{
checkRecordPosition
(
)
;
int
result
=
LittleEndian
.
getInt
(
data
,
recordOffset
)
;
recordOffset
+=
LittleEndian
.
INT_SIZE
;
pos
+=
LittleEndian
.
INT_SIZE
;
return
result
;
}
public
long
readLong
(
)
{
checkRecordPosition
(
)
;
long
result
=
LittleEndian
.
getLong
(
data
,
recordOffset
)
;
recordOffset
+=
LittleEndian
.
LONG_SIZE
;
pos
+=
LittleEndian
.
LONG_SIZE
;
return
result
;
}
public
int
readUShort
(
)
{
checkRecordPosition
(
)
;
int
result
=
LittleEndian
.
getUShort
(
data
,
recordOffset
)
;
recordOffset
+=
LittleEndian
.
SHORT_SIZE
;
pos
+=
LittleEndian
.
SHORT_SIZE
;
return
result
;
}
byte
[
]
NAN_data
=
null
;
public
double
readDouble
(
)
{
checkRecordPosition
(
)
;
NAN_data
=
null
;
double
result
=
LittleEndian
.
getDouble
(
data
,
recordOffset
)
;
if
(
Double
.
isNaN
(
result
)
)
{
NAN_data
=
new
byte
[
8
]
;
System
.
arraycopy
(
data
,
recordOffset
,
NAN_data
,
0
,
8
)
;
}
recordOffset
+=
LittleEndian
.
DOUBLE_SIZE
;
pos
+=
LittleEndian
.
DOUBLE_SIZE
;
return
result
;
}
public
byte
[
]
getNANData
(
)
{
if
(
NAN_data
==
null
)
throw
new
RecordFormatException
(
"Do NOT call getNANData without calling readDouble that returns NaN"
)
;
return
NAN_data
;
}
public
short
[
]
readShortArray
(
)
{
checkRecordPosition
(
)
;
short
[
]
arr
=
LittleEndian
.
getShortArray
(
data
,
recordOffset
)
;
final
int
size
=
(
2
*
(
arr
.
length
+
1
)
)
;
recordOffset
+=
size
;
pos
+=
size
;
return
arr
;
}
public
String
readUnicodeLEString
(
int
length
)
{
if
(
(
length
<
0
)
||
(
(
(
remaining
(
)
/
2
)
<
length
)
&&
!
isContinueNext
(
)
)
)
{
throw
new
IllegalArgumentException
(
"Illegal length"
)
;
}
StringBuffer
buf
=
new
StringBuffer
(
length
)
;
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
if
(
(
remaining
(
)
==
0
)
&&
(
isContinueNext
(
)
)
)
nextRecord
(
)
;
char
ch
=
(
char
)
readShort
(
)
;
buf
.
append
(
ch
)
;
}
return
buf
.
toString
(
)
;
}
public
String
readCompressedUnicode
(
int
length
)
{
if
(
(
length
<
0
)
||
(
remaining
(
)
<
length
)
)
{
throw
new
IllegalArgumentException
(
"Illegal length"
)
;
}
StringBuffer
buf
=
new
StringBuffer
(
length
)
;
for
(
int
i
=
0
;
i
<
length
;
i
++
)
{
if
(
(
remaining
(
)
==
0
)
&&
(
isContinueNext
(
)
)
)
nextRecord
(
)
;
byte
b
=
readByte
(
)
;
char
ch
=
(
char
)
(
(
short
)
0xff
&
(
short
)
b
)
;
buf
.
append
(
ch
)
;
}
return
buf
.
toString
(
)
;
}
public
UnicodeString
readUnicodeString
(
)
{
return
new
UnicodeString
(
this
)
;
}
public
byte
[
]
readRemainder
(
)
{
int
size
=
remaining
(
)
;
byte
[
]
result
=
new
byte
[
size
]
;
System
.
arraycopy
(
data
,
recordOffset
,
result
,
0
,
size
)
;
recordOffset
+=
size
;
pos
+=
size
;
return
result
;
}
public
byte
[
]
readAllContinuedRemainder
(
)
{
ByteArrayOutputStream
out
=
new
ByteArrayOutputStream
(
2
*
MAX_RECORD_DATA_SIZE
)
;
while
(
isContinueNext
(
)
)
{
byte
[
]
b
=
readRemainder
(
)
;
out
.
write
(
b
,
0
,
b
.
length
)
;
nextRecord
(
)
;
}
byte
[
]
b
=
readRemainder
(
)
;
out
.
write
(
b
,
0
,
b
.
length
)
;
return
out
.
toByteArray
(
)
;
}
public
int
remaining
(
)
{
return
(
currentLength
-
recordOffset
)
;
}
public
boolean
isContinueNext
(
)
{
return
(
nextSid
==
ContinueRecord
.
sid
)
;
}
}
