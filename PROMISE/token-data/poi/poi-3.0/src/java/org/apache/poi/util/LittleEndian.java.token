package
org
.
apache
.
poi
.
util
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
util
.
Arrays
;
public
class
LittleEndian
implements
LittleEndianConsts
{
private
LittleEndian
(
)
{
}
public
static
short
getShort
(
final
byte
[
]
data
,
final
int
offset
)
{
return
(
short
)
getNumber
(
data
,
offset
,
SHORT_SIZE
)
;
}
public
static
int
getUShort
(
final
byte
[
]
data
,
final
int
offset
)
{
short
num
=
(
short
)
getNumber
(
data
,
offset
,
SHORT_SIZE
)
;
int
retNum
;
if
(
num
<
0
)
{
retNum
=
(
Short
.
MAX_VALUE
+
1
)
*
2
+
num
;
}
else
{
retNum
=
num
;
}
return
retNum
;
}
public
static
short
[
]
getSimpleShortArray
(
final
byte
[
]
data
,
final
int
offset
,
final
int
size
)
{
short
[
]
results
=
new
short
[
size
]
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
results
[
i
]
=
getShort
(
data
,
offset
+
2
+
(
i
*
2
)
)
;
}
return
results
;
}
public
static
short
[
]
getShortArray
(
final
byte
[
]
data
,
final
int
offset
)
{
int
size
=
(
int
)
getNumber
(
data
,
offset
,
SHORT_SIZE
)
;
short
[
]
results
=
getSimpleShortArray
(
data
,
offset
,
size
)
;
return
results
;
}
public
static
short
getShort
(
final
byte
[
]
data
)
{
return
getShort
(
data
,
0
)
;
}
public
static
int
getUShort
(
final
byte
[
]
data
)
{
return
getUShort
(
data
,
0
)
;
}
public
static
int
getInt
(
final
byte
[
]
data
,
final
int
offset
)
{
return
(
int
)
getNumber
(
data
,
offset
,
INT_SIZE
)
;
}
public
static
int
getInt
(
final
byte
[
]
data
)
{
return
getInt
(
data
,
0
)
;
}
public
static
long
getUInt
(
final
byte
[
]
data
,
final
int
offset
)
{
int
num
=
(
int
)
getNumber
(
data
,
offset
,
INT_SIZE
)
;
long
retNum
;
if
(
num
<
0
)
{
retNum
=
(
(
long
)
Integer
.
MAX_VALUE
+
1
)
*
2
+
num
;
}
else
{
retNum
=
num
;
}
return
retNum
;
}
public
static
long
getUInt
(
final
byte
[
]
data
)
{
return
getUInt
(
data
,
0
)
;
}
public
static
long
getLong
(
final
byte
[
]
data
,
final
int
offset
)
{
return
getNumber
(
data
,
offset
,
LONG_SIZE
)
;
}
public
static
long
getLong
(
final
byte
[
]
data
)
{
return
getLong
(
data
,
0
)
;
}
public
static
double
getDouble
(
final
byte
[
]
data
,
final
int
offset
)
{
return
Double
.
longBitsToDouble
(
getNumber
(
data
,
offset
,
DOUBLE_SIZE
)
)
;
}
public
static
double
getDouble
(
final
byte
[
]
data
)
{
return
getDouble
(
data
,
0
)
;
}
public
static
void
putShort
(
final
byte
[
]
data
,
final
int
offset
,
final
short
value
)
{
putNumber
(
data
,
offset
,
value
,
SHORT_SIZE
)
;
}
public
static
void
putShortArray
(
final
byte
[
]
data
,
final
int
offset
,
final
short
[
]
value
)
{
putNumber
(
data
,
offset
,
value
.
length
,
SHORT_SIZE
)
;
for
(
int
i
=
0
;
i
<
value
.
length
;
i
++
)
{
putNumber
(
data
,
offset
+
2
+
(
i
*
2
)
,
value
[
i
]
,
SHORT_SIZE
)
;
}
}
public
static
void
putUShort
(
final
byte
[
]
data
,
final
int
offset
,
final
int
value
)
{
putNumber
(
data
,
offset
,
value
,
SHORT_SIZE
)
;
}
public
static
void
putShort
(
final
byte
[
]
data
,
final
short
value
)
{
putShort
(
data
,
0
,
value
)
;
}
public
static
void
putInt
(
final
byte
[
]
data
,
final
int
offset
,
final
int
value
)
{
putNumber
(
data
,
offset
,
value
,
INT_SIZE
)
;
}
public
static
void
putInt
(
final
byte
[
]
data
,
final
int
value
)
{
putInt
(
data
,
0
,
value
)
;
}
public
static
void
putLong
(
final
byte
[
]
data
,
final
int
offset
,
final
long
value
)
{
putNumber
(
data
,
offset
,
value
,
LONG_SIZE
)
;
}
public
static
void
putLong
(
final
byte
[
]
data
,
final
long
value
)
{
putLong
(
data
,
0
,
value
)
;
}
public
static
void
putDouble
(
final
byte
[
]
data
,
final
int
offset
,
final
double
value
)
{
if
(
Double
.
isNaN
(
value
)
)
putNumber
(
data
,
offset
,
-
276939487313920L
,
DOUBLE_SIZE
)
;
else
putNumber
(
data
,
offset
,
Double
.
doubleToLongBits
(
value
)
,
DOUBLE_SIZE
)
;
}
public
static
void
putDouble
(
final
byte
[
]
data
,
final
double
value
)
{
putDouble
(
data
,
0
,
value
)
;
}
public
static
class
BufferUnderrunException
extends
IOException
{
BufferUnderrunException
(
)
{
super
(
"buffer underrun"
)
;
}
}
public
static
short
readShort
(
final
InputStream
stream
)
throws
IOException
,
BufferUnderrunException
{
return
getShort
(
readFromStream
(
stream
,
SHORT_SIZE
)
)
;
}
public
static
int
readInt
(
final
InputStream
stream
)
throws
IOException
,
BufferUnderrunException
{
return
getInt
(
readFromStream
(
stream
,
INT_SIZE
)
)
;
}
public
static
long
readLong
(
final
InputStream
stream
)
throws
IOException
,
BufferUnderrunException
{
return
getLong
(
readFromStream
(
stream
,
LONG_SIZE
)
)
;
}
public
static
byte
[
]
readFromStream
(
final
InputStream
stream
,
final
int
size
)
throws
IOException
,
BufferUnderrunException
{
byte
[
]
buffer
=
new
byte
[
size
]
;
int
count
=
stream
.
read
(
buffer
)
;
if
(
count
==
-
1
)
{
Arrays
.
fill
(
buffer
,
(
byte
)
0
)
;
}
else
if
(
count
!=
size
)
{
throw
new
BufferUnderrunException
(
)
;
}
return
buffer
;
}
private
static
long
getNumber
(
final
byte
[
]
data
,
final
int
offset
,
final
int
size
)
{
long
result
=
0
;
for
(
int
j
=
offset
+
size
-
1
;
j
>=
offset
;
j
--
)
{
result
<<=
8
;
result
|=
0xff
&
data
[
j
]
;
}
return
result
;
}
private
static
void
putNumber
(
final
byte
[
]
data
,
final
int
offset
,
final
long
value
,
final
int
size
)
{
int
limit
=
size
+
offset
;
long
v
=
value
;
for
(
int
j
=
offset
;
j
<
limit
;
j
++
)
{
data
[
j
]
=
(
byte
)
(
v
&
0xFF
)
;
v
>>=
8
;
}
}
public
static
int
ubyteToInt
(
byte
b
)
{
return
(
(
b
&
0x80
)
==
0
?
(
int
)
b
:
(
b
&
(
byte
)
0x7f
)
+
0x80
)
;
}
public
static
int
getUnsignedByte
(
final
byte
[
]
data
,
final
int
offset
)
{
return
(
int
)
getNumber
(
data
,
offset
,
BYTE_SIZE
)
;
}
public
static
int
getUnsignedByte
(
final
byte
[
]
data
)
{
return
getUnsignedByte
(
data
,
0
)
;
}
public
static
byte
[
]
getByteArray
(
final
byte
[
]
data
,
int
offset
,
int
size
)
{
byte
[
]
copy
=
new
byte
[
size
]
;
System
.
arraycopy
(
data
,
offset
,
copy
,
0
,
size
)
;
return
copy
;
}
public
static
long
getULong
(
final
byte
[
]
data
,
final
int
offset
)
{
int
num
=
(
int
)
getNumber
(
data
,
offset
,
LONG_SIZE
)
;
long
retNum
;
if
(
num
<
0
)
retNum
=
(
(
long
)
Integer
.
MAX_VALUE
+
1
)
*
2
+
num
;
else
retNum
=
num
;
return
retNum
;
}
}
