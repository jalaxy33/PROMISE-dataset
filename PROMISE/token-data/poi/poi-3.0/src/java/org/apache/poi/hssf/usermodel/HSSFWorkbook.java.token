package
org
.
apache
.
poi
.
hssf
.
usermodel
;
import
org
.
apache
.
poi
.
ddf
.
EscherBSERecord
;
import
org
.
apache
.
poi
.
ddf
.
EscherBitmapBlip
;
import
org
.
apache
.
poi
.
ddf
.
EscherRecord
;
import
org
.
apache
.
poi
.
ddf
.
EscherBlipRecord
;
import
org
.
apache
.
poi
.
hssf
.
eventmodel
.
EventRecordFactory
;
import
org
.
apache
.
poi
.
hssf
.
model
.
Sheet
;
import
org
.
apache
.
poi
.
hssf
.
model
.
Workbook
;
import
org
.
apache
.
poi
.
hssf
.
record
.
*
;
import
org
.
apache
.
poi
.
hssf
.
record
.
formula
.
Area3DPtg
;
import
org
.
apache
.
poi
.
hssf
.
record
.
formula
.
MemFuncPtg
;
import
org
.
apache
.
poi
.
hssf
.
record
.
formula
.
UnionPtg
;
import
org
.
apache
.
poi
.
hssf
.
util
.
CellReference
;
import
org
.
apache
.
poi
.
poifs
.
filesystem
.
*
;
import
org
.
apache
.
poi
.
util
.
POILogFactory
;
import
org
.
apache
.
poi
.
util
.
POILogger
;
import
java
.
io
.
ByteArrayInputStream
;
import
java
.
io
.
FileNotFoundException
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
PrintWriter
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
Stack
;
public
class
HSSFWorkbook
{
private
static
final
int
DEBUG
=
POILogger
.
DEBUG
;
public
final
static
int
INITIAL_CAPACITY
=
3
;
private
Workbook
workbook
;
protected
ArrayList
sheets
;
private
ArrayList
names
;
private
boolean
preserveNodes
;
private
POIFSFileSystem
poifs
;
private
HSSFDataFormat
formatter
;
public
static
final
int
PICTURE_TYPE_EMF
=
2
;
public
static
final
int
PICTURE_TYPE_WMF
=
3
;
public
static
final
int
PICTURE_TYPE_PICT
=
4
;
public
static
final
int
PICTURE_TYPE_JPEG
=
5
;
public
static
final
int
PICTURE_TYPE_PNG
=
6
;
public
static
final
int
PICTURE_TYPE_DIB
=
7
;
private
static
POILogger
log
=
POILogFactory
.
getLogger
(
HSSFWorkbook
.
class
)
;
public
HSSFWorkbook
(
)
{
this
(
Workbook
.
createWorkbook
(
)
)
;
}
protected
HSSFWorkbook
(
Workbook
book
)
{
workbook
=
book
;
sheets
=
new
ArrayList
(
INITIAL_CAPACITY
)
;
names
=
new
ArrayList
(
INITIAL_CAPACITY
)
;
}
public
HSSFWorkbook
(
POIFSFileSystem
fs
)
throws
IOException
{
this
(
fs
,
true
)
;
}
public
HSSFWorkbook
(
POIFSFileSystem
fs
,
boolean
preserveNodes
)
throws
IOException
{
this
.
preserveNodes
=
preserveNodes
;
if
(
preserveNodes
)
{
this
.
poifs
=
fs
;
}
sheets
=
new
ArrayList
(
INITIAL_CAPACITY
)
;
names
=
new
ArrayList
(
INITIAL_CAPACITY
)
;
String
workbookName
=
"Workbook"
;
try
{
fs
.
getRoot
(
)
.
getEntry
(
workbookName
)
;
}
catch
(
FileNotFoundException
fe
)
{
try
{
workbookName
=
"WORKBOOK"
;
fs
.
getRoot
(
)
.
getEntry
(
workbookName
)
;
}
catch
(
FileNotFoundException
wfe
)
{
throw
new
IllegalArgumentException
(
"The supplied POIFSFileSystem contained neither a 'Workbook' entry, nor a 'WORKBOOK' entry. Is it really an excel file?"
)
;
}
}
InputStream
stream
=
fs
.
createDocumentInputStream
(
workbookName
)
;
EventRecordFactory
factory
=
new
EventRecordFactory
(
)
;
List
records
=
RecordFactory
.
createRecords
(
stream
)
;
workbook
=
Workbook
.
createWorkbook
(
records
)
;
setPropertiesFromWorkbook
(
workbook
)
;
int
recOffset
=
workbook
.
getNumRecords
(
)
;
int
sheetNum
=
0
;
convertLabelRecords
(
records
,
recOffset
)
;
while
(
recOffset
<
records
.
size
(
)
)
{
Sheet
sheet
=
Sheet
.
createSheet
(
records
,
sheetNum
++
,
recOffset
)
;
recOffset
=
sheet
.
getEofLoc
(
)
+
1
;
if
(
recOffset
==
1
)
{
break
;
}
HSSFSheet
hsheet
=
new
HSSFSheet
(
workbook
,
sheet
)
;
sheets
.
add
(
hsheet
)
;
}
for
(
int
i
=
0
;
i
<
workbook
.
getNumNames
(
)
;
++
i
)
{
HSSFName
name
=
new
HSSFName
(
workbook
,
workbook
.
getNameRecord
(
i
)
)
;
names
.
add
(
name
)
;
}
}
public
HSSFWorkbook
(
InputStream
s
)
throws
IOException
{
this
(
s
,
true
)
;
}
public
HSSFWorkbook
(
InputStream
s
,
boolean
preserveNodes
)
throws
IOException
{
this
(
new
POIFSFileSystem
(
s
)
,
preserveNodes
)
;
}
private
void
setPropertiesFromWorkbook
(
Workbook
book
)
{
this
.
workbook
=
book
;
}
private
void
convertLabelRecords
(
List
records
,
int
offset
)
{
if
(
log
.
check
(
POILogger
.
DEBUG
)
)
log
.
log
(
POILogger
.
DEBUG
,
"convertLabelRecords called"
)
;
for
(
int
k
=
offset
;
k
<
records
.
size
(
)
;
k
++
)
{
Record
rec
=
(
Record
)
records
.
get
(
k
)
;
if
(
rec
.
getSid
(
)
==
LabelRecord
.
sid
)
{
LabelRecord
oldrec
=
(
LabelRecord
)
rec
;
records
.
remove
(
k
)
;
LabelSSTRecord
newrec
=
new
LabelSSTRecord
(
)
;
int
stringid
=
workbook
.
addSSTString
(
new
UnicodeString
(
oldrec
.
getValue
(
)
)
)
;
newrec
.
setRow
(
oldrec
.
getRow
(
)
)
;
newrec
.
setColumn
(
oldrec
.
getColumn
(
)
)
;
newrec
.
setXFIndex
(
oldrec
.
getXFIndex
(
)
)
;
newrec
.
setSSTIndex
(
stringid
)
;
records
.
add
(
k
,
newrec
)
;
}
}
if
(
log
.
check
(
POILogger
.
DEBUG
)
)
log
.
log
(
POILogger
.
DEBUG
,
"convertLabelRecords exit"
)
;
}
public
void
setSheetOrder
(
String
sheetname
,
int
pos
)
{
workbook
.
setSheetOrder
(
sheetname
,
pos
)
;
}
public
void
setSelectedTab
(
short
index
)
{
workbook
.
getWindowOne
(
)
.
setSelectedTab
(
index
)
;
}
public
short
getSelectedTab
(
)
{
return
workbook
.
getWindowOne
(
)
.
getSelectedTab
(
)
;
}
public
void
setDisplayedTab
(
short
index
)
{
workbook
.
getWindowOne
(
)
.
setDisplayedTab
(
index
)
;
}
public
short
getDisplayedTab
(
)
{
return
workbook
.
getWindowOne
(
)
.
getDisplayedTab
(
)
;
}
public
final
static
byte
ENCODING_COMPRESSED_UNICODE
=
0
;
public
final
static
byte
ENCODING_UTF_16
=
1
;
public
void
setSheetName
(
int
sheet
,
String
name
)
{
if
(
workbook
.
doesContainsSheetName
(
name
,
sheet
)
)
throw
new
IllegalArgumentException
(
"The workbook already contains a sheet with this name"
)
;
if
(
sheet
>
(
sheets
.
size
(
)
-
1
)
)
{
throw
new
RuntimeException
(
"Sheet out of bounds"
)
;
}
workbook
.
setSheetName
(
sheet
,
name
)
;
}
public
void
setSheetName
(
int
sheet
,
String
name
,
short
encoding
)
{
if
(
workbook
.
doesContainsSheetName
(
name
,
sheet
)
)
throw
new
IllegalArgumentException
(
"The workbook already contains a sheet with this name"
)
;
if
(
sheet
>
(
sheets
.
size
(
)
-
1
)
)
{
throw
new
RuntimeException
(
"Sheet out of bounds"
)
;
}
switch
(
encoding
)
{
case
ENCODING_COMPRESSED_UNICODE
:
case
ENCODING_UTF_16
:
break
;
default
:
throw
new
RuntimeException
(
"Unsupported encoding"
)
;
}
workbook
.
setSheetName
(
sheet
,
name
,
encoding
)
;
}
public
String
getSheetName
(
int
sheet
)
{
if
(
sheet
>
(
sheets
.
size
(
)
-
1
)
)
{
throw
new
RuntimeException
(
"Sheet out of bounds"
)
;
}
return
workbook
.
getSheetName
(
sheet
)
;
}
public
int
getSheetIndex
(
String
name
)
{
int
retval
=
workbook
.
getSheetIndex
(
name
)
;
return
retval
;
}
public
HSSFSheet
createSheet
(
)
{
HSSFSheet
sheet
=
new
HSSFSheet
(
workbook
)
;
sheets
.
add
(
sheet
)
;
workbook
.
setSheetName
(
sheets
.
size
(
)
-
1
,
"Sheet"
+
(
sheets
.
size
(
)
-
1
)
)
;
WindowTwoRecord
windowTwo
=
(
WindowTwoRecord
)
sheet
.
getSheet
(
)
.
findFirstRecordBySid
(
WindowTwoRecord
.
sid
)
;
windowTwo
.
setSelected
(
sheets
.
size
(
)
==
1
)
;
windowTwo
.
setPaged
(
sheets
.
size
(
)
==
1
)
;
return
sheet
;
}
public
HSSFSheet
cloneSheet
(
int
sheetNum
)
{
HSSFSheet
srcSheet
=
(
HSSFSheet
)
sheets
.
get
(
sheetNum
)
;
String
srcName
=
workbook
.
getSheetName
(
sheetNum
)
;
if
(
srcSheet
!=
null
)
{
HSSFSheet
clonedSheet
=
srcSheet
.
cloneSheet
(
workbook
)
;
WindowTwoRecord
windowTwo
=
(
WindowTwoRecord
)
clonedSheet
.
getSheet
(
)
.
findFirstRecordBySid
(
WindowTwoRecord
.
sid
)
;
windowTwo
.
setSelected
(
sheets
.
size
(
)
==
1
)
;
windowTwo
.
setPaged
(
sheets
.
size
(
)
==
1
)
;
sheets
.
add
(
clonedSheet
)
;
int
i
=
1
;
while
(
true
)
{
String
name
=
srcName
;
String
index
=
Integer
.
toString
(
i
++
)
;
if
(
name
.
length
(
)
+
index
.
length
(
)
+
2
<
31
)
name
=
name
+
"("
+
index
+
")"
;
else
name
=
name
.
substring
(
0
,
31
-
index
.
length
(
)
-
2
)
+
"("
+
index
+
")"
;
if
(
workbook
.
getSheetIndex
(
name
)
==
-
1
)
{
workbook
.
setSheetName
(
sheets
.
size
(
)
-
1
,
name
)
;
break
;
}
}
return
clonedSheet
;
}
return
null
;
}
public
HSSFSheet
createSheet
(
String
sheetname
)
{
if
(
workbook
.
doesContainsSheetName
(
sheetname
,
sheets
.
size
(
)
)
)
throw
new
IllegalArgumentException
(
"The workbook already contains a sheet of this name"
)
;
HSSFSheet
sheet
=
new
HSSFSheet
(
workbook
)
;
sheets
.
add
(
sheet
)
;
workbook
.
setSheetName
(
sheets
.
size
(
)
-
1
,
sheetname
)
;
WindowTwoRecord
windowTwo
=
(
WindowTwoRecord
)
sheet
.
getSheet
(
)
.
findFirstRecordBySid
(
WindowTwoRecord
.
sid
)
;
windowTwo
.
setSelected
(
sheets
.
size
(
)
==
1
)
;
windowTwo
.
setPaged
(
sheets
.
size
(
)
==
1
)
;
return
sheet
;
}
public
int
getNumberOfSheets
(
)
{
return
sheets
.
size
(
)
;
}
public
HSSFSheet
getSheetAt
(
int
index
)
{
return
(
HSSFSheet
)
sheets
.
get
(
index
)
;
}
public
HSSFSheet
getSheet
(
String
name
)
{
HSSFSheet
retval
=
null
;
for
(
int
k
=
0
;
k
<
sheets
.
size
(
)
;
k
++
)
{
String
sheetname
=
workbook
.
getSheetName
(
k
)
;
if
(
sheetname
.
equals
(
name
)
)
{
retval
=
(
HSSFSheet
)
sheets
.
get
(
k
)
;
}
}
return
retval
;
}
public
void
removeSheetAt
(
int
index
)
{
sheets
.
remove
(
index
)
;
workbook
.
removeSheet
(
index
)
;
}
public
void
setBackupFlag
(
boolean
backupValue
)
{
BackupRecord
backupRecord
=
workbook
.
getBackupRecord
(
)
;
backupRecord
.
setBackup
(
backupValue
?
(
short
)
1
:
(
short
)
0
)
;
}
public
boolean
getBackupFlag
(
)
{
BackupRecord
backupRecord
=
workbook
.
getBackupRecord
(
)
;
return
(
backupRecord
.
getBackup
(
)
==
0
)
?
false
:
true
;
}
public
void
setRepeatingRowsAndColumns
(
int
sheetIndex
,
int
startColumn
,
int
endColumn
,
int
startRow
,
int
endRow
)
{
if
(
startColumn
==
-
1
&&
endColumn
!=
-
1
)
throw
new
IllegalArgumentException
(
"Invalid column range specification"
)
;
if
(
startRow
==
-
1
&&
endRow
!=
-
1
)
throw
new
IllegalArgumentException
(
"Invalid row range specification"
)
;
if
(
startColumn
<
-
1
||
startColumn
>=
0xFF
)
throw
new
IllegalArgumentException
(
"Invalid column range specification"
)
;
if
(
endColumn
<
-
1
||
endColumn
>=
0xFF
)
throw
new
IllegalArgumentException
(
"Invalid column range specification"
)
;
if
(
startRow
<
-
1
||
startRow
>
65535
)
throw
new
IllegalArgumentException
(
"Invalid row range specification"
)
;
if
(
endRow
<
-
1
||
endRow
>
65535
)
throw
new
IllegalArgumentException
(
"Invalid row range specification"
)
;
if
(
startColumn
>
endColumn
)
throw
new
IllegalArgumentException
(
"Invalid column range specification"
)
;
if
(
startRow
>
endRow
)
throw
new
IllegalArgumentException
(
"Invalid row range specification"
)
;
HSSFSheet
sheet
=
getSheetAt
(
sheetIndex
)
;
short
externSheetIndex
=
getWorkbook
(
)
.
checkExternSheet
(
sheetIndex
)
;
boolean
settingRowAndColumn
=
startColumn
!=
-
1
&&
endColumn
!=
-
1
&&
startRow
!=
-
1
&&
endRow
!=
-
1
;
boolean
removingRange
=
startColumn
==
-
1
&&
endColumn
==
-
1
&&
startRow
==
-
1
&&
endRow
==
-
1
;
boolean
isNewRecord
=
false
;
NameRecord
nameRecord
;
nameRecord
=
findExistingRowColHeaderNameRecord
(
sheetIndex
)
;
if
(
removingRange
)
{
if
(
nameRecord
!=
null
)
workbook
.
removeName
(
findExistingRowColHeaderNameRecordIdx
(
sheetIndex
+
1
)
)
;
return
;
}
if
(
nameRecord
==
null
)
{
nameRecord
=
workbook
.
createBuiltInName
(
NameRecord
.
BUILTIN_PRINT_TITLE
,
sheetIndex
+
1
)
;
isNewRecord
=
true
;
}
short
definitionTextLength
=
settingRowAndColumn
?
(
short
)
0x001a
:
(
short
)
0x000b
;
nameRecord
.
setDefinitionTextLength
(
definitionTextLength
)
;
Stack
ptgs
=
new
Stack
(
)
;
if
(
settingRowAndColumn
)
{
MemFuncPtg
memFuncPtg
=
new
MemFuncPtg
(
)
;
memFuncPtg
.
setLenRefSubexpression
(
23
)
;
ptgs
.
add
(
memFuncPtg
)
;
}
if
(
startColumn
>=
0
)
{
Area3DPtg
area3DPtg1
=
new
Area3DPtg
(
)
;
area3DPtg1
.
setExternSheetIndex
(
externSheetIndex
)
;
area3DPtg1
.
setFirstColumn
(
(
short
)
startColumn
)
;
area3DPtg1
.
setLastColumn
(
(
short
)
endColumn
)
;
area3DPtg1
.
setFirstRow
(
(
short
)
0
)
;
area3DPtg1
.
setLastRow
(
(
short
)
0xFFFF
)
;
ptgs
.
add
(
area3DPtg1
)
;
}
if
(
startRow
>=
0
)
{
Area3DPtg
area3DPtg2
=
new
Area3DPtg
(
)
;
area3DPtg2
.
setExternSheetIndex
(
externSheetIndex
)
;
area3DPtg2
.
setFirstColumn
(
(
short
)
0
)
;
area3DPtg2
.
setLastColumn
(
(
short
)
0x00FF
)
;
area3DPtg2
.
setFirstRow
(
(
short
)
startRow
)
;
area3DPtg2
.
setLastRow
(
(
short
)
endRow
)
;
ptgs
.
add
(
area3DPtg2
)
;
}
if
(
settingRowAndColumn
)
{
UnionPtg
unionPtg
=
new
UnionPtg
(
)
;
ptgs
.
add
(
unionPtg
)
;
}
nameRecord
.
setNameDefinition
(
ptgs
)
;
if
(
isNewRecord
)
{
HSSFName
newName
=
new
HSSFName
(
workbook
,
nameRecord
)
;
names
.
add
(
newName
)
;
}
HSSFPrintSetup
printSetup
=
sheet
.
getPrintSetup
(
)
;
printSetup
.
setValidSettings
(
false
)
;
WindowTwoRecord
w2
=
(
WindowTwoRecord
)
sheet
.
getSheet
(
)
.
findFirstRecordBySid
(
WindowTwoRecord
.
sid
)
;
w2
.
setPaged
(
true
)
;
}
private
NameRecord
findExistingRowColHeaderNameRecord
(
int
sheetIndex
)
{
int
index
=
findExistingRowColHeaderNameRecordIdx
(
sheetIndex
)
;
if
(
index
==
-
1
)
return
null
;
else
return
(
NameRecord
)
workbook
.
findNextRecordBySid
(
NameRecord
.
sid
,
index
)
;
}
private
int
findExistingRowColHeaderNameRecordIdx
(
int
sheetIndex
)
{
int
index
=
0
;
NameRecord
r
=
null
;
while
(
(
r
=
(
NameRecord
)
workbook
.
findNextRecordBySid
(
NameRecord
.
sid
,
index
)
)
!=
null
)
{
int
indexToSheet
=
r
.
getEqualsToIndexToSheet
(
)
-
1
;
if
(
indexToSheet
>
-
1
)
{
int
nameRecordSheetIndex
=
workbook
.
getSheetIndexFromExternSheetIndex
(
indexToSheet
)
;
if
(
isRowColHeaderRecord
(
r
)
&&
nameRecordSheetIndex
==
sheetIndex
)
{
return
index
;
}
}
index
++
;
}
return
-
1
;
}
private
boolean
isRowColHeaderRecord
(
NameRecord
r
)
{
return
r
.
getOptionFlag
(
)
==
0x20
&&
(
""
+
(
(
char
)
7
)
)
.
equals
(
r
.
getNameText
(
)
)
;
}
public
HSSFFont
createFont
(
)
{
FontRecord
font
=
workbook
.
createNewFont
(
)
;
short
fontindex
=
(
short
)
(
getNumberOfFonts
(
)
-
1
)
;
if
(
fontindex
>
3
)
{
fontindex
++
;
}
HSSFFont
retval
=
new
HSSFFont
(
fontindex
,
font
)
;
return
retval
;
}
public
HSSFFont
findFont
(
short
boldWeight
,
short
color
,
short
fontHeight
,
String
name
,
boolean
italic
,
boolean
strikeout
,
short
typeOffset
,
byte
underline
)
{
for
(
short
i
=
0
;
i
<
workbook
.
getNumberOfFontRecords
(
)
;
i
++
)
{
if
(
i
==
4
)
continue
;
FontRecord
font
=
workbook
.
getFontRecordAt
(
i
)
;
HSSFFont
hssfFont
=
new
HSSFFont
(
i
,
font
)
;
if
(
hssfFont
.
getBoldweight
(
)
==
boldWeight
&&
hssfFont
.
getColor
(
)
==
color
&&
hssfFont
.
getFontHeight
(
)
==
fontHeight
&&
hssfFont
.
getFontName
(
)
.
equals
(
name
)
&&
hssfFont
.
getItalic
(
)
==
italic
&&
hssfFont
.
getStrikeout
(
)
==
strikeout
&&
hssfFont
.
getTypeOffset
(
)
==
typeOffset
&&
hssfFont
.
getUnderline
(
)
==
underline
)
{
return
hssfFont
;
}
}
return
null
;
}
public
short
getNumberOfFonts
(
)
{
return
(
short
)
workbook
.
getNumberOfFontRecords
(
)
;
}
public
HSSFFont
getFontAt
(
short
idx
)
{
FontRecord
font
=
workbook
.
getFontRecordAt
(
idx
)
;
HSSFFont
retval
=
new
HSSFFont
(
idx
,
font
)
;
return
retval
;
}
public
HSSFCellStyle
createCellStyle
(
)
{
ExtendedFormatRecord
xfr
=
workbook
.
createCellXF
(
)
;
short
index
=
(
short
)
(
getNumCellStyles
(
)
-
1
)
;
HSSFCellStyle
style
=
new
HSSFCellStyle
(
index
,
xfr
)
;
return
style
;
}
public
short
getNumCellStyles
(
)
{
return
(
short
)
workbook
.
getNumExFormats
(
)
;
}
public
HSSFCellStyle
getCellStyleAt
(
short
idx
)
{
ExtendedFormatRecord
xfr
=
workbook
.
getExFormatAt
(
idx
)
;
HSSFCellStyle
style
=
new
HSSFCellStyle
(
idx
,
xfr
)
;
return
style
;
}
public
void
write
(
OutputStream
stream
)
throws
IOException
{
byte
[
]
bytes
=
getBytes
(
)
;
POIFSFileSystem
fs
=
new
POIFSFileSystem
(
)
;
fs
.
createDocument
(
new
ByteArrayInputStream
(
bytes
)
,
"Workbook"
)
;
if
(
preserveNodes
)
{
List
excepts
=
new
ArrayList
(
1
)
;
excepts
.
add
(
"Workbook"
)
;
copyNodes
(
this
.
poifs
,
fs
,
excepts
)
;
}
fs
.
writeFilesystem
(
stream
)
;
}
public
byte
[
]
getBytes
(
)
{
if
(
log
.
check
(
POILogger
.
DEBUG
)
)
log
.
log
(
DEBUG
,
"HSSFWorkbook.getBytes()"
)
;
for
(
int
k
=
0
;
k
<
sheets
.
size
(
)
;
k
++
)
(
(
HSSFSheet
)
sheets
.
get
(
k
)
)
.
getSheet
(
)
.
preSerialize
(
)
;
int
wbsize
=
workbook
.
getSize
(
)
;
int
totalsize
=
wbsize
;
for
(
int
k
=
0
;
k
<
sheets
.
size
(
)
;
k
++
)
{
workbook
.
setSheetBof
(
k
,
totalsize
)
;
totalsize
+=
(
(
HSSFSheet
)
sheets
.
get
(
k
)
)
.
getSheet
(
)
.
getSize
(
)
;
}
byte
[
]
retval
=
new
byte
[
totalsize
]
;
int
pos
=
workbook
.
serialize
(
0
,
retval
)
;
for
(
int
k
=
0
;
k
<
sheets
.
size
(
)
;
k
++
)
{
int
len
=
(
(
HSSFSheet
)
sheets
.
get
(
k
)
)
.
getSheet
(
)
.
serialize
(
pos
,
retval
)
;
pos
+=
len
;
}
return
retval
;
}
public
int
addSSTString
(
String
string
)
{
return
workbook
.
addSSTString
(
new
UnicodeString
(
string
)
)
;
}
public
String
getSSTString
(
int
index
)
{
return
workbook
.
getSSTString
(
index
)
.
getString
(
)
;
}
Workbook
getWorkbook
(
)
{
return
workbook
;
}
public
int
getNumberOfNames
(
)
{
int
result
=
names
.
size
(
)
;
return
result
;
}
public
HSSFName
getNameAt
(
int
index
)
{
HSSFName
result
=
(
HSSFName
)
names
.
get
(
index
)
;
return
result
;
}
public
String
getNameName
(
int
index
)
{
String
result
=
getNameAt
(
index
)
.
getNameName
(
)
;
return
result
;
}
public
void
setPrintArea
(
int
sheetIndex
,
String
reference
)
{
NameRecord
name
=
workbook
.
getSpecificBuiltinRecord
(
NameRecord
.
BUILTIN_PRINT_AREA
,
sheetIndex
+
1
)
;
if
(
name
==
null
)
name
=
workbook
.
createBuiltInName
(
NameRecord
.
BUILTIN_PRINT_AREA
,
sheetIndex
+
1
)
;
short
externSheetIndex
=
getWorkbook
(
)
.
checkExternSheet
(
sheetIndex
)
;
name
.
setExternSheetNumber
(
externSheetIndex
)
;
name
.
setAreaReference
(
reference
)
;
}
public
void
setPrintArea
(
int
sheetIndex
,
int
startColumn
,
int
endColumn
,
int
startRow
,
int
endRow
)
{
CellReference
cell
=
new
CellReference
(
startRow
,
startColumn
,
true
,
true
)
;
String
reference
=
cell
.
toString
(
)
;
cell
=
new
CellReference
(
endRow
,
endColumn
,
true
,
true
)
;
reference
=
reference
+
":"
+
cell
.
toString
(
)
;
setPrintArea
(
sheetIndex
,
reference
)
;
}
public
String
getPrintArea
(
int
sheetIndex
)
{
NameRecord
name
=
workbook
.
getSpecificBuiltinRecord
(
NameRecord
.
BUILTIN_PRINT_AREA
,
sheetIndex
+
1
)
;
if
(
name
==
null
)
return
null
;
return
name
.
getAreaReference
(
workbook
)
;
}
public
void
removePrintArea
(
int
sheetIndex
)
{
getWorkbook
(
)
.
removeBuiltinRecord
(
NameRecord
.
BUILTIN_PRINT_AREA
,
sheetIndex
+
1
)
;
}
public
HSSFName
createName
(
)
{
NameRecord
nameRecord
=
workbook
.
createName
(
)
;
HSSFName
newName
=
new
HSSFName
(
workbook
,
nameRecord
)
;
names
.
add
(
newName
)
;
return
newName
;
}
public
int
getNameIndex
(
String
name
)
{
int
retval
=
-
1
;
for
(
int
k
=
0
;
k
<
names
.
size
(
)
;
k
++
)
{
String
nameName
=
getNameName
(
k
)
;
if
(
nameName
.
equalsIgnoreCase
(
name
)
)
{
retval
=
k
;
break
;
}
}
return
retval
;
}
public
void
removeName
(
int
index
)
{
names
.
remove
(
index
)
;
workbook
.
removeName
(
index
)
;
}
public
HSSFDataFormat
createDataFormat
(
)
{
if
(
formatter
==
null
)
formatter
=
new
HSSFDataFormat
(
workbook
)
;
return
formatter
;
}
public
void
removeName
(
String
name
)
{
int
index
=
getNameIndex
(
name
)
;
removeName
(
index
)
;
}
public
HSSFPalette
getCustomPalette
(
)
{
return
new
HSSFPalette
(
workbook
.
getCustomPalette
(
)
)
;
}
private
void
copyNodes
(
POIFSFileSystem
source
,
POIFSFileSystem
target
,
List
excepts
)
throws
IOException
{
DirectoryEntry
root
=
source
.
getRoot
(
)
;
DirectoryEntry
newRoot
=
target
.
getRoot
(
)
;
Iterator
entries
=
root
.
getEntries
(
)
;
while
(
entries
.
hasNext
(
)
)
{
Entry
entry
=
(
Entry
)
entries
.
next
(
)
;
if
(
!
isInList
(
entry
.
getName
(
)
,
excepts
)
)
{
copyNodeRecursively
(
entry
,
newRoot
)
;
}
}
}
private
boolean
isInList
(
String
entry
,
List
list
)
{
for
(
int
k
=
0
;
k
<
list
.
size
(
)
;
k
++
)
{
if
(
list
.
get
(
k
)
.
equals
(
entry
)
)
{
return
true
;
}
}
return
false
;
}
private
void
copyNodeRecursively
(
Entry
entry
,
DirectoryEntry
target
)
throws
IOException
{
DirectoryEntry
newTarget
=
null
;
if
(
entry
.
isDirectoryEntry
(
)
)
{
newTarget
=
target
.
createDirectory
(
entry
.
getName
(
)
)
;
Iterator
entries
=
(
(
DirectoryEntry
)
entry
)
.
getEntries
(
)
;
while
(
entries
.
hasNext
(
)
)
{
copyNodeRecursively
(
(
Entry
)
entries
.
next
(
)
,
newTarget
)
;
}
}
else
{
DocumentEntry
dentry
=
(
DocumentEntry
)
entry
;
DocumentInputStream
dstream
=
new
DocumentInputStream
(
dentry
)
;
target
.
createDocument
(
dentry
.
getName
(
)
,
dstream
)
;
dstream
.
close
(
)
;
}
}
public
void
insertChartRecord
(
)
{
int
loc
=
workbook
.
findFirstRecordLocBySid
(
SSTRecord
.
sid
)
;
byte
[
]
data
=
{
(
byte
)
0x0F
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0xF0
,
(
byte
)
0x52
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x06
,
(
byte
)
0xF0
,
(
byte
)
0x18
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x01
,
(
byte
)
0x08
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x02
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x02
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x01
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x01
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x03
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x33
,
(
byte
)
0x00
,
(
byte
)
0x0B
,
(
byte
)
0xF0
,
(
byte
)
0x12
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0xBF
,
(
byte
)
0x00
,
(
byte
)
0x08
,
(
byte
)
0x00
,
(
byte
)
0x08
,
(
byte
)
0x00
,
(
byte
)
0x81
,
(
byte
)
0x01
,
(
byte
)
0x09
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x08
,
(
byte
)
0xC0
,
(
byte
)
0x01
,
(
byte
)
0x40
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x08
,
(
byte
)
0x40
,
(
byte
)
0x00
,
(
byte
)
0x1E
,
(
byte
)
0xF1
,
(
byte
)
0x10
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x0D
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x08
,
(
byte
)
0x0C
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x08
,
(
byte
)
0x17
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x08
,
(
byte
)
0xF7
,
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0x10
,
}
;
UnknownRecord
r
=
new
UnknownRecord
(
(
short
)
0x00EB
,
data
)
;
workbook
.
getRecords
(
)
.
add
(
loc
,
r
)
;
}
public
void
dumpDrawingGroupRecords
(
boolean
fat
)
{
DrawingGroupRecord
r
=
(
DrawingGroupRecord
)
workbook
.
findFirstRecordBySid
(
DrawingGroupRecord
.
sid
)
;
r
.
decode
(
)
;
List
escherRecords
=
r
.
getEscherRecords
(
)
;
PrintWriter
w
=
new
PrintWriter
(
System
.
out
)
;
for
(
Iterator
iterator
=
escherRecords
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
EscherRecord
escherRecord
=
(
EscherRecord
)
iterator
.
next
(
)
;
if
(
fat
)
System
.
out
.
println
(
escherRecord
.
toString
(
)
)
;
else
escherRecord
.
display
(
w
,
0
)
;
}
w
.
flush
(
)
;
}
public
int
addPicture
(
byte
[
]
pictureData
,
int
format
)
{
byte
[
]
uid
=
newUID
(
)
;
EscherBitmapBlip
blipRecord
=
new
EscherBitmapBlip
(
)
;
blipRecord
.
setRecordId
(
(
short
)
(
EscherBitmapBlip
.
RECORD_ID_START
+
format
)
)
;
switch
(
format
)
{
case
PICTURE_TYPE_EMF
:
blipRecord
.
setOptions
(
HSSFPictureData
.
MSOBI_EMF
)
;
break
;
case
PICTURE_TYPE_WMF
:
blipRecord
.
setOptions
(
HSSFPictureData
.
MSOBI_WMF
)
;
break
;
case
PICTURE_TYPE_PICT
:
blipRecord
.
setOptions
(
HSSFPictureData
.
MSOBI_PICT
)
;
break
;
case
PICTURE_TYPE_PNG
:
blipRecord
.
setOptions
(
HSSFPictureData
.
MSOBI_PNG
)
;
break
;
case
HSSFWorkbook
.
PICTURE_TYPE_JPEG
:
blipRecord
.
setOptions
(
HSSFPictureData
.
MSOBI_JPEG
)
;
break
;
case
HSSFWorkbook
.
PICTURE_TYPE_DIB
:
blipRecord
.
setOptions
(
HSSFPictureData
.
MSOBI_DIB
)
;
break
;
}
blipRecord
.
setUID
(
uid
)
;
blipRecord
.
setMarker
(
(
byte
)
0xFF
)
;
blipRecord
.
setPictureData
(
pictureData
)
;
EscherBSERecord
r
=
new
EscherBSERecord
(
)
;
r
.
setRecordId
(
EscherBSERecord
.
RECORD_ID
)
;
r
.
setOptions
(
(
short
)
(
0x0002
|
(
format
<<
4
)
)
)
;
r
.
setBlipTypeMacOS
(
(
byte
)
format
)
;
r
.
setBlipTypeWin32
(
(
byte
)
format
)
;
r
.
setUid
(
uid
)
;
r
.
setTag
(
(
short
)
0xFF
)
;
r
.
setSize
(
pictureData
.
length
+
25
)
;
r
.
setRef
(
1
)
;
r
.
setOffset
(
0
)
;
r
.
setBlipRecord
(
blipRecord
)
;
return
workbook
.
addBSERecord
(
r
)
;
}
public
List
getAllPictures
(
)
{
List
pictures
=
new
ArrayList
(
)
;
Iterator
recordIter
=
workbook
.
getRecords
(
)
.
iterator
(
)
;
while
(
recordIter
.
hasNext
(
)
)
{
Object
obj
=
recordIter
.
next
(
)
;
if
(
obj
instanceof
AbstractEscherHolderRecord
)
{
(
(
AbstractEscherHolderRecord
)
obj
)
.
decode
(
)
;
List
escherRecords
=
(
(
AbstractEscherHolderRecord
)
obj
)
.
getEscherRecords
(
)
;
searchForPictures
(
escherRecords
,
pictures
)
;
}
}
return
pictures
;
}
private
void
searchForPictures
(
List
escherRecords
,
List
pictures
)
{
Iterator
recordIter
=
escherRecords
.
iterator
(
)
;
while
(
recordIter
.
hasNext
(
)
)
{
Object
obj
=
recordIter
.
next
(
)
;
if
(
obj
instanceof
EscherRecord
)
{
EscherRecord
escherRecord
=
(
EscherRecord
)
obj
;
if
(
escherRecord
instanceof
EscherBSERecord
)
{
EscherBlipRecord
blip
=
(
(
EscherBSERecord
)
escherRecord
)
.
getBlipRecord
(
)
;
if
(
blip
instanceof
EscherBitmapBlip
)
{
pictures
.
add
(
new
HSSFPictureData
(
(
EscherBitmapBlip
)
blip
)
)
;
}
}
searchForPictures
(
escherRecord
.
getChildRecords
(
)
,
pictures
)
;
}
}
}
private
byte
[
]
newUID
(
)
{
byte
[
]
bytes
=
new
byte
[
16
]
;
return
bytes
;
}
}
