package
org
.
apache
.
poi
.
hssf
.
record
;
import
org
.
apache
.
poi
.
util
.
BinaryTree
;
import
org
.
apache
.
poi
.
util
.
LittleEndian
;
import
org
.
apache
.
poi
.
util
.
LittleEndianConsts
;
import
java
.
util
.
*
;
public
class
SSTRecord
extends
Record
{
private
static
final
int
_max
=
8228
;
private
static
final
int
_std_record_overhead
=
2
*
LittleEndianConsts
.
SHORT_SIZE
;
private
static
final
int
_sst_record_overhead
=
(
_std_record_overhead
+
(
2
*
LittleEndianConsts
.
INT_SIZE
)
)
;
private
static
final
int
_max_data_space
=
_max
-
_sst_record_overhead
;
private
static
final
int
_string_minimal_overhead
=
LittleEndianConsts
.
SHORT_SIZE
+
LittleEndianConsts
.
BYTE_SIZE
;
public
static
final
short
sid
=
0xfc
;
private
int
field_1_num_strings
;
private
int
field_2_num_unique_strings
;
private
BinaryTree
field_3_strings
;
private
int
__expected_chars
;
private
String
_unfinished_string
;
private
int
_total_length_bytes
;
private
int
_string_data_offset
;
private
boolean
_wide_char
;
private
List
_record_lengths
=
null
;
public
SSTRecord
(
)
{
field_1_num_strings
=
0
;
field_2_num_unique_strings
=
0
;
field_3_strings
=
new
BinaryTree
(
)
;
setExpectedChars
(
0
)
;
_unfinished_string
=
""
;
_total_length_bytes
=
0
;
_string_data_offset
=
0
;
_wide_char
=
false
;
}
public
SSTRecord
(
final
short
id
,
final
short
size
,
final
byte
[
]
data
)
{
super
(
id
,
size
,
data
)
;
}
public
SSTRecord
(
final
short
id
,
final
short
size
,
final
byte
[
]
data
,
int
offset
)
{
super
(
id
,
size
,
data
,
offset
)
;
}
public
int
addString
(
final
String
string
)
{
int
rval
;
if
(
string
==
null
)
{
rval
=
addString
(
""
,
false
)
;
}
else
{
boolean
useUTF16
=
false
;
int
strlen
=
string
.
length
(
)
;
for
(
int
j
=
0
;
j
<
strlen
;
j
++
)
{
if
(
string
.
charAt
(
j
)
>
255
)
{
useUTF16
=
true
;
break
;
}
}
rval
=
addString
(
string
,
useUTF16
)
;
}
return
rval
;
}
public
int
addString
(
final
String
string
,
final
boolean
useUTF16
)
{
field_1_num_strings
++
;
String
str
=
(
string
==
null
)
?
""
:
string
;
int
rval
=
-
1
;
UnicodeString
ucs
=
new
UnicodeString
(
)
;
ucs
.
setString
(
str
)
;
ucs
.
setCharCount
(
(
short
)
str
.
length
(
)
)
;
ucs
.
setOptionFlags
(
(
byte
)
(
useUTF16
?
1
:
0
)
)
;
Integer
integer
=
(
Integer
)
field_3_strings
.
getKeyForValue
(
ucs
)
;
if
(
integer
!=
null
)
{
rval
=
integer
.
intValue
(
)
;
}
else
{
rval
=
field_3_strings
.
size
(
)
;
field_2_num_unique_strings
++
;
integer
=
new
Integer
(
rval
)
;
field_3_strings
.
put
(
integer
,
ucs
)
;
}
return
rval
;
}
public
int
getNumStrings
(
)
{
return
field_1_num_strings
;
}
public
int
getNumUniqueStrings
(
)
{
return
field_2_num_unique_strings
;
}
public
void
setNumStrings
(
final
int
count
)
{
field_1_num_strings
=
count
;
}
public
void
getNumUniqueStrings
(
final
int
count
)
{
field_2_num_unique_strings
=
count
;
}
public
String
getString
(
final
int
id
)
{
return
(
(
UnicodeString
)
field_3_strings
.
get
(
new
Integer
(
id
)
)
)
.
getString
(
)
;
}
public
boolean
getString16bit
(
final
int
id
)
{
return
(
(
(
UnicodeString
)
field_3_strings
.
get
(
new
Integer
(
id
)
)
)
.
getOptionFlags
(
)
==
1
)
;
}
public
String
toString
(
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
buffer
.
append
(
"[SST]\n"
)
;
buffer
.
append
(
"    .numstrings     = "
)
.
append
(
Integer
.
toHexString
(
getNumStrings
(
)
)
)
.
append
(
"\n"
)
;
buffer
.
append
(
"    .uniquestrings  = "
)
.
append
(
Integer
.
toHexString
(
getNumUniqueStrings
(
)
)
)
.
append
(
"\n"
)
;
for
(
int
k
=
0
;
k
<
field_3_strings
.
size
(
)
;
k
++
)
{
buffer
.
append
(
"    .string_"
+
k
+
"      = "
)
.
append
(
(
(
UnicodeString
)
field_3_strings
.
get
(
new
Integer
(
k
)
)
)
.
toString
(
)
)
.
append
(
"\n"
)
;
}
buffer
.
append
(
"[/SST]\n"
)
;
return
buffer
.
toString
(
)
;
}
public
int
serialize
(
int
offset
,
byte
[
]
data
)
{
int
rval
=
getRecordSize
(
)
;
int
record_length_index
=
0
;
int
unicodesize
=
calculateUnicodeSize
(
)
;
if
(
unicodesize
>
_max_data_space
)
{
byte
[
]
stringreminant
=
null
;
int
unipos
=
0
;
boolean
lastneedcontinue
=
false
;
int
stringbyteswritten
=
0
;
boolean
first_record
=
true
;
int
totalWritten
=
0
;
int
size
=
0
;
while
(
totalWritten
!=
rval
)
{
int
pos
=
0
;
int
available
;
if
(
first_record
)
{
size
=
(
(
Integer
)
_record_lengths
.
get
(
record_length_index
++
)
)
.
intValue
(
)
;
available
=
size
-
8
;
pos
=
writeSSTHeader
(
data
,
pos
+
offset
+
totalWritten
,
size
)
;
size
+=
_std_record_overhead
;
first_record
=
false
;
}
else
{
pos
=
0
;
int
to_be_written
=
(
unicodesize
-
stringbyteswritten
)
+
(
lastneedcontinue
?
1
:
0
)
;
size
=
(
(
Integer
)
_record_lengths
.
get
(
record_length_index
++
)
)
.
intValue
(
)
;
available
=
size
;
pos
=
writeContinueHeader
(
data
,
pos
+
offset
+
totalWritten
,
size
)
;
size
=
size
+
_std_record_overhead
;
}
if
(
lastneedcontinue
)
{
if
(
stringreminant
.
length
<=
available
)
{
System
.
arraycopy
(
stringreminant
,
0
,
data
,
pos
+
offset
+
totalWritten
,
stringreminant
.
length
)
;
stringbyteswritten
+=
stringreminant
.
length
-
1
;
pos
+=
stringreminant
.
length
;
lastneedcontinue
=
false
;
available
-=
stringreminant
.
length
;
}
else
{
System
.
arraycopy
(
stringreminant
,
0
,
data
,
pos
+
offset
+
totalWritten
,
available
)
;
stringbyteswritten
+=
available
-
1
;
pos
+=
available
;
byte
[
]
leftover
=
new
byte
[
(
stringreminant
.
length
-
available
)
+
LittleEndianConsts
.
BYTE_SIZE
]
;
System
.
arraycopy
(
stringreminant
,
available
,
leftover
,
LittleEndianConsts
.
BYTE_SIZE
,
stringreminant
.
length
-
available
)
;
leftover
[
0
]
=
stringreminant
[
0
]
;
stringreminant
=
leftover
;
available
=
0
;
lastneedcontinue
=
true
;
}
}
for
(
;
unipos
<
field_3_strings
.
size
(
)
;
unipos
++
)
{
Integer
intunipos
=
new
Integer
(
unipos
)
;
UnicodeString
unistr
=
(
(
UnicodeString
)
field_3_strings
.
get
(
intunipos
)
)
;
if
(
unistr
.
getRecordSize
(
)
<=
available
)
{
unistr
.
serialize
(
pos
+
offset
+
totalWritten
,
data
)
;
int
rsize
=
unistr
.
getRecordSize
(
)
;
stringbyteswritten
+=
rsize
;
pos
+=
rsize
;
available
-=
rsize
;
}
else
{
if
(
available
>=
_string_minimal_overhead
)
{
byte
[
]
ucs
=
unistr
.
serialize
(
)
;
System
.
arraycopy
(
ucs
,
0
,
data
,
pos
+
offset
+
totalWritten
,
available
)
;
stringbyteswritten
+=
available
;
stringreminant
=
new
byte
[
(
ucs
.
length
-
available
)
+
LittleEndianConsts
.
BYTE_SIZE
]
;
System
.
arraycopy
(
ucs
,
available
,
stringreminant
,
LittleEndianConsts
.
BYTE_SIZE
,
ucs
.
length
-
available
)
;
stringreminant
[
0
]
=
ucs
[
LittleEndianConsts
.
SHORT_SIZE
]
;
available
=
0
;
lastneedcontinue
=
true
;
unipos
++
;
}
break
;
}
}
totalWritten
+=
size
;
}
}
else
{
int
datasize
=
_sst_record_overhead
+
unicodesize
;
writeSSTHeader
(
data
,
0
+
offset
,
_sst_record_overhead
+
(
(
Integer
)
_record_lengths
.
get
(
record_length_index
++
)
)
.
intValue
(
)
-
_std_record_overhead
)
;
int
pos
=
_sst_record_overhead
;
for
(
int
k
=
0
;
k
<
field_3_strings
.
size
(
)
;
k
++
)
{
UnicodeString
unistr
=
(
(
UnicodeString
)
field_3_strings
.
get
(
new
Integer
(
k
)
)
)
;
System
.
arraycopy
(
unistr
.
serialize
(
)
,
0
,
data
,
pos
+
offset
,
unistr
.
getRecordSize
(
)
)
;
pos
+=
unistr
.
getRecordSize
(
)
;
}
}
return
rval
;
}
private
int
calculateStringsize
(
)
{
int
retval
=
0
;
for
(
int
k
=
0
;
k
<
field_3_strings
.
size
(
)
;
k
++
)
{
retval
+=
(
(
UnicodeString
)
field_3_strings
.
get
(
new
Integer
(
k
)
)
)
.
getRecordSize
(
)
;
}
return
retval
;
}
public
void
processContinueRecord
(
final
byte
[
]
record
)
{
if
(
getExpectedChars
(
)
==
0
)
{
_unfinished_string
=
""
;
_total_length_bytes
=
0
;
_string_data_offset
=
0
;
_wide_char
=
false
;
manufactureStrings
(
record
,
0
,
(
short
)
record
.
length
)
;
}
else
{
int
data_length
=
record
.
length
-
LittleEndianConsts
.
BYTE_SIZE
;
if
(
calculateByteCount
(
getExpectedChars
(
)
)
>
data_length
)
{
byte
[
]
input
=
new
byte
[
record
.
length
+
LittleEndianConsts
.
SHORT_SIZE
]
;
short
size
=
(
short
)
(
(
(
record
[
0
]
&
1
)
==
1
)
?
(
data_length
/
LittleEndianConsts
.
SHORT_SIZE
)
:
(
data_length
/
LittleEndianConsts
.
BYTE_SIZE
)
)
;
LittleEndian
.
putShort
(
input
,
(
byte
)
0
,
size
)
;
System
.
arraycopy
(
record
,
0
,
input
,
LittleEndianConsts
.
SHORT_SIZE
,
record
.
length
)
;
UnicodeString
ucs
=
new
UnicodeString
(
UnicodeString
.
sid
,
(
short
)
input
.
length
,
input
)
;
_unfinished_string
=
_unfinished_string
+
ucs
.
getString
(
)
;
setExpectedChars
(
getExpectedChars
(
)
-
size
)
;
}
else
{
setupStringParameters
(
record
,
-
LittleEndianConsts
.
SHORT_SIZE
,
getExpectedChars
(
)
)
;
byte
[
]
str_data
=
new
byte
[
_total_length_bytes
]
;
int
length
=
_string_minimal_overhead
+
(
calculateByteCount
(
getExpectedChars
(
)
)
)
;
byte
[
]
bstring
=
new
byte
[
length
]
;
System
.
arraycopy
(
record
,
0
,
str_data
,
LittleEndianConsts
.
SHORT_SIZE
,
str_data
.
length
-
LittleEndianConsts
.
SHORT_SIZE
)
;
LittleEndian
.
putShort
(
bstring
,
0
,
(
short
)
getExpectedChars
(
)
)
;
bstring
[
LittleEndianConsts
.
SHORT_SIZE
]
=
str_data
[
LittleEndianConsts
.
SHORT_SIZE
]
;
System
.
arraycopy
(
str_data
,
_string_data_offset
,
bstring
,
_string_minimal_overhead
,
bstring
.
length
-
_string_minimal_overhead
)
;
UnicodeString
string
=
new
UnicodeString
(
UnicodeString
.
sid
,
(
short
)
bstring
.
length
,
bstring
,
_unfinished_string
)
;
Integer
integer
=
new
Integer
(
field_3_strings
.
size
(
)
)
;
field_3_strings
.
put
(
integer
,
string
)
;
manufactureStrings
(
record
,
_total_length_bytes
-
LittleEndianConsts
.
SHORT_SIZE
,
(
short
)
record
.
length
)
;
}
}
}
public
short
getSid
(
)
{
return
sid
;
}
public
int
hashCode
(
)
{
return
field_2_num_unique_strings
;
}
public
boolean
equals
(
Object
o
)
{
if
(
(
o
==
null
)
||
(
o
.
getClass
(
)
!=
this
.
getClass
(
)
)
)
{
return
false
;
}
SSTRecord
other
=
(
SSTRecord
)
o
;
return
(
(
field_1_num_strings
==
other
.
field_1_num_strings
)
&&
(
field_2_num_unique_strings
==
other
.
field_2_num_unique_strings
)
&&
field_3_strings
.
equals
(
other
.
field_3_strings
)
)
;
}
protected
void
validateSid
(
final
short
id
)
throws
RecordFormatException
{
if
(
id
!=
sid
)
{
throw
new
RecordFormatException
(
"NOT An SST RECORD"
)
;
}
}
protected
void
fillFields
(
final
byte
[
]
data
,
final
short
size
,
int
offset
)
{
field_1_num_strings
=
LittleEndian
.
getInt
(
data
,
0
+
offset
)
;
field_2_num_unique_strings
=
LittleEndian
.
getInt
(
data
,
4
+
offset
)
;
field_3_strings
=
new
BinaryTree
(
)
;
setExpectedChars
(
0
)
;
_unfinished_string
=
""
;
_total_length_bytes
=
0
;
_string_data_offset
=
0
;
_wide_char
=
false
;
manufactureStrings
(
data
,
8
+
offset
,
size
)
;
}
int
getExpectedChars
(
)
{
return
__expected_chars
;
}
Iterator
getStrings
(
)
{
return
field_3_strings
.
values
(
)
.
iterator
(
)
;
}
int
countStrings
(
)
{
return
field_3_strings
.
size
(
)
;
}
String
getUnfinishedString
(
)
{
return
_unfinished_string
;
}
int
getTotalLength
(
)
{
return
_total_length_bytes
;
}
int
getStringDataOffset
(
)
{
return
_string_data_offset
;
}
boolean
isWideChar
(
)
{
return
_wide_char
;
}
private
int
writeSSTHeader
(
final
byte
[
]
data
,
final
int
pos
,
final
int
recsize
)
{
int
offset
=
pos
;
LittleEndian
.
putShort
(
data
,
offset
,
sid
)
;
offset
+=
LittleEndianConsts
.
SHORT_SIZE
;
LittleEndian
.
putShort
(
data
,
offset
,
(
short
)
(
recsize
)
)
;
offset
+=
LittleEndianConsts
.
SHORT_SIZE
;
LittleEndian
.
putInt
(
data
,
offset
,
getNumStrings
(
)
)
;
offset
+=
LittleEndianConsts
.
INT_SIZE
;
LittleEndian
.
putInt
(
data
,
offset
,
getNumUniqueStrings
(
)
)
;
offset
+=
LittleEndianConsts
.
INT_SIZE
;
return
offset
-
pos
;
}
private
int
writeContinueHeader
(
final
byte
[
]
data
,
final
int
pos
,
final
int
recsize
)
{
int
offset
=
pos
;
LittleEndian
.
putShort
(
data
,
offset
,
ContinueRecord
.
sid
)
;
offset
+=
LittleEndianConsts
.
SHORT_SIZE
;
LittleEndian
.
putShort
(
data
,
offset
,
(
short
)
(
recsize
)
)
;
offset
+=
LittleEndianConsts
.
SHORT_SIZE
;
return
offset
-
pos
;
}
private
int
calculateUCArrayLength
(
final
byte
[
]
[
]
ucarray
)
{
int
retval
=
0
;
for
(
int
k
=
0
;
k
<
ucarray
.
length
;
k
++
)
{
retval
+=
ucarray
[
k
]
.
length
;
}
return
retval
;
}
private
void
manufactureStrings
(
final
byte
[
]
data
,
final
int
index
,
short
size
)
{
int
offset
=
index
;
while
(
offset
<
size
)
{
int
remaining
=
size
-
offset
;
if
(
(
remaining
>
0
)
&&
(
remaining
<
LittleEndianConsts
.
SHORT_SIZE
)
)
{
throw
new
RecordFormatException
(
"Cannot get length of the last string in SSTRecord"
)
;
}
if
(
remaining
==
LittleEndianConsts
.
SHORT_SIZE
)
{
setExpectedChars
(
LittleEndian
.
getShort
(
data
,
offset
)
)
;
_unfinished_string
=
""
;
break
;
}
short
char_count
=
LittleEndian
.
getShort
(
data
,
offset
)
;
setupStringParameters
(
data
,
offset
,
char_count
)
;
if
(
remaining
<
_total_length_bytes
)
{
setExpectedChars
(
calculateCharCount
(
_total_length_bytes
-
remaining
)
)
;
char_count
-=
getExpectedChars
(
)
;
_total_length_bytes
=
remaining
;
}
else
{
setExpectedChars
(
0
)
;
}
processString
(
data
,
offset
,
char_count
)
;
offset
+=
_total_length_bytes
;
if
(
getExpectedChars
(
)
!=
0
)
{
break
;
}
}
}
private
void
setupStringParameters
(
final
byte
[
]
data
,
final
int
index
,
final
int
char_count
)
{
byte
flag
=
data
[
index
+
LittleEndianConsts
.
SHORT_SIZE
]
;
_wide_char
=
(
flag
&
1
)
==
1
;
boolean
extended
=
(
flag
&
4
)
==
4
;
boolean
formatted_run
=
(
flag
&
8
)
==
8
;
_total_length_bytes
=
_string_minimal_overhead
+
calculateByteCount
(
char_count
)
;
_string_data_offset
=
_string_minimal_overhead
;
if
(
formatted_run
)
{
short
run_count
=
LittleEndian
.
getShort
(
data
,
index
+
_string_data_offset
)
;
_string_data_offset
+=
LittleEndianConsts
.
SHORT_SIZE
;
_total_length_bytes
+=
LittleEndianConsts
.
SHORT_SIZE
+
(
LittleEndianConsts
.
INT_SIZE
*
run_count
)
;
}
if
(
extended
)
{
int
extension_length
=
LittleEndian
.
getInt
(
data
,
index
+
_string_data_offset
)
;
_string_data_offset
+=
LittleEndianConsts
.
INT_SIZE
;
_total_length_bytes
+=
LittleEndianConsts
.
INT_SIZE
+
extension_length
;
}
}
private
void
processString
(
final
byte
[
]
data
,
final
int
index
,
final
short
char_count
)
{
byte
[
]
str_data
=
new
byte
[
_total_length_bytes
]
;
int
length
=
_string_minimal_overhead
+
calculateByteCount
(
char_count
)
;
byte
[
]
bstring
=
new
byte
[
length
]
;
System
.
arraycopy
(
data
,
index
,
str_data
,
0
,
str_data
.
length
)
;
int
offset
=
0
;
LittleEndian
.
putShort
(
bstring
,
offset
,
char_count
)
;
offset
+=
LittleEndianConsts
.
SHORT_SIZE
;
bstring
[
offset
]
=
str_data
[
offset
]
;
System
.
arraycopy
(
str_data
,
_string_data_offset
,
bstring
,
_string_minimal_overhead
,
bstring
.
length
-
_string_minimal_overhead
)
;
UnicodeString
string
=
new
UnicodeString
(
UnicodeString
.
sid
,
(
short
)
bstring
.
length
,
bstring
)
;
if
(
getExpectedChars
(
)
!=
0
)
{
_unfinished_string
=
string
.
getString
(
)
;
}
else
{
Integer
integer
=
new
Integer
(
field_3_strings
.
size
(
)
)
;
field_3_strings
.
put
(
integer
,
string
)
;
}
}
private
void
setExpectedChars
(
final
int
count
)
{
__expected_chars
=
count
;
}
private
int
calculateByteCount
(
final
int
character_count
)
{
return
character_count
*
(
_wide_char
?
LittleEndianConsts
.
SHORT_SIZE
:
LittleEndianConsts
.
BYTE_SIZE
)
;
}
private
int
calculateCharCount
(
final
int
byte_count
)
{
return
byte_count
/
(
_wide_char
?
LittleEndianConsts
.
SHORT_SIZE
:
LittleEndianConsts
.
BYTE_SIZE
)
;
}
public
int
getRecordSize
(
)
{
_record_lengths
=
new
ArrayList
(
)
;
int
retval
=
0
;
int
unicodesize
=
calculateUnicodeSize
(
)
;
if
(
unicodesize
>
_max_data_space
)
{
UnicodeString
unistr
=
null
;
int
stringreminant
=
0
;
int
unipos
=
0
;
boolean
lastneedcontinue
=
false
;
int
stringbyteswritten
=
0
;
boolean
finished
=
false
;
boolean
first_record
=
true
;
int
totalWritten
=
0
;
while
(
!
finished
)
{
int
record
=
0
;
int
pos
=
0
;
if
(
first_record
)
{
record
=
_max
;
pos
=
12
;
first_record
=
false
;
_record_lengths
.
add
(
new
Integer
(
record
-
_std_record_overhead
)
)
;
}
else
{
pos
=
0
;
int
to_be_written
=
(
unicodesize
-
stringbyteswritten
)
+
(
lastneedcontinue
?
1
:
0
)
;
int
size
=
Math
.
min
(
_max
-
_std_record_overhead
,
to_be_written
)
;
if
(
size
==
to_be_written
)
{
finished
=
true
;
}
record
=
size
+
_std_record_overhead
;
_record_lengths
.
add
(
new
Integer
(
size
)
)
;
pos
=
4
;
}
if
(
lastneedcontinue
)
{
int
available
=
_max
-
pos
;
if
(
stringreminant
<=
available
)
{
stringbyteswritten
+=
stringreminant
-
1
;
pos
+=
stringreminant
;
lastneedcontinue
=
false
;
}
else
{
int
toBeWritten
=
unistr
.
maxBrokenLength
(
available
)
;
if
(
available
!=
toBeWritten
)
{
int
shortrecord
=
record
-
(
available
-
toBeWritten
)
;
_record_lengths
.
set
(
_record_lengths
.
size
(
)
-
1
,
new
Integer
(
shortrecord
-
_std_record_overhead
)
)
;
record
=
shortrecord
;
}
stringbyteswritten
+=
toBeWritten
-
1
;
pos
+=
toBeWritten
;
stringreminant
-=
toBeWritten
-
1
;
lastneedcontinue
=
true
;
}
}
for
(
;
unipos
<
field_3_strings
.
size
(
)
;
unipos
++
)
{
int
available
=
_max
-
pos
;
Integer
intunipos
=
new
Integer
(
unipos
)
;
unistr
=
(
(
UnicodeString
)
field_3_strings
.
get
(
intunipos
)
)
;
if
(
unistr
.
getRecordSize
(
)
<=
available
)
{
stringbyteswritten
+=
unistr
.
getRecordSize
(
)
;
pos
+=
unistr
.
getRecordSize
(
)
;
}
else
{
if
(
available
>=
_string_minimal_overhead
)
{
int
toBeWritten
=
unistr
.
maxBrokenLength
(
available
)
;
stringbyteswritten
+=
toBeWritten
;
stringreminant
=
(
unistr
.
getRecordSize
(
)
-
toBeWritten
)
+
LittleEndianConsts
.
BYTE_SIZE
;
if
(
available
!=
toBeWritten
)
{
int
shortrecord
=
record
-
(
available
-
toBeWritten
)
;
_record_lengths
.
set
(
_record_lengths
.
size
(
)
-
1
,
new
Integer
(
shortrecord
-
_std_record_overhead
)
)
;
record
=
shortrecord
;
}
lastneedcontinue
=
true
;
unipos
++
;
}
else
{
int
shortrecord
=
record
-
available
;
_record_lengths
.
set
(
_record_lengths
.
size
(
)
-
1
,
new
Integer
(
shortrecord
-
_std_record_overhead
)
)
;
record
=
shortrecord
;
}
break
;
}
}
totalWritten
+=
record
;
}
retval
=
totalWritten
;
}
else
{
retval
=
_sst_record_overhead
+
unicodesize
;
_record_lengths
.
add
(
new
Integer
(
unicodesize
)
)
;
}
return
retval
;
}
private
int
calculateUnicodeSize
(
)
{
int
retval
=
0
;
for
(
int
k
=
0
;
k
<
field_3_strings
.
size
(
)
;
k
++
)
{
UnicodeString
string
=
(
UnicodeString
)
field_3_strings
.
get
(
new
Integer
(
k
)
)
;
retval
+=
string
.
getRecordSize
(
)
;
}
return
retval
;
}
}
