package
org
.
apache
.
poi
.
poifs
.
storage
;
import
java
.
io
.
*
;
import
java
.
util
.
*
;
import
org
.
apache
.
poi
.
poifs
.
common
.
POIFSConstants
;
public
class
SmallDocumentBlock
implements
BlockWritable
,
ListManagedBlock
{
private
byte
[
]
_data
;
private
static
final
byte
_default_fill
=
(
byte
)
0xff
;
private
static
final
int
_block_size
=
64
;
private
static
final
int
_blocks_per_big_block
=
POIFSConstants
.
BIG_BLOCK_SIZE
/
_block_size
;
private
SmallDocumentBlock
(
final
byte
[
]
data
,
final
int
index
)
{
this
(
)
;
System
.
arraycopy
(
data
,
index
*
_block_size
,
_data
,
0
,
_block_size
)
;
}
private
SmallDocumentBlock
(
)
{
_data
=
new
byte
[
_block_size
]
;
}
public
static
SmallDocumentBlock
[
]
convert
(
final
byte
[
]
array
,
final
int
size
)
{
SmallDocumentBlock
[
]
rval
=
new
SmallDocumentBlock
[
(
size
+
_block_size
-
1
)
/
_block_size
]
;
int
offset
=
0
;
for
(
int
k
=
0
;
k
<
rval
.
length
;
k
++
)
{
rval
[
k
]
=
new
SmallDocumentBlock
(
)
;
if
(
offset
<
array
.
length
)
{
int
length
=
Math
.
min
(
_block_size
,
array
.
length
-
offset
)
;
System
.
arraycopy
(
array
,
offset
,
rval
[
k
]
.
_data
,
0
,
length
)
;
if
(
length
!=
_block_size
)
{
Arrays
.
fill
(
rval
[
k
]
.
_data
,
length
,
_block_size
,
_default_fill
)
;
}
}
else
{
Arrays
.
fill
(
rval
[
k
]
.
_data
,
_default_fill
)
;
}
offset
+=
_block_size
;
}
return
rval
;
}
public
static
int
fill
(
final
List
blocks
)
{
int
count
=
blocks
.
size
(
)
;
int
big_block_count
=
(
count
+
_blocks_per_big_block
-
1
)
/
_blocks_per_big_block
;
int
full_count
=
big_block_count
*
_blocks_per_big_block
;
for
(
;
count
<
full_count
;
count
++
)
{
blocks
.
add
(
makeEmptySmallDocumentBlock
(
)
)
;
}
return
big_block_count
;
}
public
static
SmallDocumentBlock
[
]
convert
(
final
BlockWritable
[
]
store
,
final
int
size
)
throws
IOException
,
ArrayIndexOutOfBoundsException
{
ByteArrayOutputStream
stream
=
new
ByteArrayOutputStream
(
)
;
for
(
int
j
=
0
;
j
<
store
.
length
;
j
++
)
{
store
[
j
]
.
writeBlocks
(
stream
)
;
}
byte
[
]
data
=
stream
.
toByteArray
(
)
;
SmallDocumentBlock
[
]
rval
=
new
SmallDocumentBlock
[
convertToBlockCount
(
size
)
]
;
for
(
int
index
=
0
;
index
<
rval
.
length
;
index
++
)
{
rval
[
index
]
=
new
SmallDocumentBlock
(
data
,
index
)
;
}
return
rval
;
}
public
static
List
extract
(
ListManagedBlock
[
]
blocks
)
throws
IOException
{
List
sdbs
=
new
ArrayList
(
)
;
for
(
int
j
=
0
;
j
<
blocks
.
length
;
j
++
)
{
byte
[
]
data
=
blocks
[
j
]
.
getData
(
)
;
for
(
int
k
=
0
;
k
<
_blocks_per_big_block
;
k
++
)
{
sdbs
.
add
(
new
SmallDocumentBlock
(
data
,
k
)
)
;
}
}
return
sdbs
;
}
public
static
void
read
(
final
BlockWritable
[
]
blocks
,
final
byte
[
]
buffer
,
final
int
offset
)
{
int
firstBlockIndex
=
offset
/
_block_size
;
int
firstBlockOffset
=
offset
%
_block_size
;
int
lastBlockIndex
=
(
offset
+
buffer
.
length
-
1
)
/
_block_size
;
if
(
firstBlockIndex
==
lastBlockIndex
)
{
System
.
arraycopy
(
(
(
SmallDocumentBlock
)
blocks
[
firstBlockIndex
]
)
.
_data
,
firstBlockOffset
,
buffer
,
0
,
buffer
.
length
)
;
}
else
{
int
buffer_offset
=
0
;
System
.
arraycopy
(
(
(
SmallDocumentBlock
)
blocks
[
firstBlockIndex
]
)
.
_data
,
firstBlockOffset
,
buffer
,
buffer_offset
,
_block_size
-
firstBlockOffset
)
;
buffer_offset
+=
_block_size
-
firstBlockOffset
;
for
(
int
j
=
firstBlockIndex
+
1
;
j
<
lastBlockIndex
;
j
++
)
{
System
.
arraycopy
(
(
(
SmallDocumentBlock
)
blocks
[
j
]
)
.
_data
,
0
,
buffer
,
buffer_offset
,
_block_size
)
;
buffer_offset
+=
_block_size
;
}
System
.
arraycopy
(
(
(
SmallDocumentBlock
)
blocks
[
lastBlockIndex
]
)
.
_data
,
0
,
buffer
,
buffer_offset
,
buffer
.
length
-
buffer_offset
)
;
}
}
public
static
int
calcSize
(
int
size
)
{
return
size
*
_block_size
;
}
private
static
SmallDocumentBlock
makeEmptySmallDocumentBlock
(
)
{
SmallDocumentBlock
block
=
new
SmallDocumentBlock
(
)
;
Arrays
.
fill
(
block
.
_data
,
_default_fill
)
;
return
block
;
}
private
static
int
convertToBlockCount
(
final
int
size
)
{
return
(
size
+
_block_size
-
1
)
/
_block_size
;
}
public
void
writeBlocks
(
final
OutputStream
stream
)
throws
IOException
{
stream
.
write
(
_data
)
;
}
public
byte
[
]
getData
(
)
throws
IOException
{
return
_data
;
}
}
