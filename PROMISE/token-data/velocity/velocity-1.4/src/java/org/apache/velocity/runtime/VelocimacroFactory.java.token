package
org
.
apache
.
velocity
.
runtime
;
import
org
.
apache
.
velocity
.
Template
;
import
org
.
apache
.
velocity
.
runtime
.
directive
.
Directive
;
import
org
.
apache
.
velocity
.
runtime
.
directive
.
VelocimacroProxy
;
import
java
.
util
.
Vector
;
import
java
.
util
.
Map
;
import
java
.
util
.
HashMap
;
public
class
VelocimacroFactory
{
private
RuntimeServices
rsvc
=
null
;
private
VelocimacroManager
vmManager
=
null
;
private
boolean
replaceAllowed
=
false
;
private
boolean
addNewAllowed
=
true
;
private
boolean
templateLocal
=
false
;
private
boolean
blather
=
false
;
private
boolean
autoReloadLibrary
=
false
;
private
Vector
macroLibVec
=
null
;
private
Map
libModMap
;
public
VelocimacroFactory
(
RuntimeServices
rs
)
{
this
.
rsvc
=
rs
;
libModMap
=
new
HashMap
(
)
;
vmManager
=
new
VelocimacroManager
(
rsvc
)
;
}
public
void
initVelocimacro
(
)
{
synchronized
(
this
)
{
setReplacementPermission
(
true
)
;
setBlather
(
true
)
;
logVMMessageInfo
(
"Velocimacro : initialization starting."
)
;
vmManager
.
setNamespaceUsage
(
false
)
;
Object
libfiles
=
rsvc
.
getProperty
(
RuntimeConstants
.
VM_LIBRARY
)
;
if
(
libfiles
!=
null
)
{
if
(
libfiles
instanceof
Vector
)
{
macroLibVec
=
(
Vector
)
libfiles
;
}
else
if
(
libfiles
instanceof
String
)
{
macroLibVec
=
new
Vector
(
)
;
macroLibVec
.
addElement
(
libfiles
)
;
}
for
(
int
i
=
0
;
i
<
macroLibVec
.
size
(
)
;
i
++
)
{
String
lib
=
(
String
)
macroLibVec
.
elementAt
(
i
)
;
if
(
lib
!=
null
&&
!
lib
.
equals
(
""
)
)
{
vmManager
.
setRegisterFromLib
(
true
)
;
logVMMessageInfo
(
"Velocimacro : adding VMs from "
+
"VM library template : "
+
lib
)
;
try
{
Template
template
=
rsvc
.
getTemplate
(
lib
)
;
Twonk
twonk
=
new
Twonk
(
)
;
twonk
.
template
=
template
;
twonk
.
modificationTime
=
template
.
getLastModified
(
)
;
libModMap
.
put
(
lib
,
twonk
)
;
}
catch
(
Exception
e
)
{
logVMMessageInfo
(
"Velocimacro : error using  VM "
+
"library template "
+
lib
+
" : "
+
e
)
;
}
logVMMessageInfo
(
"Velocimacro :  VM library template "
+
"macro registration complete."
)
;
vmManager
.
setRegisterFromLib
(
false
)
;
}
}
}
setAddMacroPermission
(
true
)
;
if
(
!
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_PERM_ALLOW_INLINE
,
true
)
)
{
setAddMacroPermission
(
false
)
;
logVMMessageInfo
(
"Velocimacro : allowInline = false : VMs can not "
+
"be defined inline in templates"
)
;
}
else
{
logVMMessageInfo
(
"Velocimacro : allowInline = true : VMs can be "
+
"defined inline in templates"
)
;
}
setReplacementPermission
(
false
)
;
if
(
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL
,
false
)
)
{
setReplacementPermission
(
true
)
;
logVMMessageInfo
(
"Velocimacro : allowInlineToOverride = true : VMs "
+
"defined inline may replace previous VM definitions"
)
;
}
else
{
logVMMessageInfo
(
"Velocimacro : allowInlineToOverride = false : VMs "
+
"defined inline may NOT replace previous VM definitions"
)
;
}
vmManager
.
setNamespaceUsage
(
true
)
;
setTemplateLocalInline
(
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_PERM_INLINE_LOCAL
,
false
)
)
;
if
(
getTemplateLocalInline
(
)
)
{
logVMMessageInfo
(
"Velocimacro : allowInlineLocal = true : VMs "
+
"defined inline will be local to their defining template only."
)
;
}
else
{
logVMMessageInfo
(
"Velocimacro : allowInlineLocal = false : VMs "
+
"defined inline will be  global in scope if allowed."
)
;
}
vmManager
.
setTemplateLocalInlineVM
(
getTemplateLocalInline
(
)
)
;
setBlather
(
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_MESSAGES_ON
,
true
)
)
;
if
(
getBlather
(
)
)
{
logVMMessageInfo
(
"Velocimacro : messages on  : VM system "
+
"will output logging messages"
)
;
}
else
{
logVMMessageInfo
(
"Velocimacro : messages off : VM system will be quiet"
)
;
}
setAutoload
(
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_LIBRARY_AUTORELOAD
,
false
)
)
;
if
(
getAutoload
(
)
)
{
logVMMessageInfo
(
"Velocimacro : autoload on  : VM system "
+
"will automatically reload global library macros"
)
;
}
else
{
logVMMessageInfo
(
"Velocimacro : autoload off  : VM system "
+
"will not automatically reload global library macros"
)
;
}
rsvc
.
info
(
"Velocimacro : initialization complete."
)
;
}
return
;
}
public
boolean
addVelocimacro
(
String
name
,
String
macroBody
,
String
argArray
[
]
,
String
sourceTemplate
)
{
if
(
name
==
null
||
macroBody
==
null
||
argArray
==
null
||
sourceTemplate
==
null
)
{
logVMMessageWarn
(
"Velocimacro : VM addition rejected : "
+
"programmer error : arg null"
)
;
return
false
;
}
if
(
!
canAddVelocimacro
(
name
,
sourceTemplate
)
)
{
return
false
;
}
synchronized
(
this
)
{
vmManager
.
addVM
(
name
,
macroBody
,
argArray
,
sourceTemplate
)
;
}
if
(
blather
)
{
String
s
=
"#"
+
argArray
[
0
]
;
s
+=
"("
;
for
(
int
i
=
1
;
i
<
argArray
.
length
;
i
++
)
{
s
+=
" "
;
s
+=
argArray
[
i
]
;
}
s
+=
" ) : source = "
;
s
+=
sourceTemplate
;
logVMMessageInfo
(
"Velocimacro : added new VM : "
+
s
)
;
}
return
true
;
}
private
boolean
canAddVelocimacro
(
String
name
,
String
sourceTemplate
)
{
if
(
getAutoload
(
)
)
{
for
(
int
i
=
0
;
i
<
macroLibVec
.
size
(
)
;
i
++
)
{
String
lib
=
(
String
)
macroLibVec
.
elementAt
(
i
)
;
if
(
lib
.
equals
(
sourceTemplate
)
)
{
return
true
;
}
}
}
if
(
!
addNewAllowed
)
{
logVMMessageWarn
(
"Velocimacro : VM addition rejected : "
+
name
+
" : inline VMs not allowed."
)
;
return
false
;
}
if
(
!
templateLocal
)
{
if
(
isVelocimacro
(
name
,
sourceTemplate
)
&&
!
replaceAllowed
)
{
logVMMessageWarn
(
"Velocimacro : VM addition rejected : "
+
name
+
" : inline not allowed to replace existing VM"
)
;
return
false
;
}
}
return
true
;
}
private
void
logVMMessageInfo
(
String
s
)
{
if
(
blather
)
rsvc
.
info
(
s
)
;
}
private
void
logVMMessageWarn
(
String
s
)
{
if
(
blather
)
rsvc
.
warn
(
s
)
;
}
public
boolean
isVelocimacro
(
String
vm
,
String
sourceTemplate
)
{
synchronized
(
this
)
{
if
(
vmManager
.
get
(
vm
,
sourceTemplate
)
!=
null
)
return
true
;
}
return
false
;
}
public
Directive
getVelocimacro
(
String
vmName
,
String
sourceTemplate
)
{
VelocimacroProxy
vp
=
null
;
synchronized
(
this
)
{
vp
=
vmManager
.
get
(
vmName
,
sourceTemplate
)
;
if
(
vp
!=
null
&&
getAutoload
(
)
)
{
String
lib
=
vmManager
.
getLibraryName
(
vmName
,
sourceTemplate
)
;
if
(
lib
!=
null
)
{
try
{
Twonk
tw
=
(
Twonk
)
libModMap
.
get
(
lib
)
;
if
(
tw
!=
null
)
{
Template
template
=
tw
.
template
;
long
tt
=
tw
.
modificationTime
;
long
ft
=
template
.
getResourceLoader
(
)
.
getLastModified
(
template
)
;
if
(
ft
>
tt
)
{
logVMMessageInfo
(
"Velocimacro : autoload reload for VMs from "
+
"VM library template : "
+
lib
)
;
tw
.
modificationTime
=
ft
;
template
=
rsvc
.
getTemplate
(
lib
)
;
tw
.
template
=
template
;
tw
.
modificationTime
=
template
.
getLastModified
(
)
;
}
}
}
catch
(
Exception
e
)
{
logVMMessageInfo
(
"Velocimacro : error using  VM "
+
"library template "
+
lib
+
" : "
+
e
)
;
}
vp
=
vmManager
.
get
(
vmName
,
sourceTemplate
)
;
}
}
}
return
vp
;
}
public
boolean
dumpVMNamespace
(
String
namespace
)
{
return
vmManager
.
dumpNamespace
(
namespace
)
;
}
private
void
setTemplateLocalInline
(
boolean
b
)
{
templateLocal
=
b
;
}
private
boolean
getTemplateLocalInline
(
)
{
return
templateLocal
;
}
private
boolean
setAddMacroPermission
(
boolean
arg
)
{
boolean
b
=
addNewAllowed
;
addNewAllowed
=
arg
;
return
b
;
}
private
boolean
setReplacementPermission
(
boolean
arg
)
{
boolean
b
=
replaceAllowed
;
replaceAllowed
=
arg
;
return
b
;
}
private
void
setBlather
(
boolean
b
)
{
blather
=
b
;
}
private
boolean
getBlather
(
)
{
return
blather
;
}
private
void
setAutoload
(
boolean
b
)
{
autoReloadLibrary
=
b
;
}
private
boolean
getAutoload
(
)
{
return
autoReloadLibrary
;
}
private
class
Twonk
{
public
Template
template
;
public
long
modificationTime
;
}
}
