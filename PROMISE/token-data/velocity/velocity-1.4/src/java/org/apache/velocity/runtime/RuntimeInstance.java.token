package
org
.
apache
.
velocity
.
runtime
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
Reader
;
import
java
.
util
.
Map
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Properties
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
HashMap
;
import
org
.
apache
.
velocity
.
Template
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
LogManager
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
LogSystem
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
PrimordialLogSystem
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
NullLogSystem
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
Parser
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
ParseException
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SimpleNode
;
import
org
.
apache
.
velocity
.
runtime
.
directive
.
Directive
;
import
org
.
apache
.
velocity
.
runtime
.
VelocimacroFactory
;
import
org
.
apache
.
velocity
.
runtime
.
resource
.
ContentResource
;
import
org
.
apache
.
velocity
.
runtime
.
resource
.
ResourceManager
;
import
org
.
apache
.
velocity
.
util
.
SimplePool
;
import
org
.
apache
.
velocity
.
util
.
StringUtils
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
Introspector
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
Uberspect
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
UberspectLoggable
;
import
org
.
apache
.
velocity
.
exception
.
ResourceNotFoundException
;
import
org
.
apache
.
velocity
.
exception
.
ParseErrorException
;
import
org
.
apache
.
commons
.
collections
.
ExtendedProperties
;
public
class
RuntimeInstance
implements
RuntimeConstants
,
RuntimeServices
{
private
VelocimacroFactory
vmFactory
=
null
;
private
LogSystem
logSystem
=
new
PrimordialLogSystem
(
)
;
private
SimplePool
parserPool
;
private
boolean
initialized
;
private
ExtendedProperties
overridingProperties
=
null
;
private
Hashtable
runtimeDirectives
;
private
ExtendedProperties
configuration
=
new
ExtendedProperties
(
)
;
private
ResourceManager
resourceManager
=
null
;
private
Introspector
introspector
=
null
;
private
Map
applicationAttributes
=
null
;
private
Uberspect
uberSpect
;
public
RuntimeInstance
(
)
{
vmFactory
=
new
VelocimacroFactory
(
this
)
;
introspector
=
new
Introspector
(
this
)
;
applicationAttributes
=
new
HashMap
(
)
;
}
public
synchronized
void
init
(
)
throws
Exception
{
if
(
initialized
==
false
)
{
info
(
"************************************************************** "
)
;
info
(
"Starting Jakarta Velocity v1.4"
)
;
info
(
"RuntimeInstance initializing."
)
;
initializeProperties
(
)
;
initializeLogger
(
)
;
initializeResourceManager
(
)
;
initializeDirectives
(
)
;
initializeParserPool
(
)
;
initializeIntrospection
(
)
;
vmFactory
.
initVelocimacro
(
)
;
info
(
"Velocity successfully started."
)
;
initialized
=
true
;
}
}
private
void
initializeIntrospection
(
)
throws
Exception
{
String
rm
=
getString
(
RuntimeConstants
.
UBERSPECT_CLASSNAME
)
;
if
(
rm
!=
null
&&
rm
.
length
(
)
>
0
)
{
Object
o
=
null
;
try
{
o
=
Class
.
forName
(
rm
)
.
newInstance
(
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
String
err
=
"The specified class for Uberspect ("
+
rm
+
") does not exist (or is not accessible to the current classlaoder."
;
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
if
(
!
(
o
instanceof
Uberspect
)
)
{
String
err
=
"The specified class for Uberspect ("
+
rm
+
") does not implement org.apache.velocity.util.introspector.Uberspect."
+
" Velocity not initialized correctly."
;
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
uberSpect
=
(
Uberspect
)
o
;
if
(
uberSpect
instanceof
UberspectLoggable
)
{
(
(
UberspectLoggable
)
uberSpect
)
.
setRuntimeLogger
(
this
)
;
}
uberSpect
.
init
(
)
;
}
else
{
String
err
=
"It appears that no class was specified as the"
+
" Uberspect.  Please ensure that all configuration"
+
" information is correct."
;
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
}
private
void
setDefaultProperties
(
)
{
try
{
InputStream
inputStream
=
getClass
(
)
.
getResourceAsStream
(
'/'
+
DEFAULT_RUNTIME_PROPERTIES
)
;
configuration
.
load
(
inputStream
)
;
info
(
"Default Properties File: "
+
new
File
(
DEFAULT_RUNTIME_PROPERTIES
)
.
getPath
(
)
)
;
}
catch
(
IOException
ioe
)
{
System
.
err
.
println
(
"Cannot get Velocity Runtime default properties!"
)
;
}
}
public
void
setProperty
(
String
key
,
Object
value
)
{
if
(
overridingProperties
==
null
)
{
overridingProperties
=
new
ExtendedProperties
(
)
;
}
overridingProperties
.
setProperty
(
key
,
value
)
;
}
public
void
setConfiguration
(
ExtendedProperties
configuration
)
{
if
(
overridingProperties
==
null
)
{
overridingProperties
=
configuration
;
}
else
{
if
(
overridingProperties
!=
configuration
)
{
overridingProperties
.
combine
(
configuration
)
;
}
}
}
public
void
addProperty
(
String
key
,
Object
value
)
{
if
(
overridingProperties
==
null
)
{
overridingProperties
=
new
ExtendedProperties
(
)
;
}
overridingProperties
.
addProperty
(
key
,
value
)
;
}
public
void
clearProperty
(
String
key
)
{
if
(
overridingProperties
!=
null
)
{
overridingProperties
.
clearProperty
(
key
)
;
}
}
public
Object
getProperty
(
String
key
)
{
return
configuration
.
getProperty
(
key
)
;
}
private
void
initializeProperties
(
)
{
if
(
configuration
.
isInitialized
(
)
==
false
)
{
setDefaultProperties
(
)
;
}
if
(
overridingProperties
!=
null
)
{
configuration
.
combine
(
overridingProperties
)
;
}
}
public
void
init
(
Properties
p
)
throws
Exception
{
overridingProperties
=
ExtendedProperties
.
convertProperties
(
p
)
;
init
(
)
;
}
public
void
init
(
String
configurationFile
)
throws
Exception
{
overridingProperties
=
new
ExtendedProperties
(
configurationFile
)
;
init
(
)
;
}
private
void
initializeResourceManager
(
)
throws
Exception
{
String
rm
=
getString
(
RuntimeConstants
.
RESOURCE_MANAGER_CLASS
)
;
if
(
rm
!=
null
&&
rm
.
length
(
)
>
0
)
{
Object
o
=
null
;
try
{
o
=
Class
.
forName
(
rm
)
.
newInstance
(
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
String
err
=
"The specified class for Resourcemanager ("
+
rm
+
") does not exist (or is not accessible to the current classlaoder."
;
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
if
(
!
(
o
instanceof
ResourceManager
)
)
{
String
err
=
"The specified class for ResourceManager ("
+
rm
+
") does not implement org.apache.runtime.resource.ResourceManager."
+
" Velocity not initialized correctly."
;
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
resourceManager
=
(
ResourceManager
)
o
;
resourceManager
.
initialize
(
this
)
;
}
else
{
String
err
=
"It appears that no class was specified as the"
+
" ResourceManager.  Please ensure that all configuration"
+
" information is correct."
;
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
}
private
void
initializeLogger
(
)
throws
Exception
{
if
(
logSystem
instanceof
PrimordialLogSystem
)
{
PrimordialLogSystem
pls
=
(
PrimordialLogSystem
)
logSystem
;
logSystem
=
LogManager
.
createLogSystem
(
this
)
;
if
(
logSystem
==
null
)
{
logSystem
=
new
NullLogSystem
(
)
;
}
else
{
pls
.
dumpLogMessages
(
logSystem
)
;
}
}
}
private
void
initializeDirectives
(
)
throws
Exception
{
runtimeDirectives
=
new
Hashtable
(
)
;
Properties
directiveProperties
=
new
Properties
(
)
;
InputStream
inputStream
=
getClass
(
)
.
getResourceAsStream
(
'/'
+
DEFAULT_RUNTIME_DIRECTIVES
)
;
if
(
inputStream
==
null
)
throw
new
Exception
(
"Error loading directive.properties! "
+
"Something is very wrong if these properties "
+
"aren't being located. Either your Velocity "
+
"distribution is incomplete or your Velocity "
+
"jar file is corrupted!"
)
;
directiveProperties
.
load
(
inputStream
)
;
Enumeration
directiveClasses
=
directiveProperties
.
elements
(
)
;
while
(
directiveClasses
.
hasMoreElements
(
)
)
{
String
directiveClass
=
(
String
)
directiveClasses
.
nextElement
(
)
;
loadDirective
(
directiveClass
,
"System"
)
;
}
String
[
]
userdirective
=
configuration
.
getStringArray
(
"userdirective"
)
;
for
(
int
i
=
0
;
i
<
userdirective
.
length
;
i
++
)
{
loadDirective
(
userdirective
[
i
]
,
"User"
)
;
}
}
private
void
loadDirective
(
String
directiveClass
,
String
caption
)
{
try
{
Object
o
=
Class
.
forName
(
directiveClass
)
.
newInstance
(
)
;
if
(
o
instanceof
Directive
)
{
Directive
directive
=
(
Directive
)
o
;
runtimeDirectives
.
put
(
directive
.
getName
(
)
,
directive
)
;
info
(
"Loaded "
+
caption
+
" Directive: "
+
directiveClass
)
;
}
else
{
error
(
caption
+
" Directive "
+
directiveClass
+
" is not org.apache.velocity.runtime.directive.Directive."
+
" Ignoring. "
)
;
}
}
catch
(
Exception
e
)
{
error
(
"Exception Loading "
+
caption
+
" Directive: "
+
directiveClass
+
" : "
+
e
)
;
}
}
private
void
initializeParserPool
(
)
{
int
numParsers
=
getInt
(
PARSER_POOL_SIZE
,
NUMBER_OF_PARSERS
)
;
parserPool
=
new
SimplePool
(
numParsers
)
;
for
(
int
i
=
0
;
i
<
numParsers
;
i
++
)
{
parserPool
.
put
(
createNewParser
(
)
)
;
}
info
(
"Created: "
+
numParsers
+
" parsers."
)
;
}
public
Parser
createNewParser
(
)
{
Parser
parser
=
new
Parser
(
this
)
;
parser
.
setDirectives
(
runtimeDirectives
)
;
return
parser
;
}
public
SimpleNode
parse
(
Reader
reader
,
String
templateName
)
throws
ParseException
{
return
parse
(
reader
,
templateName
,
true
)
;
}
public
SimpleNode
parse
(
Reader
reader
,
String
templateName
,
boolean
dumpNamespace
)
throws
ParseException
{
SimpleNode
ast
=
null
;
Parser
parser
=
(
Parser
)
parserPool
.
get
(
)
;
boolean
madeNew
=
false
;
if
(
parser
==
null
)
{
error
(
"Runtime : ran out of parsers. Creating new.  "
+
" Please increment the parser.pool.size property."
+
" The current value is too small."
)
;
parser
=
createNewParser
(
)
;
if
(
parser
!=
null
)
{
madeNew
=
true
;
}
}
if
(
parser
!=
null
)
{
try
{
if
(
dumpNamespace
)
{
dumpVMNamespace
(
templateName
)
;
}
ast
=
parser
.
parse
(
reader
,
templateName
)
;
}
finally
{
if
(
!
madeNew
)
{
parserPool
.
put
(
parser
)
;
}
}
}
else
{
error
(
"Runtime : ran out of parsers and unable to create more."
)
;
}
return
ast
;
}
public
Template
getTemplate
(
String
name
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
return
getTemplate
(
name
,
getString
(
INPUT_ENCODING
,
ENCODING_DEFAULT
)
)
;
}
public
Template
getTemplate
(
String
name
,
String
encoding
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
return
(
Template
)
resourceManager
.
getResource
(
name
,
ResourceManager
.
RESOURCE_TEMPLATE
,
encoding
)
;
}
public
ContentResource
getContent
(
String
name
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
return
getContent
(
name
,
getString
(
INPUT_ENCODING
,
ENCODING_DEFAULT
)
)
;
}
public
ContentResource
getContent
(
String
name
,
String
encoding
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
return
(
ContentResource
)
resourceManager
.
getResource
(
name
,
ResourceManager
.
RESOURCE_CONTENT
,
encoding
)
;
}
public
String
getLoaderNameForResource
(
String
resourceName
)
{
return
resourceManager
.
getLoaderNameForResource
(
resourceName
)
;
}
private
boolean
showStackTrace
(
)
{
if
(
configuration
.
isInitialized
(
)
)
{
return
getBoolean
(
RUNTIME_LOG_WARN_STACKTRACE
,
false
)
;
}
else
{
return
false
;
}
}
private
void
log
(
int
level
,
Object
message
)
{
String
out
;
if
(
showStackTrace
(
)
&&
(
message
instanceof
Throwable
||
message
instanceof
Exception
)
)
{
out
=
StringUtils
.
stackTrace
(
(
Throwable
)
message
)
;
}
else
{
out
=
message
.
toString
(
)
;
}
logSystem
.
logVelocityMessage
(
level
,
out
)
;
}
public
void
warn
(
Object
message
)
{
log
(
LogSystem
.
WARN_ID
,
message
)
;
}
public
void
info
(
Object
message
)
{
log
(
LogSystem
.
INFO_ID
,
message
)
;
}
public
void
error
(
Object
message
)
{
log
(
LogSystem
.
ERROR_ID
,
message
)
;
}
public
void
debug
(
Object
message
)
{
log
(
LogSystem
.
DEBUG_ID
,
message
)
;
}
public
String
getString
(
String
key
,
String
defaultValue
)
{
return
configuration
.
getString
(
key
,
defaultValue
)
;
}
public
Directive
getVelocimacro
(
String
vmName
,
String
templateName
)
{
return
vmFactory
.
getVelocimacro
(
vmName
,
templateName
)
;
}
public
boolean
addVelocimacro
(
String
name
,
String
macro
,
String
argArray
[
]
,
String
sourceTemplate
)
{
return
vmFactory
.
addVelocimacro
(
name
,
macro
,
argArray
,
sourceTemplate
)
;
}
public
boolean
isVelocimacro
(
String
vmName
,
String
templateName
)
{
return
vmFactory
.
isVelocimacro
(
vmName
,
templateName
)
;
}
public
boolean
dumpVMNamespace
(
String
namespace
)
{
return
vmFactory
.
dumpVMNamespace
(
namespace
)
;
}
public
String
getString
(
String
key
)
{
return
configuration
.
getString
(
key
)
;
}
public
int
getInt
(
String
key
)
{
return
configuration
.
getInt
(
key
)
;
}
public
int
getInt
(
String
key
,
int
defaultValue
)
{
return
configuration
.
getInt
(
key
,
defaultValue
)
;
}
public
boolean
getBoolean
(
String
key
,
boolean
def
)
{
return
configuration
.
getBoolean
(
key
,
def
)
;
}
public
ExtendedProperties
getConfiguration
(
)
{
return
configuration
;
}
public
Introspector
getIntrospector
(
)
{
return
introspector
;
}
public
Object
getApplicationAttribute
(
Object
key
)
{
return
applicationAttributes
.
get
(
key
)
;
}
public
Object
setApplicationAttribute
(
Object
key
,
Object
o
)
{
return
applicationAttributes
.
put
(
key
,
o
)
;
}
public
Uberspect
getUberspect
(
)
{
return
uberSpect
;
}
}
