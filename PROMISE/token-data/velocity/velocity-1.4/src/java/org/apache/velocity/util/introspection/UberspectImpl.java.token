package
org
.
apache
.
velocity
.
util
.
introspection
;
import
org
.
apache
.
velocity
.
util
.
ArrayIterator
;
import
org
.
apache
.
velocity
.
util
.
EnumerationIterator
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeServices
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeLogger
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
AbstractExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
PropertyExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
GetExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
BooleanPropertyExecutor
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Map
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
ArrayList
;
public
class
UberspectImpl
implements
Uberspect
,
UberspectLoggable
{
private
RuntimeLogger
rlog
;
private
static
Introspector
introspector
;
public
void
init
(
)
throws
Exception
{
}
public
void
setRuntimeLogger
(
RuntimeLogger
runtimeLogger
)
{
rlog
=
runtimeLogger
;
introspector
=
new
Introspector
(
rlog
)
;
}
public
Iterator
getIterator
(
Object
obj
,
Info
i
)
throws
Exception
{
if
(
obj
.
getClass
(
)
.
isArray
(
)
)
{
return
new
ArrayIterator
(
obj
)
;
}
else
if
(
obj
instanceof
Collection
)
{
return
(
(
Collection
)
obj
)
.
iterator
(
)
;
}
else
if
(
obj
instanceof
Map
)
{
return
(
(
Map
)
obj
)
.
values
(
)
.
iterator
(
)
;
}
else
if
(
obj
instanceof
Iterator
)
{
rlog
.
warn
(
"Warning! The iterative "
+
" is an Iterator in the #foreach() loop at ["
+
i
.
getLine
(
)
+
","
+
i
.
getColumn
(
)
+
"]"
+
" in template "
+
i
.
getTemplateName
(
)
+
". Because it's not resetable,"
+
" if used in more than once, this may lead to"
+
" unexpected results."
)
;
return
(
(
Iterator
)
obj
)
;
}
else
if
(
obj
instanceof
Enumeration
)
{
rlog
.
warn
(
"Warning! The iterative "
+
" is an Enumeration in the #foreach() loop at ["
+
i
.
getLine
(
)
+
","
+
i
.
getColumn
(
)
+
"]"
+
" in template "
+
i
.
getTemplateName
(
)
+
". Because it's not resetable,"
+
" if used in more than once, this may lead to"
+
" unexpected results."
)
;
return
new
EnumerationIterator
(
(
Enumeration
)
obj
)
;
}
rlog
.
warn
(
"Could not determine type of iterator in "
+
"#foreach loop "
+
" at ["
+
i
.
getLine
(
)
+
","
+
i
.
getColumn
(
)
+
"]"
+
" in template "
+
i
.
getTemplateName
(
)
)
;
return
null
;
}
public
VelMethod
getMethod
(
Object
obj
,
String
methodName
,
Object
[
]
args
,
Info
i
)
throws
Exception
{
if
(
obj
==
null
)
return
null
;
Method
m
=
introspector
.
getMethod
(
obj
.
getClass
(
)
,
methodName
,
args
)
;
return
(
m
!=
null
)
?
new
VelMethodImpl
(
m
)
:
null
;
}
public
VelPropertyGet
getPropertyGet
(
Object
obj
,
String
identifier
,
Info
i
)
throws
Exception
{
AbstractExecutor
executor
;
Class
claz
=
obj
.
getClass
(
)
;
executor
=
new
PropertyExecutor
(
rlog
,
introspector
,
claz
,
identifier
)
;
if
(
executor
.
isAlive
(
)
==
false
)
{
executor
=
new
GetExecutor
(
rlog
,
introspector
,
claz
,
identifier
)
;
}
if
(
executor
.
isAlive
(
)
==
false
)
{
executor
=
new
BooleanPropertyExecutor
(
rlog
,
introspector
,
claz
,
identifier
)
;
}
return
(
executor
!=
null
)
?
new
VelGetterImpl
(
executor
)
:
null
;
}
public
VelPropertySet
getPropertySet
(
Object
obj
,
String
identifier
,
Object
arg
,
Info
i
)
throws
Exception
{
Class
claz
=
obj
.
getClass
(
)
;
VelPropertySet
vs
=
null
;
VelMethod
vm
=
null
;
try
{
Object
[
]
params
=
{
arg
}
;
try
{
vm
=
getMethod
(
obj
,
"set"
+
identifier
,
params
,
i
)
;
if
(
vm
==
null
)
{
throw
new
NoSuchMethodException
(
)
;
}
}
catch
(
NoSuchMethodException
nsme2
)
{
StringBuffer
sb
=
new
StringBuffer
(
"set"
)
;
sb
.
append
(
identifier
)
;
if
(
Character
.
isLowerCase
(
sb
.
charAt
(
3
)
)
)
{
sb
.
setCharAt
(
3
,
Character
.
toUpperCase
(
sb
.
charAt
(
3
)
)
)
;
}
else
{
sb
.
setCharAt
(
3
,
Character
.
toLowerCase
(
sb
.
charAt
(
3
)
)
)
;
}
vm
=
getMethod
(
obj
,
sb
.
toString
(
)
,
params
,
i
)
;
if
(
vm
==
null
)
{
throw
new
NoSuchMethodException
(
)
;
}
}
}
catch
(
NoSuchMethodException
nsme
)
{
if
(
Map
.
class
.
isAssignableFrom
(
claz
)
)
{
Object
[
]
params
=
{
new
Object
(
)
,
new
Object
(
)
}
;
vm
=
getMethod
(
obj
,
"put"
,
params
,
i
)
;
if
(
vm
!=
null
)
return
new
VelSetterImpl
(
vm
,
identifier
)
;
}
}
return
(
vm
!=
null
)
?
new
VelSetterImpl
(
vm
)
:
null
;
}
public
class
VelMethodImpl
implements
VelMethod
{
Method
method
=
null
;
public
VelMethodImpl
(
Method
m
)
{
method
=
m
;
}
private
VelMethodImpl
(
)
{
}
public
Object
invoke
(
Object
o
,
Object
[
]
params
)
throws
Exception
{
return
method
.
invoke
(
o
,
params
)
;
}
public
boolean
isCacheable
(
)
{
return
true
;
}
public
String
getMethodName
(
)
{
return
method
.
getName
(
)
;
}
public
Class
getReturnType
(
)
{
return
method
.
getReturnType
(
)
;
}
}
public
class
VelGetterImpl
implements
VelPropertyGet
{
AbstractExecutor
ae
=
null
;
public
VelGetterImpl
(
AbstractExecutor
exec
)
{
ae
=
exec
;
}
private
VelGetterImpl
(
)
{
}
public
Object
invoke
(
Object
o
)
throws
Exception
{
return
ae
.
execute
(
o
)
;
}
public
boolean
isCacheable
(
)
{
return
true
;
}
public
String
getMethodName
(
)
{
return
ae
.
getMethod
(
)
.
getName
(
)
;
}
}
public
class
VelSetterImpl
implements
VelPropertySet
{
VelMethod
vm
=
null
;
String
putKey
=
null
;
public
VelSetterImpl
(
VelMethod
velmethod
)
{
this
.
vm
=
velmethod
;
}
public
VelSetterImpl
(
VelMethod
velmethod
,
String
key
)
{
this
.
vm
=
velmethod
;
putKey
=
key
;
}
private
VelSetterImpl
(
)
{
}
public
Object
invoke
(
Object
o
,
Object
value
)
throws
Exception
{
ArrayList
al
=
new
ArrayList
(
)
;
if
(
putKey
!=
null
)
{
al
.
add
(
putKey
)
;
al
.
add
(
value
)
;
}
else
{
al
.
add
(
value
)
;
}
return
vm
.
invoke
(
o
,
al
.
toArray
(
)
)
;
}
public
boolean
isCacheable
(
)
{
return
true
;
}
public
String
getMethodName
(
)
{
return
vm
.
getMethodName
(
)
;
}
}
}
