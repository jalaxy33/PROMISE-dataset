package
org
.
apache
.
velocity
.
runtime
.
configuration
;
import
java
.
io
.
IOException
;
import
java
.
io
.
File
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
InputStreamReader
;
import
java
.
io
.
LineNumberReader
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
PrintWriter
;
import
java
.
io
.
Reader
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
NoSuchElementException
;
import
java
.
util
.
Properties
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Vector
;
import
org
.
apache
.
commons
.
collections
.
ExtendedProperties
;
public
class
Configuration
extends
Hashtable
{
private
ExtendedProperties
deprecationCrutch
=
new
ExtendedProperties
(
)
;
private
Configuration
defaults
;
protected
String
file
;
protected
String
basePath
;
protected
String
fileSeparator
=
System
.
getProperty
(
"file.separator"
)
;
protected
boolean
isInitialized
=
false
;
protected
static
String
include
=
"include"
;
protected
ArrayList
keysAsListed
=
new
ArrayList
(
)
;
class
PropertiesReader
extends
LineNumberReader
{
public
PropertiesReader
(
Reader
reader
)
{
super
(
reader
)
;
}
public
String
readProperty
(
)
throws
IOException
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
try
{
while
(
true
)
{
String
line
=
readLine
(
)
.
trim
(
)
;
if
(
(
line
.
length
(
)
!=
0
)
&&
(
line
.
charAt
(
0
)
!=
'#'
)
)
{
if
(
line
.
endsWith
(
"\\"
)
)
{
line
=
line
.
substring
(
0
,
line
.
length
(
)
-
1
)
;
buffer
.
append
(
line
)
;
}
else
{
buffer
.
append
(
line
)
;
break
;
}
}
}
}
catch
(
NullPointerException
e
)
{
return
null
;
}
return
buffer
.
toString
(
)
;
}
}
class
PropertiesTokenizer
extends
StringTokenizer
{
static
final
String
DELIMITER
=
","
;
public
PropertiesTokenizer
(
String
string
)
{
super
(
string
,
DELIMITER
)
;
}
public
boolean
hasMoreTokens
(
)
{
return
super
.
hasMoreTokens
(
)
;
}
public
String
nextToken
(
)
{
StringBuffer
buffer
=
new
StringBuffer
(
)
;
while
(
hasMoreTokens
(
)
)
{
String
token
=
super
.
nextToken
(
)
;
if
(
token
.
endsWith
(
"\\"
)
)
{
buffer
.
append
(
token
.
substring
(
0
,
token
.
length
(
)
-
1
)
)
;
buffer
.
append
(
DELIMITER
)
;
}
else
{
buffer
.
append
(
token
)
;
break
;
}
}
return
buffer
.
toString
(
)
.
trim
(
)
;
}
}
public
Configuration
(
)
{
super
(
)
;
}
public
Configuration
(
String
file
)
throws
IOException
{
this
(
file
,
null
)
;
}
public
Configuration
(
String
file
,
String
defaultFile
)
throws
IOException
{
this
.
file
=
file
;
basePath
=
new
File
(
file
)
.
getAbsolutePath
(
)
;
basePath
=
basePath
.
substring
(
0
,
basePath
.
lastIndexOf
(
fileSeparator
)
+
1
)
;
this
.
load
(
new
FileInputStream
(
file
)
)
;
if
(
defaultFile
!=
null
)
{
defaults
=
new
Configuration
(
defaultFile
)
;
}
}
private
void
init
(
Configuration
exp
)
throws
IOException
{
isInitialized
=
true
;
}
public
boolean
isInitialized
(
)
{
return
isInitialized
;
}
public
String
getInclude
(
)
{
return
Configuration
.
include
;
}
public
void
setInclude
(
String
inc
)
{
Configuration
.
include
=
inc
;
}
public
synchronized
void
load
(
InputStream
input
)
throws
IOException
{
PropertiesReader
reader
=
new
PropertiesReader
(
new
InputStreamReader
(
input
)
)
;
try
{
while
(
true
)
{
String
line
=
reader
.
readProperty
(
)
;
int
equalSign
=
line
.
indexOf
(
'='
)
;
if
(
equalSign
>
0
)
{
String
key
=
line
.
substring
(
0
,
equalSign
)
.
trim
(
)
;
String
value
=
line
.
substring
(
equalSign
+
1
)
.
trim
(
)
;
if
(
""
.
equals
(
value
)
)
continue
;
if
(
getInclude
(
)
!=
null
&&
key
.
equalsIgnoreCase
(
getInclude
(
)
)
)
{
File
file
=
null
;
if
(
value
.
startsWith
(
fileSeparator
)
)
{
file
=
new
File
(
value
)
;
}
else
{
if
(
value
.
startsWith
(
"."
+
fileSeparator
)
)
{
value
=
value
.
substring
(
2
)
;
}
file
=
new
File
(
basePath
+
value
)
;
}
if
(
file
!=
null
&&
file
.
exists
(
)
&&
file
.
canRead
(
)
)
{
load
(
new
FileInputStream
(
file
)
)
;
}
}
else
{
addProperty
(
key
,
value
)
;
}
}
}
}
catch
(
NullPointerException
e
)
{
return
;
}
}
public
Object
getProperty
(
String
key
)
{
Object
o
=
this
.
get
(
key
)
;
if
(
o
==
null
)
{
if
(
defaults
!=
null
)
{
o
=
defaults
.
get
(
key
)
;
}
}
return
o
;
}
public
void
addProperty
(
String
key
,
Object
token
)
{
deprecationCrutch
.
addProperty
(
key
,
token
)
;
Object
o
=
this
.
get
(
key
)
;
if
(
o
instanceof
String
)
{
Vector
v
=
new
Vector
(
2
)
;
v
.
addElement
(
o
)
;
v
.
addElement
(
token
)
;
put
(
key
,
v
)
;
}
else
if
(
o
instanceof
Vector
)
{
(
(
Vector
)
o
)
.
addElement
(
token
)
;
}
else
{
if
(
token
instanceof
String
&&
(
(
String
)
token
)
.
indexOf
(
PropertiesTokenizer
.
DELIMITER
)
>
0
)
{
PropertiesTokenizer
tokenizer
=
new
PropertiesTokenizer
(
(
String
)
token
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
String
value
=
tokenizer
.
nextToken
(
)
;
addStringProperty
(
key
,
value
)
;
}
}
else
{
if
(
!
containsKey
(
key
)
)
{
keysAsListed
.
add
(
key
)
;
}
put
(
key
,
token
)
;
}
}
}
private
void
addStringProperty
(
String
key
,
String
token
)
{
Object
o
=
this
.
get
(
key
)
;
if
(
o
instanceof
String
)
{
Vector
v
=
new
Vector
(
2
)
;
v
.
addElement
(
o
)
;
v
.
addElement
(
token
)
;
put
(
key
,
v
)
;
}
else
if
(
o
instanceof
Vector
)
{
(
(
Vector
)
o
)
.
addElement
(
token
)
;
}
else
{
if
(
!
containsKey
(
key
)
)
{
keysAsListed
.
add
(
key
)
;
}
put
(
key
,
token
)
;
}
}
public
void
setProperty
(
String
key
,
Object
value
)
{
clearProperty
(
key
)
;
addProperty
(
key
,
value
)
;
}
public
synchronized
void
save
(
OutputStream
output
,
String
Header
)
throws
IOException
{
if
(
output
!=
null
)
{
PrintWriter
theWrtr
=
new
PrintWriter
(
output
)
;
if
(
Header
!=
null
)
{
theWrtr
.
println
(
Header
)
;
}
Enumeration
theKeys
=
keys
(
)
;
while
(
theKeys
.
hasMoreElements
(
)
)
{
String
key
=
(
String
)
theKeys
.
nextElement
(
)
;
Object
value
=
get
(
(
Object
)
key
)
;
if
(
value
!=
null
)
{
if
(
value
instanceof
String
)
{
StringBuffer
currentOutput
=
new
StringBuffer
(
)
;
currentOutput
.
append
(
key
)
;
currentOutput
.
append
(
"="
)
;
currentOutput
.
append
(
(
String
)
value
)
;
theWrtr
.
println
(
currentOutput
.
toString
(
)
)
;
}
else
if
(
value
instanceof
Vector
)
{
Vector
values
=
(
Vector
)
value
;
Enumeration
valuesEnum
=
values
.
elements
(
)
;
while
(
valuesEnum
.
hasMoreElements
(
)
)
{
String
currentElement
=
(
String
)
valuesEnum
.
nextElement
(
)
;
StringBuffer
currentOutput
=
new
StringBuffer
(
)
;
currentOutput
.
append
(
key
)
;
currentOutput
.
append
(
"="
)
;
currentOutput
.
append
(
currentElement
)
;
theWrtr
.
println
(
currentOutput
.
toString
(
)
)
;
}
}
}
theWrtr
.
println
(
)
;
theWrtr
.
flush
(
)
;
}
}
}
public
void
combine
(
Configuration
c
)
{
for
(
Iterator
i
=
c
.
getKeys
(
)
;
i
.
hasNext
(
)
;
)
{
String
key
=
(
String
)
i
.
next
(
)
;
setProperty
(
key
,
c
.
get
(
key
)
)
;
}
}
public
void
clearProperty
(
String
key
)
{
deprecationCrutch
.
clearProperty
(
key
)
;
if
(
containsKey
(
key
)
)
{
for
(
int
i
=
0
;
i
<
keysAsListed
.
size
(
)
;
i
++
)
{
if
(
(
(
String
)
keysAsListed
.
get
(
i
)
)
.
equals
(
key
)
)
{
keysAsListed
.
remove
(
i
)
;
break
;
}
}
remove
(
key
)
;
}
}
public
Iterator
getKeys
(
)
{
return
keysAsListed
.
iterator
(
)
;
}
public
Iterator
getKeys
(
String
prefix
)
{
Iterator
keys
=
getKeys
(
)
;
ArrayList
matchingKeys
=
new
ArrayList
(
)
;
while
(
keys
.
hasNext
(
)
)
{
Object
key
=
keys
.
next
(
)
;
if
(
key
instanceof
String
&&
(
(
String
)
key
)
.
startsWith
(
prefix
)
)
{
matchingKeys
.
add
(
key
)
;
}
}
return
matchingKeys
.
iterator
(
)
;
}
public
Configuration
subset
(
String
prefix
)
{
Configuration
c
=
new
Configuration
(
)
;
Iterator
keys
=
getKeys
(
)
;
boolean
validSubset
=
false
;
while
(
keys
.
hasNext
(
)
)
{
Object
key
=
keys
.
next
(
)
;
if
(
key
instanceof
String
&&
(
(
String
)
key
)
.
startsWith
(
prefix
)
)
{
if
(
!
validSubset
)
{
validSubset
=
true
;
}
String
newKey
=
null
;
if
(
(
(
String
)
key
)
.
length
(
)
==
prefix
.
length
(
)
)
{
newKey
=
prefix
;
}
else
{
newKey
=
(
(
String
)
key
)
.
substring
(
prefix
.
length
(
)
+
1
)
;
}
c
.
setProperty
(
newKey
,
get
(
key
)
)
;
}
}
if
(
validSubset
)
{
return
c
;
}
else
{
return
null
;
}
}
public
void
display
(
)
{
Iterator
i
=
getKeys
(
)
;
while
(
i
.
hasNext
(
)
)
{
String
key
=
(
String
)
i
.
next
(
)
;
Object
value
=
get
(
key
)
;
System
.
out
.
println
(
key
+
" => "
+
value
)
;
}
}
public
String
getString
(
String
key
)
{
return
getString
(
key
,
null
)
;
}
public
String
getString
(
String
key
,
String
defaultValue
)
{
Object
value
=
get
(
key
)
;
if
(
value
instanceof
String
)
{
return
(
String
)
value
;
}
else
if
(
value
==
null
)
{
if
(
defaults
!=
null
)
{
return
defaults
.
getString
(
key
,
defaultValue
)
;
}
else
{
return
defaultValue
;
}
}
else
if
(
value
instanceof
Vector
)
{
return
(
String
)
(
(
Vector
)
value
)
.
get
(
0
)
;
}
else
{
throw
new
ClassCastException
(
'\''
+
key
+
"' doesn't map to a String object"
)
;
}
}
public
Properties
getProperties
(
String
key
)
{
return
getProperties
(
key
,
new
Properties
(
)
)
;
}
public
Properties
getProperties
(
String
key
,
Properties
defaults
)
{
String
[
]
tokens
=
getStringArray
(
key
)
;
Properties
props
=
new
Properties
(
defaults
)
;
for
(
int
i
=
0
;
i
<
tokens
.
length
;
i
++
)
{
String
token
=
tokens
[
i
]
;
int
equalSign
=
token
.
indexOf
(
'='
)
;
if
(
equalSign
>
0
)
{
String
pkey
=
token
.
substring
(
0
,
equalSign
)
.
trim
(
)
;
String
pvalue
=
token
.
substring
(
equalSign
+
1
)
.
trim
(
)
;
props
.
put
(
pkey
,
pvalue
)
;
}
else
{
throw
new
IllegalArgumentException
(
'\''
+
token
+
"' does not contain "
+
"an equals sign"
)
;
}
}
return
props
;
}
public
String
[
]
getStringArray
(
String
key
)
{
Object
value
=
get
(
key
)
;
Vector
vector
;
if
(
value
instanceof
String
)
{
vector
=
new
Vector
(
1
)
;
vector
.
addElement
(
value
)
;
}
else
if
(
value
instanceof
Vector
)
{
vector
=
(
Vector
)
value
;
}
else
if
(
value
==
null
)
{
if
(
defaults
!=
null
)
{
return
defaults
.
getStringArray
(
key
)
;
}
else
{
return
new
String
[
0
]
;
}
}
else
{
throw
new
ClassCastException
(
'\''
+
key
+
"' doesn't map to a String/Vector object"
)
;
}
String
[
]
tokens
=
new
String
[
vector
.
size
(
)
]
;
for
(
int
i
=
0
;
i
<
tokens
.
length
;
i
++
)
{
tokens
[
i
]
=
(
String
)
vector
.
elementAt
(
i
)
;
}
return
tokens
;
}
public
Vector
getVector
(
String
key
)
{
return
getVector
(
key
,
null
)
;
}
public
Vector
getVector
(
String
key
,
Vector
defaultValue
)
{
Object
value
=
get
(
key
)
;
if
(
value
instanceof
Vector
)
{
return
(
Vector
)
value
;
}
else
if
(
value
instanceof
String
)
{
Vector
v
=
new
Vector
(
1
)
;
v
.
addElement
(
(
String
)
value
)
;
put
(
key
,
v
)
;
return
v
;
}
else
if
(
value
==
null
)
{
if
(
defaults
!=
null
)
{
return
defaults
.
getVector
(
key
,
defaultValue
)
;
}
else
{
return
(
(
defaultValue
==
null
)
?
new
Vector
(
)
:
defaultValue
)
;
}
}
else
{
throw
new
ClassCastException
(
'\''
+
key
+
"' doesn't map to a Vector object"
)
;
}
}
public
boolean
getBoolean
(
String
key
)
{
Boolean
b
=
getBoolean
(
key
,
(
Boolean
)
null
)
;
if
(
b
!=
null
)
{
return
b
.
booleanValue
(
)
;
}
else
{
throw
new
NoSuchElementException
(
'\''
+
key
+
"' doesn't map to an existing object"
)
;
}
}
public
boolean
getBoolean
(
String
key
,
boolean
defaultValue
)
{
return
getBoolean
(
key
,
new
Boolean
(
defaultValue
)
)
.
booleanValue
(
)
;
}
public
Boolean
getBoolean
(
String
key
,
Boolean
defaultValue
)
{
Object
value
=
get
(
key
)
;
if
(
value
instanceof
Boolean
)
{
return
(
Boolean
)
value
;
}
else
if
(
value
instanceof
String
)
{
String
s
=
testBoolean
(
(
String
)
value
)
;
Boolean
b
=
new
Boolean
(
s
)
;
put
(
key
,
b
)
;
return
b
;
}
else
if
(
value
==
null
)
{
if
(
defaults
!=
null
)
{
return
defaults
.
getBoolean
(
key
,
defaultValue
)
;
}
else
{
return
defaultValue
;
}
}
else
{
throw
new
ClassCastException
(
'\''
+
key
+
"' doesn't map to a Boolean object"
)
;
}
}
public
String
testBoolean
(
String
value
)
{
String
s
=
(
(
String
)
value
)
.
toLowerCase
(
)
;
if
(
s
.
equals
(
"true"
)
||
s
.
equals
(
"on"
)
||
s
.
equals
(
"yes"
)
)
{
return
"true"
;
}
else
if
(
s
.
equals
(
"false"
)
||
s
.
equals
(
"off"
)
||
s
.
equals
(
"no"
)
)
{
return
"false"
;
}
else
{
return
null
;
}
}
public
byte
getByte
(
String
key
)
{
Byte
b
=
getByte
(
key
,
null
)
;
if
(
b
!=
null
)
{
return
b
.
byteValue
(
)
;
}
else
{
throw
new
NoSuchElementException
(
'\''
+
key
+
" doesn't map to an existing object"
)
;
}
}
public
byte
getByte
(
String
key
,
byte
defaultValue
)
{
return
getByte
(
key
,
new
Byte
(
defaultValue
)
)
.
byteValue
(
)
;
}
public
Byte
getByte
(
String
key
,
Byte
defaultValue
)
{
Object
value
=
get
(
key
)
;
if
(
value
instanceof
Byte
)
{
return
(
Byte
)
value
;
}
else
if
(
value
instanceof
String
)
{
Byte
b
=
new
Byte
(
(
String
)
value
)
;
put
(
key
,
b
)
;
return
b
;
}
else
if
(
value
==
null
)
{
if
(
defaults
!=
null
)
{
return
defaults
.
getByte
(
key
,
defaultValue
)
;
}
else
{
return
defaultValue
;
}
}
else
{
throw
new
ClassCastException
(
'\''
+
key
+
"' doesn't map to a Byte object"
)
;
}
}
public
short
getShort
(
String
key
)
{
Short
s
=
getShort
(
key
,
null
)
;
if
(
s
!=
null
)
{
return
s
.
shortValue
(
)
;
}
else
{
throw
new
NoSuchElementException
(
'\''
+
key
+
"' doesn't map to an existing object"
)
;
}
}
public
short
getShort
(
String
key
,
short
defaultValue
)
{
return
getShort
(
key
,
new
Short
(
defaultValue
)
)
.
shortValue
(
)
;
}
public
Short
getShort
(
String
key
,
Short
defaultValue
)
{
Object
value
=
get
(
key
)
;
if
(
value
instanceof
Short
)
{
return
(
Short
)
value
;
}
else
if
(
value
instanceof
String
)
{
Short
s
=
new
Short
(
(
String
)
value
)
;
put
(
key
,
s
)
;
return
s
;
}
else
if
(
value
==
null
)
{
if
(
defaults
!=
null
)
{
return
defaults
.
getShort
(
key
,
defaultValue
)
;
}
else
{
return
defaultValue
;
}
}
else
{
throw
new
ClassCastException
(
'\''
+
key
+
"' doesn't map to a Short object"
)
;
}
}
public
int
getInt
(
String
name
)
{
return
getInteger
(
name
)
;
}
public
int
getInt
(
String
name
,
int
def
)
{
return
getInteger
(
name
,
def
)
;
}
public
int
getInteger
(
String
key
)
{
Integer
i
=
getInteger
(
key
,
null
)
;
if
(
i
!=
null
)
{
return
i
.
intValue
(
)
;
}
else
{
throw
new
NoSuchElementException
(
'\''
+
key
+
"' doesn't map to an existing object"
)
;
}
}
public
int
getInteger
(
String
key
,
int
defaultValue
)
{
Integer
i
=
getInteger
(
key
,
null
)
;
if
(
i
==
null
)
{
return
defaultValue
;
}
return
i
.
intValue
(
)
;
}
public
Integer
getInteger
(
String
key
,
Integer
defaultValue
)
{
Object
value
=
get
(
key
)
;
if
(
value
instanceof
Integer
)
{
return
(
Integer
)
value
;
}
else
if
(
value
instanceof
String
)
{
Integer
i
=
new
Integer
(
(
String
)
value
)
;
put
(
key
,
i
)
;
return
i
;
}
else
if
(
value
==
null
)
{
if
(
defaults
!=
null
)
{
return
defaults
.
getInteger
(
key
,
defaultValue
)
;
}
else
{
return
defaultValue
;
}
}
else
{
throw
new
ClassCastException
(
'\''
+
key
+
"' doesn't map to a Integer object"
)
;
}
}
public
long
getLong
(
String
key
)
{
Long
l
=
getLong
(
key
,
null
)
;
if
(
l
!=
null
)
{
return
l
.
longValue
(
)
;
}
else
{
throw
new
NoSuchElementException
(
'\''
+
key
+
"' doesn't map to an existing object"
)
;
}
}
public
long
getLong
(
String
key
,
long
defaultValue
)
{
return
getLong
(
key
,
new
Long
(
defaultValue
)
)
.
longValue
(
)
;
}
public
Long
getLong
(
String
key
,
Long
defaultValue
)
{
Object
value
=
get
(
key
)
;
if
(
value
instanceof
Long
)
{
return
(
Long
)
value
;
}
else
if
(
value
instanceof
String
)
{
Long
l
=
new
Long
(
(
String
)
value
)
;
put
(
key
,
l
)
;
return
l
;
}
else
if
(
value
==
null
)
{
if
(
defaults
!=
null
)
{
return
defaults
.
getLong
(
key
,
defaultValue
)
;
}
else
{
return
defaultValue
;
}
}
else
{
throw
new
ClassCastException
(
'\''
+
key
+
"' doesn't map to a Long object"
)
;
}
}
public
float
getFloat
(
String
key
)
{
Float
f
=
getFloat
(
key
,
null
)
;
if
(
f
!=
null
)
{
return
f
.
floatValue
(
)
;
}
else
{
throw
new
NoSuchElementException
(
'\''
+
key
+
"' doesn't map to an existing object"
)
;
}
}
public
float
getFloat
(
String
key
,
float
defaultValue
)
{
return
getFloat
(
key
,
new
Float
(
defaultValue
)
)
.
floatValue
(
)
;
}
public
Float
getFloat
(
String
key
,
Float
defaultValue
)
{
Object
value
=
get
(
key
)
;
if
(
value
instanceof
Float
)
{
return
(
Float
)
value
;
}
else
if
(
value
instanceof
String
)
{
Float
f
=
new
Float
(
(
String
)
value
)
;
put
(
key
,
f
)
;
return
f
;
}
else
if
(
value
==
null
)
{
if
(
defaults
!=
null
)
{
return
defaults
.
getFloat
(
key
,
defaultValue
)
;
}
else
{
return
defaultValue
;
}
}
else
{
throw
new
ClassCastException
(
'\''
+
key
+
"' doesn't map to a Float object"
)
;
}
}
public
double
getDouble
(
String
key
)
{
Double
d
=
getDouble
(
key
,
null
)
;
if
(
d
!=
null
)
{
return
d
.
doubleValue
(
)
;
}
else
{
throw
new
NoSuchElementException
(
'\''
+
key
+
"' doesn't map to an existing object"
)
;
}
}
public
double
getDouble
(
String
key
,
double
defaultValue
)
{
return
getDouble
(
key
,
new
Double
(
defaultValue
)
)
.
doubleValue
(
)
;
}
public
Double
getDouble
(
String
key
,
Double
defaultValue
)
{
Object
value
=
get
(
key
)
;
if
(
value
instanceof
Double
)
{
return
(
Double
)
value
;
}
else
if
(
value
instanceof
String
)
{
Double
d
=
new
Double
(
(
String
)
value
)
;
put
(
key
,
d
)
;
return
d
;
}
else
if
(
value
==
null
)
{
if
(
defaults
!=
null
)
{
return
defaults
.
getDouble
(
key
,
defaultValue
)
;
}
else
{
return
defaultValue
;
}
}
else
{
throw
new
ClassCastException
(
'\''
+
key
+
"' doesn't map to a Double object"
)
;
}
}
public
static
Configuration
convertProperties
(
Properties
p
)
{
Configuration
c
=
new
Configuration
(
)
;
for
(
Enumeration
e
=
p
.
keys
(
)
;
e
.
hasMoreElements
(
)
;
)
{
String
s
=
(
String
)
e
.
nextElement
(
)
;
c
.
setProperty
(
s
,
p
.
getProperty
(
s
)
)
;
}
return
c
;
}
public
ExtendedProperties
getExtendedProperties
(
)
{
return
deprecationCrutch
;
}
}
