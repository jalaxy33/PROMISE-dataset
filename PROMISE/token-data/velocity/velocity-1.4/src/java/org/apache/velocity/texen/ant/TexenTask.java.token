package
org
.
apache
.
velocity
.
texen
.
ant
;
import
java
.
util
.
StringTokenizer
;
import
java
.
util
.
Date
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Map
;
import
java
.
io
.
File
;
import
java
.
io
.
Writer
;
import
java
.
io
.
FileInputStream
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
IOException
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
Task
;
import
org
.
apache
.
velocity
.
VelocityContext
;
import
org
.
apache
.
velocity
.
app
.
VelocityEngine
;
import
org
.
apache
.
velocity
.
context
.
Context
;
import
org
.
apache
.
velocity
.
texen
.
Generator
;
import
org
.
apache
.
velocity
.
util
.
StringUtils
;
import
org
.
apache
.
velocity
.
exception
.
MethodInvocationException
;
import
org
.
apache
.
velocity
.
exception
.
ParseErrorException
;
import
org
.
apache
.
velocity
.
exception
.
ResourceNotFoundException
;
import
org
.
apache
.
commons
.
collections
.
ExtendedProperties
;
public
class
TexenTask
extends
Task
{
private
final
static
String
ERR_MSG_FRAGMENT
=
". For more information consult the velocity log, or invoke ant "
+
"with the -debug flag."
;
protected
String
controlTemplate
;
protected
String
templatePath
;
protected
String
outputDirectory
;
protected
String
outputFile
;
protected
String
outputEncoding
;
protected
String
inputEncoding
;
protected
ExtendedProperties
contextProperties
;
protected
boolean
useClasspath
;
private
String
fileSeparator
=
System
.
getProperty
(
"file.separator"
)
;
public
void
setControlTemplate
(
String
controlTemplate
)
{
this
.
controlTemplate
=
controlTemplate
;
}
public
String
getControlTemplate
(
)
{
return
controlTemplate
;
}
public
void
setTemplatePath
(
String
templatePath
)
throws
Exception
{
StringBuffer
resolvedPath
=
new
StringBuffer
(
)
;
StringTokenizer
st
=
new
StringTokenizer
(
templatePath
,
","
)
;
while
(
st
.
hasMoreTokens
(
)
)
{
File
fullPath
=
project
.
resolveFile
(
st
.
nextToken
(
)
)
;
resolvedPath
.
append
(
fullPath
.
getCanonicalPath
(
)
)
;
if
(
st
.
hasMoreTokens
(
)
)
{
resolvedPath
.
append
(
","
)
;
}
}
this
.
templatePath
=
resolvedPath
.
toString
(
)
;
System
.
out
.
println
(
templatePath
)
;
}
public
String
getTemplatePath
(
)
{
return
templatePath
;
}
public
void
setOutputDirectory
(
File
outputDirectory
)
{
try
{
this
.
outputDirectory
=
outputDirectory
.
getCanonicalPath
(
)
;
}
catch
(
java
.
io
.
IOException
ioe
)
{
throw
new
BuildException
(
ioe
)
;
}
}
public
String
getOutputDirectory
(
)
{
return
outputDirectory
;
}
public
void
setOutputFile
(
String
outputFile
)
{
this
.
outputFile
=
outputFile
;
}
public
void
setOutputEncoding
(
String
outputEncoding
)
{
this
.
outputEncoding
=
outputEncoding
;
}
public
void
setInputEncoding
(
String
inputEncoding
)
{
this
.
inputEncoding
=
inputEncoding
;
}
public
String
getOutputFile
(
)
{
return
outputFile
;
}
public
void
setContextProperties
(
String
file
)
{
String
[
]
sources
=
StringUtils
.
split
(
file
,
","
)
;
contextProperties
=
new
ExtendedProperties
(
)
;
for
(
int
i
=
0
;
i
<
sources
.
length
;
i
++
)
{
ExtendedProperties
source
=
new
ExtendedProperties
(
)
;
try
{
File
fullPath
=
project
.
resolveFile
(
sources
[
i
]
)
;
log
(
"Using contextProperties file: "
+
fullPath
)
;
source
.
load
(
new
FileInputStream
(
fullPath
)
)
;
}
catch
(
Exception
e
)
{
ClassLoader
classLoader
=
this
.
getClass
(
)
.
getClassLoader
(
)
;
try
{
InputStream
inputStream
=
classLoader
.
getResourceAsStream
(
sources
[
i
]
)
;
if
(
inputStream
==
null
)
{
throw
new
BuildException
(
"Context properties file "
+
sources
[
i
]
+
" could not be found in the file system or on the classpath!"
)
;
}
else
{
source
.
load
(
inputStream
)
;
}
}
catch
(
IOException
ioe
)
{
source
=
null
;
}
}
Iterator
j
=
source
.
getKeys
(
)
;
while
(
j
.
hasNext
(
)
)
{
String
name
=
(
String
)
j
.
next
(
)
;
String
value
=
source
.
getString
(
name
)
;
contextProperties
.
setProperty
(
name
,
value
)
;
}
}
}
public
ExtendedProperties
getContextProperties
(
)
{
return
contextProperties
;
}
public
void
setUseClasspath
(
boolean
useClasspath
)
{
this
.
useClasspath
=
useClasspath
;
}
public
Context
initControlContext
(
)
throws
Exception
{
return
new
VelocityContext
(
)
;
}
public
void
execute
(
)
throws
BuildException
{
if
(
templatePath
==
null
&&
useClasspath
==
false
)
{
throw
new
BuildException
(
"The template path needs to be defined if you are not using "
+
"the classpath for locating templates!"
)
;
}
if
(
controlTemplate
==
null
)
{
throw
new
BuildException
(
"The control template needs to be defined!"
)
;
}
if
(
outputDirectory
==
null
)
{
throw
new
BuildException
(
"The output directory needs to be defined!"
)
;
}
if
(
outputFile
==
null
)
{
throw
new
BuildException
(
"The output file needs to be defined!"
)
;
}
VelocityEngine
ve
=
new
VelocityEngine
(
)
;
try
{
if
(
templatePath
!=
null
)
{
log
(
"Using templatePath: "
+
templatePath
,
project
.
MSG_VERBOSE
)
;
ve
.
setProperty
(
ve
.
FILE_RESOURCE_LOADER_PATH
,
templatePath
)
;
}
if
(
useClasspath
)
{
log
(
"Using classpath"
)
;
ve
.
addProperty
(
VelocityEngine
.
RESOURCE_LOADER
,
"classpath"
)
;
ve
.
setProperty
(
"classpath."
+
VelocityEngine
.
RESOURCE_LOADER
+
".class"
,
"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"
)
;
ve
.
setProperty
(
"classpath."
+
VelocityEngine
.
RESOURCE_LOADER
+
".cache"
,
"false"
)
;
ve
.
setProperty
(
"classpath."
+
VelocityEngine
.
RESOURCE_LOADER
+
".modificationCheckInterval"
,
"2"
)
;
}
ve
.
init
(
)
;
Generator
generator
=
Generator
.
getInstance
(
)
;
generator
.
setVelocityEngine
(
ve
)
;
generator
.
setOutputPath
(
outputDirectory
)
;
generator
.
setInputEncoding
(
inputEncoding
)
;
generator
.
setOutputEncoding
(
outputEncoding
)
;
if
(
templatePath
!=
null
)
{
generator
.
setTemplatePath
(
templatePath
)
;
}
File
file
=
new
File
(
outputDirectory
)
;
if
(
!
file
.
exists
(
)
)
{
file
.
mkdirs
(
)
;
}
String
path
=
outputDirectory
+
File
.
separator
+
outputFile
;
log
(
"Generating to file "
+
path
,
project
.
MSG_INFO
)
;
Writer
writer
=
generator
.
getWriter
(
path
,
outputEncoding
)
;
Context
c
=
initControlContext
(
)
;
populateInitialContext
(
c
)
;
if
(
contextProperties
!=
null
)
{
Iterator
i
=
contextProperties
.
getKeys
(
)
;
while
(
i
.
hasNext
(
)
)
{
String
property
=
(
String
)
i
.
next
(
)
;
String
value
=
contextProperties
.
getString
(
property
)
;
try
{
c
.
put
(
property
,
new
Integer
(
value
)
)
;
}
catch
(
NumberFormatException
nfe
)
{
String
booleanString
=
contextProperties
.
testBoolean
(
value
)
;
if
(
booleanString
!=
null
)
{
c
.
put
(
property
,
new
Boolean
(
booleanString
)
)
;
}
else
{
if
(
property
.
endsWith
(
"file.contents"
)
)
{
value
=
StringUtils
.
fileContentsToString
(
project
.
resolveFile
(
value
)
.
getCanonicalPath
(
)
)
;
property
=
property
.
substring
(
0
,
property
.
indexOf
(
"file.contents"
)
-
1
)
;
}
c
.
put
(
property
,
value
)
;
}
}
}
}
writer
.
write
(
generator
.
parse
(
controlTemplate
,
c
)
)
;
writer
.
flush
(
)
;
writer
.
close
(
)
;
generator
.
shutdown
(
)
;
cleanup
(
)
;
}
catch
(
BuildException
e
)
{
throw
e
;
}
catch
(
MethodInvocationException
e
)
{
throw
new
BuildException
(
"Exception thrown by '"
+
e
.
getReferenceName
(
)
+
"."
+
e
.
getMethodName
(
)
+
"'"
+
ERR_MSG_FRAGMENT
,
e
.
getWrappedThrowable
(
)
)
;
}
catch
(
ParseErrorException
e
)
{
throw
new
BuildException
(
"Velocity syntax error"
+
ERR_MSG_FRAGMENT
,
e
)
;
}
catch
(
ResourceNotFoundException
e
)
{
throw
new
BuildException
(
"Resource not found"
+
ERR_MSG_FRAGMENT
,
e
)
;
}
catch
(
Exception
e
)
{
throw
new
BuildException
(
"Generation failed"
+
ERR_MSG_FRAGMENT
,
e
)
;
}
}
protected
void
populateInitialContext
(
Context
context
)
throws
Exception
{
context
.
put
(
"now"
,
new
Date
(
)
.
toString
(
)
)
;
}
protected
void
cleanup
(
)
throws
Exception
{
}
}
