package
org
.
apache
.
velocity
.
runtime
.
parser
.
node
;
import
java
.
io
.
Writer
;
import
java
.
io
.
IOException
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
org
.
apache
.
velocity
.
context
.
Context
;
import
org
.
apache
.
velocity
.
context
.
InternalContextAdapter
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeConstants
;
import
org
.
apache
.
velocity
.
runtime
.
exception
.
ReferenceException
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
*
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
VelPropertySet
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
Info
;
import
org
.
apache
.
velocity
.
exception
.
MethodInvocationException
;
import
org
.
apache
.
velocity
.
app
.
event
.
EventCartridge
;
public
class
ASTReference
extends
SimpleNode
{
private
static
final
int
NORMAL_REFERENCE
=
1
;
private
static
final
int
FORMAL_REFERENCE
=
2
;
private
static
final
int
QUIET_REFERENCE
=
3
;
private
static
final
int
RUNT
=
4
;
private
int
referenceType
;
private
String
nullString
;
private
String
rootString
;
private
boolean
escaped
=
false
;
private
boolean
computableReference
=
true
;
private
String
escPrefix
=
""
;
private
String
morePrefix
=
""
;
private
String
identifier
=
""
;
private
String
literal
=
null
;
private
int
numChildren
=
0
;
protected
Info
uberInfo
;
public
ASTReference
(
int
id
)
{
super
(
id
)
;
}
public
ASTReference
(
Parser
p
,
int
id
)
{
super
(
p
,
id
)
;
}
public
Object
jjtAccept
(
ParserVisitor
visitor
,
Object
data
)
{
return
visitor
.
visit
(
this
,
data
)
;
}
public
Object
init
(
InternalContextAdapter
context
,
Object
data
)
throws
Exception
{
super
.
init
(
context
,
data
)
;
rootString
=
getRoot
(
)
;
numChildren
=
jjtGetNumChildren
(
)
;
if
(
numChildren
>
0
)
{
identifier
=
jjtGetChild
(
numChildren
-
1
)
.
getFirstToken
(
)
.
image
;
}
uberInfo
=
new
Info
(
context
.
getCurrentTemplateName
(
)
,
getLine
(
)
,
getColumn
(
)
)
;
return
data
;
}
public
String
getRootString
(
)
{
return
rootString
;
}
public
Object
execute
(
Object
o
,
InternalContextAdapter
context
)
throws
MethodInvocationException
{
if
(
referenceType
==
RUNT
)
return
null
;
Object
result
=
getVariableValue
(
context
,
rootString
)
;
if
(
result
==
null
)
{
return
null
;
}
try
{
for
(
int
i
=
0
;
i
<
numChildren
;
i
++
)
{
result
=
jjtGetChild
(
i
)
.
execute
(
result
,
context
)
;
if
(
result
==
null
)
{
return
null
;
}
}
return
result
;
}
catch
(
MethodInvocationException
mie
)
{
rsvc
.
error
(
"Method "
+
mie
.
getMethodName
(
)
+
" threw exception for reference $"
+
rootString
+
" in template "
+
context
.
getCurrentTemplateName
(
)
+
" at "
+
" ["
+
this
.
getLine
(
)
+
","
+
this
.
getColumn
(
)
+
"]"
)
;
mie
.
setReferenceName
(
rootString
)
;
throw
mie
;
}
}
public
boolean
render
(
InternalContextAdapter
context
,
Writer
writer
)
throws
IOException
,
MethodInvocationException
{
if
(
referenceType
==
RUNT
)
{
writer
.
write
(
rootString
)
;
return
true
;
}
Object
value
=
execute
(
null
,
context
)
;
if
(
escaped
)
{
if
(
value
==
null
)
{
writer
.
write
(
escPrefix
)
;
writer
.
write
(
"\\"
)
;
writer
.
write
(
nullString
)
;
}
else
{
writer
.
write
(
escPrefix
)
;
writer
.
write
(
nullString
)
;
}
return
true
;
}
EventCartridge
ec
=
context
.
getEventCartridge
(
)
;
if
(
ec
!=
null
)
{
value
=
ec
.
referenceInsert
(
literal
(
)
,
value
)
;
}
if
(
value
==
null
)
{
writer
.
write
(
escPrefix
)
;
writer
.
write
(
escPrefix
)
;
writer
.
write
(
morePrefix
)
;
writer
.
write
(
nullString
)
;
if
(
referenceType
!=
QUIET_REFERENCE
&&
rsvc
.
getBoolean
(
RuntimeConstants
.
RUNTIME_LOG_REFERENCE_LOG_INVALID
,
true
)
)
{
rsvc
.
warn
(
new
ReferenceException
(
"reference : template = "
+
context
.
getCurrentTemplateName
(
)
,
this
)
)
;
}
return
true
;
}
else
{
writer
.
write
(
escPrefix
)
;
writer
.
write
(
morePrefix
)
;
writer
.
write
(
value
.
toString
(
)
)
;
return
true
;
}
}
public
boolean
evaluate
(
InternalContextAdapter
context
)
throws
MethodInvocationException
{
Object
value
=
execute
(
null
,
context
)
;
if
(
value
==
null
)
{
return
false
;
}
else
if
(
value
instanceof
Boolean
)
{
if
(
(
(
Boolean
)
value
)
.
booleanValue
(
)
)
return
true
;
else
return
false
;
}
else
return
true
;
}
public
Object
value
(
InternalContextAdapter
context
)
throws
MethodInvocationException
{
return
(
computableReference
?
execute
(
null
,
context
)
:
null
)
;
}
public
boolean
setValue
(
InternalContextAdapter
context
,
Object
value
)
throws
MethodInvocationException
{
if
(
jjtGetNumChildren
(
)
==
0
)
{
context
.
put
(
rootString
,
value
)
;
return
true
;
}
Object
result
=
getVariableValue
(
context
,
rootString
)
;
if
(
result
==
null
)
{
rsvc
.
error
(
new
ReferenceException
(
"reference set : template = "
+
context
.
getCurrentTemplateName
(
)
,
this
)
)
;
return
false
;
}
for
(
int
i
=
0
;
i
<
numChildren
-
1
;
i
++
)
{
result
=
jjtGetChild
(
i
)
.
execute
(
result
,
context
)
;
if
(
result
==
null
)
{
rsvc
.
error
(
new
ReferenceException
(
"reference set : template = "
+
context
.
getCurrentTemplateName
(
)
,
this
)
)
;
return
false
;
}
}
try
{
VelPropertySet
vs
=
rsvc
.
getUberspect
(
)
.
getPropertySet
(
result
,
identifier
,
value
,
uberInfo
)
;
if
(
vs
==
null
)
return
false
;
vs
.
invoke
(
result
,
value
)
;
}
catch
(
InvocationTargetException
ite
)
{
throw
new
MethodInvocationException
(
"ASTReference : Invocation of method '"
+
identifier
+
"' in  "
+
result
.
getClass
(
)
+
" threw exception "
+
ite
.
getTargetException
(
)
.
getClass
(
)
,
ite
.
getTargetException
(
)
,
identifier
)
;
}
catch
(
Exception
e
)
{
rsvc
.
error
(
"ASTReference setValue() : exception : "
+
e
+
" template = "
+
context
.
getCurrentTemplateName
(
)
+
" ["
+
this
.
getLine
(
)
+
","
+
this
.
getColumn
(
)
+
"]"
)
;
return
false
;
}
return
true
;
}
private
String
getRoot
(
)
{
Token
t
=
getFirstToken
(
)
;
int
slashbang
=
t
.
image
.
indexOf
(
"\\!"
)
;
if
(
slashbang
!=
-
1
)
{
int
i
=
0
;
int
len
=
t
.
image
.
length
(
)
;
i
=
t
.
image
.
indexOf
(
'$'
)
;
if
(
i
==
-
1
)
{
rsvc
.
error
(
"ASTReference.getRoot() : internal error : "
+
"no $ found for slashbang."
)
;
computableReference
=
false
;
nullString
=
t
.
image
;
return
nullString
;
}
while
(
i
<
len
&&
t
.
image
.
charAt
(
i
)
!=
'\\'
)
{
i
++
;
}
int
start
=
i
;
int
count
=
0
;
while
(
i
<
len
&&
t
.
image
.
charAt
(
i
++
)
==
'\\'
)
{
count
++
;
}
nullString
=
t
.
image
.
substring
(
0
,
start
)
;
nullString
+=
t
.
image
.
substring
(
start
,
start
+
count
-
1
)
;
nullString
+=
t
.
image
.
substring
(
start
+
count
)
;
computableReference
=
false
;
return
nullString
;
}
escaped
=
false
;
if
(
t
.
image
.
startsWith
(
"\\"
)
)
{
int
i
=
0
;
int
len
=
t
.
image
.
length
(
)
;
while
(
i
<
len
&&
t
.
image
.
charAt
(
i
)
==
'\\'
)
{
i
++
;
}
if
(
(
i
%
2
)
!=
0
)
escaped
=
true
;
if
(
i
>
0
)
escPrefix
=
t
.
image
.
substring
(
0
,
i
/
2
)
;
t
.
image
=
t
.
image
.
substring
(
i
)
;
}
int
loc1
=
t
.
image
.
lastIndexOf
(
'$'
)
;
if
(
loc1
>
0
)
{
morePrefix
=
morePrefix
+
t
.
image
.
substring
(
0
,
loc1
)
;
t
.
image
=
t
.
image
.
substring
(
loc1
)
;
}
nullString
=
literal
(
)
;
if
(
t
.
image
.
startsWith
(
"$!"
)
)
{
referenceType
=
QUIET_REFERENCE
;
if
(
!
escaped
)
nullString
=
""
;
if
(
t
.
image
.
startsWith
(
"$!{"
)
)
{
return
t
.
next
.
image
;
}
else
{
return
t
.
image
.
substring
(
2
)
;
}
}
else
if
(
t
.
image
.
equals
(
"${"
)
)
{
referenceType
=
FORMAL_REFERENCE
;
return
t
.
next
.
image
;
}
else
if
(
t
.
image
.
startsWith
(
"$"
)
)
{
referenceType
=
NORMAL_REFERENCE
;
return
t
.
image
.
substring
(
1
)
;
}
else
{
referenceType
=
RUNT
;
return
t
.
image
;
}
}
public
Object
getVariableValue
(
Context
context
,
String
variable
)
{
return
context
.
get
(
variable
)
;
}
public
void
setLiteral
(
String
literal
)
{
if
(
this
.
literal
==
null
)
this
.
literal
=
literal
;
}
public
String
literal
(
)
{
if
(
literal
!=
null
)
return
literal
;
return
super
.
literal
(
)
;
}
}
