package
org
.
apache
.
velocity
.
runtime
;
import
java
.
util
.
Collections
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
Map
;
import
java
.
util
.
Set
;
import
org
.
apache
.
velocity
.
runtime
.
directive
.
VelocimacroProxy
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
Node
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SimpleNode
;
import
org
.
apache
.
velocity
.
util
.
MapFactory
;
public
class
VelocimacroManager
{
private
static
String
GLOBAL_NAMESPACE
=
""
;
private
boolean
registerFromLib
=
false
;
private
final
Map
namespaceHash
=
MapFactory
.
create
(
17
,
0.5f
,
20
,
false
)
;
private
final
Map
globalNamespace
;
private
final
Set
libraries
=
Collections
.
synchronizedSet
(
new
HashSet
(
)
)
;
private
boolean
namespacesOn
=
true
;
private
boolean
inlineLocalMode
=
false
;
private
boolean
inlineReplacesGlobal
=
false
;
VelocimacroManager
(
RuntimeServices
rsvc
)
{
globalNamespace
=
addNamespace
(
GLOBAL_NAMESPACE
)
;
}
public
boolean
addVM
(
final
String
vmName
,
final
Node
macroBody
,
final
String
argArray
[
]
,
final
String
namespace
,
boolean
canReplaceGlobalMacro
)
{
if
(
macroBody
==
null
)
{
throw
new
RuntimeException
(
"Null AST for "
+
vmName
+
" in "
+
namespace
)
;
}
MacroEntry
me
=
new
MacroEntry
(
vmName
,
macroBody
,
argArray
,
namespace
)
;
me
.
setFromLibrary
(
registerFromLib
)
;
boolean
isLib
=
true
;
MacroEntry
exist
=
(
MacroEntry
)
globalNamespace
.
get
(
vmName
)
;
if
(
registerFromLib
)
{
libraries
.
add
(
namespace
)
;
}
else
{
isLib
=
libraries
.
contains
(
namespace
)
;
}
if
(
!
isLib
&&
usingNamespaces
(
namespace
)
)
{
Map
local
=
getNamespace
(
namespace
,
true
)
;
local
.
put
(
vmName
,
me
)
;
return
true
;
}
else
{
if
(
exist
!=
null
)
{
me
.
setFromLibrary
(
exist
.
getFromLibrary
(
)
)
;
}
globalNamespace
.
put
(
vmName
,
me
)
;
return
true
;
}
}
public
VelocimacroProxy
get
(
final
String
vmName
,
final
String
namespace
)
{
return
(
get
(
vmName
,
namespace
,
null
)
)
;
}
public
VelocimacroProxy
get
(
final
String
vmName
,
final
String
namespace
,
final
String
renderingTemplate
)
{
if
(
inlineReplacesGlobal
&&
renderingTemplate
!=
null
)
{
Map
local
=
getNamespace
(
renderingTemplate
,
false
)
;
if
(
local
!=
null
)
{
MacroEntry
me
=
(
MacroEntry
)
local
.
get
(
vmName
)
;
if
(
me
!=
null
)
{
return
me
.
getProxy
(
namespace
)
;
}
}
}
if
(
usingNamespaces
(
namespace
)
)
{
Map
local
=
getNamespace
(
namespace
,
false
)
;
if
(
local
!=
null
)
{
MacroEntry
me
=
(
MacroEntry
)
local
.
get
(
vmName
)
;
if
(
me
!=
null
)
{
return
me
.
getProxy
(
namespace
)
;
}
}
}
MacroEntry
me
=
(
MacroEntry
)
globalNamespace
.
get
(
vmName
)
;
if
(
me
!=
null
)
{
return
me
.
getProxy
(
namespace
)
;
}
return
null
;
}
public
boolean
dumpNamespace
(
final
String
namespace
)
{
synchronized
(
this
)
{
if
(
usingNamespaces
(
namespace
)
)
{
Map
h
=
(
Map
)
namespaceHash
.
remove
(
namespace
)
;
if
(
h
==
null
)
{
return
false
;
}
h
.
clear
(
)
;
return
true
;
}
return
false
;
}
}
public
void
setNamespaceUsage
(
final
boolean
namespaceOn
)
{
this
.
namespacesOn
=
namespaceOn
;
}
public
void
setRegisterFromLib
(
final
boolean
registerFromLib
)
{
this
.
registerFromLib
=
registerFromLib
;
}
public
void
setTemplateLocalInlineVM
(
final
boolean
inlineLocalMode
)
{
this
.
inlineLocalMode
=
inlineLocalMode
;
}
private
Map
getNamespace
(
final
String
namespace
,
final
boolean
addIfNew
)
{
Map
h
=
(
Map
)
namespaceHash
.
get
(
namespace
)
;
if
(
h
==
null
&&
addIfNew
)
{
h
=
addNamespace
(
namespace
)
;
}
return
h
;
}
private
Map
addNamespace
(
final
String
namespace
)
{
Map
h
=
MapFactory
.
create
(
17
,
0.5f
,
20
,
false
)
;
Object
oh
;
if
(
(
oh
=
namespaceHash
.
put
(
namespace
,
h
)
)
!=
null
)
{
namespaceHash
.
put
(
namespace
,
oh
)
;
return
null
;
}
return
h
;
}
private
boolean
usingNamespaces
(
final
String
namespace
)
{
if
(
!
namespacesOn
)
{
return
false
;
}
if
(
inlineLocalMode
)
{
return
true
;
}
return
false
;
}
public
String
getLibraryName
(
final
String
vmName
,
final
String
namespace
)
{
if
(
usingNamespaces
(
namespace
)
)
{
Map
local
=
getNamespace
(
namespace
,
false
)
;
if
(
local
!=
null
)
{
MacroEntry
me
=
(
MacroEntry
)
local
.
get
(
vmName
)
;
if
(
me
!=
null
)
{
return
null
;
}
}
}
MacroEntry
me
=
(
MacroEntry
)
globalNamespace
.
get
(
vmName
)
;
if
(
me
!=
null
)
{
return
me
.
getSourceTemplate
(
)
;
}
return
null
;
}
public
void
setInlineReplacesGlobal
(
boolean
is
)
{
inlineReplacesGlobal
=
is
;
}
private
static
class
MacroEntry
{
private
final
String
vmName
;
private
final
String
[
]
argArray
;
private
final
String
sourceTemplate
;
private
SimpleNode
nodeTree
=
null
;
private
boolean
fromLibrary
=
false
;
private
VelocimacroProxy
vp
;
private
MacroEntry
(
final
String
vmName
,
final
Node
macro
,
final
String
argArray
[
]
,
final
String
sourceTemplate
)
{
this
.
vmName
=
vmName
;
this
.
argArray
=
argArray
;
this
.
nodeTree
=
(
SimpleNode
)
macro
;
this
.
sourceTemplate
=
sourceTemplate
;
vp
=
new
VelocimacroProxy
(
)
;
vp
.
setName
(
this
.
vmName
)
;
vp
.
setArgArray
(
this
.
argArray
)
;
vp
.
setNodeTree
(
this
.
nodeTree
)
;
}
public
void
setFromLibrary
(
final
boolean
fromLibrary
)
{
this
.
fromLibrary
=
fromLibrary
;
}
public
boolean
getFromLibrary
(
)
{
return
fromLibrary
;
}
public
SimpleNode
getNodeTree
(
)
{
return
nodeTree
;
}
public
String
getSourceTemplate
(
)
{
return
sourceTemplate
;
}
VelocimacroProxy
getProxy
(
final
String
namespace
)
{
return
vp
;
}
}
}
