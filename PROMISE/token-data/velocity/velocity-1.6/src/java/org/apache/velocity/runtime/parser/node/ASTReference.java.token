package
org
.
apache
.
velocity
.
runtime
.
parser
.
node
;
import
java
.
io
.
IOException
;
import
java
.
io
.
Writer
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
org
.
apache
.
velocity
.
app
.
event
.
EventHandlerUtil
;
import
org
.
apache
.
velocity
.
context
.
Context
;
import
org
.
apache
.
velocity
.
context
.
InternalContextAdapter
;
import
org
.
apache
.
velocity
.
exception
.
MethodInvocationException
;
import
org
.
apache
.
velocity
.
exception
.
TemplateInitException
;
import
org
.
apache
.
velocity
.
exception
.
VelocityException
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeConstants
;
import
org
.
apache
.
velocity
.
runtime
.
Renderable
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
Log
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
Parser
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
Token
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
Info
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
VelPropertySet
;
public
class
ASTReference
extends
SimpleNode
{
private
static
final
int
NORMAL_REFERENCE
=
1
;
private
static
final
int
FORMAL_REFERENCE
=
2
;
private
static
final
int
QUIET_REFERENCE
=
3
;
private
static
final
int
RUNT
=
4
;
private
int
referenceType
;
private
String
nullString
;
private
String
rootString
;
private
boolean
escaped
=
false
;
private
boolean
computableReference
=
true
;
private
boolean
logOnNull
=
true
;
private
String
escPrefix
=
""
;
private
String
morePrefix
=
""
;
private
String
identifier
=
""
;
private
String
literal
=
null
;
public
boolean
strictRef
=
false
;
private
int
numChildren
=
0
;
protected
Info
uberInfo
;
public
ASTReference
(
int
id
)
{
super
(
id
)
;
}
public
ASTReference
(
Parser
p
,
int
id
)
{
super
(
p
,
id
)
;
}
public
Object
jjtAccept
(
ParserVisitor
visitor
,
Object
data
)
{
return
visitor
.
visit
(
this
,
data
)
;
}
public
Object
init
(
InternalContextAdapter
context
,
Object
data
)
throws
TemplateInitException
{
super
.
init
(
context
,
data
)
;
rootString
=
getRoot
(
)
;
numChildren
=
jjtGetNumChildren
(
)
;
if
(
numChildren
>
0
)
{
identifier
=
jjtGetChild
(
numChildren
-
1
)
.
getFirstToken
(
)
.
image
;
}
uberInfo
=
new
Info
(
getTemplateName
(
)
,
getLine
(
)
,
getColumn
(
)
)
;
logOnNull
=
rsvc
.
getBoolean
(
RuntimeConstants
.
RUNTIME_LOG_REFERENCE_LOG_INVALID
,
true
)
;
strictRef
=
rsvc
.
getBoolean
(
RuntimeConstants
.
RUNTIME_REFERENCES_STRICT
,
false
)
;
if
(
strictRef
&&
numChildren
==
0
)
{
logOnNull
=
false
;
Node
node
=
this
.
jjtGetParent
(
)
;
if
(
node
instanceof
ASTNotNode
||
node
instanceof
ASTExpression
||
node
instanceof
ASTOrNode
||
node
instanceof
ASTAndNode
)
{
while
(
node
!=
null
)
{
if
(
node
instanceof
ASTIfStatement
)
{
strictRef
=
false
;
break
;
}
node
=
node
.
jjtGetParent
(
)
;
}
}
}
return
data
;
}
public
String
getRootString
(
)
{
return
rootString
;
}
public
Object
execute
(
Object
o
,
InternalContextAdapter
context
)
throws
MethodInvocationException
{
if
(
referenceType
==
RUNT
)
return
null
;
Object
result
=
getVariableValue
(
context
,
rootString
)
;
if
(
result
==
null
&&
!
strictRef
)
{
return
EventHandlerUtil
.
invalidGetMethod
(
rsvc
,
context
,
"$"
+
rootString
,
null
,
null
,
uberInfo
)
;
}
try
{
Object
previousResult
=
result
;
int
failedChild
=
-
1
;
for
(
int
i
=
0
;
i
<
numChildren
;
i
++
)
{
if
(
strictRef
&&
result
==
null
)
{
String
name
=
jjtGetChild
(
i
)
.
getFirstToken
(
)
.
image
;
throw
new
VelocityException
(
"Attempted to access '"
+
name
+
"' on a null value at "
+
Log
.
formatFileString
(
uberInfo
.
getTemplateName
(
)
,
+
jjtGetChild
(
i
)
.
getLine
(
)
,
jjtGetChild
(
i
)
.
getColumn
(
)
)
)
;
}
previousResult
=
result
;
result
=
jjtGetChild
(
i
)
.
execute
(
result
,
context
)
;
if
(
result
==
null
&&
!
strictRef
)
{
failedChild
=
i
;
break
;
}
}
if
(
result
==
null
)
{
if
(
failedChild
==
-
1
)
{
result
=
EventHandlerUtil
.
invalidGetMethod
(
rsvc
,
context
,
"$"
+
rootString
,
previousResult
,
null
,
uberInfo
)
;
}
else
{
StringBuffer
name
=
new
StringBuffer
(
"$"
)
.
append
(
rootString
)
;
for
(
int
i
=
0
;
i
<=
failedChild
;
i
++
)
{
Node
node
=
jjtGetChild
(
i
)
;
if
(
node
instanceof
ASTMethod
)
{
name
.
append
(
"."
)
.
append
(
(
(
ASTMethod
)
node
)
.
getMethodName
(
)
)
.
append
(
"()"
)
;
}
else
{
name
.
append
(
"."
)
.
append
(
node
.
getFirstToken
(
)
.
image
)
;
}
}
if
(
jjtGetChild
(
failedChild
)
instanceof
ASTMethod
)
{
String
methodName
=
(
(
ASTMethod
)
jjtGetChild
(
failedChild
)
)
.
getMethodName
(
)
;
result
=
EventHandlerUtil
.
invalidMethod
(
rsvc
,
context
,
name
.
toString
(
)
,
previousResult
,
methodName
,
uberInfo
)
;
}
else
{
String
property
=
jjtGetChild
(
failedChild
)
.
getFirstToken
(
)
.
image
;
result
=
EventHandlerUtil
.
invalidGetMethod
(
rsvc
,
context
,
name
.
toString
(
)
,
previousResult
,
property
,
uberInfo
)
;
}
}
}
return
result
;
}
catch
(
MethodInvocationException
mie
)
{
mie
.
setReferenceName
(
rootString
)
;
throw
mie
;
}
}
public
boolean
render
(
InternalContextAdapter
context
,
Writer
writer
)
throws
IOException
,
MethodInvocationException
{
if
(
referenceType
==
RUNT
)
{
if
(
context
.
getAllowRendering
(
)
)
{
writer
.
write
(
rootString
)
;
}
return
true
;
}
Object
value
=
execute
(
null
,
context
)
;
String
localNullString
=
null
;
if
(
escaped
)
{
localNullString
=
getNullString
(
context
)
;
if
(
value
==
null
)
{
if
(
context
.
getAllowRendering
(
)
)
{
writer
.
write
(
escPrefix
)
;
writer
.
write
(
"\\"
)
;
writer
.
write
(
localNullString
)
;
}
}
else
{
if
(
context
.
getAllowRendering
(
)
)
{
writer
.
write
(
escPrefix
)
;
writer
.
write
(
localNullString
)
;
}
}
return
true
;
}
value
=
EventHandlerUtil
.
referenceInsert
(
rsvc
,
context
,
literal
(
)
,
value
)
;
String
toString
=
null
;
if
(
value
!=
null
)
{
if
(
value
instanceof
Renderable
&&
(
(
Renderable
)
value
)
.
render
(
context
,
writer
)
)
{
return
true
;
}
toString
=
value
.
toString
(
)
;
}
if
(
value
==
null
||
toString
==
null
)
{
if
(
context
.
getAllowRendering
(
)
)
{
localNullString
=
getNullString
(
context
)
;
writer
.
write
(
escPrefix
)
;
writer
.
write
(
escPrefix
)
;
writer
.
write
(
morePrefix
)
;
writer
.
write
(
localNullString
)
;
}
if
(
logOnNull
&&
referenceType
!=
QUIET_REFERENCE
&&
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Null reference [template '"
+
getTemplateName
(
)
+
"', line "
+
this
.
getLine
(
)
+
", column "
+
this
.
getColumn
(
)
+
"] : "
+
this
.
literal
(
)
+
" cannot be resolved."
)
;
}
return
true
;
}
else
{
if
(
context
.
getAllowRendering
(
)
)
{
writer
.
write
(
escPrefix
)
;
writer
.
write
(
morePrefix
)
;
writer
.
write
(
toString
)
;
}
return
true
;
}
}
private
String
getNullString
(
InternalContextAdapter
context
)
{
Object
callingArgument
=
context
.
get
(
".literal."
+
nullString
)
;
if
(
callingArgument
!=
null
)
return
(
(
Node
)
callingArgument
)
.
literal
(
)
;
else
return
nullString
;
}
public
boolean
evaluate
(
InternalContextAdapter
context
)
throws
MethodInvocationException
{
Object
value
=
execute
(
null
,
context
)
;
if
(
value
==
null
)
{
return
false
;
}
else
if
(
value
instanceof
Boolean
)
{
if
(
(
(
Boolean
)
value
)
.
booleanValue
(
)
)
return
true
;
else
return
false
;
}
else
if
(
value
.
toString
(
)
==
null
)
{
return
false
;
}
else
return
true
;
}
public
Object
value
(
InternalContextAdapter
context
)
throws
MethodInvocationException
{
return
(
computableReference
?
execute
(
null
,
context
)
:
null
)
;
}
public
boolean
setValue
(
InternalContextAdapter
context
,
Object
value
)
throws
MethodInvocationException
{
if
(
jjtGetNumChildren
(
)
==
0
)
{
context
.
put
(
rootString
,
value
)
;
return
true
;
}
Object
result
=
getVariableValue
(
context
,
rootString
)
;
if
(
result
==
null
)
{
String
msg
=
"reference set is not a valid reference at "
+
Log
.
formatFileString
(
uberInfo
)
;
log
.
error
(
msg
)
;
return
false
;
}
for
(
int
i
=
0
;
i
<
numChildren
-
1
;
i
++
)
{
result
=
jjtGetChild
(
i
)
.
execute
(
result
,
context
)
;
if
(
result
==
null
)
{
if
(
strictRef
)
{
String
name
=
jjtGetChild
(
i
+
1
)
.
getFirstToken
(
)
.
image
;
throw
new
MethodInvocationException
(
"Attempted to access '"
+
name
+
"' on a null value"
,
null
,
name
,
uberInfo
.
getTemplateName
(
)
,
jjtGetChild
(
i
+
1
)
.
getLine
(
)
,
jjtGetChild
(
i
+
1
)
.
getColumn
(
)
)
;
}
String
msg
=
"reference set is not a valid reference at "
+
Log
.
formatFileString
(
uberInfo
)
;
log
.
error
(
msg
)
;
return
false
;
}
}
try
{
VelPropertySet
vs
=
rsvc
.
getUberspect
(
)
.
getPropertySet
(
result
,
identifier
,
value
,
uberInfo
)
;
if
(
vs
==
null
)
{
if
(
strictRef
)
{
throw
new
MethodInvocationException
(
"Object '"
+
result
.
getClass
(
)
.
getName
(
)
+
"' does not contain property '"
+
identifier
+
"'"
,
null
,
identifier
,
uberInfo
.
getTemplateName
(
)
,
uberInfo
.
getLine
(
)
,
uberInfo
.
getColumn
(
)
)
;
}
else
{
return
false
;
}
}
vs
.
invoke
(
result
,
value
)
;
}
catch
(
InvocationTargetException
ite
)
{
throw
new
MethodInvocationException
(
"ASTReference : Invocation of method '"
+
identifier
+
"' in  "
+
result
.
getClass
(
)
+
" threw exception "
+
ite
.
getTargetException
(
)
.
toString
(
)
,
ite
.
getTargetException
(
)
,
identifier
,
getTemplateName
(
)
,
this
.
getLine
(
)
,
this
.
getColumn
(
)
)
;
}
catch
(
RuntimeException
e
)
{
throw
e
;
}
catch
(
Exception
e
)
{
String
msg
=
"ASTReference setValue() : exception : "
+
e
+
" template at "
+
Log
.
formatFileString
(
uberInfo
)
;
log
.
error
(
msg
,
e
)
;
throw
new
VelocityException
(
msg
,
e
)
;
}
return
true
;
}
private
String
getRoot
(
)
{
Token
t
=
getFirstToken
(
)
;
int
slashbang
=
t
.
image
.
indexOf
(
"\\!"
)
;
if
(
slashbang
!=
-
1
)
{
int
i
=
0
;
int
len
=
t
.
image
.
length
(
)
;
i
=
t
.
image
.
indexOf
(
'$'
)
;
if
(
i
==
-
1
)
{
log
.
error
(
"ASTReference.getRoot() : internal error : "
+
"no $ found for slashbang."
)
;
computableReference
=
false
;
nullString
=
t
.
image
;
return
nullString
;
}
while
(
i
<
len
&&
t
.
image
.
charAt
(
i
)
!=
'\\'
)
{
i
++
;
}
int
start
=
i
;
int
count
=
0
;
while
(
i
<
len
&&
t
.
image
.
charAt
(
i
++
)
==
'\\'
)
{
count
++
;
}
nullString
=
t
.
image
.
substring
(
0
,
start
)
;
nullString
+=
t
.
image
.
substring
(
start
,
start
+
count
-
1
)
;
nullString
+=
t
.
image
.
substring
(
start
+
count
)
;
computableReference
=
false
;
return
nullString
;
}
escaped
=
false
;
if
(
t
.
image
.
startsWith
(
"\\"
)
)
{
int
i
=
0
;
int
len
=
t
.
image
.
length
(
)
;
while
(
i
<
len
&&
t
.
image
.
charAt
(
i
)
==
'\\'
)
{
i
++
;
}
if
(
(
i
%
2
)
!=
0
)
escaped
=
true
;
if
(
i
>
0
)
escPrefix
=
t
.
image
.
substring
(
0
,
i
/
2
)
;
t
.
image
=
t
.
image
.
substring
(
i
)
;
}
int
loc1
=
t
.
image
.
lastIndexOf
(
'$'
)
;
if
(
loc1
>
0
)
{
morePrefix
=
morePrefix
+
t
.
image
.
substring
(
0
,
loc1
)
;
t
.
image
=
t
.
image
.
substring
(
loc1
)
;
}
nullString
=
literal
(
)
;
if
(
t
.
image
.
startsWith
(
"$!"
)
)
{
referenceType
=
QUIET_REFERENCE
;
if
(
!
escaped
)
nullString
=
""
;
if
(
t
.
image
.
startsWith
(
"$!{"
)
)
{
return
t
.
next
.
image
;
}
else
{
return
t
.
image
.
substring
(
2
)
;
}
}
else
if
(
t
.
image
.
equals
(
"${"
)
)
{
referenceType
=
FORMAL_REFERENCE
;
return
t
.
next
.
image
;
}
else
if
(
t
.
image
.
startsWith
(
"$"
)
)
{
referenceType
=
NORMAL_REFERENCE
;
return
t
.
image
.
substring
(
1
)
;
}
else
{
referenceType
=
RUNT
;
return
t
.
image
;
}
}
public
Object
getVariableValue
(
Context
context
,
String
variable
)
throws
MethodInvocationException
{
Object
obj
=
null
;
try
{
obj
=
context
.
get
(
variable
)
;
}
catch
(
RuntimeException
e
)
{
log
.
error
(
"Exception calling reference $"
+
variable
+
" at "
+
Log
.
formatFileString
(
uberInfo
)
)
;
throw
e
;
}
if
(
strictRef
&&
obj
==
null
)
{
if
(
!
context
.
containsKey
(
variable
)
)
{
log
.
error
(
"Variable $"
+
variable
+
" has not been set at "
+
Log
.
formatFileString
(
uberInfo
)
)
;
throw
new
MethodInvocationException
(
"Variable $"
+
variable
+
" has not been set"
,
null
,
identifier
,
uberInfo
.
getTemplateName
(
)
,
uberInfo
.
getLine
(
)
,
uberInfo
.
getColumn
(
)
)
;
}
}
return
obj
;
}
public
void
setLiteral
(
String
literal
)
{
if
(
this
.
literal
==
null
)
this
.
literal
=
literal
;
}
public
String
literal
(
)
{
if
(
literal
!=
null
)
return
literal
;
return
super
.
literal
(
)
;
}
}
