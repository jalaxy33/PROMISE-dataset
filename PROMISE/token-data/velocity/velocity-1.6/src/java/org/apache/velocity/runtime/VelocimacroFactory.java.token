package
org
.
apache
.
velocity
.
runtime
;
import
java
.
io
.
StringReader
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
java
.
util
.
Vector
;
import
java
.
util
.
ArrayList
;
import
org
.
apache
.
commons
.
lang
.
StringUtils
;
import
org
.
apache
.
velocity
.
Template
;
import
org
.
apache
.
velocity
.
exception
.
VelocityException
;
import
org
.
apache
.
velocity
.
runtime
.
directive
.
Directive
;
import
org
.
apache
.
velocity
.
runtime
.
directive
.
Macro
;
import
org
.
apache
.
velocity
.
runtime
.
directive
.
VelocimacroProxy
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
LogDisplayWrapper
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
ParseException
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
Node
;
public
class
VelocimacroFactory
{
private
final
RuntimeServices
rsvc
;
private
final
LogDisplayWrapper
log
;
private
VelocimacroManager
vmManager
=
null
;
private
boolean
replaceAllowed
=
false
;
private
boolean
addNewAllowed
=
true
;
private
boolean
templateLocal
=
false
;
private
boolean
autoReloadLibrary
=
false
;
private
List
macroLibVec
=
null
;
private
Map
libModMap
;
public
VelocimacroFactory
(
final
RuntimeServices
rsvc
)
{
this
.
rsvc
=
rsvc
;
this
.
log
=
new
LogDisplayWrapper
(
rsvc
.
getLog
(
)
,
"Velocimacro : "
,
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_MESSAGES_ON
,
true
)
)
;
libModMap
=
new
HashMap
(
)
;
vmManager
=
new
VelocimacroManager
(
rsvc
)
;
}
public
void
initVelocimacro
(
)
{
synchronized
(
this
)
{
log
.
trace
(
"initialization starting."
)
;
setReplacementPermission
(
true
)
;
vmManager
.
setNamespaceUsage
(
false
)
;
Object
libfiles
=
rsvc
.
getProperty
(
RuntimeConstants
.
VM_LIBRARY
)
;
if
(
libfiles
==
null
)
{
log
.
debug
(
"\""
+
RuntimeConstants
.
VM_LIBRARY
+
"\" is not set.  Trying default library: "
+
RuntimeConstants
.
VM_LIBRARY_DEFAULT
)
;
if
(
rsvc
.
getLoaderNameForResource
(
RuntimeConstants
.
VM_LIBRARY_DEFAULT
)
!=
null
)
{
libfiles
=
RuntimeConstants
.
VM_LIBRARY_DEFAULT
;
}
else
{
log
.
debug
(
"Default library not found."
)
;
}
}
if
(
libfiles
!=
null
)
{
macroLibVec
=
new
ArrayList
(
)
;
if
(
libfiles
instanceof
Vector
)
{
macroLibVec
.
addAll
(
(
Vector
)
libfiles
)
;
}
else
if
(
libfiles
instanceof
String
)
{
macroLibVec
.
add
(
libfiles
)
;
}
for
(
int
i
=
0
,
is
=
macroLibVec
.
size
(
)
;
i
<
is
;
i
++
)
{
String
lib
=
(
String
)
macroLibVec
.
get
(
i
)
;
if
(
StringUtils
.
isNotEmpty
(
lib
)
)
{
vmManager
.
setRegisterFromLib
(
true
)
;
log
.
debug
(
"adding VMs from VM library : "
+
lib
)
;
try
{
Template
template
=
rsvc
.
getTemplate
(
lib
)
;
Twonk
twonk
=
new
Twonk
(
)
;
twonk
.
template
=
template
;
twonk
.
modificationTime
=
template
.
getLastModified
(
)
;
libModMap
.
put
(
lib
,
twonk
)
;
}
catch
(
Exception
e
)
{
String
msg
=
"Velocimacro : Error using VM library : "
+
lib
;
log
.
error
(
true
,
msg
,
e
)
;
throw
new
VelocityException
(
msg
,
e
)
;
}
log
.
trace
(
"VM library registration complete."
)
;
vmManager
.
setRegisterFromLib
(
false
)
;
}
}
}
setAddMacroPermission
(
true
)
;
if
(
!
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_PERM_ALLOW_INLINE
,
true
)
)
{
setAddMacroPermission
(
false
)
;
log
.
debug
(
"allowInline = false : VMs can NOT be defined inline in templates"
)
;
}
else
{
log
.
debug
(
"allowInline = true : VMs can be defined inline in templates"
)
;
}
setReplacementPermission
(
false
)
;
if
(
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL
,
false
)
)
{
setReplacementPermission
(
true
)
;
log
.
debug
(
"allowInlineToOverride = true : VMs "
+
"defined inline may replace previous VM definitions"
)
;
}
else
{
log
.
debug
(
"allowInlineToOverride = false : VMs "
+
"defined inline may NOT replace previous VM definitions"
)
;
}
vmManager
.
setNamespaceUsage
(
true
)
;
setTemplateLocalInline
(
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_PERM_INLINE_LOCAL
,
false
)
)
;
if
(
getTemplateLocalInline
(
)
)
{
log
.
debug
(
"allowInlineLocal = true : VMs "
+
"defined inline will be local to their defining template only."
)
;
}
else
{
log
.
debug
(
"allowInlineLocal = false : VMs "
+
"defined inline will be global in scope if allowed."
)
;
}
vmManager
.
setTemplateLocalInlineVM
(
getTemplateLocalInline
(
)
)
;
setAutoload
(
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_LIBRARY_AUTORELOAD
,
false
)
)
;
if
(
getAutoload
(
)
)
{
log
.
debug
(
"autoload on : VM system "
+
"will automatically reload global library macros"
)
;
}
else
{
log
.
debug
(
"autoload off : VM system "
+
"will not automatically reload global library macros"
)
;
}
log
.
trace
(
"Velocimacro : initialization complete."
)
;
}
}
public
boolean
addVelocimacro
(
String
name
,
String
macroBody
,
String
argArray
[
]
,
String
sourceTemplate
)
{
if
(
name
==
null
||
macroBody
==
null
||
argArray
==
null
||
sourceTemplate
==
null
)
{
String
msg
=
"VM '"
+
name
+
"' addition rejected : "
;
if
(
name
==
null
)
{
msg
+=
"name"
;
}
else
if
(
macroBody
==
null
)
{
msg
+=
"macroBody"
;
}
else
if
(
argArray
==
null
)
{
msg
+=
"argArray"
;
}
else
{
msg
+=
"sourceTemplate"
;
}
msg
+=
" argument was null"
;
log
.
error
(
msg
)
;
throw
new
NullPointerException
(
msg
)
;
}
if
(
!
canAddVelocimacro
(
name
,
sourceTemplate
)
)
{
return
false
;
}
synchronized
(
this
)
{
try
{
Node
macroRootNode
=
rsvc
.
parse
(
new
StringReader
(
macroBody
)
,
sourceTemplate
)
;
vmManager
.
addVM
(
name
,
macroRootNode
,
argArray
,
sourceTemplate
,
replaceAllowed
)
;
}
catch
(
ParseException
ex
)
{
throw
new
RuntimeException
(
ex
.
toString
(
)
)
;
}
}
if
(
log
.
isDebugEnabled
(
)
)
{
StringBuffer
msg
=
new
StringBuffer
(
"added "
)
;
Macro
.
macroToString
(
msg
,
argArray
)
;
msg
.
append
(
" : source = "
)
.
append
(
sourceTemplate
)
;
log
.
debug
(
msg
.
toString
(
)
)
;
}
return
true
;
}
public
boolean
addVelocimacro
(
String
name
,
Node
macroBody
,
String
argArray
[
]
,
String
sourceTemplate
)
{
if
(
name
==
null
||
macroBody
==
null
||
argArray
==
null
||
sourceTemplate
==
null
)
{
String
msg
=
"VM '"
+
name
+
"' addition rejected : "
;
if
(
name
==
null
)
{
msg
+=
"name"
;
}
else
if
(
macroBody
==
null
)
{
msg
+=
"macroBody"
;
}
else
if
(
argArray
==
null
)
{
msg
+=
"argArray"
;
}
else
{
msg
+=
"sourceTemplate"
;
}
msg
+=
" argument was null"
;
log
.
error
(
msg
)
;
throw
new
NullPointerException
(
msg
)
;
}
if
(
!
canAddVelocimacro
(
name
,
sourceTemplate
)
)
{
return
false
;
}
synchronized
(
this
)
{
vmManager
.
addVM
(
name
,
macroBody
,
argArray
,
sourceTemplate
,
replaceAllowed
)
;
}
return
(
true
)
;
}
private
synchronized
boolean
canAddVelocimacro
(
String
name
,
String
sourceTemplate
)
{
if
(
autoReloadLibrary
&&
(
macroLibVec
!=
null
)
)
{
if
(
macroLibVec
.
contains
(
sourceTemplate
)
)
return
true
;
}
if
(
!
addNewAllowed
)
{
log
.
warn
(
"VM addition rejected : "
+
name
+
" : inline VMs not allowed."
)
;
return
false
;
}
if
(
!
templateLocal
)
{
if
(
!
replaceAllowed
&&
isVelocimacro
(
name
,
sourceTemplate
)
)
{
if
(
log
.
isDebugEnabled
(
)
)
log
.
debug
(
"VM addition rejected : "
+
name
+
" : inline not allowed to replace existing VM"
)
;
return
false
;
}
}
return
true
;
}
public
boolean
isVelocimacro
(
String
vm
,
String
sourceTemplate
)
{
return
(
vmManager
.
get
(
vm
,
sourceTemplate
)
!=
null
)
;
}
public
Directive
getVelocimacro
(
String
vmName
,
String
sourceTemplate
)
{
return
(
getVelocimacro
(
vmName
,
sourceTemplate
,
null
)
)
;
}
public
Directive
getVelocimacro
(
String
vmName
,
String
sourceTemplate
,
String
renderingTemplate
)
{
VelocimacroProxy
vp
=
null
;
vp
=
vmManager
.
get
(
vmName
,
sourceTemplate
,
renderingTemplate
)
;
if
(
vp
!=
null
&&
autoReloadLibrary
)
{
synchronized
(
this
)
{
String
lib
=
vmManager
.
getLibraryName
(
vmName
,
sourceTemplate
)
;
if
(
lib
!=
null
)
{
try
{
Twonk
tw
=
(
Twonk
)
libModMap
.
get
(
lib
)
;
if
(
tw
!=
null
)
{
Template
template
=
tw
.
template
;
long
tt
=
tw
.
modificationTime
;
long
ft
=
template
.
getResourceLoader
(
)
.
getLastModified
(
template
)
;
if
(
ft
>
tt
)
{
log
.
debug
(
"auto-reloading VMs from VM library : "
+
lib
)
;
tw
.
modificationTime
=
ft
;
template
=
rsvc
.
getTemplate
(
lib
)
;
tw
.
template
=
template
;
tw
.
modificationTime
=
template
.
getLastModified
(
)
;
}
}
}
catch
(
Exception
e
)
{
String
msg
=
"Velocimacro : Error using VM library : "
+
lib
;
log
.
error
(
true
,
msg
,
e
)
;
throw
new
VelocityException
(
msg
,
e
)
;
}
vp
=
vmManager
.
get
(
vmName
,
sourceTemplate
,
renderingTemplate
)
;
}
}
}
return
vp
;
}
public
boolean
dumpVMNamespace
(
String
namespace
)
{
return
vmManager
.
dumpNamespace
(
namespace
)
;
}
private
void
setTemplateLocalInline
(
boolean
b
)
{
templateLocal
=
b
;
}
private
boolean
getTemplateLocalInline
(
)
{
return
templateLocal
;
}
private
boolean
setAddMacroPermission
(
final
boolean
addNewAllowed
)
{
boolean
b
=
this
.
addNewAllowed
;
this
.
addNewAllowed
=
addNewAllowed
;
return
b
;
}
private
boolean
setReplacementPermission
(
boolean
arg
)
{
boolean
b
=
replaceAllowed
;
replaceAllowed
=
arg
;
vmManager
.
setInlineReplacesGlobal
(
arg
)
;
return
b
;
}
private
void
setAutoload
(
boolean
b
)
{
autoReloadLibrary
=
b
;
}
private
boolean
getAutoload
(
)
{
return
autoReloadLibrary
;
}
private
static
class
Twonk
{
public
Template
template
;
public
long
modificationTime
;
}
}
