package
org
.
apache
.
velocity
.
context
;
import
java
.
io
.
StringWriter
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
HashSet
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
org
.
apache
.
velocity
.
app
.
event
.
EventCartridge
;
import
org
.
apache
.
velocity
.
exception
.
MethodInvocationException
;
import
org
.
apache
.
velocity
.
exception
.
VelocityException
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeServices
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
ParserTreeConstants
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
ASTReference
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
Node
;
import
org
.
apache
.
velocity
.
runtime
.
resource
.
Resource
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
IntrospectionCacheData
;
public
class
ProxyVMContext
extends
ChainedInternalContextAdapter
{
Map
vmproxyhash
=
new
HashMap
(
8
,
0.8f
)
;
Map
localcontext
=
new
HashMap
(
8
,
0.8f
)
;
;
private
boolean
localContextScope
;
private
RuntimeServices
rsvc
;
public
ProxyVMContext
(
InternalContextAdapter
inner
,
RuntimeServices
rsvc
,
boolean
localContextScope
)
{
super
(
inner
)
;
this
.
localContextScope
=
localContextScope
;
this
.
rsvc
=
rsvc
;
}
public
void
addVMProxyArg
(
InternalContextAdapter
context
,
String
macroArgumentName
,
String
literalMacroArgumentName
,
Node
argumentValue
)
throws
MethodInvocationException
{
if
(
isConstant
(
argumentValue
)
)
{
localcontext
.
put
(
macroArgumentName
,
argumentValue
.
value
(
context
)
)
;
}
else
{
vmproxyhash
.
put
(
macroArgumentName
,
argumentValue
)
;
localcontext
.
put
(
literalMacroArgumentName
,
argumentValue
)
;
}
}
private
boolean
isConstant
(
Node
node
)
{
switch
(
node
.
getType
(
)
)
{
case
ParserTreeConstants
.
JJTINTEGERRANGE
:
case
ParserTreeConstants
.
JJTREFERENCE
:
case
ParserTreeConstants
.
JJTOBJECTARRAY
:
case
ParserTreeConstants
.
JJTMAP
:
case
ParserTreeConstants
.
JJTSTRINGLITERAL
:
case
ParserTreeConstants
.
JJTTEXT
:
return
(
false
)
;
default
:
return
(
true
)
;
}
}
public
Object
put
(
final
String
key
,
final
Object
value
)
{
return
put
(
key
,
value
,
localContextScope
)
;
}
public
Object
localPut
(
final
String
key
,
final
Object
value
)
{
return
put
(
key
,
value
,
true
)
;
}
protected
Object
put
(
final
String
key
,
final
Object
value
,
final
boolean
forceLocal
)
{
Object
old
=
localcontext
.
put
(
key
,
value
)
;
if
(
!
forceLocal
)
{
old
=
super
.
put
(
key
,
value
)
;
}
return
old
;
}
public
Object
get
(
String
key
)
{
Object
o
=
localcontext
.
get
(
key
)
;
if
(
o
!=
null
)
{
return
o
;
}
Node
astNode
=
(
Node
)
vmproxyhash
.
get
(
key
)
;
if
(
astNode
!=
null
)
{
int
type
=
astNode
.
getType
(
)
;
if
(
type
==
ParserTreeConstants
.
JJTREFERENCE
)
{
ASTReference
ref
=
(
ASTReference
)
astNode
;
if
(
ref
.
jjtGetNumChildren
(
)
>
0
)
{
return
ref
.
execute
(
null
,
innerContext
)
;
}
else
{
Object
obj
=
innerContext
.
get
(
ref
.
getRootString
(
)
)
;
if
(
obj
==
null
&&
ref
.
strictRef
)
{
if
(
!
innerContext
.
containsKey
(
ref
.
getRootString
(
)
)
)
{
throw
new
MethodInvocationException
(
"Parameter '"
+
ref
.
getRootString
(
)
+
"' not defined"
,
null
,
key
,
ref
.
getTemplateName
(
)
,
ref
.
getLine
(
)
,
ref
.
getColumn
(
)
)
;
}
}
return
obj
;
}
}
else
if
(
type
==
ParserTreeConstants
.
JJTTEXT
)
{
try
{
StringWriter
writer
=
new
StringWriter
(
)
;
astNode
.
render
(
innerContext
,
writer
)
;
return
writer
.
toString
(
)
;
}
catch
(
RuntimeException
e
)
{
throw
e
;
}
catch
(
Exception
e
)
{
String
msg
=
"ProxyVMContext.get() : error rendering reference"
;
rsvc
.
getLog
(
)
.
error
(
msg
,
e
)
;
throw
new
VelocityException
(
msg
,
e
)
;
}
}
else
{
return
astNode
.
value
(
innerContext
)
;
}
}
return
super
.
get
(
key
)
;
}
public
boolean
containsKey
(
Object
key
)
{
return
vmproxyhash
.
containsKey
(
key
)
||
localcontext
.
containsKey
(
key
)
||
super
.
containsKey
(
key
)
;
}
public
Object
[
]
getKeys
(
)
{
if
(
localcontext
.
isEmpty
(
)
)
{
return
vmproxyhash
.
keySet
(
)
.
toArray
(
)
;
}
else
if
(
vmproxyhash
.
isEmpty
(
)
)
{
return
localcontext
.
keySet
(
)
.
toArray
(
)
;
}
HashSet
keys
=
new
HashSet
(
localcontext
.
keySet
(
)
)
;
keys
.
addAll
(
vmproxyhash
.
keySet
(
)
)
;
return
keys
.
toArray
(
)
;
}
public
Object
remove
(
Object
key
)
{
Object
loc
=
localcontext
.
remove
(
key
)
;
Object
arg
=
vmproxyhash
.
remove
(
key
)
;
Object
glo
=
null
;
if
(
!
localContextScope
)
{
glo
=
super
.
remove
(
key
)
;
}
if
(
loc
!=
null
)
{
return
loc
;
}
return
glo
;
}
}
