package
org
.
apache
.
velocity
.
util
.
introspection
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
public
class
MethodMap
{
private
static
final
int
MORE_SPECIFIC
=
0
;
private
static
final
int
LESS_SPECIFIC
=
1
;
private
static
final
int
INCOMPARABLE
=
2
;
Map
methodByNameMap
=
new
HashMap
(
)
;
public
void
add
(
Method
method
)
{
String
methodName
=
method
.
getName
(
)
;
List
l
=
get
(
methodName
)
;
if
(
l
==
null
)
{
l
=
new
ArrayList
(
)
;
methodByNameMap
.
put
(
methodName
,
l
)
;
}
l
.
add
(
method
)
;
}
public
List
get
(
String
key
)
{
return
(
List
)
methodByNameMap
.
get
(
key
)
;
}
public
Method
find
(
String
methodName
,
Object
[
]
args
)
throws
AmbiguousException
{
List
methodList
=
get
(
methodName
)
;
if
(
methodList
==
null
)
{
return
null
;
}
int
l
=
args
.
length
;
Class
[
]
classes
=
new
Class
[
l
]
;
for
(
int
i
=
0
;
i
<
l
;
++
i
)
{
Object
arg
=
args
[
i
]
;
classes
[
i
]
=
arg
==
null
?
null
:
arg
.
getClass
(
)
;
}
return
getBestMatch
(
methodList
,
classes
)
;
}
private
static
Method
getBestMatch
(
List
methods
,
Class
[
]
args
)
{
List
equivalentMatches
=
null
;
Method
bestMatch
=
null
;
Class
[
]
bestMatchTypes
=
null
;
for
(
Iterator
i
=
methods
.
iterator
(
)
;
i
.
hasNext
(
)
;
)
{
Method
method
=
(
Method
)
i
.
next
(
)
;
if
(
isApplicable
(
method
,
args
)
)
{
if
(
bestMatch
==
null
)
{
bestMatch
=
method
;
bestMatchTypes
=
method
.
getParameterTypes
(
)
;
}
else
{
Class
[
]
methodTypes
=
method
.
getParameterTypes
(
)
;
switch
(
compare
(
methodTypes
,
bestMatchTypes
)
)
{
case
MORE_SPECIFIC
:
if
(
equivalentMatches
==
null
)
{
bestMatch
=
method
;
bestMatchTypes
=
methodTypes
;
}
else
{
int
ambiguities
=
equivalentMatches
.
size
(
)
;
for
(
int
a
=
0
;
a
<
ambiguities
;
a
++
)
{
Method
other
=
(
Method
)
equivalentMatches
.
get
(
a
)
;
switch
(
compare
(
methodTypes
,
other
.
getParameterTypes
(
)
)
)
{
case
MORE_SPECIFIC
:
bestMatch
=
method
;
bestMatchTypes
=
methodTypes
;
equivalentMatches
=
null
;
ambiguities
=
0
;
break
;
case
INCOMPARABLE
:
equivalentMatches
.
add
(
method
)
;
break
;
case
LESS_SPECIFIC
:
break
;
}
}
}
break
;
case
INCOMPARABLE
:
if
(
equivalentMatches
==
null
)
{
equivalentMatches
=
new
ArrayList
(
bestMatchTypes
.
length
)
;
}
equivalentMatches
.
add
(
method
)
;
break
;
case
LESS_SPECIFIC
:
break
;
}
}
}
}
if
(
equivalentMatches
!=
null
)
{
throw
new
AmbiguousException
(
)
;
}
return
bestMatch
;
}
public
static
class
AmbiguousException
extends
RuntimeException
{
private
static
final
long
serialVersionUID
=
-
2314636505414551663L
;
}
private
static
int
compare
(
Class
[
]
c1
,
Class
[
]
c2
)
{
boolean
c1MoreSpecific
=
false
;
boolean
c2MoreSpecific
=
false
;
if
(
c1
.
length
>
c2
.
length
)
{
return
MORE_SPECIFIC
;
}
if
(
c2
.
length
>
c1
.
length
)
{
return
LESS_SPECIFIC
;
}
for
(
int
i
=
0
;
i
<
c1
.
length
;
++
i
)
{
if
(
c1
[
i
]
!=
c2
[
i
]
)
{
boolean
last
=
(
i
==
c1
.
length
-
1
)
;
c1MoreSpecific
=
c1MoreSpecific
||
isStrictConvertible
(
c2
[
i
]
,
c1
[
i
]
,
last
)
;
c2MoreSpecific
=
c2MoreSpecific
||
isStrictConvertible
(
c1
[
i
]
,
c2
[
i
]
,
last
)
;
}
}
if
(
c1MoreSpecific
)
{
if
(
c2MoreSpecific
)
{
boolean
last1Array
=
c1
[
c1
.
length
-
1
]
.
isArray
(
)
;
boolean
last2Array
=
c2
[
c2
.
length
-
1
]
.
isArray
(
)
;
if
(
last1Array
&&
!
last2Array
)
{
return
LESS_SPECIFIC
;
}
if
(
!
last1Array
&&
last2Array
)
{
return
MORE_SPECIFIC
;
}
return
INCOMPARABLE
;
}
return
MORE_SPECIFIC
;
}
if
(
c2MoreSpecific
)
{
return
LESS_SPECIFIC
;
}
return
INCOMPARABLE
;
}
private
static
boolean
isApplicable
(
Method
method
,
Class
[
]
classes
)
{
Class
[
]
methodArgs
=
method
.
getParameterTypes
(
)
;
if
(
methodArgs
.
length
>
classes
.
length
)
{
if
(
methodArgs
.
length
==
classes
.
length
+
1
&&
methodArgs
[
methodArgs
.
length
-
1
]
.
isArray
(
)
)
{
for
(
int
i
=
0
;
i
<
classes
.
length
;
i
++
)
{
if
(
!
isConvertible
(
methodArgs
[
i
]
,
classes
[
i
]
,
false
)
)
{
return
false
;
}
}
return
true
;
}
else
{
return
false
;
}
}
else
if
(
methodArgs
.
length
==
classes
.
length
)
{
for
(
int
i
=
0
;
i
<
classes
.
length
;
++
i
)
{
if
(
!
isConvertible
(
methodArgs
[
i
]
,
classes
[
i
]
,
false
)
)
{
if
(
i
==
classes
.
length
-
1
&&
methodArgs
[
i
]
.
isArray
(
)
)
{
return
isConvertible
(
methodArgs
[
i
]
,
classes
[
i
]
,
true
)
;
}
return
false
;
}
}
}
else
if
(
methodArgs
.
length
>
0
)
{
Class
lastarg
=
methodArgs
[
methodArgs
.
length
-
1
]
;
if
(
!
lastarg
.
isArray
(
)
)
{
return
false
;
}
for
(
int
i
=
0
;
i
<
methodArgs
.
length
-
1
;
++
i
)
{
if
(
!
isConvertible
(
methodArgs
[
i
]
,
classes
[
i
]
,
false
)
)
{
return
false
;
}
}
Class
vararg
=
lastarg
.
getComponentType
(
)
;
for
(
int
i
=
methodArgs
.
length
-
1
;
i
<
classes
.
length
;
++
i
)
{
if
(
!
isConvertible
(
vararg
,
classes
[
i
]
,
false
)
)
{
return
false
;
}
}
}
return
true
;
}
private
static
boolean
isConvertible
(
Class
formal
,
Class
actual
,
boolean
possibleVarArg
)
{
return
IntrospectionUtils
.
isMethodInvocationConvertible
(
formal
,
actual
,
possibleVarArg
)
;
}
private
static
boolean
isStrictConvertible
(
Class
formal
,
Class
actual
,
boolean
possibleVarArg
)
{
return
IntrospectionUtils
.
isStrictMethodInvocationConvertible
(
formal
,
actual
,
possibleVarArg
)
;
}
}
