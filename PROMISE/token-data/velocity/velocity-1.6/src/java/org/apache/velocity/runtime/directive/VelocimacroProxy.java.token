package
org
.
apache
.
velocity
.
runtime
.
directive
;
import
java
.
io
.
IOException
;
import
java
.
io
.
Writer
;
import
org
.
apache
.
commons
.
lang
.
StringUtils
;
import
org
.
apache
.
velocity
.
context
.
InternalContextAdapter
;
import
org
.
apache
.
velocity
.
context
.
ProxyVMContext
;
import
org
.
apache
.
velocity
.
exception
.
MacroOverflowException
;
import
org
.
apache
.
velocity
.
exception
.
MethodInvocationException
;
import
org
.
apache
.
velocity
.
exception
.
TemplateInitException
;
import
org
.
apache
.
velocity
.
exception
.
VelocityException
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeConstants
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeServices
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
ParserTreeConstants
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
ASTDirective
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
Node
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SimpleNode
;
public
class
VelocimacroProxy
extends
Directive
{
private
String
macroName
;
private
String
[
]
argArray
=
null
;
private
String
[
]
literalArgArray
=
null
;
private
SimpleNode
nodeTree
=
null
;
private
int
numMacroArgs
=
0
;
private
boolean
preInit
=
false
;
private
boolean
strictArguments
;
private
boolean
localContextScope
=
false
;
private
int
maxCallDepth
;
public
String
getName
(
)
{
return
macroName
;
}
public
int
getType
(
)
{
return
LINE
;
}
public
void
setName
(
String
name
)
{
macroName
=
name
;
}
public
void
setArgArray
(
String
[
]
arr
)
{
argArray
=
arr
;
literalArgArray
=
new
String
[
arr
.
length
]
;
for
(
int
i
=
0
;
i
<
arr
.
length
;
i
++
)
{
literalArgArray
[
i
]
=
".literal.$"
+
argArray
[
i
]
;
}
numMacroArgs
=
argArray
.
length
-
1
;
}
public
void
setNodeTree
(
SimpleNode
tree
)
{
nodeTree
=
tree
;
}
public
int
getNumArgs
(
)
{
return
numMacroArgs
;
}
public
boolean
render
(
InternalContextAdapter
context
,
Writer
writer
,
Node
node
)
throws
IOException
,
MethodInvocationException
,
MacroOverflowException
{
final
ProxyVMContext
vmc
=
new
ProxyVMContext
(
context
,
rsvc
,
localContextScope
)
;
int
callArguments
=
node
.
jjtGetNumChildren
(
)
;
if
(
callArguments
>
0
)
{
for
(
int
i
=
1
;
i
<
argArray
.
length
&&
i
<=
callArguments
;
i
++
)
{
Node
macroCallArgument
=
node
.
jjtGetChild
(
i
-
1
)
;
vmc
.
addVMProxyArg
(
context
,
argArray
[
i
]
,
literalArgArray
[
i
]
,
macroCallArgument
)
;
}
}
if
(
maxCallDepth
>
0
&&
maxCallDepth
==
vmc
.
getCurrentMacroCallDepth
(
)
)
{
String
templateName
=
vmc
.
getCurrentTemplateName
(
)
;
Object
[
]
stack
=
vmc
.
getMacroNameStack
(
)
;
StringBuffer
out
=
new
StringBuffer
(
100
)
.
append
(
"Max calling depth of "
)
.
append
(
maxCallDepth
)
.
append
(
" was exceeded in Template:"
)
.
append
(
templateName
)
.
append
(
" and Macro:"
)
.
append
(
macroName
)
.
append
(
" with Call Stack:"
)
;
for
(
int
i
=
0
;
i
<
stack
.
length
;
i
++
)
{
if
(
i
!=
0
)
{
out
.
append
(
"->"
)
;
}
out
.
append
(
stack
[
i
]
)
;
}
rsvc
.
getLog
(
)
.
error
(
out
.
toString
(
)
)
;
try
{
throw
new
MacroOverflowException
(
out
.
toString
(
)
)
;
}
finally
{
while
(
vmc
.
getCurrentMacroCallDepth
(
)
>
0
)
{
vmc
.
popCurrentMacroName
(
)
;
}
}
}
try
{
vmc
.
pushCurrentMacroName
(
macroName
)
;
nodeTree
.
render
(
vmc
,
writer
)
;
vmc
.
popCurrentMacroName
(
)
;
return
true
;
}
catch
(
RuntimeException
e
)
{
throw
e
;
}
catch
(
Exception
e
)
{
String
msg
=
"VelocimacroProxy.render() : exception VM = #"
+
macroName
+
"()"
;
rsvc
.
getLog
(
)
.
error
(
msg
,
e
)
;
throw
new
VelocityException
(
msg
,
e
)
;
}
}
public
void
init
(
RuntimeServices
rs
,
InternalContextAdapter
context
,
Node
node
)
throws
TemplateInitException
{
synchronized
(
this
)
{
if
(
!
preInit
)
{
super
.
init
(
rs
,
context
,
node
)
;
strictArguments
=
rs
.
getConfiguration
(
)
.
getBoolean
(
RuntimeConstants
.
VM_ARGUMENTS_STRICT
,
false
)
;
localContextScope
=
rsvc
.
getBoolean
(
RuntimeConstants
.
VM_CONTEXT_LOCALSCOPE
,
false
)
;
maxCallDepth
=
rsvc
.
getInt
(
RuntimeConstants
.
VM_MAX_DEPTH
)
;
nodeTree
.
init
(
context
,
rs
)
;
preInit
=
true
;
}
}
int
i
=
node
.
jjtGetNumChildren
(
)
;
if
(
getNumArgs
(
)
!=
i
)
{
for
(
Node
parent
=
node
.
jjtGetParent
(
)
;
parent
!=
null
;
)
{
if
(
(
parent
instanceof
ASTDirective
)
&&
StringUtils
.
equals
(
(
(
ASTDirective
)
parent
)
.
getDirectiveName
(
)
,
"macro"
)
)
{
return
;
}
parent
=
parent
.
jjtGetParent
(
)
;
}
String
msg
=
"VM #"
+
macroName
+
": too "
+
(
(
getNumArgs
(
)
>
i
)
?
"few"
:
"many"
)
+
" arguments to macro. Wanted "
+
getNumArgs
(
)
+
" got "
+
i
;
if
(
strictArguments
)
{
throw
new
TemplateInitException
(
msg
,
context
.
getCurrentTemplateName
(
)
,
0
,
0
)
;
}
else
{
rsvc
.
getLog
(
)
.
debug
(
msg
)
;
return
;
}
}
for
(
int
n
=
0
;
n
<
i
;
n
++
)
{
Node
child
=
node
.
jjtGetChild
(
n
)
;
if
(
child
.
getType
(
)
==
ParserTreeConstants
.
JJTWORD
)
{
throw
new
TemplateInitException
(
"Invalid arg #"
+
n
+
" in VM #"
+
macroName
,
context
.
getCurrentTemplateName
(
)
,
0
,
0
)
;
}
}
}
}
