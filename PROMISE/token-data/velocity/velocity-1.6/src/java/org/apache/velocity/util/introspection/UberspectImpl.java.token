package
org
.
apache
.
velocity
.
util
.
introspection
;
import
java
.
lang
.
reflect
.
Array
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Map
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeLogger
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
Log
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
RuntimeLoggerLog
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
AbstractExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
BooleanPropertyExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
GetExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
MapGetExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
MapSetExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
PropertyExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
PutExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SetExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SetPropertyExecutor
;
import
org
.
apache
.
velocity
.
util
.
ArrayIterator
;
import
org
.
apache
.
velocity
.
util
.
ArrayListWrapper
;
import
org
.
apache
.
velocity
.
util
.
EnumerationIterator
;
public
class
UberspectImpl
implements
Uberspect
,
UberspectLoggable
{
protected
Log
log
;
protected
Introspector
introspector
;
public
void
init
(
)
throws
Exception
{
introspector
=
new
Introspector
(
log
)
;
}
public
void
setLog
(
Log
log
)
{
this
.
log
=
log
;
}
public
void
setRuntimeLogger
(
RuntimeLogger
runtimeLogger
)
{
setLog
(
new
RuntimeLoggerLog
(
runtimeLogger
)
)
;
}
public
Iterator
getIterator
(
Object
obj
,
Info
i
)
throws
Exception
{
if
(
obj
.
getClass
(
)
.
isArray
(
)
)
{
return
new
ArrayIterator
(
obj
)
;
}
else
if
(
obj
instanceof
Collection
)
{
return
(
(
Collection
)
obj
)
.
iterator
(
)
;
}
else
if
(
obj
instanceof
Map
)
{
return
(
(
Map
)
obj
)
.
values
(
)
.
iterator
(
)
;
}
else
if
(
obj
instanceof
Iterator
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"The iterative object in the #foreach() loop at "
+
i
+
" is of type java.util.Iterator.  Because "
+
"it is not resettable, if used in more than once it "
+
"may lead to unexpected results."
)
;
}
return
(
(
Iterator
)
obj
)
;
}
else
if
(
obj
instanceof
Enumeration
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"The iterative object in the #foreach() loop at "
+
i
+
" is of type java.util.Enumeration.  Because "
+
"it is not resettable, if used in more than once it "
+
"may lead to unexpected results."
)
;
}
return
new
EnumerationIterator
(
(
Enumeration
)
obj
)
;
}
else
{
Class
type
=
obj
.
getClass
(
)
;
try
{
Method
iter
=
type
.
getMethod
(
"iterator"
,
null
)
;
Class
returns
=
iter
.
getReturnType
(
)
;
if
(
Iterator
.
class
.
isAssignableFrom
(
returns
)
)
{
return
(
Iterator
)
iter
.
invoke
(
obj
,
null
)
;
}
else
{
log
.
debug
(
"iterator() method of reference in #foreach loop at "
+
i
+
" does not return a true Iterator."
)
;
}
}
catch
(
NoSuchMethodException
nsme
)
{
}
}
log
.
debug
(
"Could not determine type of iterator in #foreach loop at "
+
i
)
;
return
null
;
}
public
VelMethod
getMethod
(
Object
obj
,
String
methodName
,
Object
[
]
args
,
Info
i
)
throws
Exception
{
if
(
obj
==
null
)
{
return
null
;
}
Method
m
=
introspector
.
getMethod
(
obj
.
getClass
(
)
,
methodName
,
args
)
;
if
(
m
!=
null
)
{
return
new
VelMethodImpl
(
m
)
;
}
Class
cls
=
obj
.
getClass
(
)
;
if
(
cls
.
isArray
(
)
)
{
m
=
introspector
.
getMethod
(
ArrayListWrapper
.
class
,
methodName
,
args
)
;
if
(
m
!=
null
)
{
return
new
VelMethodImpl
(
m
,
true
)
;
}
}
else
if
(
cls
==
Class
.
class
)
{
m
=
introspector
.
getMethod
(
(
Class
)
obj
,
methodName
,
args
)
;
if
(
m
!=
null
)
{
return
new
VelMethodImpl
(
m
)
;
}
}
return
null
;
}
public
VelPropertyGet
getPropertyGet
(
Object
obj
,
String
identifier
,
Info
i
)
throws
Exception
{
if
(
obj
==
null
)
{
return
null
;
}
Class
claz
=
obj
.
getClass
(
)
;
AbstractExecutor
executor
=
new
PropertyExecutor
(
log
,
introspector
,
claz
,
identifier
)
;
if
(
!
executor
.
isAlive
(
)
)
{
executor
=
new
MapGetExecutor
(
log
,
claz
,
identifier
)
;
}
if
(
!
executor
.
isAlive
(
)
)
{
executor
=
new
GetExecutor
(
log
,
introspector
,
claz
,
identifier
)
;
}
if
(
!
executor
.
isAlive
(
)
)
{
executor
=
new
BooleanPropertyExecutor
(
log
,
introspector
,
claz
,
identifier
)
;
}
return
(
executor
.
isAlive
(
)
)
?
new
VelGetterImpl
(
executor
)
:
null
;
}
public
VelPropertySet
getPropertySet
(
Object
obj
,
String
identifier
,
Object
arg
,
Info
i
)
throws
Exception
{
if
(
obj
==
null
)
{
return
null
;
}
Class
claz
=
obj
.
getClass
(
)
;
SetExecutor
executor
=
new
SetPropertyExecutor
(
log
,
introspector
,
claz
,
identifier
,
arg
)
;
if
(
!
executor
.
isAlive
(
)
)
{
executor
=
new
MapSetExecutor
(
log
,
claz
,
identifier
)
;
}
if
(
!
executor
.
isAlive
(
)
)
{
executor
=
new
PutExecutor
(
log
,
introspector
,
claz
,
arg
,
identifier
)
;
}
return
(
executor
.
isAlive
(
)
)
?
new
VelSetterImpl
(
executor
)
:
null
;
}
public
static
class
VelMethodImpl
implements
VelMethod
{
final
Method
method
;
Boolean
isVarArg
;
boolean
wrapArray
;
public
VelMethodImpl
(
Method
m
)
{
this
(
m
,
false
)
;
}
public
VelMethodImpl
(
Method
method
,
boolean
wrapArray
)
{
this
.
method
=
method
;
this
.
wrapArray
=
wrapArray
;
}
private
VelMethodImpl
(
)
{
method
=
null
;
}
public
Object
invoke
(
Object
o
,
Object
[
]
actual
)
throws
Exception
{
if
(
wrapArray
)
{
o
=
new
ArrayListWrapper
(
o
)
;
}
if
(
isVarArg
(
)
)
{
Class
[
]
formal
=
method
.
getParameterTypes
(
)
;
int
index
=
formal
.
length
-
1
;
if
(
actual
.
length
>=
index
)
{
Class
type
=
formal
[
index
]
.
getComponentType
(
)
;
actual
=
handleVarArg
(
type
,
index
,
actual
)
;
}
}
return
doInvoke
(
o
,
actual
)
;
}
protected
Object
doInvoke
(
Object
o
,
Object
[
]
actual
)
throws
Exception
{
return
method
.
invoke
(
o
,
actual
)
;
}
public
boolean
isVarArg
(
)
{
if
(
isVarArg
==
null
)
{
Class
[
]
formal
=
method
.
getParameterTypes
(
)
;
if
(
formal
==
null
||
formal
.
length
==
0
)
{
this
.
isVarArg
=
Boolean
.
FALSE
;
}
else
{
Class
last
=
formal
[
formal
.
length
-
1
]
;
this
.
isVarArg
=
Boolean
.
valueOf
(
last
.
isArray
(
)
)
;
}
}
return
isVarArg
.
booleanValue
(
)
;
}
private
Object
[
]
handleVarArg
(
final
Class
type
,
final
int
index
,
Object
[
]
actual
)
{
if
(
actual
.
length
==
index
)
{
Object
[
]
newActual
=
new
Object
[
actual
.
length
+
1
]
;
System
.
arraycopy
(
actual
,
0
,
newActual
,
0
,
actual
.
length
)
;
newActual
[
index
]
=
Array
.
newInstance
(
type
,
0
)
;
actual
=
newActual
;
}
else
if
(
actual
.
length
==
index
+
1
&&
actual
[
index
]
!=
null
)
{
Class
argClass
=
actual
[
index
]
.
getClass
(
)
;
if
(
!
argClass
.
isArray
(
)
&&
IntrospectionUtils
.
isMethodInvocationConvertible
(
type
,
argClass
,
false
)
)
{
Object
lastActual
=
Array
.
newInstance
(
type
,
1
)
;
Array
.
set
(
lastActual
,
0
,
actual
[
index
]
)
;
actual
[
index
]
=
lastActual
;
}
}
else
if
(
actual
.
length
>
index
+
1
)
{
int
size
=
actual
.
length
-
index
;
Object
lastActual
=
Array
.
newInstance
(
type
,
size
)
;
for
(
int
i
=
0
;
i
<
size
;
i
++
)
{
Array
.
set
(
lastActual
,
i
,
actual
[
index
+
i
]
)
;
}
Object
[
]
newActual
=
new
Object
[
index
+
1
]
;
for
(
int
i
=
0
;
i
<
index
;
i
++
)
{
newActual
[
i
]
=
actual
[
i
]
;
}
newActual
[
index
]
=
lastActual
;
actual
=
newActual
;
}
return
actual
;
}
public
boolean
isCacheable
(
)
{
return
true
;
}
public
String
getMethodName
(
)
{
return
method
.
getName
(
)
;
}
public
Class
getReturnType
(
)
{
return
method
.
getReturnType
(
)
;
}
}
public
static
class
VelGetterImpl
implements
VelPropertyGet
{
final
AbstractExecutor
getExecutor
;
public
VelGetterImpl
(
AbstractExecutor
exec
)
{
getExecutor
=
exec
;
}
private
VelGetterImpl
(
)
{
getExecutor
=
null
;
}
public
Object
invoke
(
Object
o
)
throws
Exception
{
return
getExecutor
.
execute
(
o
)
;
}
public
boolean
isCacheable
(
)
{
return
true
;
}
public
String
getMethodName
(
)
{
return
getExecutor
.
isAlive
(
)
?
getExecutor
.
getMethod
(
)
.
getName
(
)
:
null
;
}
}
public
static
class
VelSetterImpl
implements
VelPropertySet
{
private
final
SetExecutor
setExecutor
;
public
VelSetterImpl
(
final
SetExecutor
setExecutor
)
{
this
.
setExecutor
=
setExecutor
;
}
private
VelSetterImpl
(
)
{
setExecutor
=
null
;
}
public
Object
invoke
(
final
Object
o
,
final
Object
value
)
throws
Exception
{
return
setExecutor
.
execute
(
o
,
value
)
;
}
public
boolean
isCacheable
(
)
{
return
true
;
}
public
String
getMethodName
(
)
{
return
setExecutor
.
isAlive
(
)
?
setExecutor
.
getMethod
(
)
.
getName
(
)
:
null
;
}
}
}
