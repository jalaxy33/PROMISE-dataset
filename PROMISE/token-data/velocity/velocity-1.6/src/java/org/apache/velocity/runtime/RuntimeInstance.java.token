package
org
.
apache
.
velocity
.
runtime
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
Reader
;
import
java
.
io
.
StringReader
;
import
java
.
io
.
Writer
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Map
;
import
java
.
util
.
Properties
;
import
org
.
apache
.
commons
.
collections
.
ExtendedProperties
;
import
org
.
apache
.
commons
.
lang
.
text
.
StrBuilder
;
import
org
.
apache
.
velocity
.
Template
;
import
org
.
apache
.
velocity
.
app
.
event
.
EventCartridge
;
import
org
.
apache
.
velocity
.
app
.
event
.
EventHandler
;
import
org
.
apache
.
velocity
.
app
.
event
.
IncludeEventHandler
;
import
org
.
apache
.
velocity
.
app
.
event
.
InvalidReferenceEventHandler
;
import
org
.
apache
.
velocity
.
app
.
event
.
MethodExceptionEventHandler
;
import
org
.
apache
.
velocity
.
app
.
event
.
NullSetEventHandler
;
import
org
.
apache
.
velocity
.
app
.
event
.
ReferenceInsertionEventHandler
;
import
org
.
apache
.
velocity
.
context
.
Context
;
import
org
.
apache
.
velocity
.
context
.
InternalContextAdapterImpl
;
import
org
.
apache
.
velocity
.
exception
.
MethodInvocationException
;
import
org
.
apache
.
velocity
.
exception
.
ParseErrorException
;
import
org
.
apache
.
velocity
.
exception
.
ResourceNotFoundException
;
import
org
.
apache
.
velocity
.
exception
.
TemplateInitException
;
import
org
.
apache
.
velocity
.
exception
.
VelocityException
;
import
org
.
apache
.
velocity
.
runtime
.
directive
.
Directive
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
Log
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
LogManager
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
ParseException
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
Parser
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
Node
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SimpleNode
;
import
org
.
apache
.
velocity
.
runtime
.
resource
.
ContentResource
;
import
org
.
apache
.
velocity
.
runtime
.
resource
.
ResourceManager
;
import
org
.
apache
.
velocity
.
util
.
ClassUtils
;
import
org
.
apache
.
velocity
.
util
.
RuntimeServicesAware
;
import
org
.
apache
.
velocity
.
util
.
StringUtils
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
Introspector
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
Uberspect
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
UberspectLoggable
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
ChainableUberspector
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
LinkingUberspector
;
public
class
RuntimeInstance
implements
RuntimeConstants
,
RuntimeServices
{
private
VelocimacroFactory
vmFactory
=
null
;
private
Log
log
=
new
Log
(
)
;
private
ParserPool
parserPool
;
private
boolean
initializing
=
false
;
private
boolean
initialized
=
false
;
private
ExtendedProperties
overridingProperties
=
null
;
private
Hashtable
runtimeDirectives
;
private
ExtendedProperties
configuration
=
new
ExtendedProperties
(
)
;
private
ResourceManager
resourceManager
=
null
;
private
EventCartridge
eventCartridge
=
null
;
private
Introspector
introspector
=
null
;
private
Map
applicationAttributes
=
null
;
private
Uberspect
uberSpect
;
private
String
encoding
;
public
RuntimeInstance
(
)
{
vmFactory
=
new
VelocimacroFactory
(
this
)
;
introspector
=
new
Introspector
(
getLog
(
)
)
;
applicationAttributes
=
new
HashMap
(
)
;
}
public
synchronized
void
init
(
)
throws
Exception
{
if
(
!
initialized
&&
!
initializing
)
{
initializing
=
true
;
log
.
trace
(
"*******************************************************************"
)
;
log
.
debug
(
"Starting Apache Velocity v1.6.1 (compiled: 2008-12-09 10:57:23)"
)
;
log
.
trace
(
"RuntimeInstance initializing."
)
;
initializeProperties
(
)
;
initializeLog
(
)
;
initializeResourceManager
(
)
;
initializeDirectives
(
)
;
initializeEventHandlers
(
)
;
initializeParserPool
(
)
;
initializeIntrospection
(
)
;
vmFactory
.
initVelocimacro
(
)
;
log
.
trace
(
"RuntimeInstance successfully initialized."
)
;
initialized
=
true
;
initializing
=
false
;
}
}
public
boolean
isInitialized
(
)
{
return
initialized
;
}
private
void
requireInitialization
(
)
{
if
(
!
initialized
&&
!
initializing
)
{
log
.
debug
(
"Velocity was not initialized! Calling init()..."
)
;
try
{
init
(
)
;
}
catch
(
Exception
e
)
{
getLog
(
)
.
error
(
"Could not auto-initialize Velocity"
,
e
)
;
throw
new
RuntimeException
(
"Velocity could not be initialized!"
,
e
)
;
}
}
}
private
void
initializeIntrospection
(
)
throws
Exception
{
String
[
]
uberspectors
=
configuration
.
getStringArray
(
RuntimeConstants
.
UBERSPECT_CLASSNAME
)
;
for
(
int
i
=
0
;
i
<
uberspectors
.
length
;
i
++
)
{
String
rm
=
uberspectors
[
i
]
;
Object
o
=
null
;
try
{
o
=
ClassUtils
.
getNewInstance
(
rm
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
String
err
=
"The specified class for Uberspect ("
+
rm
+
") does not exist or is not accessible to the current classloader."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
if
(
!
(
o
instanceof
Uberspect
)
)
{
String
err
=
"The specified class for Uberspect ("
+
rm
+
") does not implement "
+
Uberspect
.
class
.
getName
(
)
+
"; Velocity is not initialized correctly."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
Uberspect
u
=
(
Uberspect
)
o
;
if
(
u
instanceof
UberspectLoggable
)
{
(
(
UberspectLoggable
)
u
)
.
setLog
(
getLog
(
)
)
;
}
if
(
u
instanceof
RuntimeServicesAware
)
{
(
(
RuntimeServicesAware
)
u
)
.
setRuntimeServices
(
this
)
;
}
if
(
uberSpect
==
null
)
{
uberSpect
=
u
;
}
else
{
if
(
u
instanceof
ChainableUberspector
)
{
(
(
ChainableUberspector
)
u
)
.
wrap
(
uberSpect
)
;
uberSpect
=
u
;
}
else
{
uberSpect
=
new
LinkingUberspector
(
uberSpect
,
u
)
;
}
}
}
if
(
uberSpect
!=
null
)
{
uberSpect
.
init
(
)
;
}
else
{
String
err
=
"It appears that no class was specified as the"
+
" Uberspect.  Please ensure that all configuration"
+
" information is correct."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
}
private
void
setDefaultProperties
(
)
{
InputStream
inputStream
=
null
;
try
{
inputStream
=
getClass
(
)
.
getResourceAsStream
(
'/'
+
DEFAULT_RUNTIME_PROPERTIES
)
;
configuration
.
load
(
inputStream
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Default Properties File: "
+
new
File
(
DEFAULT_RUNTIME_PROPERTIES
)
.
getPath
(
)
)
;
}
}
catch
(
IOException
ioe
)
{
String
msg
=
"Cannot get Velocity Runtime default properties!"
;
log
.
error
(
msg
,
ioe
)
;
throw
new
RuntimeException
(
msg
,
ioe
)
;
}
finally
{
try
{
if
(
inputStream
!=
null
)
{
inputStream
.
close
(
)
;
}
}
catch
(
IOException
ioe
)
{
String
msg
=
"Cannot close Velocity Runtime default properties!"
;
log
.
error
(
msg
,
ioe
)
;
throw
new
RuntimeException
(
msg
,
ioe
)
;
}
}
}
public
void
setProperty
(
String
key
,
Object
value
)
{
if
(
overridingProperties
==
null
)
{
overridingProperties
=
new
ExtendedProperties
(
)
;
}
overridingProperties
.
setProperty
(
key
,
value
)
;
}
public
void
setConfiguration
(
ExtendedProperties
configuration
)
{
if
(
overridingProperties
==
null
)
{
overridingProperties
=
configuration
;
}
else
{
if
(
overridingProperties
!=
configuration
)
{
overridingProperties
.
combine
(
configuration
)
;
}
}
}
public
void
addProperty
(
String
key
,
Object
value
)
{
if
(
overridingProperties
==
null
)
{
overridingProperties
=
new
ExtendedProperties
(
)
;
}
overridingProperties
.
addProperty
(
key
,
value
)
;
}
public
void
clearProperty
(
String
key
)
{
if
(
overridingProperties
!=
null
)
{
overridingProperties
.
clearProperty
(
key
)
;
}
}
public
Object
getProperty
(
String
key
)
{
Object
o
=
null
;
if
(
!
initialized
&&
!
initializing
&&
overridingProperties
!=
null
)
{
o
=
overridingProperties
.
get
(
key
)
;
}
if
(
o
==
null
)
{
o
=
configuration
.
getProperty
(
key
)
;
}
if
(
o
instanceof
String
)
{
return
StringUtils
.
nullTrim
(
(
String
)
o
)
;
}
else
{
return
o
;
}
}
private
void
initializeProperties
(
)
{
if
(
configuration
.
isInitialized
(
)
==
false
)
{
setDefaultProperties
(
)
;
}
if
(
overridingProperties
!=
null
)
{
configuration
.
combine
(
overridingProperties
)
;
}
}
public
void
init
(
Properties
p
)
throws
Exception
{
setProperties
(
ExtendedProperties
.
convertProperties
(
p
)
)
;
init
(
)
;
}
private
void
setProperties
(
ExtendedProperties
p
)
{
if
(
overridingProperties
==
null
)
{
overridingProperties
=
p
;
}
else
{
overridingProperties
.
combine
(
p
)
;
}
}
public
void
init
(
String
configurationFile
)
throws
Exception
{
setProperties
(
new
ExtendedProperties
(
configurationFile
)
)
;
init
(
)
;
}
private
void
initializeResourceManager
(
)
throws
Exception
{
String
rm
=
getString
(
RuntimeConstants
.
RESOURCE_MANAGER_CLASS
)
;
if
(
rm
!=
null
&&
rm
.
length
(
)
>
0
)
{
Object
o
=
null
;
try
{
o
=
ClassUtils
.
getNewInstance
(
rm
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
String
err
=
"The specified class for ResourceManager ("
+
rm
+
") does not exist or is not accessible to the current classloader."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
if
(
!
(
o
instanceof
ResourceManager
)
)
{
String
err
=
"The specified class for ResourceManager ("
+
rm
+
") does not implement "
+
ResourceManager
.
class
.
getName
(
)
+
"; Velocity is not initialized correctly."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
resourceManager
=
(
ResourceManager
)
o
;
resourceManager
.
initialize
(
this
)
;
}
else
{
String
err
=
"It appears that no class was specified as the"
+
" ResourceManager.  Please ensure that all configuration"
+
" information is correct."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
}
private
void
initializeEventHandlers
(
)
throws
Exception
{
eventCartridge
=
new
EventCartridge
(
)
;
String
[
]
referenceinsertion
=
configuration
.
getStringArray
(
RuntimeConstants
.
EVENTHANDLER_REFERENCEINSERTION
)
;
if
(
referenceinsertion
!=
null
)
{
for
(
int
i
=
0
;
i
<
referenceinsertion
.
length
;
i
++
)
{
EventHandler
ev
=
initializeSpecificEventHandler
(
referenceinsertion
[
i
]
,
RuntimeConstants
.
EVENTHANDLER_REFERENCEINSERTION
,
ReferenceInsertionEventHandler
.
class
)
;
if
(
ev
!=
null
)
eventCartridge
.
addReferenceInsertionEventHandler
(
(
ReferenceInsertionEventHandler
)
ev
)
;
}
}
String
[
]
nullset
=
configuration
.
getStringArray
(
RuntimeConstants
.
EVENTHANDLER_NULLSET
)
;
if
(
nullset
!=
null
)
{
for
(
int
i
=
0
;
i
<
nullset
.
length
;
i
++
)
{
EventHandler
ev
=
initializeSpecificEventHandler
(
nullset
[
i
]
,
RuntimeConstants
.
EVENTHANDLER_NULLSET
,
NullSetEventHandler
.
class
)
;
if
(
ev
!=
null
)
eventCartridge
.
addNullSetEventHandler
(
(
NullSetEventHandler
)
ev
)
;
}
}
String
[
]
methodexception
=
configuration
.
getStringArray
(
RuntimeConstants
.
EVENTHANDLER_METHODEXCEPTION
)
;
if
(
methodexception
!=
null
)
{
for
(
int
i
=
0
;
i
<
methodexception
.
length
;
i
++
)
{
EventHandler
ev
=
initializeSpecificEventHandler
(
methodexception
[
i
]
,
RuntimeConstants
.
EVENTHANDLER_METHODEXCEPTION
,
MethodExceptionEventHandler
.
class
)
;
if
(
ev
!=
null
)
eventCartridge
.
addMethodExceptionHandler
(
(
MethodExceptionEventHandler
)
ev
)
;
}
}
String
[
]
includeHandler
=
configuration
.
getStringArray
(
RuntimeConstants
.
EVENTHANDLER_INCLUDE
)
;
if
(
includeHandler
!=
null
)
{
for
(
int
i
=
0
;
i
<
includeHandler
.
length
;
i
++
)
{
EventHandler
ev
=
initializeSpecificEventHandler
(
includeHandler
[
i
]
,
RuntimeConstants
.
EVENTHANDLER_INCLUDE
,
IncludeEventHandler
.
class
)
;
if
(
ev
!=
null
)
eventCartridge
.
addIncludeEventHandler
(
(
IncludeEventHandler
)
ev
)
;
}
}
String
[
]
invalidReferenceSet
=
configuration
.
getStringArray
(
RuntimeConstants
.
EVENTHANDLER_INVALIDREFERENCES
)
;
if
(
invalidReferenceSet
!=
null
)
{
for
(
int
i
=
0
;
i
<
invalidReferenceSet
.
length
;
i
++
)
{
EventHandler
ev
=
initializeSpecificEventHandler
(
invalidReferenceSet
[
i
]
,
RuntimeConstants
.
EVENTHANDLER_INVALIDREFERENCES
,
InvalidReferenceEventHandler
.
class
)
;
if
(
ev
!=
null
)
{
eventCartridge
.
addInvalidReferenceEventHandler
(
(
InvalidReferenceEventHandler
)
ev
)
;
}
}
}
}
private
EventHandler
initializeSpecificEventHandler
(
String
classname
,
String
paramName
,
Class
EventHandlerInterface
)
throws
Exception
{
if
(
classname
!=
null
&&
classname
.
length
(
)
>
0
)
{
Object
o
=
null
;
try
{
o
=
ClassUtils
.
getNewInstance
(
classname
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
String
err
=
"The specified class for "
+
paramName
+
" ("
+
classname
+
") does not exist or is not accessible to the current classloader."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
if
(
!
EventHandlerInterface
.
isAssignableFrom
(
EventHandlerInterface
)
)
{
String
err
=
"The specified class for "
+
paramName
+
" ("
+
classname
+
") does not implement "
+
EventHandlerInterface
.
getName
(
)
+
"; Velocity is not initialized correctly."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
EventHandler
ev
=
(
EventHandler
)
o
;
if
(
ev
instanceof
RuntimeServicesAware
)
(
(
RuntimeServicesAware
)
ev
)
.
setRuntimeServices
(
this
)
;
return
ev
;
}
else
return
null
;
}
private
void
initializeLog
(
)
throws
Exception
{
LogManager
.
updateLog
(
this
.
log
,
this
)
;
}
private
void
initializeDirectives
(
)
throws
Exception
{
runtimeDirectives
=
new
Hashtable
(
)
;
Properties
directiveProperties
=
new
Properties
(
)
;
InputStream
inputStream
=
null
;
try
{
inputStream
=
getClass
(
)
.
getResourceAsStream
(
'/'
+
DEFAULT_RUNTIME_DIRECTIVES
)
;
if
(
inputStream
==
null
)
{
throw
new
Exception
(
"Error loading directive.properties! "
+
"Something is very wrong if these properties "
+
"aren't being located. Either your Velocity "
+
"distribution is incomplete or your Velocity "
+
"jar file is corrupted!"
)
;
}
directiveProperties
.
load
(
inputStream
)
;
}
catch
(
IOException
ioe
)
{
String
msg
=
"Error while loading directive properties!"
;
log
.
error
(
msg
,
ioe
)
;
throw
new
RuntimeException
(
msg
,
ioe
)
;
}
finally
{
try
{
if
(
inputStream
!=
null
)
{
inputStream
.
close
(
)
;
}
}
catch
(
IOException
ioe
)
{
String
msg
=
"Cannot close directive properties!"
;
log
.
error
(
msg
,
ioe
)
;
throw
new
RuntimeException
(
msg
,
ioe
)
;
}
}
Enumeration
directiveClasses
=
directiveProperties
.
elements
(
)
;
while
(
directiveClasses
.
hasMoreElements
(
)
)
{
String
directiveClass
=
(
String
)
directiveClasses
.
nextElement
(
)
;
loadDirective
(
directiveClass
)
;
log
.
debug
(
"Loaded System Directive: "
+
directiveClass
)
;
}
String
[
]
userdirective
=
configuration
.
getStringArray
(
"userdirective"
)
;
for
(
int
i
=
0
;
i
<
userdirective
.
length
;
i
++
)
{
loadDirective
(
userdirective
[
i
]
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Loaded User Directive: "
+
userdirective
[
i
]
)
;
}
}
}
public
void
addDirective
(
Directive
directive
)
{
runtimeDirectives
.
put
(
directive
.
getName
(
)
,
directive
)
;
}
public
Directive
getDirective
(
String
name
)
{
return
(
Directive
)
runtimeDirectives
.
get
(
name
)
;
}
public
void
removeDirective
(
String
name
)
{
runtimeDirectives
.
remove
(
name
)
;
}
private
void
loadDirective
(
String
directiveClass
)
{
try
{
Object
o
=
ClassUtils
.
getNewInstance
(
directiveClass
)
;
if
(
o
instanceof
Directive
)
{
Directive
directive
=
(
Directive
)
o
;
addDirective
(
directive
)
;
}
else
{
String
msg
=
directiveClass
+
" does not implement "
+
Directive
.
class
.
getName
(
)
+
"; it cannot be loaded."
;
log
.
error
(
msg
)
;
throw
new
VelocityException
(
msg
)
;
}
}
catch
(
Exception
e
)
{
String
msg
=
"Failed to load Directive: "
+
directiveClass
;
log
.
error
(
msg
,
e
)
;
throw
new
VelocityException
(
msg
,
e
)
;
}
}
private
void
initializeParserPool
(
)
throws
Exception
{
String
pp
=
getString
(
RuntimeConstants
.
PARSER_POOL_CLASS
)
;
if
(
pp
!=
null
&&
pp
.
length
(
)
>
0
)
{
Object
o
=
null
;
try
{
o
=
ClassUtils
.
getNewInstance
(
pp
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
String
err
=
"The specified class for ParserPool ("
+
pp
+
") does not exist (or is not accessible to the current classloader."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
if
(
!
(
o
instanceof
ParserPool
)
)
{
String
err
=
"The specified class for ParserPool ("
+
pp
+
") does not implement "
+
ParserPool
.
class
+
" Velocity not initialized correctly."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
parserPool
=
(
ParserPool
)
o
;
parserPool
.
initialize
(
this
)
;
}
else
{
String
err
=
"It appears that no class was specified as the"
+
" ParserPool.  Please ensure that all configuration"
+
" information is correct."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
}
public
Parser
createNewParser
(
)
{
requireInitialization
(
)
;
Parser
parser
=
new
Parser
(
this
)
;
parser
.
setDirectives
(
runtimeDirectives
)
;
return
parser
;
}
public
SimpleNode
parse
(
String
string
,
String
templateName
)
throws
ParseException
{
return
parse
(
new
StringReader
(
string
)
,
templateName
)
;
}
public
SimpleNode
parse
(
Reader
reader
,
String
templateName
)
throws
ParseException
{
return
parse
(
reader
,
templateName
,
true
)
;
}
public
SimpleNode
parse
(
Reader
reader
,
String
templateName
,
boolean
dumpNamespace
)
throws
ParseException
{
requireInitialization
(
)
;
Parser
parser
=
(
Parser
)
parserPool
.
get
(
)
;
boolean
keepParser
=
true
;
if
(
parser
==
null
)
{
if
(
log
.
isInfoEnabled
(
)
)
{
log
.
info
(
"Runtime : ran out of parsers. Creating a new one. "
+
" Please increment the parser.pool.size property."
+
" The current value is too small."
)
;
}
parser
=
createNewParser
(
)
;
keepParser
=
false
;
}
try
{
if
(
dumpNamespace
)
{
dumpVMNamespace
(
templateName
)
;
}
return
parser
.
parse
(
reader
,
templateName
)
;
}
finally
{
if
(
keepParser
)
{
parserPool
.
put
(
parser
)
;
}
}
}
public
boolean
evaluate
(
Context
context
,
Writer
out
,
String
logTag
,
String
instring
)
throws
IOException
{
return
evaluate
(
context
,
out
,
logTag
,
new
StringReader
(
instring
)
)
;
}
public
boolean
evaluate
(
Context
context
,
Writer
writer
,
String
logTag
,
Reader
reader
)
throws
IOException
{
if
(
logTag
==
null
)
{
throw
new
NullPointerException
(
"logTag (i.e. template name) cannot be null, you must provide an identifier for the content being evaluated"
)
;
}
SimpleNode
nodeTree
=
null
;
try
{
nodeTree
=
parse
(
reader
,
logTag
)
;
}
catch
(
ParseException
pex
)
{
throw
new
ParseErrorException
(
pex
)
;
}
catch
(
TemplateInitException
pex
)
{
throw
new
ParseErrorException
(
pex
)
;
}
if
(
nodeTree
==
null
)
{
return
false
;
}
else
{
return
render
(
context
,
writer
,
logTag
,
nodeTree
)
;
}
}
public
boolean
render
(
Context
context
,
Writer
writer
,
String
logTag
,
SimpleNode
nodeTree
)
throws
IOException
{
InternalContextAdapterImpl
ica
=
new
InternalContextAdapterImpl
(
context
)
;
ica
.
pushCurrentTemplateName
(
logTag
)
;
try
{
try
{
nodeTree
.
init
(
ica
,
this
)
;
}
catch
(
TemplateInitException
pex
)
{
throw
new
ParseErrorException
(
pex
)
;
}
catch
(
RuntimeException
e
)
{
throw
e
;
}
catch
(
Exception
e
)
{
String
msg
=
"RuntimeInstance.render(): init exception for tag = "
+
logTag
;
getLog
(
)
.
error
(
msg
,
e
)
;
throw
new
VelocityException
(
msg
,
e
)
;
}
nodeTree
.
render
(
ica
,
writer
)
;
}
finally
{
ica
.
popCurrentTemplateName
(
)
;
}
return
true
;
}
public
boolean
invokeVelocimacro
(
final
String
vmName
,
String
logTag
,
String
[
]
params
,
final
Context
context
,
final
Writer
writer
)
throws
IOException
{
if
(
vmName
==
null
||
context
==
null
||
writer
==
null
)
{
String
msg
=
"RuntimeInstance.invokeVelocimacro() : invalid call : vmName, context, and writer must not be null"
;
getLog
(
)
.
error
(
msg
)
;
throw
new
NullPointerException
(
msg
)
;
}
if
(
logTag
==
null
)
{
logTag
=
vmName
;
}
if
(
params
==
null
)
{
params
=
new
String
[
0
]
;
}
if
(
!
isVelocimacro
(
vmName
,
logTag
)
)
{
String
msg
=
"RuntimeInstance.invokeVelocimacro() : VM '"
+
vmName
+
"' is not registered."
;
getLog
(
)
.
error
(
msg
)
;
throw
new
VelocityException
(
msg
)
;
}
StrBuilder
template
=
new
StrBuilder
(
"#"
)
;
template
.
append
(
vmName
)
;
template
.
append
(
"("
)
;
for
(
int
i
=
0
;
i
<
params
.
length
;
i
++
)
{
template
.
append
(
" $"
)
;
template
.
append
(
params
[
i
]
)
;
}
template
.
append
(
" )"
)
;
return
evaluate
(
context
,
writer
,
logTag
,
template
.
toString
(
)
)
;
}
private
String
getDefaultEncoding
(
)
{
if
(
encoding
==
null
)
{
encoding
=
getString
(
INPUT_ENCODING
,
ENCODING_DEFAULT
)
;
}
return
encoding
;
}
public
Template
getTemplate
(
String
name
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
return
getTemplate
(
name
,
getDefaultEncoding
(
)
)
;
}
public
Template
getTemplate
(
String
name
,
String
encoding
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
requireInitialization
(
)
;
return
(
Template
)
resourceManager
.
getResource
(
name
,
ResourceManager
.
RESOURCE_TEMPLATE
,
encoding
)
;
}
public
ContentResource
getContent
(
String
name
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
return
getContent
(
name
,
getDefaultEncoding
(
)
)
;
}
public
ContentResource
getContent
(
String
name
,
String
encoding
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
requireInitialization
(
)
;
return
(
ContentResource
)
resourceManager
.
getResource
(
name
,
ResourceManager
.
RESOURCE_CONTENT
,
encoding
)
;
}
public
String
getLoaderNameForResource
(
String
resourceName
)
{
requireInitialization
(
)
;
return
resourceManager
.
getLoaderNameForResource
(
resourceName
)
;
}
public
Log
getLog
(
)
{
return
log
;
}
public
void
warn
(
Object
message
)
{
getLog
(
)
.
warn
(
message
)
;
}
public
void
info
(
Object
message
)
{
getLog
(
)
.
info
(
message
)
;
}
public
void
error
(
Object
message
)
{
getLog
(
)
.
error
(
message
)
;
}
public
void
debug
(
Object
message
)
{
getLog
(
)
.
debug
(
message
)
;
}
public
String
getString
(
String
key
,
String
defaultValue
)
{
return
configuration
.
getString
(
key
,
defaultValue
)
;
}
public
Directive
getVelocimacro
(
String
vmName
,
String
templateName
)
{
return
vmFactory
.
getVelocimacro
(
vmName
,
templateName
)
;
}
public
Directive
getVelocimacro
(
String
vmName
,
String
templateName
,
String
renderingTemplate
)
{
return
vmFactory
.
getVelocimacro
(
vmName
,
templateName
,
renderingTemplate
)
;
}
public
boolean
addVelocimacro
(
String
name
,
String
macro
,
String
argArray
[
]
,
String
sourceTemplate
)
{
return
vmFactory
.
addVelocimacro
(
name
,
macro
,
argArray
,
sourceTemplate
)
;
}
public
boolean
addVelocimacro
(
String
name
,
Node
macro
,
String
argArray
[
]
,
String
sourceTemplate
)
{
return
vmFactory
.
addVelocimacro
(
name
,
macro
,
argArray
,
sourceTemplate
)
;
}
public
boolean
isVelocimacro
(
String
vmName
,
String
templateName
)
{
return
vmFactory
.
isVelocimacro
(
vmName
,
templateName
)
;
}
public
boolean
dumpVMNamespace
(
String
namespace
)
{
return
vmFactory
.
dumpVMNamespace
(
namespace
)
;
}
public
String
getString
(
String
key
)
{
return
StringUtils
.
nullTrim
(
configuration
.
getString
(
key
)
)
;
}
public
int
getInt
(
String
key
)
{
return
configuration
.
getInt
(
key
)
;
}
public
int
getInt
(
String
key
,
int
defaultValue
)
{
return
configuration
.
getInt
(
key
,
defaultValue
)
;
}
public
boolean
getBoolean
(
String
key
,
boolean
def
)
{
return
configuration
.
getBoolean
(
key
,
def
)
;
}
public
ExtendedProperties
getConfiguration
(
)
{
return
configuration
;
}
public
Introspector
getIntrospector
(
)
{
return
introspector
;
}
public
EventCartridge
getApplicationEventCartridge
(
)
{
return
eventCartridge
;
}
public
Object
getApplicationAttribute
(
Object
key
)
{
return
applicationAttributes
.
get
(
key
)
;
}
public
Object
setApplicationAttribute
(
Object
key
,
Object
o
)
{
return
applicationAttributes
.
put
(
key
,
o
)
;
}
public
Uberspect
getUberspect
(
)
{
return
uberSpect
;
}
}
