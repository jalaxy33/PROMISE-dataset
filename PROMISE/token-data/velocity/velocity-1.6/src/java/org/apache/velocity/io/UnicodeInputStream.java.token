package
org
.
apache
.
velocity
.
io
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
PushbackInputStream
;
import
org
.
apache
.
velocity
.
util
.
ExceptionUtils
;
public
class
UnicodeInputStream
extends
InputStream
{
public
static
final
UnicodeBOM
UTF8_BOM
=
new
UnicodeBOM
(
"UTF-8"
,
new
byte
[
]
{
(
byte
)
0xef
,
(
byte
)
0xbb
,
(
byte
)
0xbf
}
)
;
public
static
final
UnicodeBOM
UTF16LE_BOM
=
new
UnicodeBOM
(
"UTF-16LE"
,
new
byte
[
]
{
(
byte
)
0xff
,
(
byte
)
0xfe
}
)
;
public
static
final
UnicodeBOM
UTF16BE_BOM
=
new
UnicodeBOM
(
"UTF-16BE"
,
new
byte
[
]
{
(
byte
)
0xfe
,
(
byte
)
0xff
}
)
;
public
static
final
UnicodeBOM
UTF32LE_BOM
=
new
UnicodeBOM
(
"UTF-32LE"
,
new
byte
[
]
{
(
byte
)
0xff
,
(
byte
)
0xfe
,
(
byte
)
0x00
,
(
byte
)
0x00
}
)
;
public
static
final
UnicodeBOM
UTF32BE_BOM
=
new
UnicodeBOM
(
"UTF-32BE"
,
new
byte
[
]
{
(
byte
)
0x00
,
(
byte
)
0x00
,
(
byte
)
0xfe
,
(
byte
)
0xff
}
)
;
private
static
final
int
MAX_BOM_SIZE
=
4
;
private
byte
[
]
buf
=
new
byte
[
MAX_BOM_SIZE
]
;
private
int
pos
=
0
;
private
final
String
encoding
;
private
final
boolean
skipBOM
;
private
final
PushbackInputStream
inputStream
;
public
UnicodeInputStream
(
final
InputStream
inputStream
)
throws
IllegalStateException
,
IOException
{
this
(
inputStream
,
true
)
;
}
public
UnicodeInputStream
(
final
InputStream
inputStream
,
boolean
skipBOM
)
throws
IllegalStateException
,
IOException
{
super
(
)
;
this
.
skipBOM
=
skipBOM
;
this
.
inputStream
=
new
PushbackInputStream
(
inputStream
,
MAX_BOM_SIZE
)
;
try
{
this
.
encoding
=
readEncoding
(
)
;
}
catch
(
IOException
ioe
)
{
IllegalStateException
ex
=
new
IllegalStateException
(
"Could not read BOM from Stream"
)
;
ExceptionUtils
.
setCause
(
ex
,
ioe
)
;
throw
ex
;
}
}
public
boolean
isSkipBOM
(
)
{
return
skipBOM
;
}
public
String
getEncodingFromStream
(
)
{
return
encoding
;
}
protected
String
readEncoding
(
)
throws
IOException
{
pos
=
0
;
UnicodeBOM
encoding
=
null
;
if
(
readByte
(
)
)
{
switch
(
buf
[
0
]
)
{
case
(
byte
)
0x00
:
encoding
=
match
(
UTF32BE_BOM
,
null
)
;
break
;
case
(
byte
)
0xef
:
encoding
=
match
(
UTF8_BOM
,
null
)
;
break
;
case
(
byte
)
0xfe
:
encoding
=
match
(
UTF16BE_BOM
,
null
)
;
break
;
case
(
byte
)
0xff
:
encoding
=
match
(
UTF16LE_BOM
,
null
)
;
if
(
encoding
!=
null
)
{
encoding
=
match
(
UTF32LE_BOM
,
encoding
)
;
}
break
;
default
:
encoding
=
null
;
break
;
}
}
pushback
(
encoding
)
;
return
(
encoding
!=
null
)
?
encoding
.
getEncoding
(
)
:
null
;
}
private
final
UnicodeBOM
match
(
final
UnicodeBOM
matchEncoding
,
final
UnicodeBOM
noMatchEncoding
)
throws
IOException
{
byte
[
]
bom
=
matchEncoding
.
getBytes
(
)
;
for
(
int
i
=
0
;
i
<
bom
.
length
;
i
++
)
{
if
(
pos
<=
i
)
{
if
(
!
readByte
(
)
)
{
return
noMatchEncoding
;
}
}
if
(
bom
[
i
]
!=
buf
[
i
]
)
{
return
noMatchEncoding
;
}
}
return
matchEncoding
;
}
private
final
boolean
readByte
(
)
throws
IOException
{
int
res
=
inputStream
.
read
(
)
;
if
(
res
==
-
1
)
{
return
false
;
}
if
(
pos
>=
buf
.
length
)
{
throw
new
IOException
(
"BOM read error"
)
;
}
buf
[
pos
++
]
=
(
byte
)
res
;
return
true
;
}
private
final
void
pushback
(
final
UnicodeBOM
matchBOM
)
throws
IOException
{
int
count
=
pos
;
int
start
=
0
;
if
(
matchBOM
!=
null
&&
skipBOM
)
{
start
=
matchBOM
.
getBytes
(
)
.
length
;
count
=
(
pos
-
start
)
;
if
(
count
<
0
)
{
throw
new
IllegalStateException
(
"Match has more bytes than available!"
)
;
}
}
inputStream
.
unread
(
buf
,
start
,
count
)
;
}
public
void
close
(
)
throws
IOException
{
inputStream
.
close
(
)
;
}
public
int
available
(
)
throws
IOException
{
return
inputStream
.
available
(
)
;
}
public
void
mark
(
final
int
readlimit
)
{
inputStream
.
mark
(
readlimit
)
;
}
public
boolean
markSupported
(
)
{
return
inputStream
.
markSupported
(
)
;
}
public
int
read
(
)
throws
IOException
{
return
inputStream
.
read
(
)
;
}
public
int
read
(
final
byte
[
]
b
)
throws
IOException
{
return
inputStream
.
read
(
b
)
;
}
public
int
read
(
final
byte
[
]
b
,
final
int
off
,
final
int
len
)
throws
IOException
{
return
inputStream
.
read
(
b
,
off
,
len
)
;
}
public
void
reset
(
)
throws
IOException
{
inputStream
.
reset
(
)
;
}
public
long
skip
(
final
long
n
)
throws
IOException
{
return
inputStream
.
skip
(
n
)
;
}
static
final
class
UnicodeBOM
{
private
final
String
encoding
;
private
final
byte
[
]
bytes
;
private
UnicodeBOM
(
final
String
encoding
,
final
byte
[
]
bytes
)
{
this
.
encoding
=
encoding
;
this
.
bytes
=
bytes
;
}
String
getEncoding
(
)
{
return
encoding
;
}
byte
[
]
getBytes
(
)
{
return
bytes
;
}
}
}
