package
org
.
apache
.
velocity
.
io
;
import
java
.
io
.
IOException
;
import
java
.
io
.
Writer
;
public
final
class
VelocityWriter
extends
Writer
{
public
static
final
int
NO_BUFFER
=
0
;
public
static
final
int
DEFAULT_BUFFER
=
-
1
;
public
static
final
int
UNBOUNDED_BUFFER
=
-
2
;
private
int
bufferSize
;
private
boolean
autoFlush
;
private
Writer
writer
;
private
char
cb
[
]
;
private
int
nextChar
;
private
static
int
defaultCharBufferSize
=
8
*
1024
;
public
VelocityWriter
(
Writer
writer
)
{
this
(
writer
,
defaultCharBufferSize
,
true
)
;
}
private
VelocityWriter
(
int
bufferSize
,
boolean
autoFlush
)
{
this
.
bufferSize
=
bufferSize
;
this
.
autoFlush
=
autoFlush
;
}
public
int
getBufferSize
(
)
{
return
bufferSize
;
}
public
boolean
isAutoFlush
(
)
{
return
autoFlush
;
}
public
VelocityWriter
(
Writer
writer
,
int
sz
,
boolean
autoFlush
)
{
this
(
sz
,
autoFlush
)
;
if
(
sz
<
0
)
throw
new
IllegalArgumentException
(
"Buffer size <= 0"
)
;
this
.
writer
=
writer
;
cb
=
sz
==
0
?
null
:
new
char
[
sz
]
;
nextChar
=
0
;
}
private
final
void
flushBuffer
(
)
throws
IOException
{
if
(
bufferSize
==
0
)
return
;
if
(
nextChar
==
0
)
return
;
writer
.
write
(
cb
,
0
,
nextChar
)
;
nextChar
=
0
;
}
public
final
void
clear
(
)
{
nextChar
=
0
;
}
private
final
void
bufferOverflow
(
)
throws
IOException
{
throw
new
IOException
(
"overflow"
)
;
}
public
final
void
flush
(
)
throws
IOException
{
flushBuffer
(
)
;
if
(
writer
!=
null
)
{
writer
.
flush
(
)
;
}
}
public
final
void
close
(
)
throws
IOException
{
if
(
writer
==
null
)
return
;
flush
(
)
;
}
public
final
int
getRemaining
(
)
{
return
bufferSize
-
nextChar
;
}
public
final
void
write
(
int
c
)
throws
IOException
{
if
(
bufferSize
==
0
)
{
writer
.
write
(
c
)
;
}
else
{
if
(
nextChar
>=
bufferSize
)
if
(
autoFlush
)
flushBuffer
(
)
;
else
bufferOverflow
(
)
;
cb
[
nextChar
++
]
=
(
char
)
c
;
}
}
private
final
int
min
(
int
a
,
int
b
)
{
return
(
a
<
b
?
a
:
b
)
;
}
public
final
void
write
(
char
cbuf
[
]
,
int
off
,
int
len
)
throws
IOException
{
if
(
bufferSize
==
0
)
{
writer
.
write
(
cbuf
,
off
,
len
)
;
return
;
}
if
(
len
==
0
)
{
return
;
}
if
(
len
>=
bufferSize
)
{
if
(
autoFlush
)
flushBuffer
(
)
;
else
bufferOverflow
(
)
;
writer
.
write
(
cbuf
,
off
,
len
)
;
return
;
}
int
b
=
off
,
t
=
off
+
len
;
while
(
b
<
t
)
{
int
d
=
min
(
bufferSize
-
nextChar
,
t
-
b
)
;
System
.
arraycopy
(
cbuf
,
b
,
cb
,
nextChar
,
d
)
;
b
+=
d
;
nextChar
+=
d
;
if
(
nextChar
>=
bufferSize
)
if
(
autoFlush
)
flushBuffer
(
)
;
else
bufferOverflow
(
)
;
}
}
public
final
void
write
(
char
buf
[
]
)
throws
IOException
{
write
(
buf
,
0
,
buf
.
length
)
;
}
public
final
void
write
(
String
s
,
int
off
,
int
len
)
throws
IOException
{
if
(
bufferSize
==
0
)
{
writer
.
write
(
s
,
off
,
len
)
;
return
;
}
int
b
=
off
,
t
=
off
+
len
;
while
(
b
<
t
)
{
int
d
=
min
(
bufferSize
-
nextChar
,
t
-
b
)
;
s
.
getChars
(
b
,
b
+
d
,
cb
,
nextChar
)
;
b
+=
d
;
nextChar
+=
d
;
if
(
nextChar
>=
bufferSize
)
if
(
autoFlush
)
flushBuffer
(
)
;
else
bufferOverflow
(
)
;
}
}
public
final
void
write
(
String
s
)
throws
IOException
{
if
(
s
!=
null
)
{
write
(
s
,
0
,
s
.
length
(
)
)
;
}
}
public
final
void
recycle
(
Writer
writer
)
{
this
.
writer
=
writer
;
clear
(
)
;
}
}
