package
org
.
apache
.
velocity
.
util
.
introspection
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
lang
.
reflect
.
Modifier
;
import
java
.
util
.
ArrayList
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
List
;
import
java
.
util
.
Map
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
Log
;
public
class
ClassMap
{
private
static
final
boolean
debugReflection
=
false
;
private
final
Log
log
;
private
final
Class
clazz
;
private
final
MethodCache
methodCache
;
public
ClassMap
(
final
Class
clazz
,
final
Log
log
)
{
this
.
clazz
=
clazz
;
this
.
log
=
log
;
if
(
debugReflection
&&
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"================================================================="
)
;
log
.
debug
(
"== Class: "
+
clazz
)
;
}
methodCache
=
new
MethodCache
(
log
)
;
populateMethodCache
(
)
;
if
(
debugReflection
&&
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"================================================================="
)
;
}
}
public
Class
getCachedClass
(
)
{
return
clazz
;
}
public
Method
findMethod
(
final
String
name
,
final
Object
[
]
params
)
throws
MethodMap
.
AmbiguousException
{
return
methodCache
.
get
(
name
,
params
)
;
}
private
void
populateMethodCache
(
)
{
List
classesToReflect
=
new
ArrayList
(
)
;
for
(
Class
classToReflect
=
getCachedClass
(
)
;
classToReflect
!=
null
;
classToReflect
=
classToReflect
.
getSuperclass
(
)
)
{
if
(
Modifier
.
isPublic
(
classToReflect
.
getModifiers
(
)
)
)
{
classesToReflect
.
add
(
classToReflect
)
;
if
(
debugReflection
&&
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Adding "
+
classToReflect
+
" for reflection"
)
;
}
}
Class
[
]
interfaces
=
classToReflect
.
getInterfaces
(
)
;
for
(
int
i
=
0
;
i
<
interfaces
.
length
;
i
++
)
{
if
(
Modifier
.
isPublic
(
interfaces
[
i
]
.
getModifiers
(
)
)
)
{
classesToReflect
.
add
(
interfaces
[
i
]
)
;
if
(
debugReflection
&&
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Adding "
+
interfaces
[
i
]
+
" for reflection"
)
;
}
}
}
}
for
(
Iterator
it
=
classesToReflect
.
iterator
(
)
;
it
.
hasNext
(
)
;
)
{
Class
classToReflect
=
(
Class
)
it
.
next
(
)
;
if
(
debugReflection
&&
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Reflecting "
+
classToReflect
)
;
}
try
{
Method
[
]
methods
=
classToReflect
.
getMethods
(
)
;
for
(
int
i
=
0
;
i
<
methods
.
length
;
i
++
)
{
int
modifiers
=
methods
[
i
]
.
getModifiers
(
)
;
if
(
Modifier
.
isPublic
(
modifiers
)
)
{
if
(
classToReflect
.
isInterface
(
)
||
!
Modifier
.
isAbstract
(
modifiers
)
)
{
methodCache
.
put
(
methods
[
i
]
)
;
}
}
}
}
catch
(
SecurityException
se
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"While accessing methods of "
+
classToReflect
+
": "
,
se
)
;
}
}
}
}
private
static
final
class
MethodCache
{
private
static
final
class
CacheMiss
{
}
private
static
final
CacheMiss
CACHE_MISS
=
new
CacheMiss
(
)
;
private
static
final
Object
OBJECT
=
new
Object
(
)
;
private
static
final
Map
convertPrimitives
=
new
HashMap
(
)
;
static
{
convertPrimitives
.
put
(
Boolean
.
TYPE
,
Boolean
.
class
.
getName
(
)
)
;
convertPrimitives
.
put
(
Byte
.
TYPE
,
Byte
.
class
.
getName
(
)
)
;
convertPrimitives
.
put
(
Character
.
TYPE
,
Character
.
class
.
getName
(
)
)
;
convertPrimitives
.
put
(
Double
.
TYPE
,
Double
.
class
.
getName
(
)
)
;
convertPrimitives
.
put
(
Float
.
TYPE
,
Float
.
class
.
getName
(
)
)
;
convertPrimitives
.
put
(
Integer
.
TYPE
,
Integer
.
class
.
getName
(
)
)
;
convertPrimitives
.
put
(
Long
.
TYPE
,
Long
.
class
.
getName
(
)
)
;
convertPrimitives
.
put
(
Short
.
TYPE
,
Short
.
class
.
getName
(
)
)
;
}
private
final
Log
log
;
private
final
Map
cache
=
new
HashMap
(
)
;
private
final
MethodMap
methodMap
=
new
MethodMap
(
)
;
private
MethodCache
(
Log
log
)
{
this
.
log
=
log
;
}
public
synchronized
Method
get
(
final
String
name
,
final
Object
[
]
params
)
throws
MethodMap
.
AmbiguousException
{
String
methodKey
=
makeMethodKey
(
name
,
params
)
;
Object
cacheEntry
=
cache
.
get
(
methodKey
)
;
if
(
cacheEntry
==
CACHE_MISS
)
{
return
null
;
}
if
(
cacheEntry
==
null
)
{
try
{
cacheEntry
=
methodMap
.
find
(
name
,
params
)
;
}
catch
(
MethodMap
.
AmbiguousException
ae
)
{
cache
.
put
(
methodKey
,
CACHE_MISS
)
;
throw
ae
;
}
cache
.
put
(
methodKey
,
(
cacheEntry
!=
null
)
?
cacheEntry
:
CACHE_MISS
)
;
}
return
(
Method
)
cacheEntry
;
}
public
synchronized
void
put
(
Method
method
)
{
String
methodKey
=
makeMethodKey
(
method
)
;
if
(
cache
.
get
(
methodKey
)
==
null
)
{
cache
.
put
(
methodKey
,
method
)
;
methodMap
.
add
(
method
)
;
if
(
debugReflection
&&
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Adding "
+
method
)
;
}
}
}
private
String
makeMethodKey
(
final
Method
method
)
{
Class
[
]
parameterTypes
=
method
.
getParameterTypes
(
)
;
StringBuffer
methodKey
=
new
StringBuffer
(
method
.
getName
(
)
)
;
for
(
int
j
=
0
;
j
<
parameterTypes
.
length
;
j
++
)
{
if
(
parameterTypes
[
j
]
.
isPrimitive
(
)
)
{
methodKey
.
append
(
(
String
)
convertPrimitives
.
get
(
parameterTypes
[
j
]
)
)
;
}
else
{
methodKey
.
append
(
parameterTypes
[
j
]
.
getName
(
)
)
;
}
}
return
methodKey
.
toString
(
)
;
}
private
String
makeMethodKey
(
String
method
,
Object
[
]
params
)
{
StringBuffer
methodKey
=
new
StringBuffer
(
)
.
append
(
method
)
;
for
(
int
j
=
0
;
j
<
params
.
length
;
j
++
)
{
Object
arg
=
params
[
j
]
;
if
(
arg
==
null
)
{
arg
=
OBJECT
;
}
methodKey
.
append
(
arg
.
getClass
(
)
.
getName
(
)
)
;
}
return
methodKey
.
toString
(
)
;
}
}
}
