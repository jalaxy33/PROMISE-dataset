package
org
.
apache
.
velocity
.
anakia
;
import
java
.
io
.
BufferedWriter
;
import
java
.
io
.
File
;
import
java
.
io
.
FileOutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
Writer
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
LinkedList
;
import
java
.
util
.
List
;
import
java
.
util
.
StringTokenizer
;
import
org
.
apache
.
commons
.
collections
.
ExtendedProperties
;
import
org
.
apache
.
tools
.
ant
.
BuildException
;
import
org
.
apache
.
tools
.
ant
.
DirectoryScanner
;
import
org
.
apache
.
tools
.
ant
.
Project
;
import
org
.
apache
.
tools
.
ant
.
taskdefs
.
MatchingTask
;
import
org
.
apache
.
velocity
.
Template
;
import
org
.
apache
.
velocity
.
VelocityContext
;
import
org
.
apache
.
velocity
.
app
.
VelocityEngine
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeConstants
;
import
org
.
apache
.
velocity
.
util
.
StringUtils
;
import
org
.
jdom
.
Document
;
import
org
.
jdom
.
JDOMException
;
import
org
.
jdom
.
input
.
SAXBuilder
;
import
org
.
jdom
.
output
.
Format
;
import
org
.
xml
.
sax
.
SAXParseException
;
public
class
AnakiaTask
extends
MatchingTask
{
SAXBuilder
builder
;
private
File
destDir
=
null
;
File
baseDir
=
null
;
private
String
style
=
null
;
private
long
styleSheetLastModified
=
0
;
private
String
projectAttribute
=
null
;
private
File
projectFile
=
null
;
private
long
projectFileLastModified
=
0
;
private
boolean
lastModifiedCheck
=
true
;
private
String
extension
=
".html"
;
private
String
templatePath
=
null
;
private
File
velocityPropertiesFile
=
null
;
private
VelocityEngine
ve
=
new
VelocityEngine
(
)
;
private
List
contexts
=
new
LinkedList
(
)
;
public
AnakiaTask
(
)
{
builder
=
new
SAXBuilder
(
)
;
builder
.
setFactory
(
new
AnakiaJDOMFactory
(
)
)
;
}
public
void
setBasedir
(
File
dir
)
{
baseDir
=
dir
;
}
public
void
setDestdir
(
File
dir
)
{
destDir
=
dir
;
}
public
void
setExtension
(
String
extension
)
{
this
.
extension
=
extension
;
}
public
void
setStyle
(
String
style
)
{
this
.
style
=
style
;
}
public
void
setProjectFile
(
String
projectAttribute
)
{
this
.
projectAttribute
=
projectAttribute
;
}
public
void
setTemplatePath
(
File
templatePath
)
{
try
{
this
.
templatePath
=
templatePath
.
getCanonicalPath
(
)
;
}
catch
(
java
.
io
.
IOException
ioe
)
{
throw
new
BuildException
(
ioe
)
;
}
}
public
void
setVelocityPropertiesFile
(
File
velocityPropertiesFile
)
{
this
.
velocityPropertiesFile
=
velocityPropertiesFile
;
}
public
void
setLastModifiedCheck
(
String
lastmod
)
{
if
(
lastmod
.
equalsIgnoreCase
(
"false"
)
||
lastmod
.
equalsIgnoreCase
(
"no"
)
||
lastmod
.
equalsIgnoreCase
(
"off"
)
)
{
this
.
lastModifiedCheck
=
false
;
}
}
public
void
execute
(
)
throws
BuildException
{
DirectoryScanner
scanner
;
String
[
]
list
;
if
(
baseDir
==
null
)
{
baseDir
=
project
.
resolveFile
(
"."
)
;
}
if
(
destDir
==
null
)
{
String
msg
=
"destdir attribute must be set!"
;
throw
new
BuildException
(
msg
)
;
}
if
(
style
==
null
)
{
throw
new
BuildException
(
"style attribute must be set!"
)
;
}
if
(
velocityPropertiesFile
==
null
)
{
velocityPropertiesFile
=
new
File
(
"velocity.properties"
)
;
}
if
(
!
velocityPropertiesFile
.
exists
(
)
&&
templatePath
==
null
)
{
throw
new
BuildException
(
"No template path and could not "
+
"locate velocity.properties file: "
+
velocityPropertiesFile
.
getAbsolutePath
(
)
)
;
}
log
(
"Transforming into: "
+
destDir
.
getAbsolutePath
(
)
,
Project
.
MSG_INFO
)
;
if
(
projectAttribute
!=
null
&&
projectAttribute
.
length
(
)
>
0
)
{
projectFile
=
new
File
(
baseDir
,
projectAttribute
)
;
if
(
projectFile
.
exists
(
)
)
{
projectFileLastModified
=
projectFile
.
lastModified
(
)
;
}
else
{
log
(
"Project file is defined, but could not be located: "
+
projectFile
.
getAbsolutePath
(
)
,
Project
.
MSG_INFO
)
;
projectFile
=
null
;
}
}
Document
projectDocument
=
null
;
try
{
if
(
velocityPropertiesFile
.
exists
(
)
)
{
String
file
=
velocityPropertiesFile
.
getAbsolutePath
(
)
;
ExtendedProperties
config
=
new
ExtendedProperties
(
file
)
;
ve
.
setExtendedProperties
(
config
)
;
}
if
(
templatePath
!=
null
&&
templatePath
.
length
(
)
>
0
)
{
ve
.
setProperty
(
RuntimeConstants
.
FILE_RESOURCE_LOADER_PATH
,
templatePath
)
;
}
ve
.
init
(
)
;
styleSheetLastModified
=
ve
.
getTemplate
(
style
)
.
getLastModified
(
)
;
if
(
projectFile
!=
null
)
{
projectDocument
=
builder
.
build
(
projectFile
)
;
}
}
catch
(
Exception
e
)
{
log
(
"Error: "
+
e
.
toString
(
)
,
Project
.
MSG_INFO
)
;
throw
new
BuildException
(
e
)
;
}
scanner
=
getDirectoryScanner
(
baseDir
)
;
list
=
scanner
.
getIncludedFiles
(
)
;
for
(
int
i
=
0
;
i
<
list
.
length
;
++
i
)
{
process
(
list
[
i
]
,
projectDocument
)
;
}
}
private
void
process
(
String
xmlFile
,
Document
projectDocument
)
throws
BuildException
{
File
outFile
=
null
;
File
inFile
=
null
;
Writer
writer
=
null
;
try
{
inFile
=
new
File
(
baseDir
,
xmlFile
)
;
outFile
=
new
File
(
destDir
,
xmlFile
.
substring
(
0
,
xmlFile
.
lastIndexOf
(
'.'
)
)
+
extension
)
;
if
(
lastModifiedCheck
==
false
||
(
inFile
.
lastModified
(
)
>
outFile
.
lastModified
(
)
||
styleSheetLastModified
>
outFile
.
lastModified
(
)
||
projectFileLastModified
>
outFile
.
lastModified
(
)
||
userContextsModifed
(
outFile
.
lastModified
(
)
)
)
)
{
ensureDirectoryFor
(
outFile
)
;
log
(
"Input:  "
+
xmlFile
,
Project
.
MSG_INFO
)
;
Document
root
=
builder
.
build
(
inFile
)
;
VelocityContext
context
=
new
VelocityContext
(
)
;
String
encoding
=
(
String
)
ve
.
getProperty
(
RuntimeConstants
.
OUTPUT_ENCODING
)
;
if
(
encoding
==
null
||
encoding
.
length
(
)
==
0
||
encoding
.
equals
(
"8859-1"
)
||
encoding
.
equals
(
"8859_1"
)
)
{
encoding
=
"ISO-8859-1"
;
}
Format
f
=
Format
.
getRawFormat
(
)
;
f
.
setEncoding
(
encoding
)
;
OutputWrapper
ow
=
new
OutputWrapper
(
f
)
;
context
.
put
(
"root"
,
root
.
getRootElement
(
)
)
;
context
.
put
(
"xmlout"
,
ow
)
;
context
.
put
(
"relativePath"
,
getRelativePath
(
xmlFile
)
)
;
context
.
put
(
"treeWalk"
,
new
TreeWalker
(
)
)
;
context
.
put
(
"xpath"
,
new
XPathTool
(
)
)
;
context
.
put
(
"escape"
,
new
Escape
(
)
)
;
context
.
put
(
"date"
,
new
java
.
util
.
Date
(
)
)
;
if
(
projectDocument
!=
null
)
{
context
.
put
(
"project"
,
projectDocument
.
getRootElement
(
)
)
;
}
for
(
Iterator
iter
=
contexts
.
iterator
(
)
;
iter
.
hasNext
(
)
;
)
{
Context
subContext
=
(
Context
)
iter
.
next
(
)
;
if
(
subContext
==
null
)
{
throw
new
BuildException
(
"Found an undefined SubContext!"
)
;
}
if
(
subContext
.
getContextDocument
(
)
==
null
)
{
throw
new
BuildException
(
"Could not build a subContext for "
+
subContext
.
getName
(
)
)
;
}
context
.
put
(
subContext
.
getName
(
)
,
subContext
.
getContextDocument
(
)
.
getRootElement
(
)
)
;
}
writer
=
new
BufferedWriter
(
new
OutputStreamWriter
(
new
FileOutputStream
(
outFile
)
,
encoding
)
)
;
Template
template
=
ve
.
getTemplate
(
style
)
;
template
.
merge
(
context
,
writer
)
;
log
(
"Output: "
+
outFile
,
Project
.
MSG_INFO
)
;
}
}
catch
(
JDOMException
e
)
{
outFile
.
delete
(
)
;
if
(
e
.
getCause
(
)
!=
null
)
{
Throwable
rootCause
=
e
.
getCause
(
)
;
if
(
rootCause
instanceof
SAXParseException
)
{
System
.
out
.
println
(
""
)
;
System
.
out
.
println
(
"Error: "
+
rootCause
.
getMessage
(
)
)
;
System
.
out
.
println
(
"       Line: "
+
(
(
SAXParseException
)
rootCause
)
.
getLineNumber
(
)
+
" Column: "
+
(
(
SAXParseException
)
rootCause
)
.
getColumnNumber
(
)
)
;
System
.
out
.
println
(
""
)
;
}
else
{
rootCause
.
printStackTrace
(
)
;
}
}
else
{
e
.
printStackTrace
(
)
;
}
}
catch
(
Throwable
e
)
{
if
(
outFile
!=
null
)
{
outFile
.
delete
(
)
;
}
e
.
printStackTrace
(
)
;
}
finally
{
if
(
writer
!=
null
)
{
try
{
writer
.
flush
(
)
;
}
catch
(
IOException
e
)
{
}
try
{
writer
.
close
(
)
;
}
catch
(
IOException
e
)
{
}
}
}
}
private
String
getRelativePath
(
String
file
)
{
if
(
file
==
null
||
file
.
length
(
)
==
0
)
return
""
;
StringTokenizer
st
=
new
StringTokenizer
(
file
,
"/\\"
)
;
int
slashCount
=
st
.
countTokens
(
)
-
1
;
StringBuffer
sb
=
new
StringBuffer
(
)
;
for
(
int
i
=
0
;
i
<
slashCount
;
i
++
)
{
sb
.
append
(
"../"
)
;
}
if
(
sb
.
toString
(
)
.
length
(
)
>
0
)
{
return
StringUtils
.
chop
(
sb
.
toString
(
)
,
1
)
;
}
return
"."
;
}
private
void
ensureDirectoryFor
(
File
targetFile
)
throws
BuildException
{
File
directory
=
new
File
(
targetFile
.
getParent
(
)
)
;
if
(
!
directory
.
exists
(
)
)
{
if
(
!
directory
.
mkdirs
(
)
)
{
throw
new
BuildException
(
"Unable to create directory: "
+
directory
.
getAbsolutePath
(
)
)
;
}
}
}
private
boolean
userContextsModifed
(
long
lastModified
)
{
for
(
Iterator
iter
=
contexts
.
iterator
(
)
;
iter
.
hasNext
(
)
;
)
{
AnakiaTask
.
Context
ctx
=
(
AnakiaTask
.
Context
)
iter
.
next
(
)
;
if
(
ctx
.
getLastModified
(
)
>
lastModified
)
{
return
true
;
}
}
return
false
;
}
public
Context
createContext
(
)
{
Context
context
=
new
Context
(
)
;
contexts
.
add
(
context
)
;
return
context
;
}
public
class
Context
{
private
String
name
;
private
Document
contextDoc
=
null
;
private
String
file
;
public
Context
(
)
{
}
public
String
getName
(
)
{
return
name
;
}
public
void
setName
(
String
name
)
{
if
(
name
.
equals
(
"relativePath"
)
||
name
.
equals
(
"treeWalk"
)
||
name
.
equals
(
"xpath"
)
||
name
.
equals
(
"escape"
)
||
name
.
equals
(
"date"
)
||
name
.
equals
(
"project"
)
)
{
throw
new
IllegalArgumentException
(
"Context name '"
+
name
+
"' is reserved by Anakia"
)
;
}
this
.
name
=
name
;
}
public
void
setFile
(
String
file
)
{
this
.
file
=
file
;
}
public
long
getLastModified
(
)
{
return
new
File
(
baseDir
,
file
)
.
lastModified
(
)
;
}
public
Document
getContextDocument
(
)
{
if
(
contextDoc
==
null
)
{
File
contextFile
=
new
File
(
baseDir
,
file
)
;
try
{
contextDoc
=
builder
.
build
(
contextFile
)
;
}
catch
(
Exception
e
)
{
throw
new
BuildException
(
e
)
;
}
}
return
contextDoc
;
}
}
}
