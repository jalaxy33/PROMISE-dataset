package
org
.
apache
.
velocity
.
runtime
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
StringReader
;
import
java
.
util
.
Hashtable
;
import
org
.
apache
.
velocity
.
context
.
InternalContextAdapter
;
import
org
.
apache
.
velocity
.
runtime
.
directive
.
VelocimacroProxy
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SimpleNode
;
public
class
VelocimacroManager
{
private
final
RuntimeServices
rsvc
;
private
static
String
GLOBAL_NAMESPACE
=
""
;
private
boolean
registerFromLib
=
false
;
private
final
Hashtable
namespaceHash
=
new
Hashtable
(
)
;
private
final
Hashtable
libraryMap
=
new
Hashtable
(
)
;
private
boolean
namespacesOn
=
true
;
private
boolean
inlineLocalMode
=
false
;
VelocimacroManager
(
RuntimeServices
rsvc
)
{
this
.
rsvc
=
rsvc
;
addNamespace
(
GLOBAL_NAMESPACE
)
;
}
public
boolean
addVM
(
final
String
vmName
,
final
String
macroBody
,
final
String
argArray
[
]
,
final
String
namespace
)
{
MacroEntry
me
=
new
MacroEntry
(
vmName
,
macroBody
,
argArray
,
namespace
)
;
me
.
setFromLibrary
(
registerFromLib
)
;
boolean
isLib
=
true
;
if
(
registerFromLib
)
{
libraryMap
.
put
(
namespace
,
namespace
)
;
}
else
{
isLib
=
libraryMap
.
containsKey
(
namespace
)
;
}
if
(
!
isLib
&&
usingNamespaces
(
namespace
)
)
{
Hashtable
local
=
getNamespace
(
namespace
,
true
)
;
local
.
put
(
vmName
,
me
)
;
return
true
;
}
else
{
MacroEntry
exist
=
(
MacroEntry
)
getNamespace
(
GLOBAL_NAMESPACE
)
.
get
(
vmName
)
;
if
(
exist
!=
null
)
{
me
.
setFromLibrary
(
exist
.
getFromLibrary
(
)
)
;
}
getNamespace
(
GLOBAL_NAMESPACE
)
.
put
(
vmName
,
me
)
;
return
true
;
}
}
public
VelocimacroProxy
get
(
final
String
vmName
,
final
String
namespace
)
{
if
(
usingNamespaces
(
namespace
)
)
{
Hashtable
local
=
getNamespace
(
namespace
,
false
)
;
if
(
local
!=
null
)
{
MacroEntry
me
=
(
MacroEntry
)
local
.
get
(
vmName
)
;
if
(
me
!=
null
)
{
return
me
.
createVelocimacro
(
namespace
)
;
}
}
}
MacroEntry
me
=
(
MacroEntry
)
getNamespace
(
GLOBAL_NAMESPACE
)
.
get
(
vmName
)
;
if
(
me
!=
null
)
{
return
me
.
createVelocimacro
(
namespace
)
;
}
return
null
;
}
public
boolean
dumpNamespace
(
final
String
namespace
)
{
synchronized
(
this
)
{
if
(
usingNamespaces
(
namespace
)
)
{
Hashtable
h
=
(
Hashtable
)
namespaceHash
.
remove
(
namespace
)
;
if
(
h
==
null
)
{
return
false
;
}
h
.
clear
(
)
;
return
true
;
}
return
false
;
}
}
public
void
setNamespaceUsage
(
final
boolean
namespaceOn
)
{
this
.
namespacesOn
=
namespaceOn
;
}
public
void
setRegisterFromLib
(
final
boolean
registerFromLib
)
{
this
.
registerFromLib
=
registerFromLib
;
}
public
void
setTemplateLocalInlineVM
(
final
boolean
inlineLocalMode
)
{
this
.
inlineLocalMode
=
inlineLocalMode
;
}
private
Hashtable
getNamespace
(
final
String
namespace
)
{
return
getNamespace
(
namespace
,
false
)
;
}
private
Hashtable
getNamespace
(
final
String
namespace
,
final
boolean
addIfNew
)
{
Hashtable
h
=
(
Hashtable
)
namespaceHash
.
get
(
namespace
)
;
if
(
h
==
null
&&
addIfNew
)
{
h
=
addNamespace
(
namespace
)
;
}
return
h
;
}
private
Hashtable
addNamespace
(
final
String
namespace
)
{
Hashtable
h
=
new
Hashtable
(
)
;
Object
oh
;
if
(
(
oh
=
namespaceHash
.
put
(
namespace
,
h
)
)
!=
null
)
{
namespaceHash
.
put
(
namespace
,
oh
)
;
return
null
;
}
return
h
;
}
private
boolean
usingNamespaces
(
final
String
namespace
)
{
if
(
!
namespacesOn
)
{
return
false
;
}
if
(
inlineLocalMode
)
{
return
true
;
}
return
false
;
}
public
String
getLibraryName
(
final
String
vmName
,
final
String
namespace
)
{
if
(
usingNamespaces
(
namespace
)
)
{
Hashtable
local
=
getNamespace
(
namespace
,
false
)
;
if
(
local
!=
null
)
{
MacroEntry
me
=
(
MacroEntry
)
local
.
get
(
vmName
)
;
if
(
me
!=
null
)
{
return
null
;
}
}
}
MacroEntry
me
=
(
MacroEntry
)
getNamespace
(
GLOBAL_NAMESPACE
)
.
get
(
vmName
)
;
if
(
me
!=
null
)
{
return
me
.
getSourceTemplate
(
)
;
}
return
null
;
}
private
class
MacroEntry
{
private
final
String
vmName
;
private
final
String
[
]
argArray
;
private
final
String
macroBody
;
private
final
String
sourceTemplate
;
private
SimpleNode
nodeTree
=
null
;
private
boolean
fromLibrary
=
false
;
private
MacroEntry
(
final
String
vmName
,
final
String
macroBody
,
final
String
argArray
[
]
,
final
String
sourceTemplate
)
{
this
.
vmName
=
vmName
;
this
.
argArray
=
argArray
;
this
.
macroBody
=
macroBody
;
this
.
sourceTemplate
=
sourceTemplate
;
}
public
void
setFromLibrary
(
final
boolean
fromLibrary
)
{
this
.
fromLibrary
=
fromLibrary
;
}
public
boolean
getFromLibrary
(
)
{
return
fromLibrary
;
}
public
SimpleNode
getNodeTree
(
)
{
return
nodeTree
;
}
public
String
getSourceTemplate
(
)
{
return
sourceTemplate
;
}
VelocimacroProxy
createVelocimacro
(
final
String
namespace
)
{
VelocimacroProxy
vp
=
new
VelocimacroProxy
(
)
;
vp
.
setName
(
this
.
vmName
)
;
vp
.
setArgArray
(
this
.
argArray
)
;
vp
.
setMacrobody
(
this
.
macroBody
)
;
vp
.
setNodeTree
(
this
.
nodeTree
)
;
vp
.
setNamespace
(
namespace
)
;
return
vp
;
}
void
setup
(
final
InternalContextAdapter
ica
)
{
if
(
nodeTree
==
null
)
{
parseTree
(
ica
)
;
}
}
void
parseTree
(
final
InternalContextAdapter
ica
)
{
try
{
BufferedReader
br
=
new
BufferedReader
(
new
StringReader
(
macroBody
)
)
;
nodeTree
=
rsvc
.
parse
(
br
,
"VM:"
+
vmName
,
true
)
;
nodeTree
.
init
(
ica
,
null
)
;
}
catch
(
Exception
e
)
{
rsvc
.
getLog
(
)
.
error
(
"VelocimacroManager.parseTree() failed on VM '"
+
vmName
+
"'"
,
e
)
;
}
}
}
}
