package
org
.
apache
.
velocity
.
util
.
introspection
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
Collection
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
Iterator
;
import
java
.
util
.
Map
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeLogger
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
Log
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
RuntimeLoggerLog
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
AbstractExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
BooleanPropertyExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
GetExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
MapGetExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
MapSetExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
PropertyExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
PutExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SetExecutor
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SetPropertyExecutor
;
import
org
.
apache
.
velocity
.
util
.
ArrayIterator
;
import
org
.
apache
.
velocity
.
util
.
EnumerationIterator
;
public
class
UberspectImpl
implements
Uberspect
,
UberspectLoggable
{
protected
Log
log
;
protected
Introspector
introspector
;
public
void
init
(
)
{
introspector
=
new
Introspector
(
log
)
;
}
public
void
setLog
(
Log
log
)
{
this
.
log
=
log
;
}
public
void
setRuntimeLogger
(
RuntimeLogger
runtimeLogger
)
{
setLog
(
new
RuntimeLoggerLog
(
runtimeLogger
)
)
;
}
public
Iterator
getIterator
(
Object
obj
,
Info
i
)
throws
Exception
{
if
(
obj
.
getClass
(
)
.
isArray
(
)
)
{
return
new
ArrayIterator
(
obj
)
;
}
else
if
(
obj
instanceof
Collection
)
{
return
(
(
Collection
)
obj
)
.
iterator
(
)
;
}
else
if
(
obj
instanceof
Map
)
{
return
(
(
Map
)
obj
)
.
values
(
)
.
iterator
(
)
;
}
else
if
(
obj
instanceof
Iterator
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"The iterative object in the #foreach() loop at "
+
i
+
" is of type java.util.Iterator.  Because "
+
"it is not resettable, if used in more than once it "
+
"may lead to unexpected results."
)
;
}
return
(
(
Iterator
)
obj
)
;
}
else
if
(
obj
instanceof
Enumeration
)
{
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"The iterative object in the #foreach() loop at "
+
i
+
" is of type java.util.Enumeration.  Because "
+
"it is not resettable, if used in more than once it "
+
"may lead to unexpected results."
)
;
}
return
new
EnumerationIterator
(
(
Enumeration
)
obj
)
;
}
log
.
info
(
"Could not determine type of iterator in #foreach loop at "
+
i
)
;
return
null
;
}
public
VelMethod
getMethod
(
Object
obj
,
String
methodName
,
Object
[
]
args
,
Info
i
)
throws
Exception
{
if
(
obj
==
null
)
{
return
null
;
}
Method
m
=
introspector
.
getMethod
(
obj
.
getClass
(
)
,
methodName
,
args
)
;
return
(
m
!=
null
)
?
new
VelMethodImpl
(
m
)
:
null
;
}
public
VelPropertyGet
getPropertyGet
(
Object
obj
,
String
identifier
,
Info
i
)
throws
Exception
{
if
(
obj
==
null
)
{
return
null
;
}
Class
claz
=
obj
.
getClass
(
)
;
AbstractExecutor
executor
=
new
PropertyExecutor
(
log
,
introspector
,
claz
,
identifier
)
;
if
(
!
executor
.
isAlive
(
)
)
{
executor
=
new
MapGetExecutor
(
log
,
claz
,
identifier
)
;
}
if
(
!
executor
.
isAlive
(
)
)
{
executor
=
new
GetExecutor
(
log
,
introspector
,
claz
,
identifier
)
;
}
if
(
!
executor
.
isAlive
(
)
)
{
executor
=
new
BooleanPropertyExecutor
(
log
,
introspector
,
claz
,
identifier
)
;
}
return
(
executor
.
isAlive
(
)
)
?
new
VelGetterImpl
(
executor
)
:
null
;
}
public
VelPropertySet
getPropertySet
(
Object
obj
,
String
identifier
,
Object
arg
,
Info
i
)
throws
Exception
{
if
(
obj
==
null
)
{
return
null
;
}
Class
claz
=
obj
.
getClass
(
)
;
SetExecutor
executor
=
new
SetPropertyExecutor
(
log
,
introspector
,
claz
,
identifier
,
arg
)
;
if
(
!
executor
.
isAlive
(
)
)
{
executor
=
new
MapSetExecutor
(
log
,
claz
,
identifier
)
;
}
if
(
!
executor
.
isAlive
(
)
)
{
executor
=
new
PutExecutor
(
log
,
introspector
,
claz
,
arg
,
identifier
)
;
}
return
(
executor
.
isAlive
(
)
)
?
new
VelSetterImpl
(
executor
)
:
null
;
}
public
static
class
VelMethodImpl
implements
VelMethod
{
final
Method
method
;
public
VelMethodImpl
(
Method
m
)
{
method
=
m
;
}
private
VelMethodImpl
(
)
{
method
=
null
;
}
public
Object
invoke
(
Object
o
,
Object
[
]
params
)
throws
Exception
{
return
method
.
invoke
(
o
,
params
)
;
}
public
boolean
isCacheable
(
)
{
return
true
;
}
public
String
getMethodName
(
)
{
return
method
.
getName
(
)
;
}
public
Class
getReturnType
(
)
{
return
method
.
getReturnType
(
)
;
}
}
public
static
class
VelGetterImpl
implements
VelPropertyGet
{
final
AbstractExecutor
getExecutor
;
public
VelGetterImpl
(
AbstractExecutor
exec
)
{
getExecutor
=
exec
;
}
private
VelGetterImpl
(
)
{
getExecutor
=
null
;
}
public
Object
invoke
(
Object
o
)
throws
Exception
{
return
getExecutor
.
execute
(
o
)
;
}
public
boolean
isCacheable
(
)
{
return
true
;
}
public
String
getMethodName
(
)
{
return
getExecutor
.
isAlive
(
)
?
getExecutor
.
getMethod
(
)
.
getName
(
)
:
null
;
}
}
public
static
class
VelSetterImpl
implements
VelPropertySet
{
private
final
SetExecutor
setExecutor
;
public
VelSetterImpl
(
final
SetExecutor
setExecutor
)
{
this
.
setExecutor
=
setExecutor
;
}
private
VelSetterImpl
(
)
{
setExecutor
=
null
;
}
public
Object
invoke
(
final
Object
o
,
final
Object
value
)
throws
Exception
{
return
setExecutor
.
execute
(
o
,
value
)
;
}
public
boolean
isCacheable
(
)
{
return
true
;
}
public
String
getMethodName
(
)
{
return
setExecutor
.
isAlive
(
)
?
setExecutor
.
getMethod
(
)
.
getName
(
)
:
null
;
}
}
}
