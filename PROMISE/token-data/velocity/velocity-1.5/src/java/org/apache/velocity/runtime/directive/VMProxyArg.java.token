package
org
.
apache
.
velocity
.
runtime
.
directive
;
import
java
.
io
.
BufferedReader
;
import
java
.
io
.
StringReader
;
import
java
.
io
.
StringWriter
;
import
org
.
apache
.
velocity
.
VelocityContext
;
import
org
.
apache
.
velocity
.
context
.
InternalContextAdapter
;
import
org
.
apache
.
velocity
.
context
.
InternalContextAdapterImpl
;
import
org
.
apache
.
velocity
.
exception
.
MethodInvocationException
;
import
org
.
apache
.
velocity
.
runtime
.
RuntimeServices
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
Log
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
ParserTreeConstants
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
ASTReference
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SimpleNode
;
public
class
VMProxyArg
{
private
static
final
int
GENERALSTATIC
=
-
1
;
private
int
type
=
0
;
private
SimpleNode
nodeTree
=
null
;
private
Object
staticObject
=
null
;
private
int
numTreeChildren
=
0
;
private
String
contextReference
=
null
;
private
String
callerReference
=
null
;
private
String
singleLevelRef
=
null
;
private
boolean
constant
=
false
;
private
RuntimeServices
rsvc
=
null
;
private
Log
log
=
null
;
public
VMProxyArg
(
RuntimeServices
rs
,
String
contextRef
,
String
callerRef
,
int
t
)
{
rsvc
=
rs
;
log
=
rsvc
.
getLog
(
)
;
contextReference
=
contextRef
;
callerReference
=
callerRef
;
type
=
t
;
setup
(
)
;
if
(
nodeTree
!=
null
)
{
numTreeChildren
=
nodeTree
.
jjtGetNumChildren
(
)
;
}
if
(
type
==
ParserTreeConstants
.
JJTREFERENCE
)
{
if
(
numTreeChildren
==
0
)
{
singleLevelRef
=
(
(
ASTReference
)
nodeTree
)
.
getRootString
(
)
;
}
}
}
public
boolean
isConstant
(
)
{
return
constant
;
}
public
Object
setObject
(
InternalContextAdapter
context
,
Object
o
)
{
if
(
type
==
ParserTreeConstants
.
JJTREFERENCE
)
{
if
(
numTreeChildren
>
0
)
{
try
{
(
(
ASTReference
)
nodeTree
)
.
setValue
(
context
,
o
)
;
}
catch
(
MethodInvocationException
mie
)
{
log
.
error
(
"VMProxyArg.getObject() : method invocation error setting value"
,
mie
)
;
}
}
else
{
context
.
put
(
singleLevelRef
,
o
)
;
}
}
else
{
type
=
GENERALSTATIC
;
staticObject
=
o
;
log
.
error
(
"VMProxyArg.setObject() : Programmer error : I am a constant!  No setting! : "
+
contextReference
+
" / "
+
callerReference
)
;
}
return
null
;
}
public
Object
getObject
(
InternalContextAdapter
context
)
throws
MethodInvocationException
{
try
{
Object
retObject
=
null
;
if
(
type
==
ParserTreeConstants
.
JJTREFERENCE
)
{
if
(
numTreeChildren
==
0
)
{
retObject
=
context
.
get
(
singleLevelRef
)
;
}
else
{
retObject
=
nodeTree
.
execute
(
null
,
context
)
;
}
}
else
if
(
type
==
ParserTreeConstants
.
JJTMAP
)
{
retObject
=
nodeTree
.
value
(
context
)
;
}
else
if
(
type
==
ParserTreeConstants
.
JJTOBJECTARRAY
)
{
retObject
=
nodeTree
.
value
(
context
)
;
}
else
if
(
type
==
ParserTreeConstants
.
JJTINTEGERRANGE
)
{
retObject
=
nodeTree
.
value
(
context
)
;
}
else
if
(
type
==
ParserTreeConstants
.
JJTTRUE
)
{
retObject
=
staticObject
;
}
else
if
(
type
==
ParserTreeConstants
.
JJTFALSE
)
{
retObject
=
staticObject
;
}
else
if
(
type
==
ParserTreeConstants
.
JJTSTRINGLITERAL
)
{
retObject
=
nodeTree
.
value
(
context
)
;
}
else
if
(
type
==
ParserTreeConstants
.
JJTINTEGERLITERAL
)
{
retObject
=
staticObject
;
}
else
if
(
type
==
ParserTreeConstants
.
JJTFLOATINGPOINTLITERAL
)
{
retObject
=
staticObject
;
}
else
if
(
type
==
ParserTreeConstants
.
JJTTEXT
)
{
try
{
StringWriter
writer
=
new
StringWriter
(
)
;
nodeTree
.
render
(
context
,
writer
)
;
retObject
=
writer
;
}
catch
(
RuntimeException
e
)
{
throw
e
;
}
catch
(
Exception
e
)
{
log
.
error
(
"VMProxyArg.getObject() : error rendering reference"
,
e
)
;
}
}
else
if
(
type
==
GENERALSTATIC
)
{
retObject
=
staticObject
;
}
else
{
log
.
error
(
"Unsupported VM arg type : VM arg = "
+
callerReference
+
" type = "
+
type
+
"( VMProxyArg.getObject() )"
)
;
}
return
retObject
;
}
catch
(
MethodInvocationException
mie
)
{
log
.
error
(
"VMProxyArg.getObject() : method invocation error getting value"
,
mie
)
;
throw
mie
;
}
}
private
void
setup
(
)
{
switch
(
type
)
{
case
ParserTreeConstants
.
JJTINTEGERRANGE
:
case
ParserTreeConstants
.
JJTREFERENCE
:
case
ParserTreeConstants
.
JJTOBJECTARRAY
:
case
ParserTreeConstants
.
JJTMAP
:
case
ParserTreeConstants
.
JJTSTRINGLITERAL
:
case
ParserTreeConstants
.
JJTTEXT
:
{
constant
=
false
;
try
{
String
buff
=
"#include("
+
callerReference
+
" ) "
;
BufferedReader
br
=
new
BufferedReader
(
new
StringReader
(
buff
)
)
;
nodeTree
=
rsvc
.
parse
(
br
,
"VMProxyArg:"
+
callerReference
,
true
)
;
nodeTree
=
(
SimpleNode
)
nodeTree
.
jjtGetChild
(
0
)
.
jjtGetChild
(
0
)
;
if
(
nodeTree
!=
null
)
{
if
(
nodeTree
.
getType
(
)
!=
type
)
{
log
.
error
(
"VMProxyArg.setup() : programmer error : type doesn't match node type."
)
;
}
InternalContextAdapter
ica
=
new
InternalContextAdapterImpl
(
new
VelocityContext
(
)
)
;
ica
.
pushCurrentTemplateName
(
"VMProxyArg : "
+
ParserTreeConstants
.
jjtNodeName
[
type
]
)
;
nodeTree
.
init
(
ica
,
rsvc
)
;
}
}
catch
(
RuntimeException
e
)
{
throw
e
;
}
catch
(
Exception
e
)
{
log
.
error
(
"VMProxyArg.setup() : exception "
+
callerReference
,
e
)
;
}
break
;
}
case
ParserTreeConstants
.
JJTTRUE
:
{
constant
=
true
;
staticObject
=
Boolean
.
TRUE
;
break
;
}
case
ParserTreeConstants
.
JJTFALSE
:
{
constant
=
true
;
staticObject
=
Boolean
.
FALSE
;
break
;
}
case
ParserTreeConstants
.
JJTINTEGERLITERAL
:
{
constant
=
true
;
staticObject
=
new
Integer
(
callerReference
)
;
break
;
}
case
ParserTreeConstants
.
JJTFLOATINGPOINTLITERAL
:
{
constant
=
true
;
staticObject
=
new
Double
(
callerReference
)
;
break
;
}
case
ParserTreeConstants
.
JJTWORD
:
{
log
.
error
(
"Unsupported arg type : "
+
callerReference
+
" You most likely intended to call a VM with a string literal, so enclose with ' or \" characters. (VMProxyArg.setup())"
)
;
constant
=
true
;
staticObject
=
callerReference
;
break
;
}
default
:
{
log
.
error
(
"VMProxyArg.setup() : unsupported type : "
+
callerReference
)
;
}
}
}
public
VMProxyArg
(
VMProxyArg
model
,
InternalContextAdapter
c
)
{
contextReference
=
model
.
getContextReference
(
)
;
callerReference
=
model
.
getCallerReference
(
)
;
nodeTree
=
model
.
getNodeTree
(
)
;
staticObject
=
model
.
getStaticObject
(
)
;
type
=
model
.
getType
(
)
;
if
(
nodeTree
!=
null
)
numTreeChildren
=
nodeTree
.
jjtGetNumChildren
(
)
;
if
(
type
==
ParserTreeConstants
.
JJTREFERENCE
)
{
if
(
numTreeChildren
==
0
)
{
singleLevelRef
=
(
(
ASTReference
)
nodeTree
)
.
getRootString
(
)
;
}
}
}
public
String
getCallerReference
(
)
{
return
callerReference
;
}
public
String
getContextReference
(
)
{
return
contextReference
;
}
public
SimpleNode
getNodeTree
(
)
{
return
nodeTree
;
}
public
Object
getStaticObject
(
)
{
return
staticObject
;
}
public
int
getType
(
)
{
return
type
;
}
}
