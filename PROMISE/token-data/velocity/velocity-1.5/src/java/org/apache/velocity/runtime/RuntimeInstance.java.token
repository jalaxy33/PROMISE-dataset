package
org
.
apache
.
velocity
.
runtime
;
import
java
.
io
.
File
;
import
java
.
io
.
IOException
;
import
java
.
io
.
InputStream
;
import
java
.
io
.
Reader
;
import
java
.
util
.
Enumeration
;
import
java
.
util
.
HashMap
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Map
;
import
java
.
util
.
Properties
;
import
org
.
apache
.
commons
.
collections
.
ExtendedProperties
;
import
org
.
apache
.
velocity
.
Template
;
import
org
.
apache
.
velocity
.
app
.
event
.
EventCartridge
;
import
org
.
apache
.
velocity
.
app
.
event
.
EventHandler
;
import
org
.
apache
.
velocity
.
app
.
event
.
IncludeEventHandler
;
import
org
.
apache
.
velocity
.
app
.
event
.
InvalidReferenceEventHandler
;
import
org
.
apache
.
velocity
.
app
.
event
.
MethodExceptionEventHandler
;
import
org
.
apache
.
velocity
.
app
.
event
.
NullSetEventHandler
;
import
org
.
apache
.
velocity
.
app
.
event
.
ReferenceInsertionEventHandler
;
import
org
.
apache
.
velocity
.
exception
.
ParseErrorException
;
import
org
.
apache
.
velocity
.
exception
.
ResourceNotFoundException
;
import
org
.
apache
.
velocity
.
runtime
.
directive
.
Directive
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
Log
;
import
org
.
apache
.
velocity
.
runtime
.
log
.
LogManager
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
ParseException
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
Parser
;
import
org
.
apache
.
velocity
.
runtime
.
parser
.
node
.
SimpleNode
;
import
org
.
apache
.
velocity
.
runtime
.
resource
.
ContentResource
;
import
org
.
apache
.
velocity
.
runtime
.
resource
.
ResourceManager
;
import
org
.
apache
.
velocity
.
util
.
ClassUtils
;
import
org
.
apache
.
velocity
.
util
.
RuntimeServicesAware
;
import
org
.
apache
.
velocity
.
util
.
StringUtils
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
Introspector
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
Uberspect
;
import
org
.
apache
.
velocity
.
util
.
introspection
.
UberspectLoggable
;
public
class
RuntimeInstance
implements
RuntimeConstants
,
RuntimeServices
{
private
VelocimacroFactory
vmFactory
=
null
;
private
Log
log
=
new
Log
(
)
;
private
ParserPool
parserPool
;
private
boolean
initializing
=
false
;
private
boolean
initialized
=
false
;
private
ExtendedProperties
overridingProperties
=
null
;
private
Hashtable
runtimeDirectives
;
private
ExtendedProperties
configuration
=
new
ExtendedProperties
(
)
;
private
ResourceManager
resourceManager
=
null
;
private
EventCartridge
eventCartridge
=
null
;
private
Introspector
introspector
=
null
;
private
Map
applicationAttributes
=
null
;
private
Uberspect
uberSpect
;
public
RuntimeInstance
(
)
{
vmFactory
=
new
VelocimacroFactory
(
this
)
;
introspector
=
new
Introspector
(
getLog
(
)
)
;
applicationAttributes
=
new
HashMap
(
)
;
}
public
synchronized
void
init
(
)
throws
Exception
{
if
(
!
initialized
&&
!
initializing
)
{
initializing
=
true
;
log
.
trace
(
"*******************************************************************"
)
;
log
.
debug
(
"Starting Apache Velocity v@build.version@ (compiled: @build.time@)"
)
;
log
.
trace
(
"RuntimeInstance initializing."
)
;
initializeProperties
(
)
;
initializeLog
(
)
;
initializeResourceManager
(
)
;
initializeDirectives
(
)
;
initializeEventHandlers
(
)
;
initializeParserPool
(
)
;
initializeIntrospection
(
)
;
vmFactory
.
initVelocimacro
(
)
;
log
.
trace
(
"RuntimeInstance successfully initialized."
)
;
initialized
=
true
;
initializing
=
false
;
}
}
public
boolean
isInitialized
(
)
{
return
initialized
;
}
private
void
initializeIntrospection
(
)
throws
Exception
{
String
rm
=
getString
(
RuntimeConstants
.
UBERSPECT_CLASSNAME
)
;
if
(
rm
!=
null
&&
rm
.
length
(
)
>
0
)
{
Object
o
=
null
;
try
{
o
=
ClassUtils
.
getNewInstance
(
rm
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
String
err
=
"The specified class for Uberspect ("
+
rm
+
") does not exist or is not accessible to the current classloader."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
if
(
!
(
o
instanceof
Uberspect
)
)
{
String
err
=
"The specified class for Uberspect ("
+
rm
+
") does not implement "
+
Uberspect
.
class
.
getName
(
)
+
"; Velocity is not initialized correctly."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
uberSpect
=
(
Uberspect
)
o
;
if
(
uberSpect
instanceof
UberspectLoggable
)
{
(
(
UberspectLoggable
)
uberSpect
)
.
setLog
(
getLog
(
)
)
;
}
if
(
uberSpect
instanceof
RuntimeServicesAware
)
{
(
(
RuntimeServicesAware
)
uberSpect
)
.
setRuntimeServices
(
this
)
;
}
uberSpect
.
init
(
)
;
}
else
{
String
err
=
"It appears that no class was specified as the"
+
" Uberspect.  Please ensure that all configuration"
+
" information is correct."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
}
private
void
setDefaultProperties
(
)
{
InputStream
inputStream
=
null
;
try
{
inputStream
=
getClass
(
)
.
getResourceAsStream
(
'/'
+
DEFAULT_RUNTIME_PROPERTIES
)
;
configuration
.
load
(
inputStream
)
;
if
(
log
.
isDebugEnabled
(
)
)
{
log
.
debug
(
"Default Properties File: "
+
new
File
(
DEFAULT_RUNTIME_PROPERTIES
)
.
getPath
(
)
)
;
}
}
catch
(
IOException
ioe
)
{
log
.
error
(
"Cannot get Velocity Runtime default properties!"
,
ioe
)
;
}
finally
{
try
{
if
(
inputStream
!=
null
)
{
inputStream
.
close
(
)
;
}
}
catch
(
IOException
ioe
)
{
log
.
error
(
"Cannot close Velocity Runtime default properties!"
,
ioe
)
;
}
}
}
public
void
setProperty
(
String
key
,
Object
value
)
{
if
(
overridingProperties
==
null
)
{
overridingProperties
=
new
ExtendedProperties
(
)
;
}
overridingProperties
.
setProperty
(
key
,
value
)
;
}
public
void
setConfiguration
(
ExtendedProperties
configuration
)
{
if
(
overridingProperties
==
null
)
{
overridingProperties
=
configuration
;
}
else
{
if
(
overridingProperties
!=
configuration
)
{
overridingProperties
.
combine
(
configuration
)
;
}
}
}
public
void
addProperty
(
String
key
,
Object
value
)
{
if
(
overridingProperties
==
null
)
{
overridingProperties
=
new
ExtendedProperties
(
)
;
}
overridingProperties
.
addProperty
(
key
,
value
)
;
}
public
void
clearProperty
(
String
key
)
{
if
(
overridingProperties
!=
null
)
{
overridingProperties
.
clearProperty
(
key
)
;
}
}
public
Object
getProperty
(
String
key
)
{
Object
o
=
null
;
if
(
!
initialized
&&
!
initializing
&&
overridingProperties
!=
null
)
{
o
=
overridingProperties
.
get
(
key
)
;
}
if
(
o
==
null
)
{
o
=
configuration
.
getProperty
(
key
)
;
}
if
(
o
instanceof
String
)
{
return
StringUtils
.
nullTrim
(
(
String
)
o
)
;
}
else
{
return
o
;
}
}
private
void
initializeProperties
(
)
{
if
(
configuration
.
isInitialized
(
)
==
false
)
{
setDefaultProperties
(
)
;
}
if
(
overridingProperties
!=
null
)
{
configuration
.
combine
(
overridingProperties
)
;
}
}
public
void
init
(
Properties
p
)
throws
Exception
{
overridingProperties
=
ExtendedProperties
.
convertProperties
(
p
)
;
init
(
)
;
}
public
void
init
(
String
configurationFile
)
throws
Exception
{
overridingProperties
=
new
ExtendedProperties
(
configurationFile
)
;
init
(
)
;
}
private
void
initializeResourceManager
(
)
throws
Exception
{
String
rm
=
getString
(
RuntimeConstants
.
RESOURCE_MANAGER_CLASS
)
;
if
(
rm
!=
null
&&
rm
.
length
(
)
>
0
)
{
Object
o
=
null
;
try
{
o
=
ClassUtils
.
getNewInstance
(
rm
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
String
err
=
"The specified class for ResourceManager ("
+
rm
+
") does not exist or is not accessible to the current classloader."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
if
(
!
(
o
instanceof
ResourceManager
)
)
{
String
err
=
"The specified class for ResourceManager ("
+
rm
+
") does not implement "
+
ResourceManager
.
class
.
getName
(
)
+
"; Velocity is not initialized correctly."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
resourceManager
=
(
ResourceManager
)
o
;
resourceManager
.
initialize
(
this
)
;
}
else
{
String
err
=
"It appears that no class was specified as the"
+
" ResourceManager.  Please ensure that all configuration"
+
" information is correct."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
}
private
void
initializeEventHandlers
(
)
throws
Exception
{
eventCartridge
=
new
EventCartridge
(
)
;
String
[
]
referenceinsertion
=
configuration
.
getStringArray
(
RuntimeConstants
.
EVENTHANDLER_REFERENCEINSERTION
)
;
if
(
referenceinsertion
!=
null
)
{
for
(
int
i
=
0
;
i
<
referenceinsertion
.
length
;
i
++
)
{
EventHandler
ev
=
initializeSpecificEventHandler
(
referenceinsertion
[
i
]
,
RuntimeConstants
.
EVENTHANDLER_REFERENCEINSERTION
,
ReferenceInsertionEventHandler
.
class
)
;
if
(
ev
!=
null
)
eventCartridge
.
addReferenceInsertionEventHandler
(
(
ReferenceInsertionEventHandler
)
ev
)
;
}
}
String
[
]
nullset
=
configuration
.
getStringArray
(
RuntimeConstants
.
EVENTHANDLER_NULLSET
)
;
if
(
nullset
!=
null
)
{
for
(
int
i
=
0
;
i
<
nullset
.
length
;
i
++
)
{
EventHandler
ev
=
initializeSpecificEventHandler
(
nullset
[
i
]
,
RuntimeConstants
.
EVENTHANDLER_NULLSET
,
NullSetEventHandler
.
class
)
;
if
(
ev
!=
null
)
eventCartridge
.
addNullSetEventHandler
(
(
NullSetEventHandler
)
ev
)
;
}
}
String
[
]
methodexception
=
configuration
.
getStringArray
(
RuntimeConstants
.
EVENTHANDLER_METHODEXCEPTION
)
;
if
(
methodexception
!=
null
)
{
for
(
int
i
=
0
;
i
<
methodexception
.
length
;
i
++
)
{
EventHandler
ev
=
initializeSpecificEventHandler
(
methodexception
[
i
]
,
RuntimeConstants
.
EVENTHANDLER_METHODEXCEPTION
,
MethodExceptionEventHandler
.
class
)
;
if
(
ev
!=
null
)
eventCartridge
.
addMethodExceptionHandler
(
(
MethodExceptionEventHandler
)
ev
)
;
}
}
String
[
]
includeHandler
=
configuration
.
getStringArray
(
RuntimeConstants
.
EVENTHANDLER_INCLUDE
)
;
if
(
includeHandler
!=
null
)
{
for
(
int
i
=
0
;
i
<
includeHandler
.
length
;
i
++
)
{
EventHandler
ev
=
initializeSpecificEventHandler
(
includeHandler
[
i
]
,
RuntimeConstants
.
EVENTHANDLER_INCLUDE
,
IncludeEventHandler
.
class
)
;
if
(
ev
!=
null
)
eventCartridge
.
addIncludeEventHandler
(
(
IncludeEventHandler
)
ev
)
;
}
}
String
[
]
invalidReferenceSet
=
configuration
.
getStringArray
(
RuntimeConstants
.
EVENTHANDLER_INVALIDREFERENCES
)
;
if
(
invalidReferenceSet
!=
null
)
{
for
(
int
i
=
0
;
i
<
invalidReferenceSet
.
length
;
i
++
)
{
EventHandler
ev
=
initializeSpecificEventHandler
(
invalidReferenceSet
[
i
]
,
RuntimeConstants
.
EVENTHANDLER_INVALIDREFERENCES
,
InvalidReferenceEventHandler
.
class
)
;
if
(
ev
!=
null
)
{
eventCartridge
.
addInvalidReferenceEventHandler
(
(
InvalidReferenceEventHandler
)
ev
)
;
}
}
}
}
private
EventHandler
initializeSpecificEventHandler
(
String
classname
,
String
paramName
,
Class
EventHandlerInterface
)
throws
Exception
{
if
(
classname
!=
null
&&
classname
.
length
(
)
>
0
)
{
Object
o
=
null
;
try
{
o
=
ClassUtils
.
getNewInstance
(
classname
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
String
err
=
"The specified class for "
+
paramName
+
" ("
+
classname
+
") does not exist or is not accessible to the current classloader."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
if
(
!
EventHandlerInterface
.
isAssignableFrom
(
EventHandlerInterface
)
)
{
String
err
=
"The specified class for "
+
paramName
+
" ("
+
classname
+
") does not implement "
+
EventHandlerInterface
.
getName
(
)
+
"; Velocity is not initialized correctly."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
EventHandler
ev
=
(
EventHandler
)
o
;
if
(
ev
instanceof
RuntimeServicesAware
)
(
(
RuntimeServicesAware
)
ev
)
.
setRuntimeServices
(
this
)
;
return
ev
;
}
else
return
null
;
}
private
void
initializeLog
(
)
throws
Exception
{
LogManager
.
updateLog
(
this
.
log
,
this
)
;
}
private
void
initializeDirectives
(
)
throws
Exception
{
runtimeDirectives
=
new
Hashtable
(
)
;
Properties
directiveProperties
=
new
Properties
(
)
;
InputStream
inputStream
=
null
;
try
{
inputStream
=
getClass
(
)
.
getResourceAsStream
(
'/'
+
DEFAULT_RUNTIME_DIRECTIVES
)
;
if
(
inputStream
==
null
)
{
throw
new
Exception
(
"Error loading directive.properties! "
+
"Something is very wrong if these properties "
+
"aren't being located. Either your Velocity "
+
"distribution is incomplete or your Velocity "
+
"jar file is corrupted!"
)
;
}
directiveProperties
.
load
(
inputStream
)
;
}
catch
(
IOException
ioe
)
{
log
.
error
(
"Error while loading directive properties!"
,
ioe
)
;
}
finally
{
try
{
if
(
inputStream
!=
null
)
{
inputStream
.
close
(
)
;
}
}
catch
(
IOException
ioe
)
{
log
.
error
(
"Cannot close directive properties!"
,
ioe
)
;
}
}
Enumeration
directiveClasses
=
directiveProperties
.
elements
(
)
;
while
(
directiveClasses
.
hasMoreElements
(
)
)
{
String
directiveClass
=
(
String
)
directiveClasses
.
nextElement
(
)
;
loadDirective
(
directiveClass
)
;
log
.
debug
(
"Loaded System Directive: "
+
directiveClass
)
;
}
String
[
]
userdirective
=
configuration
.
getStringArray
(
"userdirective"
)
;
for
(
int
i
=
0
;
i
<
userdirective
.
length
;
i
++
)
{
loadDirective
(
userdirective
[
i
]
)
;
if
(
log
.
isInfoEnabled
(
)
)
{
log
.
info
(
"Loaded User Directive: "
+
userdirective
[
i
]
)
;
}
}
}
private
void
loadDirective
(
String
directiveClass
)
{
try
{
Object
o
=
ClassUtils
.
getNewInstance
(
directiveClass
)
;
if
(
o
instanceof
Directive
)
{
Directive
directive
=
(
Directive
)
o
;
runtimeDirectives
.
put
(
directive
.
getName
(
)
,
directive
)
;
}
else
{
log
.
error
(
directiveClass
+
" does not implement "
+
Directive
.
class
.
getName
(
)
+
"; it cannot be loaded."
)
;
}
}
catch
(
Exception
e
)
{
log
.
error
(
"Failed to load Directive: "
+
directiveClass
,
e
)
;
}
}
private
void
initializeParserPool
(
)
throws
Exception
{
String
pp
=
getString
(
RuntimeConstants
.
PARSER_POOL_CLASS
)
;
if
(
pp
!=
null
&&
pp
.
length
(
)
>
0
)
{
Object
o
=
null
;
try
{
o
=
ClassUtils
.
getNewInstance
(
pp
)
;
}
catch
(
ClassNotFoundException
cnfe
)
{
String
err
=
"The specified class for ParserPool ("
+
pp
+
") does not exist (or is not accessible to the current classloader."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
if
(
!
(
o
instanceof
ParserPool
)
)
{
String
err
=
"The specified class for ParserPool ("
+
pp
+
") does not implement "
+
ParserPool
.
class
+
" Velocity not initialized correctly."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
parserPool
=
(
ParserPool
)
o
;
parserPool
.
initialize
(
this
)
;
}
else
{
String
err
=
"It appears that no class was specified as the"
+
" ParserPool.  Please ensure that all configuration"
+
" information is correct."
;
log
.
error
(
err
)
;
throw
new
Exception
(
err
)
;
}
}
public
Parser
createNewParser
(
)
{
if
(
!
initialized
&&
!
initializing
)
{
log
.
debug
(
"Velocity was not initialized! Calling init()..."
)
;
try
{
init
(
)
;
}
catch
(
Exception
e
)
{
getLog
(
)
.
error
(
"Could not auto-initialize Velocity"
,
e
)
;
throw
new
IllegalStateException
(
"Velocity could not be initialized!"
)
;
}
}
Parser
parser
=
new
Parser
(
this
)
;
parser
.
setDirectives
(
runtimeDirectives
)
;
return
parser
;
}
public
SimpleNode
parse
(
Reader
reader
,
String
templateName
)
throws
ParseException
{
return
parse
(
reader
,
templateName
,
true
)
;
}
public
SimpleNode
parse
(
Reader
reader
,
String
templateName
,
boolean
dumpNamespace
)
throws
ParseException
{
if
(
!
initialized
&&
!
initializing
)
{
log
.
debug
(
"Velocity was not initialized! Calling init()..."
)
;
try
{
init
(
)
;
}
catch
(
Exception
e
)
{
getLog
(
)
.
error
(
"Could not auto-initialize Velocity"
,
e
)
;
throw
new
IllegalStateException
(
"Velocity could not be initialized!"
)
;
}
}
SimpleNode
ast
=
null
;
Parser
parser
=
(
Parser
)
parserPool
.
get
(
)
;
if
(
parser
==
null
)
{
if
(
log
.
isInfoEnabled
(
)
)
{
log
.
info
(
"Runtime : ran out of parsers. Creating a new one. "
+
" Please increment the parser.pool.size property."
+
" The current value is too small."
)
;
}
parser
=
createNewParser
(
)
;
}
if
(
parser
!=
null
)
{
try
{
if
(
dumpNamespace
)
{
dumpVMNamespace
(
templateName
)
;
}
ast
=
parser
.
parse
(
reader
,
templateName
)
;
}
finally
{
parserPool
.
put
(
parser
)
;
}
}
else
{
log
.
error
(
"Runtime : ran out of parsers and unable to create more."
)
;
}
return
ast
;
}
public
Template
getTemplate
(
String
name
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
return
getTemplate
(
name
,
getString
(
INPUT_ENCODING
,
ENCODING_DEFAULT
)
)
;
}
public
Template
getTemplate
(
String
name
,
String
encoding
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
if
(
!
initialized
&&
!
initializing
)
{
log
.
info
(
"Velocity not initialized yet. Calling init()..."
)
;
init
(
)
;
}
return
(
Template
)
resourceManager
.
getResource
(
name
,
ResourceManager
.
RESOURCE_TEMPLATE
,
encoding
)
;
}
public
ContentResource
getContent
(
String
name
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
return
getContent
(
name
,
getString
(
INPUT_ENCODING
,
ENCODING_DEFAULT
)
)
;
}
public
ContentResource
getContent
(
String
name
,
String
encoding
)
throws
ResourceNotFoundException
,
ParseErrorException
,
Exception
{
if
(
!
initialized
&&
!
initializing
)
{
log
.
info
(
"Velocity not initialized yet. Calling init()..."
)
;
init
(
)
;
}
return
(
ContentResource
)
resourceManager
.
getResource
(
name
,
ResourceManager
.
RESOURCE_CONTENT
,
encoding
)
;
}
public
String
getLoaderNameForResource
(
String
resourceName
)
{
if
(
!
initialized
&&
!
initializing
)
{
log
.
debug
(
"Velocity was not initialized! Calling init()..."
)
;
try
{
init
(
)
;
}
catch
(
Exception
e
)
{
getLog
(
)
.
error
(
"Could not initialize Velocity"
,
e
)
;
throw
new
IllegalStateException
(
"Velocity could not be initialized!"
)
;
}
}
return
resourceManager
.
getLoaderNameForResource
(
resourceName
)
;
}
public
Log
getLog
(
)
{
return
log
;
}
public
void
warn
(
Object
message
)
{
getLog
(
)
.
warn
(
message
)
;
}
public
void
info
(
Object
message
)
{
getLog
(
)
.
info
(
message
)
;
}
public
void
error
(
Object
message
)
{
getLog
(
)
.
error
(
message
)
;
}
public
void
debug
(
Object
message
)
{
getLog
(
)
.
debug
(
message
)
;
}
public
String
getString
(
String
key
,
String
defaultValue
)
{
return
configuration
.
getString
(
key
,
defaultValue
)
;
}
public
Directive
getVelocimacro
(
String
vmName
,
String
templateName
)
{
return
vmFactory
.
getVelocimacro
(
vmName
,
templateName
)
;
}
public
boolean
addVelocimacro
(
String
name
,
String
macro
,
String
argArray
[
]
,
String
sourceTemplate
)
{
return
vmFactory
.
addVelocimacro
(
name
,
macro
,
argArray
,
sourceTemplate
)
;
}
public
boolean
isVelocimacro
(
String
vmName
,
String
templateName
)
{
return
vmFactory
.
isVelocimacro
(
vmName
,
templateName
)
;
}
public
boolean
dumpVMNamespace
(
String
namespace
)
{
return
vmFactory
.
dumpVMNamespace
(
namespace
)
;
}
public
String
getString
(
String
key
)
{
return
StringUtils
.
nullTrim
(
configuration
.
getString
(
key
)
)
;
}
public
int
getInt
(
String
key
)
{
return
configuration
.
getInt
(
key
)
;
}
public
int
getInt
(
String
key
,
int
defaultValue
)
{
return
configuration
.
getInt
(
key
,
defaultValue
)
;
}
public
boolean
getBoolean
(
String
key
,
boolean
def
)
{
return
configuration
.
getBoolean
(
key
,
def
)
;
}
public
ExtendedProperties
getConfiguration
(
)
{
return
configuration
;
}
public
Introspector
getIntrospector
(
)
{
return
introspector
;
}
public
EventCartridge
getApplicationEventCartridge
(
)
{
return
eventCartridge
;
}
public
Object
getApplicationAttribute
(
Object
key
)
{
return
applicationAttributes
.
get
(
key
)
;
}
public
Object
setApplicationAttribute
(
Object
key
,
Object
o
)
{
return
applicationAttributes
.
put
(
key
,
o
)
;
}
public
Uberspect
getUberspect
(
)
{
return
uberSpect
;
}
}
