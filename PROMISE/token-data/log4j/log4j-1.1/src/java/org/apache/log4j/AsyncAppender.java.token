package
org
.
apache
.
log4j
;
import
org
.
apache
.
log4j
.
Category
;
import
org
.
apache
.
log4j
.
spi
.
LoggingEvent
;
import
org
.
apache
.
log4j
.
helpers
.
BoundedFIFO
;
import
org
.
apache
.
log4j
.
helpers
.
OptionConverter
;
import
org
.
apache
.
log4j
.
spi
.
AppenderAttachable
;
import
org
.
apache
.
log4j
.
helpers
.
AppenderAttachableImpl
;
import
org
.
apache
.
log4j
.
helpers
.
LogLog
;
import
java
.
util
.
Enumeration
;
public
class
AsyncAppender
extends
AppenderSkeleton
implements
AppenderAttachable
{
public
static
final
String
LOCATION_INFO_OPTION
=
"LocationInfo"
;
public
static
final
String
BUFFER_SIZE_OPTION
=
"BufferSize"
;
public
static
final
int
DEFAULT_BUFFER_SIZE
=
128
;
BoundedFIFO
bf
=
new
BoundedFIFO
(
DEFAULT_BUFFER_SIZE
)
;
AppenderAttachableImpl
aai
;
Dispatcher
dispatcher
;
boolean
locationInfo
=
false
;
boolean
interruptedWarningMessage
=
false
;
public
AsyncAppender
(
)
{
aai
=
new
AppenderAttachableImpl
(
)
;
dispatcher
=
new
Dispatcher
(
bf
,
this
)
;
dispatcher
.
start
(
)
;
}
public
void
addAppender
(
Appender
newAppender
)
{
synchronized
(
aai
)
{
aai
.
addAppender
(
newAppender
)
;
}
}
public
void
append
(
LoggingEvent
event
)
{
event
.
getNDC
(
)
;
event
.
getThreadName
(
)
;
if
(
locationInfo
)
{
event
.
getLocationInformation
(
)
;
}
synchronized
(
bf
)
{
while
(
bf
.
isFull
(
)
)
{
try
{
bf
.
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
if
(
!
interruptedWarningMessage
)
{
interruptedWarningMessage
=
true
;
LogLog
.
warn
(
"AsyncAppender interrupted."
,
e
)
;
}
else
{
LogLog
.
warn
(
"AsyncAppender interrupted again."
)
;
}
}
}
bf
.
put
(
event
)
;
if
(
bf
.
wasEmpty
(
)
)
{
bf
.
notify
(
)
;
}
}
}
public
void
close
(
)
{
synchronized
(
this
)
{
if
(
closed
)
return
;
closed
=
true
;
}
dispatcher
.
close
(
)
;
try
{
dispatcher
.
join
(
)
;
}
catch
(
InterruptedException
e
)
{
LogLog
.
error
(
"Got an InterruptedException while waiting for the "
+
"dispatcher to finish."
,
e
)
;
}
dispatcher
=
null
;
bf
=
null
;
}
public
Enumeration
getAllAppenders
(
)
{
synchronized
(
aai
)
{
return
aai
.
getAllAppenders
(
)
;
}
}
public
Appender
getAppender
(
String
name
)
{
synchronized
(
aai
)
{
return
aai
.
getAppender
(
name
)
;
}
}
public
boolean
getLocationInfo
(
)
{
return
locationInfo
;
}
public
boolean
requiresLayout
(
)
{
return
false
;
}
public
void
removeAllAppenders
(
)
{
synchronized
(
aai
)
{
aai
.
removeAllAppenders
(
)
;
}
}
public
void
removeAppender
(
Appender
appender
)
{
synchronized
(
aai
)
{
aai
.
removeAppender
(
appender
)
;
}
}
public
void
removeAppender
(
String
name
)
{
synchronized
(
aai
)
{
aai
.
removeAppender
(
name
)
;
}
}
public
void
setLocationInfo
(
boolean
flag
)
{
locationInfo
=
flag
;
}
public
void
setBufferSize
(
int
size
)
{
bf
.
resize
(
size
)
;
}
public
int
getBufferSize
(
)
{
return
bf
.
getMaxSize
(
)
;
}
public
String
[
]
getOptionStrings
(
)
{
return
OptionConverter
.
concatanateArrays
(
super
.
getOptionStrings
(
)
,
new
String
[
]
{
LOCATION_INFO_OPTION
,
BUFFER_SIZE_OPTION
}
)
;
}
public
void
setOption
(
String
option
,
String
value
)
{
if
(
value
==
null
)
return
;
super
.
setOption
(
option
,
value
)
;
if
(
option
.
equals
(
LOCATION_INFO_OPTION
)
)
locationInfo
=
OptionConverter
.
toBoolean
(
value
,
locationInfo
)
;
else
if
(
option
.
equals
(
BUFFER_SIZE_OPTION
)
)
{
int
newSize
=
OptionConverter
.
toInt
(
value
,
DEFAULT_BUFFER_SIZE
)
;
bf
.
resize
(
newSize
)
;
}
}
}
class
Dispatcher
extends
Thread
{
BoundedFIFO
bf
;
AppenderAttachableImpl
aai
;
boolean
interrupted
=
false
;
AsyncAppender
container
;
Dispatcher
(
BoundedFIFO
bf
,
AsyncAppender
container
)
{
this
.
bf
=
bf
;
this
.
container
=
container
;
this
.
aai
=
container
.
aai
;
this
.
setPriority
(
Thread
.
MIN_PRIORITY
)
;
this
.
setName
(
"Dispatcher-"
+
getName
(
)
)
;
}
void
close
(
)
{
synchronized
(
bf
)
{
interrupted
=
true
;
if
(
bf
.
length
(
)
==
0
)
{
bf
.
notify
(
)
;
}
}
}
public
void
run
(
)
{
LoggingEvent
event
;
while
(
true
)
{
synchronized
(
bf
)
{
if
(
bf
.
length
(
)
==
0
)
{
if
(
interrupted
)
{
return
;
}
try
{
bf
.
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
LogLog
.
error
(
"The dispathcer should not be interrupted."
)
;
break
;
}
}
event
=
bf
.
get
(
)
;
if
(
bf
.
wasFull
(
)
)
{
bf
.
notify
(
)
;
}
}
synchronized
(
container
.
aai
)
{
if
(
aai
!=
null
&&
event
!=
null
)
{
aai
.
appendLoopOnAppenders
(
event
)
;
}
}
}
}
}
