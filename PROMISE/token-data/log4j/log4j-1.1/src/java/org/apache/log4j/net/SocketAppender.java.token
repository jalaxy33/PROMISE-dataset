package
org
.
apache
.
log4j
.
net
;
import
java
.
net
.
InetAddress
;
import
java
.
net
.
Socket
;
import
java
.
io
.
OutputStream
;
import
java
.
io
.
IOException
;
import
java
.
io
.
ObjectOutputStream
;
import
java
.
io
.
ObjectOutputStream
;
import
java
.
io
.
OutputStreamWriter
;
import
java
.
io
.
StringWriter
;
import
java
.
io
.
PrintWriter
;
import
org
.
apache
.
log4j
.
helpers
.
LogLog
;
import
org
.
apache
.
log4j
.
helpers
.
OptionConverter
;
import
org
.
apache
.
log4j
.
spi
.
LoggingEvent
;
import
org
.
apache
.
log4j
.
Category
;
import
org
.
apache
.
log4j
.
Priority
;
import
org
.
apache
.
log4j
.
AppenderSkeleton
;
public
class
SocketAppender
extends
AppenderSkeleton
{
public
static
final
String
REMOTE_HOST_OPTION
=
"RemoteHost"
;
public
static
final
String
PORT_OPTION
=
"Port"
;
public
static
final
String
LOCATION_INFO_OPTION
=
"LocationInfo"
;
public
static
final
String
RECONNECTION_DELAY_OPTION
=
"ReconnectionDelay"
;
static
final
int
DEFAULT_PORT
=
4560
;
static
final
int
DEFAULT_RECONNECTION_DELAY
=
30000
;
String
remoteHost
;
InetAddress
address
;
int
port
=
DEFAULT_PORT
;
ObjectOutputStream
oos
;
int
reconnectionDelay
=
DEFAULT_RECONNECTION_DELAY
;
boolean
locationInfo
=
false
;
private
Connector
connector
;
int
counter
=
0
;
private
static
final
int
RESET_FREQUENCY
=
1
;
public
SocketAppender
(
)
{
}
public
SocketAppender
(
InetAddress
address
,
int
port
)
{
this
.
address
=
address
;
this
.
remoteHost
=
address
.
getHostName
(
)
;
this
.
port
=
port
;
connect
(
address
,
port
)
;
}
public
SocketAppender
(
String
host
,
int
port
)
{
this
.
port
=
port
;
this
.
address
=
getAddressByName
(
host
)
;
this
.
remoteHost
=
host
;
connect
(
address
,
port
)
;
}
public
String
[
]
getOptionStrings
(
)
{
return
OptionConverter
.
concatanateArrays
(
super
.
getOptionStrings
(
)
,
new
String
[
]
{
REMOTE_HOST_OPTION
,
PORT_OPTION
,
LOCATION_INFO_OPTION
,
RECONNECTION_DELAY_OPTION
}
)
;
}
public
void
setOption
(
String
option
,
String
value
)
{
if
(
value
==
null
)
return
;
super
.
setOption
(
option
,
value
)
;
if
(
option
.
equals
(
REMOTE_HOST_OPTION
)
)
{
address
=
getAddressByName
(
value
)
;
remoteHost
=
value
;
}
else
if
(
option
.
equals
(
PORT_OPTION
)
)
{
port
=
OptionConverter
.
toInt
(
value
,
port
)
;
}
else
if
(
option
.
equals
(
LOCATION_INFO_OPTION
)
)
{
locationInfo
=
OptionConverter
.
toBoolean
(
value
,
locationInfo
)
;
}
else
if
(
option
.
equals
(
RECONNECTION_DELAY_OPTION
)
)
{
reconnectionDelay
=
OptionConverter
.
toInt
(
value
,
reconnectionDelay
)
;
}
}
public
void
activateOptions
(
)
{
connect
(
address
,
port
)
;
}
synchronized
public
void
close
(
)
{
if
(
closed
)
return
;
this
.
closed
=
true
;
cleanUp
(
)
;
}
public
void
cleanUp
(
)
{
if
(
oos
!=
null
)
{
try
{
oos
.
close
(
)
;
}
catch
(
IOException
e
)
{
LogLog
.
error
(
"Could not close oos."
,
e
)
;
}
oos
=
null
;
}
if
(
connector
!=
null
)
{
connector
.
interrupted
=
true
;
connector
=
null
;
}
}
void
connect
(
InetAddress
address
,
int
port
)
{
if
(
this
.
address
==
null
)
return
;
try
{
cleanUp
(
)
;
oos
=
new
ObjectOutputStream
(
new
Socket
(
address
,
port
)
.
getOutputStream
(
)
)
;
}
catch
(
IOException
e
)
{
LogLog
.
error
(
"Could not connect to remote log4j server at ["
+
address
.
getHostName
(
)
+
"]. We will try again later."
,
e
)
;
fireConnector
(
)
;
}
}
public
void
append
(
LoggingEvent
event
)
{
if
(
event
==
null
)
return
;
if
(
address
==
null
)
{
errorHandler
.
error
(
"No remote host is set for SocketAppender named \""
+
this
.
name
+
"\"."
)
;
return
;
}
if
(
oos
!=
null
)
{
try
{
if
(
locationInfo
)
{
event
.
getLocationInformation
(
)
;
}
oos
.
writeObject
(
event
)
;
oos
.
flush
(
)
;
if
(
++
counter
>=
RESET_FREQUENCY
)
{
counter
=
0
;
oos
.
reset
(
)
;
}
}
catch
(
IOException
e
)
{
oos
=
null
;
LogLog
.
warn
(
"Detected problem with connection: "
+
e
)
;
if
(
reconnectionDelay
>
0
)
{
fireConnector
(
)
;
}
}
}
}
void
fireConnector
(
)
{
if
(
connector
==
null
)
{
LogLog
.
debug
(
"Starting a new connector thread."
)
;
connector
=
new
Connector
(
)
;
connector
.
setDaemon
(
true
)
;
connector
.
setPriority
(
Thread
.
MIN_PRIORITY
)
;
connector
.
start
(
)
;
}
}
static
InetAddress
getAddressByName
(
String
host
)
{
try
{
return
InetAddress
.
getByName
(
host
)
;
}
catch
(
Exception
e
)
{
LogLog
.
error
(
"Could not find address of ["
+
host
+
"]."
,
e
)
;
return
null
;
}
}
public
boolean
requiresLayout
(
)
{
return
false
;
}
public
void
setRemoteHost
(
String
host
)
{
address
=
getAddressByName
(
host
)
;
remoteHost
=
host
;
}
public
String
getRemoteHost
(
)
{
return
remoteHost
;
}
public
void
setPort
(
int
port
)
{
this
.
port
=
port
;
}
public
int
getPort
(
)
{
return
port
;
}
public
void
setLocationInfo
(
boolean
locationInfo
)
{
this
.
locationInfo
=
locationInfo
;
}
public
boolean
getLocationInfo
(
)
{
return
locationInfo
;
}
public
void
setReconnectionDelay
(
int
delay
)
{
this
.
reconnectionDelay
=
delay
;
}
public
int
getReconnectionDelay
(
)
{
return
reconnectionDelay
;
}
class
Connector
extends
Thread
{
boolean
interrupted
=
false
;
public
void
run
(
)
{
Socket
socket
;
while
(
!
interrupted
)
{
try
{
sleep
(
reconnectionDelay
)
;
LogLog
.
debug
(
"Attempting connection to "
+
address
.
getHostName
(
)
)
;
socket
=
new
Socket
(
address
,
port
)
;
synchronized
(
this
)
{
oos
=
new
ObjectOutputStream
(
socket
.
getOutputStream
(
)
)
;
connector
=
null
;
break
;
}
}
catch
(
InterruptedException
e
)
{
LogLog
.
debug
(
"Connector interrupted. Leaving loop."
)
;
return
;
}
catch
(
java
.
net
.
ConnectException
e
)
{
LogLog
.
debug
(
"Remote host "
+
address
.
getHostName
(
)
+
" refused connection."
)
;
}
catch
(
IOException
e
)
{
LogLog
.
debug
(
"Could not connect to "
+
address
.
getHostName
(
)
+
". Exception is "
+
e
)
;
}
}
}
}
}
