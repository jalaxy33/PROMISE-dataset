package
org
.
apache
.
log4j
;
import
java
.
util
.
Hashtable
;
import
java
.
util
.
Enumeration
;
import
org
.
apache
.
log4j
.
spi
.
RootCategory
;
import
org
.
apache
.
log4j
.
spi
.
CategoryFactory
;
import
org
.
apache
.
log4j
.
or
.
RendererMap
;
import
org
.
apache
.
log4j
.
or
.
ObjectRenderer
;
public
class
Hierarchy
{
static
private
CategoryFactory
defaultFactory
=
new
DefaultCategoryFactory
(
)
;
Hashtable
ht
;
Category
root
;
RendererMap
rendererMap
;
public
Hierarchy
(
Category
root
)
{
ht
=
new
Hashtable
(
)
;
this
.
root
=
root
;
this
.
root
.
myContext
=
this
;
rendererMap
=
new
RendererMap
(
)
;
}
public
void
addRenderer
(
Class
classToRender
,
ObjectRenderer
or
)
{
rendererMap
.
put
(
classToRender
,
or
)
;
}
public
void
clear
(
)
{
ht
.
clear
(
)
;
}
public
Category
exists
(
String
name
)
{
Object
o
=
ht
.
get
(
new
CategoryKey
(
name
)
)
;
if
(
o
instanceof
Category
)
{
return
(
Category
)
o
;
}
else
{
return
null
;
}
}
public
Category
getInstance
(
String
name
)
{
return
getInstance
(
name
,
defaultFactory
)
;
}
public
Category
getInstance
(
String
name
,
CategoryFactory
factory
)
{
CategoryKey
key
=
new
CategoryKey
(
name
)
;
Category
category
;
synchronized
(
ht
)
{
Object
o
=
ht
.
get
(
key
)
;
if
(
o
==
null
)
{
category
=
factory
.
makeNewCategoryInstance
(
name
)
;
category
.
setHierarchy
(
this
)
;
ht
.
put
(
key
,
category
)
;
updateParents
(
category
)
;
return
category
;
}
else
if
(
o
instanceof
Category
)
{
return
(
Category
)
o
;
}
else
if
(
o
instanceof
ProvisionNode
)
{
category
=
factory
.
makeNewCategoryInstance
(
name
)
;
ht
.
put
(
key
,
category
)
;
updateChildren
(
(
ProvisionNode
)
o
,
category
)
;
updateParents
(
category
)
;
return
category
;
}
else
{
return
null
;
}
}
}
public
RendererMap
getRendererMap
(
)
{
return
rendererMap
;
}
public
Category
getRoot
(
)
{
return
root
;
}
final
private
void
updateParents
(
Category
cat
)
{
String
name
=
cat
.
name
;
int
length
=
name
.
length
(
)
;
boolean
parentFound
=
false
;
for
(
int
i
=
name
.
lastIndexOf
(
'.'
,
length
-
1
)
;
i
>=
0
;
i
=
name
.
lastIndexOf
(
'.'
,
i
-
1
)
)
{
String
substr
=
name
.
substring
(
0
,
i
)
;
CategoryKey
key
=
new
CategoryKey
(
substr
)
;
Object
o
=
ht
.
get
(
key
)
;
if
(
o
==
null
)
{
ProvisionNode
pn
=
new
ProvisionNode
(
cat
)
;
ht
.
put
(
key
,
pn
)
;
}
else
if
(
o
instanceof
Category
)
{
parentFound
=
true
;
cat
.
parent
=
(
Category
)
o
;
break
;
}
else
if
(
o
instanceof
ProvisionNode
)
{
(
(
ProvisionNode
)
o
)
.
addElement
(
cat
)
;
}
else
{
Exception
e
=
new
IllegalStateException
(
"unexpected object type "
+
o
.
getClass
(
)
+
" in ht."
)
;
e
.
printStackTrace
(
)
;
}
}
if
(
!
parentFound
)
cat
.
parent
=
root
;
}
final
private
void
updateChildren
(
ProvisionNode
pn
,
Category
cat
)
{
final
int
last
=
pn
.
size
(
)
;
childLoop
:
for
(
int
i
=
0
;
i
<
last
;
i
++
)
{
Category
c
=
(
Category
)
pn
.
elementAt
(
i
)
;
if
(
c
.
parent
!=
null
&&
c
.
parent
.
name
.
startsWith
(
cat
.
name
)
)
{
continue
childLoop
;
}
while
(
c
.
parent
!=
null
&&
c
.
parent
.
name
.
startsWith
(
cat
.
name
)
)
{
c
=
c
.
parent
;
}
cat
.
parent
=
c
.
parent
;
c
.
parent
=
cat
;
}
}
public
void
shutdown
(
)
{
Category
root
=
getRoot
(
)
;
root
.
closeNestedAppenders
(
)
;
synchronized
(
ht
)
{
Enumeration
cats
=
Category
.
getCurrentCategories
(
)
;
while
(
cats
.
hasMoreElements
(
)
)
{
Category
c
=
(
Category
)
cats
.
nextElement
(
)
;
c
.
closeNestedAppenders
(
)
;
}
root
.
removeAllAppenders
(
)
;
cats
=
Category
.
getCurrentCategories
(
)
;
while
(
cats
.
hasMoreElements
(
)
)
{
Category
c
=
(
Category
)
cats
.
nextElement
(
)
;
c
.
removeAllAppenders
(
)
;
}
}
}
}
