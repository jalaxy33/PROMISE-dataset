package
org
.
apache
.
log4j
;
import
org
.
apache
.
log4j
.
Category
;
import
org
.
apache
.
log4j
.
spi
.
LoggingEvent
;
import
org
.
apache
.
log4j
.
helpers
.
BoundedFIFO
;
import
org
.
apache
.
log4j
.
helpers
.
OptionConverter
;
import
org
.
apache
.
log4j
.
spi
.
AppenderAttachable
;
import
org
.
apache
.
log4j
.
helpers
.
AppenderAttachableImpl
;
import
org
.
apache
.
log4j
.
helpers
.
LogLog
;
import
java
.
util
.
Enumeration
;
public
class
AsyncAppender
extends
AppenderSkeleton
implements
AppenderAttachable
{
public
static
final
String
LOCATION_INFO_OPTION
=
"LocationInfo"
;
static
final
int
BUFFER_SIZE
=
128
;
BoundedFIFO
bf
=
new
BoundedFIFO
(
BUFFER_SIZE
)
;
AppenderAttachableImpl
aai
;
Dispatcher
dispatcher
;
boolean
locationInfo
=
false
;
public
AsyncAppender
(
)
{
aai
=
new
AppenderAttachableImpl
(
)
;
dispatcher
=
new
Dispatcher
(
bf
,
aai
)
;
dispatcher
.
start
(
)
;
}
synchronized
public
void
addAppender
(
Appender
newAppender
)
{
aai
.
addAppender
(
newAppender
)
;
}
public
void
append
(
LoggingEvent
event
)
{
event
.
getNDC
(
)
;
event
.
getThreadName
(
)
;
if
(
locationInfo
)
{
event
.
setLocationInformation
(
)
;
}
synchronized
(
bf
)
{
if
(
bf
.
isFull
(
)
)
{
try
{
bf
.
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
LogLog
.
error
(
"AsyncAppender cannot be interrupted."
,
e
)
;
}
}
bf
.
put
(
event
)
;
if
(
bf
.
wasEmpty
(
)
)
{
bf
.
notify
(
)
;
}
}
}
public
void
close
(
)
{
closed
=
true
;
dispatcher
.
interrupt
(
)
;
try
{
dispatcher
.
join
(
)
;
}
catch
(
InterruptedException
e
)
{
LogLog
.
error
(
"Got an InterruptedException while waiting for the "
+
"dispatcher to finish."
,
e
)
;
}
dispatcher
=
null
;
bf
=
null
;
}
public
Enumeration
getAllAppenders
(
)
{
return
aai
.
getAllAppenders
(
)
;
}
public
Appender
getAppender
(
String
name
)
{
return
aai
.
getAppender
(
name
)
;
}
public
String
[
]
getOptionStrings
(
)
{
return
OptionConverter
.
concatanateArrays
(
super
.
getOptionStrings
(
)
,
new
String
[
]
{
LOCATION_INFO_OPTION
}
)
;
}
public
boolean
requiresLayout
(
)
{
return
false
;
}
synchronized
public
void
removeAllAppenders
(
)
{
aai
.
removeAllAppenders
(
)
;
}
synchronized
public
void
removeAppender
(
Appender
appender
)
{
aai
.
removeAppender
(
appender
)
;
}
synchronized
public
void
removeAppender
(
String
name
)
{
aai
.
removeAppender
(
name
)
;
}
public
void
setOption
(
String
option
,
String
value
)
{
if
(
value
==
null
)
return
;
super
.
setOption
(
option
,
value
)
;
if
(
option
.
equals
(
LOCATION_INFO_OPTION
)
)
locationInfo
=
OptionConverter
.
toBoolean
(
value
,
locationInfo
)
;
}
}
class
Dispatcher
extends
Thread
{
BoundedFIFO
bf
;
AppenderAttachableImpl
aai
;
Dispatcher
(
BoundedFIFO
bf
,
AppenderAttachableImpl
aai
)
{
this
.
bf
=
bf
;
this
.
aai
=
aai
;
this
.
setPriority
(
Thread
.
MIN_PRIORITY
)
;
}
public
void
run
(
)
{
LoggingEvent
event
;
while
(
true
)
{
synchronized
(
bf
)
{
if
(
bf
.
length
(
)
==
0
)
{
if
(
interrupted
(
)
)
{
return
;
}
try
{
bf
.
wait
(
)
;
}
catch
(
InterruptedException
e
)
{
break
;
}
}
event
=
bf
.
get
(
)
;
if
(
bf
.
wasFull
(
)
)
{
bf
.
notify
(
)
;
}
}
if
(
aai
!=
null
)
aai
.
appendLoopOnAppenders
(
event
)
;
}
}
}
