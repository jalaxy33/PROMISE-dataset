package
org
.
apache
.
log4j
.
helpers
;
import
java
.
util
.
Properties
;
import
java
.
net
.
URL
;
import
org
.
apache
.
log4j
.
Level
;
import
org
.
apache
.
log4j
.
spi
.
Configurator
;
import
org
.
apache
.
log4j
.
spi
.
LoggerRepository
;
import
org
.
apache
.
log4j
.
PropertyConfigurator
;
public
class
OptionConverter
{
static
String
DELIM_START
=
"${"
;
static
char
DELIM_STOP
=
'}'
;
static
int
DELIM_START_LEN
=
2
;
static
int
DELIM_STOP_LEN
=
1
;
private
OptionConverter
(
)
{
}
public
static
String
[
]
concatanateArrays
(
String
[
]
l
,
String
[
]
r
)
{
int
len
=
l
.
length
+
r
.
length
;
String
[
]
a
=
new
String
[
len
]
;
System
.
arraycopy
(
l
,
0
,
a
,
0
,
l
.
length
)
;
System
.
arraycopy
(
r
,
0
,
a
,
l
.
length
,
r
.
length
)
;
return
a
;
}
public
static
String
convertSpecialChars
(
String
s
)
{
char
c
;
int
len
=
s
.
length
(
)
;
StringBuffer
sbuf
=
new
StringBuffer
(
len
)
;
int
i
=
0
;
while
(
i
<
len
)
{
c
=
s
.
charAt
(
i
++
)
;
if
(
c
==
'\\'
)
{
c
=
s
.
charAt
(
i
++
)
;
if
(
c
==
'n'
)
c
=
'\n'
;
else
if
(
c
==
'r'
)
c
=
'\r'
;
else
if
(
c
==
't'
)
c
=
'\t'
;
else
if
(
c
==
'f'
)
c
=
'\f'
;
else
if
(
c
==
'\b'
)
c
=
'\b'
;
else
if
(
c
==
'\"'
)
c
=
'\"'
;
else
if
(
c
==
'\''
)
c
=
'\''
;
else
if
(
c
==
'\\'
)
c
=
'\\'
;
}
sbuf
.
append
(
c
)
;
}
return
sbuf
.
toString
(
)
;
}
public
static
String
getSystemProperty
(
String
key
,
String
def
)
{
try
{
return
System
.
getProperty
(
key
,
def
)
;
}
catch
(
Throwable
e
)
{
LogLog
.
debug
(
"Was not allowed to read system property \""
+
key
+
"\"."
)
;
return
def
;
}
}
public
static
Object
instantiateByKey
(
Properties
props
,
String
key
,
Class
superClass
,
Object
defaultValue
)
{
String
className
=
findAndSubst
(
key
,
props
)
;
if
(
className
==
null
)
{
LogLog
.
error
(
"Could not find value for key "
+
key
)
;
return
defaultValue
;
}
return
OptionConverter
.
instantiateByClassName
(
className
.
trim
(
)
,
superClass
,
defaultValue
)
;
}
public
static
boolean
toBoolean
(
String
value
,
boolean
dEfault
)
{
if
(
value
==
null
)
return
dEfault
;
String
trimmedVal
=
value
.
trim
(
)
;
if
(
"true"
.
equalsIgnoreCase
(
trimmedVal
)
)
return
true
;
if
(
"false"
.
equalsIgnoreCase
(
trimmedVal
)
)
return
false
;
return
dEfault
;
}
public
static
int
toInt
(
String
value
,
int
dEfault
)
{
if
(
value
!=
null
)
{
String
s
=
value
.
trim
(
)
;
try
{
return
Integer
.
valueOf
(
s
)
.
intValue
(
)
;
}
catch
(
NumberFormatException
e
)
{
LogLog
.
error
(
"["
+
s
+
"] is not in proper int form."
)
;
e
.
printStackTrace
(
)
;
}
}
return
dEfault
;
}
public
static
Level
toLevel
(
String
value
,
Level
defaultValue
)
{
if
(
value
==
null
)
return
defaultValue
;
int
hashIndex
=
value
.
indexOf
(
'#'
)
;
if
(
hashIndex
==
-
1
)
{
if
(
"NULL"
.
equalsIgnoreCase
(
value
)
)
{
return
null
;
}
else
{
return
(
Level
)
Level
.
toLevel
(
value
,
defaultValue
)
;
}
}
Level
result
=
defaultValue
;
String
clazz
=
value
.
substring
(
hashIndex
+
1
)
;
String
levelName
=
value
.
substring
(
0
,
hashIndex
)
;
if
(
"NULL"
.
equalsIgnoreCase
(
levelName
)
)
{
return
null
;
}
LogLog
.
debug
(
"toLevel"
+
":class=["
+
clazz
+
"]"
+
":pri=["
+
levelName
+
"]"
)
;
try
{
Class
customLevel
=
Class
.
forName
(
clazz
)
;
Class
[
]
paramTypes
=
new
Class
[
]
{
String
.
class
,
org
.
apache
.
log4j
.
Level
.
class
}
;
java
.
lang
.
reflect
.
Method
toLevelMethod
=
customLevel
.
getMethod
(
"toLevel"
,
paramTypes
)
;
Object
[
]
params
=
new
Object
[
]
{
levelName
,
defaultValue
}
;
Object
o
=
toLevelMethod
.
invoke
(
null
,
params
)
;
result
=
(
Level
)
o
;
}
catch
(
ClassNotFoundException
e
)
{
LogLog
.
warn
(
"custom level class ["
+
clazz
+
"] not found."
)
;
}
catch
(
NoSuchMethodException
e
)
{
LogLog
.
warn
(
"custom level class ["
+
clazz
+
"]"
+
" does not have a constructor which takes one string parameter"
,
e
)
;
}
catch
(
java
.
lang
.
reflect
.
InvocationTargetException
e
)
{
LogLog
.
warn
(
"custom level class ["
+
clazz
+
"]"
+
" could not be instantiated"
,
e
)
;
}
catch
(
ClassCastException
e
)
{
LogLog
.
warn
(
"class ["
+
clazz
+
"] is not a subclass of org.apache.log4j.Level"
,
e
)
;
}
catch
(
IllegalAccessException
e
)
{
LogLog
.
warn
(
"class ["
+
clazz
+
"] cannot be instantiated due to access restrictions"
,
e
)
;
}
catch
(
Exception
e
)
{
LogLog
.
warn
(
"class ["
+
clazz
+
"], level ["
+
levelName
+
"] conversion failed."
,
e
)
;
}
return
result
;
}
public
static
long
toFileSize
(
String
value
,
long
dEfault
)
{
if
(
value
==
null
)
return
dEfault
;
String
s
=
value
.
trim
(
)
.
toUpperCase
(
)
;
long
multiplier
=
1
;
int
index
;
if
(
(
index
=
s
.
indexOf
(
"KB"
)
)
!=
-
1
)
{
multiplier
=
1024
;
s
=
s
.
substring
(
0
,
index
)
;
}
else
if
(
(
index
=
s
.
indexOf
(
"MB"
)
)
!=
-
1
)
{
multiplier
=
1024
*
1024
;
s
=
s
.
substring
(
0
,
index
)
;
}
else
if
(
(
index
=
s
.
indexOf
(
"GB"
)
)
!=
-
1
)
{
multiplier
=
1024
*
1024
*
1024
;
s
=
s
.
substring
(
0
,
index
)
;
}
if
(
s
!=
null
)
{
try
{
return
Long
.
valueOf
(
s
)
.
longValue
(
)
*
multiplier
;
}
catch
(
NumberFormatException
e
)
{
LogLog
.
error
(
"["
+
s
+
"] is not in proper int form."
)
;
LogLog
.
error
(
"["
+
value
+
"] not in expected format."
,
e
)
;
}
}
return
dEfault
;
}
public
static
String
findAndSubst
(
String
key
,
Properties
props
)
{
String
value
=
props
.
getProperty
(
key
)
;
if
(
value
==
null
)
return
null
;
try
{
return
substVars
(
value
,
props
)
;
}
catch
(
IllegalArgumentException
e
)
{
LogLog
.
error
(
"Bad option value ["
+
value
+
"]."
,
e
)
;
return
value
;
}
}
public
static
Object
instantiateByClassName
(
String
className
,
Class
superClass
,
Object
defaultValue
)
{
if
(
className
!=
null
)
{
try
{
Class
classObj
=
Class
.
forName
(
className
)
;
if
(
!
superClass
.
isAssignableFrom
(
classObj
)
)
{
LogLog
.
error
(
"A \""
+
className
+
"\" object is not assignable to a \""
+
superClass
.
getName
(
)
+
"\" variable."
)
;
return
defaultValue
;
}
return
classObj
.
newInstance
(
)
;
}
catch
(
Exception
e
)
{
LogLog
.
error
(
"Could not instantiate class ["
+
className
+
"]."
,
e
)
;
}
}
return
defaultValue
;
}
public
static
String
substVars
(
String
val
,
Properties
props
)
throws
IllegalArgumentException
{
StringBuffer
sbuf
=
new
StringBuffer
(
)
;
int
i
=
0
;
int
j
,
k
;
while
(
true
)
{
j
=
val
.
indexOf
(
DELIM_START
,
i
)
;
if
(
j
==
-
1
)
{
if
(
i
==
0
)
{
return
val
;
}
else
{
sbuf
.
append
(
val
.
substring
(
i
,
val
.
length
(
)
)
)
;
return
sbuf
.
toString
(
)
;
}
}
else
{
sbuf
.
append
(
val
.
substring
(
i
,
j
)
)
;
k
=
val
.
indexOf
(
DELIM_STOP
,
j
)
;
if
(
k
==
-
1
)
{
throw
new
IllegalArgumentException
(
'"'
+
val
+
"\" has no closing brace. Opening brace at position "
+
j
+
'.'
)
;
}
else
{
j
+=
DELIM_START_LEN
;
String
key
=
val
.
substring
(
j
,
k
)
;
String
replacement
=
getSystemProperty
(
key
,
null
)
;
if
(
replacement
==
null
&&
props
!=
null
)
{
replacement
=
props
.
getProperty
(
key
)
;
}
if
(
replacement
!=
null
)
{
String
recursiveReplacement
=
substVars
(
replacement
,
props
)
;
sbuf
.
append
(
recursiveReplacement
)
;
}
i
=
k
+
DELIM_STOP_LEN
;
}
}
}
}
static
public
void
selectAndConfigure
(
URL
url
,
String
clazz
,
LoggerRepository
hierarchy
)
{
Configurator
configurator
=
null
;
String
filename
=
url
.
getFile
(
)
;
if
(
clazz
==
null
&&
filename
!=
null
&&
filename
.
endsWith
(
".xml"
)
)
{
clazz
=
"org.apache.log4j.xml.DOMConfigurator"
;
}
if
(
clazz
!=
null
)
{
LogLog
.
debug
(
"Preferred configurator class: "
+
clazz
)
;
configurator
=
(
Configurator
)
instantiateByClassName
(
clazz
,
Configurator
.
class
,
null
)
;
if
(
configurator
==
null
)
{
LogLog
.
error
(
"Could not instantiate configurator ["
+
clazz
+
"]."
)
;
return
;
}
}
else
{
configurator
=
new
PropertyConfigurator
(
)
;
}
configurator
.
doConfigure
(
url
,
hierarchy
)
;
}
}
